
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Nokogiri&#58;&#58;XML&#58;&#58;Node - Nokogiri - W3cubDocs</title>
  
  <meta name="description" content=" Nokogiri&#58;&#58;XML&#58;&#58;Node is the primary API you’ll use to interact with your Document. ">
  <meta name="keywords" content="class, nokogiri, xml, node">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nokogiri/nokogiri/xml/node.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/nokogiri.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nokogiri/" class="_nav-link" title="" style="margin-left:0;">Nokogiri</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Nokogiri::XML::Node" class="class"> class Nokogiri::XML::Node </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><span>Object</span></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="pp/node">Nokogiri::XML::PP::Node</a>, <a class="include" href="searchable">Nokogiri::XML::Searchable</a>, <a class="include" href="../classresolver">Nokogiri::ClassResolver</a>
</dd>
</dl> <section class="description"> <p><a href="node"><code>Nokogiri::XML::Node</code></a> is the primary API you’ll use to interact with your <a href="document"><code>Document</code></a>.</p> <h2 id="class-Nokogiri::XML::Node-label-Attributes">Attributes</h2> <p>A <a href="node"><code>Nokogiri::XML::Node</code></a> may be treated similarly to a hash with regard to attributes. For example:</p> <pre class="ruby" data-language="ruby">node = Nokogiri::XML::DocumentFragment.parse("&lt;a href='#foo' id='link'&gt;link&lt;/a&gt;").at_css("a")
node.to_html # =&gt; "&lt;a href=\"#foo\" id=\"link\"&gt;link&lt;/a&gt;"
node['href'] # =&gt; "#foo"
node.keys # =&gt; ["href", "id"]
node.values # =&gt; ["#foo", "link"]
node['class'] = 'green' # =&gt; "green"
node.to_html # =&gt; "&lt;a href=\"#foo\" id=\"link\" class=\"green\"&gt;link&lt;/a&gt;"
</pre> <p>See the method group entitled <a href="node#class-Nokogiri::XML::Node-label-Working+With+Node+Attributes">Working With Node Attributes at <code>Node</code></a> for the full set of methods.</p> <h2 id="class-Nokogiri::XML::Node-label-Navigation">Navigation</h2> <p><a href="node"><code>Nokogiri::XML::Node</code></a> also has methods that let you move around your tree:</p> <dl class="rdoc-list label-list">
<dt>
<a href="node#method-i-parent"><code>#parent</code></a>, <a href="node#method-i-children"><code>#children</code></a>, <a href="node#method-i-next"><code>#next</code></a>, <a href="node#method-i-previous"><code>#previous</code></a> </dt>
<dd> <p>Navigate up, down, or through siblings.</p> </dd>
</dl> <p>See the method group entitled <a href="node#class-Nokogiri::XML::Node-label-Traversing+Document+Structure">Traversing Document Structure at <code>Node</code></a> for the full set of methods.</p> <h2 id="class-Nokogiri::XML::Node-label-Serialization">Serialization</h2> <p>When printing or otherwise emitting a document or a node (and its subtree), there are a few methods you might want to use:</p> <dl class="rdoc-list label-list">
<dt>
<a href="node#method-i-content"><code>#content</code></a>, <a href="node#method-i-text"><code>#text</code></a>, <a href="node#method-i-inner_text"><code>#inner_text</code></a>, <a href="node#method-i-to_str"><code>#to_str</code></a> </dt>
<dd> <p>These methods will all **emit plaintext**, meaning that entities will be replaced (e.g., +&amp;lt;+ will be replaced with +&lt;+), meaning that any sanitizing will likely be un-done in the output.</p> </dd>
<dt>
<a href="node#method-i-to_s"><code>#to_s</code></a>, <a href="node#method-i-to_xml"><code>#to_xml</code></a>, <a href="node#method-i-to_html"><code>#to_html</code></a>, <a href="node#method-i-inner_html"><code>#inner_html</code></a> </dt>
<dd> <p>These methods will all **emit properly-escaped markup**, meaning that it’s suitable for consumption by browsers, parsers, etc.</p> </dd>
</dl> <p>See the method group entitled <a href="node#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output">Serialization and Generating Output at <code>Node</code></a> for the full set of methods.</p> <h2 id="class-Nokogiri::XML::Node-label-Searching">Searching</h2> <p>You may search this node’s subtree using methods like <a href="searchable#method-i-xpath"><code>#xpath</code></a> and <a href="searchable#method-i-css"><code>#css</code></a>.</p> <p>See the method group entitled <a href="node#class-Nokogiri::XML::Node-label-Searching+via+XPath+or+CSS+Queries">Searching via XPath or CSS Queries at <code>Node</code></a> for the full set of methods.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ATTRIBUTE_DECL">ATTRIBUTE_DECL </dt>
<dd>
<p>Attribute declaration type</p> </dd>
<dt id="ATTRIBUTE_NODE">ATTRIBUTE_NODE </dt>
<dd>
<p>Attribute node type</p> </dd>
<dt id="CDATA_SECTION_NODE">CDATA_SECTION_NODE </dt>
<dd>
<p><a href="cdata"><code>CDATA</code></a> node type, see <a href="node#method-i-cdata-3F"><code>Nokogiri::XML::Node#cdata?</code></a></p> </dd>
<dt id="COMMENT_NODE">COMMENT_NODE </dt>
<dd>
<p><a href="comment"><code>Comment</code></a> node type, see <a href="node#method-i-comment-3F"><code>Nokogiri::XML::Node#comment?</code></a></p> </dd>
<dt id="DOCB_DOCUMENT_NODE">DOCB_DOCUMENT_NODE </dt>
<dd>
<p>DOCB document node type</p> </dd>
<dt id="DOCUMENT_FRAG_NODE">DOCUMENT_FRAG_NODE </dt>
<dd>
<p><a href="document"><code>Document</code></a> fragment node type</p> </dd>
<dt id="DOCUMENT_NODE">DOCUMENT_NODE </dt>
<dd>
<p><a href="document"><code>Document</code></a> node type, see <a href="node#method-i-xml-3F"><code>Nokogiri::XML::Node#xml?</code></a></p> </dd>
<dt id="DOCUMENT_TYPE_NODE">DOCUMENT_TYPE_NODE </dt>
<dd>
<p><a href="document"><code>Document</code></a> type node type</p> </dd>
<dt id="DTD_NODE">DTD_NODE </dt>
<dd>
<p><a href="dtd"><code>DTD</code></a> node type</p> </dd>
<dt id="ELEMENT_DECL">ELEMENT_DECL </dt>
<dd>
<p><a href="element"><code>Element</code></a> declaration type</p> </dd>
<dt id="ELEMENT_NODE">ELEMENT_NODE </dt>
<dd>
<p><a href="element"><code>Element</code></a> node type, see <a href="node#method-i-element-3F"><code>Nokogiri::XML::Node#element?</code></a></p> </dd>
<dt id="ENTITY_DECL">ENTITY_DECL </dt>
<dd>
<p>Entity declaration type</p> </dd>
<dt id="ENTITY_NODE">ENTITY_NODE </dt>
<dd>
<p>Entity node type</p> </dd>
<dt id="ENTITY_REF_NODE">ENTITY_REF_NODE </dt>
<dd>
<p>Entity reference node type</p> </dd>
<dt id="HTML_DOCUMENT_NODE">HTML_DOCUMENT_NODE </dt>
<dd>
<p><a href="../html4"><code>HTML</code></a> document node type, see <a href="node#method-i-html-3F"><code>Nokogiri::XML::Node#html?</code></a></p> </dd>
<dt id="IMPLIED_XPATH_CONTEXTS">IMPLIED_XPATH_CONTEXTS </dt>

<dt id="NAMESPACE_DECL">NAMESPACE_DECL </dt>
<dd>
<p><a href="namespace"><code>Namespace</code></a> declaration type</p> </dd>
<dt id="NOTATION_NODE">NOTATION_NODE </dt>
<dd>
<p><a href="notation"><code>Notation</code></a> node type</p> </dd>
<dt id="PI_NODE">PI_NODE </dt>
<dd>
<p>PI node type</p> </dd>
<dt id="TEXT_NODE">TEXT_NODE </dt>
<dd>
<p><a href="text"><code>Text</code></a> node type, see <a href="node#method-i-text-3F"><code>Nokogiri::XML::Node#text?</code></a></p> </dd>
<dt id="XINCLUDE_END">XINCLUDE_END </dt>
<dd>
<p>XInclude end type</p> </dd>
<dt id="XINCLUDE_START">XINCLUDE_START </dt>
<dd>
<p>XInclude start type</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(name, document) → Nokogiri::XML::Node </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(name, document) { |node| ... } → Nokogiri::XML::Node </span> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 126
def initialize(name, document)
  # This is intentionally empty.
end</pre> </div> <p>Create a new node with <code>name</code> that belongs to <code>document</code>.</p> <p>If you intend to add a node to a document tree, it’s likely that you will prefer one of the <a href="node"><code>Nokogiri::XML::Node</code></a> methods like <a href="node#method-i-add_child"><code>#add_child</code></a>, <a href="node#method-i-add_next_sibling"><code>#add_next_sibling</code></a>, <a href="node#method-i-replace"><code>#replace</code></a>, etc. which will both create an element (or subtree) and place it in the document tree.</p> <p>Another alternative, if you are concerned about performance, is <a href="document#method-i-create_element"><code>Nokogiri::XML::Document#create_element</code></a> which accepts additional arguments for contents or attributes but (like this method) avoids parsing markup.</p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul>
<li> <p><code>name</code> (String)</p> </li>
<li> <p><code>document</code> (<a href="document"><code>Nokogiri::XML::Document</code></a>) The document to which the the returned node will belong.</p> </li>
</ul> <dl class="rdoc-list label-list">
<dt>Yields </dt>
<dd> <p><a href="node"><code>Nokogiri::XML::Node</code></a></p> </dd>
<dt>Returns </dt>
<dd> <p><a href="node"><code>Nokogiri::XML::Node</code></a></p> </dd>
</dl>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-name">&lt;=&gt;</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1159
def &lt;=&gt;(other)
  return nil unless other.is_a?(Nokogiri::XML::Node)
  return nil unless document == other.document
  compare(other)
end</pre> </div> <p>Compare two <a href="node"><code>Node</code></a> objects with respect to their <a href="document"><code>Document</code></a>. Nodes from different documents cannot be compared.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1150
def ==(other)
  return false unless other
  return false unless other.respond_to?(:pointer_id)
  pointer_id == other.pointer_id
end</pre> </div> <p>Test to see if this <a href="node"><code>Node</code></a> is equal to <code>other</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-accept"> <span class="method-name">accept</span><span class="method-args">(visitor)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1144
def accept(visitor)
  visitor.visit(self)
end</pre> </div> <p>Accept a visitor. This method calls “visit” on <code>visitor</code> with self.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ancestors"> <span class="method-name">ancestors</span><span class="method-args">(selector = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ancestors-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1114
def ancestors(selector = nil)
  return NodeSet.new(document) unless respond_to?(:parent)
  return NodeSet.new(document) unless parent

  parents = [parent]

  while parents.last.respond_to?(:parent)
    break unless (ctx_parent = parents.last.parent)
    parents &lt;&lt; ctx_parent
  end

  return NodeSet.new(document, parents) unless selector

  root = parents.last
  search_results = root.search(selector)

  NodeSet.new(document, parents.find_all do |parent|
    search_results.include?(parent)
  end)
end</pre> </div> <p>Get a list of ancestor <a href="node"><code>Node</code></a> for this <a href="node"><code>Node</code></a>. If <code>selector</code> is given, the ancestors must match <code>selector</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-blank-3F"> <span class="method-callseq"> blank? → Boolean </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="blank-3F-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_blank_eh(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>true</code> if the node is an empty or whitespace-only text or cdata node, else <code>false</code>.</p> </dd>
</dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">Nokogiri("&lt;root&gt;&lt;child/&gt;&lt;/root&gt;").root.child.blank? # =&gt; false
Nokogiri("&lt;root&gt;\t \n&lt;/root&gt;").root.child.blank? # =&gt; true
Nokogiri("&lt;root&gt;&lt;![CDATA[\t \n]]&gt;&lt;/root&gt;").root.child.blank? # =&gt; true
Nokogiri("&lt;root&gt;not-blank&lt;/root&gt;").root.child
  .tap { |n| n.content = "" }.blank # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cdata-3F"> <span class="method-name">cdata?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cdata-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1036
def cdata?
  type == CDATA_SECTION_NODE
end</pre> </div> <p>Returns true if this is a <a href="cdata"><code>CDATA</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-clone"> <span class="method-name">clone</span><span class="method-args">(p1 = v1, p2 = v2)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-dup">dup</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-comment-3F"> <span class="method-name">comment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="comment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1031
def comment?
  type == COMMENT_NODE
end</pre> </div> <p>Returns true if this is a <a href="comment"><code>Comment</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-content"> <span class="method-callseq"> content() → String </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="content-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_content(VALUE self)
{
  xmlNodePtr node;
  xmlChar *content;

  Data_Get_Struct(self, xmlNode, node);

  content = xmlNodeGetContent(node);
  if (content) {
    VALUE rval = NOKOGIRI_STR_NEW2(content);
    xmlFree(content);
    return rval;
  }
  return Qnil;
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Contents of all the text nodes in this node’s subtree, concatenated together into a single String.</p> </dd>
</dl> <p>⚠ Note that entities will <em>always</em> be expanded in the returned String.</p> <p>See related: <a href="node#method-i-inner_html"><code>#inner_html</code></a></p> <p><strong>Example</strong> of how entities are handled:</p> <p>Note that <code>&amp;lt;</code> becomes <code>&lt;</code> in the returned String.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML.fragment("&lt;child&gt;a &amp;lt; b&lt;/child&gt;")
doc.at_css("child").content
# =&gt; "a &lt; b"
</pre> <p><strong>Example</strong> of how a subtree is handled:</p> <p>Note that the <code>&lt;span&gt;</code> tags are omitted and only the text node contents are returned, concatenated into a single string.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML.fragment("&lt;child&gt;&lt;span&gt;first&lt;/span&gt; &lt;span&gt;second&lt;/span&gt;&lt;/child&gt;")
doc.at_css("child").content
# =&gt; "first second"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-inner_text">inner_text</a>, <a href="node#method-i-text">text</a>, <a href="node#method-i-to_str">to_str</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_external_subset"> <span class="method-callseq"> create_external_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_external_subset-source"> <pre class="c" data-language="c">static VALUE
create_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if (doc-&gt;extSubset) {
    rb_raise(rb_eRuntimeError, "Document already has an external subset");
  }

  dtd = xmlNewDtd(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Create an external subset</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_internal_subset"> <span class="method-callseq"> create_internal_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_internal_subset-source"> <pre class="c" data-language="c">static VALUE
create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if (xmlGetIntSubset(doc)) {
    rb_raise(rb_eRuntimeError, "Document already has an internal subset");
  }

  dtd = xmlCreateIntSubset(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Create the internal subset of a document.</p> <pre class="ruby" data-language="ruby">doc.create_internal_subset("chapter", "-//OASIS//DTD DocBook XML//EN", "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "chapter.dtd"&gt;

doc.create_internal_subset("chapter", nil, "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter SYSTEM "chapter.dtd"&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-css_path"> <span class="method-name">css_path</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="css_path-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1105
def css_path
  path.split(%r{/}).map do |part|
    part.empty? ? nil : part.gsub(/\[(\d+)\]/, ':nth-of-type(\1)')
  end.compact.join(" &gt; ")
end</pre> </div> <p>Get the path to this node as a <a href="../css"><code>CSS</code></a> expression</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-decorate-21"> <span class="method-name">decorate!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="decorate-21-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 132
def decorate!
  document.decorate(self)
end</pre> </div> <p>Decorate this node with the decorators set up in this node’s <a href="document"><code>Document</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-description"> <span class="method-name">description</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="description-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1073
def description
  return nil if document.xml?
  Nokogiri::HTML4::ElementDescription[name]
end</pre> </div> <p>Fetch the <a href="../html4/elementdescription"><code>Nokogiri::HTML4::ElementDescription</code></a> for this node. Returns nil on <a href="../xml"><code>XML</code></a> documents and on unknown tags.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-document-3F"> <span class="method-name">document?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="document-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1051
def document?
  is_a?(XML::Document)
end</pre> </div> <p>Returns true if this is a <a href="document"><code>Document</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dup"> <span class="method-callseq"> dup → Nokogiri::XML::Node </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> dup(depth) → Nokogiri::XML::Node </span> </div> <div class="method-heading"> <span class="method-callseq"> dup(depth, new_parent_doc) → Nokogiri::XML::Node </span> </div> <div class="method-description">
<div class="method-source-code" id="dup-source"> <pre class="c" data-language="c">static VALUE
duplicate_node(int argc, VALUE *argv, VALUE self)
{
  VALUE r_level, r_new_parent_doc;
  int level;
  int n_args;
  xmlDocPtr new_parent_doc;
  xmlNodePtr node, dup;

  Data_Get_Struct(self, xmlNode, node);

  n_args = rb_scan_args(argc, argv, "02", &amp;r_level, &amp;r_new_parent_doc);

  if (n_args &lt; 1) {
    r_level = INT2NUM((long)1);
  }
  level = (int)NUM2INT(r_level);

  if (n_args &lt; 2) {
    new_parent_doc = node-&gt;doc;
  } else {
    Data_Get_Struct(r_new_parent_doc, xmlDoc, new_parent_doc);
  }

  dup = xmlDocCopyNode(node, new_parent_doc, level);
  if (dup == NULL) { return Qnil; }

  noko_xml_document_pin_node(dup);

  return noko_xml_node_wrap(rb_obj_class(self), dup);
}</pre> </div> <p>Copy this node.</p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul>
<li> <p><code>depth</code> 0 is a shallow copy, 1 (the default) is a deep copy.</p> </li>
<li> <p><code>new_parent_doc</code> The new node’s parent <a href="document"><code>Document</code></a>. Defaults to the this node’s document.</p> </li>
</ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The new Nokgiri::XML::Node</p> </dd>
</dl>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-clone">clone</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-elem-3F"> <span class="method-name">elem?</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-element-3F">element?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-element-3F"> <span class="method-name">element?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="element-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1086
def element?
  type == ELEMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="element"><code>Element</code></a> node</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-elem-3F">elem?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-element_children"> <span class="method-callseq"> element_children() → NodeSet </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="element_children-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_element_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if (!child) { return noko_xml_node_set_wrap(set, document); }

  child = xmlNextElementSibling(child);
  while (NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = xmlNextElementSibling(child);
  }

  node_set = noko_xml_node_set_wrap(set, document);

  return node_set;
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The node’s child elements as a <a href="nodeset"><code>NodeSet</code></a>. Only children that are elements will be returned, which notably excludes <a href="text"><code>Text</code></a> nodes.</p> </dd>
</dl> <p><strong>Example:</strong></p> <p>Note that <a href="node#method-i-children"><code>#children</code></a> returns the <a href="text"><code>Text</code></a> node “hello” while <a href="node#method-i-element_children"><code>#element_children</code></a> does not.</p> <pre class="ruby" data-language="ruby">div = Nokogiri::HTML5("&lt;div&gt;hello&lt;span&gt;world&lt;/span&gt;").at_css("div")
div.element_children
# =&gt; [#&lt;Nokogiri::XML::Element:0x50 name="span" children=[#&lt;Nokogiri::XML::Text:0x3c "world"&gt;]&gt;]
div.children
# =&gt; [#&lt;Nokogiri::XML::Text:0x64 "hello"&gt;,
#     #&lt;Nokogiri::XML::Element:0x50 name="span" children=[#&lt;Nokogiri::XML::Text:0x3c "world"&gt;]&gt;]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-elements">elements</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-elements"> <span class="method-callseq"> elements() → NodeSet </span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-element_children">element_children</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-encode_special_chars"> <span class="method-callseq"> encode_special_chars(string) → String </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="encode_special_chars-source"> <pre class="c" data-language="c">static VALUE
encode_special_chars(VALUE self, VALUE string)
{
  xmlNodePtr node;
  xmlChar *encoded;
  VALUE encoded_str;

  Data_Get_Struct(self, xmlNode, node);
  encoded = xmlEncodeSpecialChars(
              node-&gt;doc,
              (const xmlChar *)StringValueCStr(string)
            );

  encoded_str = NOKOGIRI_STR_NEW2(encoded);
  xmlFree(encoded);

  return encoded_str;
}</pre> </div> <p>Encode any special characters in <code>string</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-external_subset"> <span class="method-callseq"> external_subset() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="external_subset-source"> <pre class="c" data-language="c">static VALUE
external_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if (!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = doc-&gt;extSubset;

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Get the external subset</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-first_element_child"> <span class="method-callseq"> first_element_child() → Node </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="first_element_child-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_first_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The first child <a href="node"><code>Node</code></a> that is an element.</p> </dd>
</dl> <p><strong>Example:</strong></p> <p>Note that the “hello” child, which is a <a href="text"><code>Text</code></a> node, is skipped and the <code>&lt;span&gt;</code> element is returned.</p> <pre class="ruby" data-language="ruby">div = Nokogiri::HTML5("&lt;div&gt;hello&lt;span&gt;world&lt;/span&gt;").at_css("div")
div.first_element_child
# =&gt; #(Element:0x3c { name = "span", children = [ #(Text "world")] })
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fragment"> <span class="method-name">fragment</span><span class="method-args">(tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fragment-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 928
def fragment(tags)
  document.related_class("DocumentFragment").new(document, tags, self)
end</pre> </div> <p>Create a <a href="documentfragment"><code>DocumentFragment</code></a> containing <code>tags</code> that is relative to <em>this</em> context node.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fragment-3F"> <span class="method-name">fragment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fragment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1066
def fragment?
  type == DOCUMENT_FRAG_NODE
end</pre> </div> <p>Returns true if this is a <a href="documentfragment"><code>DocumentFragment</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-html-3F"> <span class="method-name">html?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="html-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1046
def html?
  type == HTML_DOCUMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="../html4/document"><code>HTML4::Document</code></a> or <a href="../html5/document"><code>HTML5::Document</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inner_html"> <span class="method-name">inner_html</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inner_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1100
def inner_html(*args)
  children.map { |x| x.to_html(*args) }.join
end</pre> </div> <p>Get the <a href="node#method-i-inner_html"><code>inner_html</code></a> for this node’s <a href="node#method-i-children"><code>Node#children</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-inner_text"> <span class="method-name">inner_text</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-internal_subset"> <span class="method-callseq"> internal_subset() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="internal_subset-source"> <pre class="c" data-language="c">static VALUE
internal_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if (!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = xmlGetIntSubset(doc);

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Get the internal subset</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-key-3F"> <span class="method-callseq"> key?(attribute) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="key-3F-source"> <pre class="c" data-language="c">static VALUE
key_eh(VALUE self, VALUE attribute)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if (xmlHasProp(node, (xmlChar *)StringValueCStr(attribute))) {
    return Qtrue;
  }
  return Qfalse;
}</pre> </div> <p>Returns true if <code>attribute</code> is set</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-has_attribute-3F">has_attribute?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lang"> <span class="method-callseq"> lang </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lang-source"> <pre class="c" data-language="c">static VALUE
get_lang(VALUE self_rb)
{
  xmlNodePtr self ;
  xmlChar *lang ;
  VALUE lang_rb ;

  Data_Get_Struct(self_rb, xmlNode, self);

  lang = xmlNodeGetLang(self);
  if (lang) {
    lang_rb = NOKOGIRI_STR_NEW2(lang);
    xmlFree(lang);
    return lang_rb ;
  }

  return Qnil ;
}</pre> </div> <p>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lang-3D"> <span class="method-callseq"> lang= </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lang-3D-source"> <pre class="c" data-language="c">static VALUE
set_lang(VALUE self_rb, VALUE lang_rb)
{
  xmlNodePtr self ;
  xmlChar *lang ;

  Data_Get_Struct(self_rb, xmlNode, self);
  lang = (xmlChar *)StringValueCStr(lang_rb);

  xmlNodeSetLang(self, lang);

  return Qnil ;
}</pre> </div> <p>Set the language of a node, i.e. the values of the xml:lang attribute.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-last_element_child"> <span class="method-callseq"> last_element_child() → Node </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="last_element_child-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_last_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlLastElementChild(node);
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The last child <a href="node"><code>Node</code></a> that is an element.</p> </dd>
</dl> <p><strong>Example:</strong></p> <p>Note that the “hello” child, which is a <a href="text"><code>Text</code></a> node, is skipped and the <code>&lt;span&gt;yes&lt;/span&gt;</code> element is returned.</p> <pre class="ruby" data-language="ruby">div = Nokogiri::HTML5("&lt;div&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;skip&lt;/div&gt;").at_css("div")
div.last_element_child
# =&gt; #(Element:0x3c { name = "span", children = [ #(Text "yes")] })
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-line"> <span class="method-callseq"> line() → Integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="line-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_line(VALUE rb_node)
{
  xmlNodePtr c_node;
  Data_Get_Struct(rb_node, xmlNode, c_node);

  return INT2NUM(xmlGetLineNo(c_node));
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The line number of this <a href="node"><code>Node</code></a>.</p> </dd>
</dl>  <p><strong> ⚠ The CRuby and JRuby implementations differ in important ways! </strong></p> <p>Semantic differences:</p> <ul>
<li> <p>The CRuby method reflects the node’s line number <em>in the parsed string</em></p> </li>
<li> <p>The JRuby method reflects the node’s line number <em>in the final DOM structure</em> after corrections have been applied</p> </li>
</ul> <p>Performance differences:</p> <ul>
<li> <p>The CRuby method is <a href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time">O(1)</a> (constant time)</p> </li>
<li> <p>The JRuby method is <a href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time">O(n)</a> (linear time, where n is the number of nodes before/above the element in the DOM)</p> </li>
</ul> <p>If you’d like to help improve the JRuby implementation, please review these issues and reach out to the maintainers:</p> <ul>
<li> <p><a href="https://github.com/sparklemotion/nokogiri/issues/1223">github.com/sparklemotion/nokogiri/issues/1223</a></p> </li>
<li> <p><a href="https://github.com/sparklemotion/nokogiri/pull/2177">github.com/sparklemotion/nokogiri/pull/2177</a></p> </li>
<li> <p><a href="https://github.com/sparklemotion/nokogiri/issues/2380">github.com/sparklemotion/nokogiri/issues/2380</a></p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-line-3D"> <span class="method-callseq"> line=(num) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="line-3D-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_line_set(VALUE rb_node, VALUE rb_line_number)
{
  xmlNodePtr c_node;
  int line_number = NUM2INT(rb_line_number);

  Data_Get_Struct(rb_node, xmlNode, c_node);

  // libxml2 optionally uses xmlNode.psvi to store longer line numbers, but only for text nodes.
  // search for "psvi" in SAX2.c and tree.c to learn more.
  if (line_number &lt; 65535) {
    c_node-&gt;line = (short) line_number;
  } else {
    c_node-&gt;line = 65535;
    if (c_node-&gt;type == XML_TEXT_NODE) {
      c_node-&gt;psvi = (void *)(ptrdiff_t) line_number;
    }
  }

  return rb_line_number;
}</pre> </div> <p>Sets the line for this <a href="node"><code>Node</code></a>. num must be less than 65535.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-matches-3F"> <span class="method-name">matches?</span><span class="method-args">(selector)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="matches-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 921
def matches?(selector)
  ancestors.last.search(selector).include?(self)
end</pre> </div> <p>Returns true if this <a href="node"><code>Node</code></a> matches <code>selector</code></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-name"> <span class="method-callseq"> name </span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-node_name">node_name</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace"> <span class="method-callseq"> namespace() → Namespace </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_namespace(VALUE rb_node)
{
  xmlNodePtr c_node ;
  Data_Get_Struct(rb_node, xmlNode, c_node);

  if (c_node-&gt;ns) {
    return noko_xml_namespace_wrap(c_node-&gt;ns, c_node-&gt;doc);
  }

  return Qnil ;
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The <a href="namespace"><code>Namespace</code></a> of the element or attribute node, or <code>nil</code> if there is no namespace.</p> </dd>
</dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;foo:third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//first").namespace
# =&gt; nil
doc.at_xpath("//xmlns:second", "xmlns" =&gt; "http://example.com/child").namespace
# =&gt; #(Namespace:0x3c { href = "http://example.com/child" })
doc.at_xpath("//foo:third", "foo" =&gt; "http://example.com/foo").namespace
# =&gt; #(Namespace:0x50 { prefix = "foo", href = "http://example.com/foo" })
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace_definitions"> <span class="method-callseq"> namespace_definitions() → Array&lt;Nokogiri::XML::Namespace&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace_definitions-source"> <pre class="c" data-language="c">static VALUE
namespace_definitions(VALUE rb_node)
{
  /* this code in the mode of xmlHasProp() */
  xmlNodePtr c_node ;
  xmlNsPtr c_namespace;
  VALUE definitions = rb_ary_new();

  Data_Get_Struct(rb_node, xmlNode, c_node);

  c_namespace = c_node-&gt;nsDef;
  if (!c_namespace) {
    return definitions;
  }

  while (c_namespace != NULL) {
    rb_ary_push(definitions, noko_xml_namespace_wrap(c_namespace, c_node-&gt;doc));
    c_namespace = c_namespace-&gt;next;
  }

  return definitions;
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Namespaces that are defined directly on this node, as an Array of <a href="namespace"><code>Namespace</code></a> objects. The array will be empty if no namespaces are defined on this node.</p> </dd>
</dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns="http://example.com/root"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child" xmlns:unused="http://example.com/unused"/&gt;
    &lt;foo:third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//root:first", "root" =&gt; "http://example.com/root").namespace_definitions
# =&gt; []
doc.at_xpath("//xmlns:second", "xmlns" =&gt; "http://example.com/child").namespace_definitions
# =&gt; [#(Namespace:0x3c { href = "http://example.com/child" }),
#     #(Namespace:0x50 {
#       prefix = "unused",
#       href = "http://example.com/unused"
#       })]
doc.at_xpath("//foo:third", "foo" =&gt; "http://example.com/foo").namespace_definitions
# =&gt; [#(Namespace:0x64 { prefix = "foo", href = "http://example.com/foo" })]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace_scopes"> <span class="method-callseq"> namespace_scopes() → Array&lt;Nokogiri::XML::Namespace&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace_scopes-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_namespace_scopes(VALUE rb_node)
{
  xmlNodePtr c_node ;
  xmlNsPtr *namespaces;
  VALUE scopes = rb_ary_new();
  int j;

  Data_Get_Struct(rb_node, xmlNode, c_node);

  namespaces = xmlGetNsList(c_node-&gt;doc, c_node);
  if (!namespaces) {
    return scopes;
  }

  for (j = 0 ; namespaces[j] != NULL ; ++j) {
    rb_ary_push(scopes, noko_xml_namespace_wrap(namespaces[j], c_node-&gt;doc));
  }

  xmlFree(namespaces);
  return scopes;
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Array of all the Namespaces on this node and its ancestors.</p> </dd>
</dl> <p>See also <a href="node#method-i-namespaces"><code>#namespaces</code></a></p> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns="http://example.com/root" xmlns:bar="http://example.com/bar"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//root:first", "root" =&gt; "http://example.com/root").namespace_scopes
# =&gt; [#(Namespace:0x3c { href = "http://example.com/root" }),
#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
doc.at_xpath("//child:second", "child" =&gt; "http://example.com/child").namespace_scopes
# =&gt; [#(Namespace:0x64 { href = "http://example.com/child" }),
#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
doc.at_xpath("//root:third", "root" =&gt; "http://example.com/root").namespace_scopes
# =&gt; [#(Namespace:0x78 { prefix = "foo", href = "http://example.com/foo" }),
#     #(Namespace:0x3c { href = "http://example.com/root" }),
#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespaced_key-3F"> <span class="method-callseq"> namespaced_key?(attribute, namespace) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespaced_key-3F-source"> <pre class="c" data-language="c">static VALUE
namespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if (xmlHasNsProp(node, (xmlChar *)StringValueCStr(attribute),
                   NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace))) {
    return Qtrue;
  }
  return Qfalse;
}</pre> </div> <p>Returns true if <code>attribute</code> is set with <code>namespace</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespaces"> <span class="method-callseq"> namespaces() → Hash&lt;String(Namespace#prefix) ⇒ String(Namespace#href)&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespaces-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1022
def namespaces
  namespace_scopes.each_with_object({}) do |ns, hash|
    prefix = ns.prefix
    key = prefix ? "xmlns:#{prefix}" : "xmlns"
    hash[key] = ns.href
  end
end</pre> </div> <p>Fetch all the namespaces on this node and its ancestors.</p> <p>Note that the keys in this hash <a href="../xml"><code>XML</code></a> attributes that would be used to define this namespace, such as “xmlns:prefix”, not just the prefix.</p> <p>The default namespace for this node will be included with key “xmlns”.</p> <p>See also <a href="node#method-i-namespace_scopes"><code>#namespace_scopes</code></a></p> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Hash containing all the namespaces on this node and its ancestors. The hash keys are the namespace prefix, and the hash value for each key is the namespace URI.</p> </dd>
</dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns="http://example.com/root" xmlns:in_scope="http://example.com/in_scope"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
EOF
doc.at_xpath("//root:first", "root" =&gt; "http://example.com/root").namespaces
# =&gt; {"xmlns"=&gt;"http://example.com/root",
#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}
doc.at_xpath("//child:second", "child" =&gt; "http://example.com/child").namespaces
# =&gt; {"xmlns"=&gt;"http://example.com/child",
#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}
doc.at_xpath("//root:third", "root" =&gt; "http://example.com/root").namespaces
# =&gt; {"xmlns:foo"=&gt;"http://example.com/foo",
#     "xmlns"=&gt;"http://example.com/root",
#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-native_content-3D"> <span class="method-callseq"> content= </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="native_content-3D-source"> <pre class="c" data-language="c">static VALUE
set_native_content(VALUE self, VALUE content)
{
  xmlNodePtr node, child, next ;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  while (NULL != child) {
    next = child-&gt;next ;
    xmlUnlinkNode(child) ;
    noko_xml_document_pin_node(child);
    child = next ;
  }

  xmlNodeSetContent(node, (xmlChar *)StringValueCStr(content));
  return content;
}</pre> </div> <p>Set the content for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next_element"> <span class="method-callseq"> next_element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="next_element-source"> <pre class="c" data-language="c">static VALUE
next_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = xmlNextElementSibling(node);
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling);
}</pre> </div> <p>Returns the next <a href="element"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next_sibling"> <span class="method-name">next_sibling</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="next_sibling-source"> <pre class="c" data-language="c">static VALUE
next_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;next;
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling) ;
}</pre> </div> <p>Returns the next sibling node</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-next">next</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_name"> <span class="method-name">node_name</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="node_name-source"> <pre class="c" data-language="c">static VALUE
get_name(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if (node-&gt;name) {
    return NOKOGIRI_STR_NEW2(node-&gt;name);
  }
  return Qnil;
}</pre> </div> <p>Returns the name for this <a href="node"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-name">name</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_name-3D"> <span class="method-name">node_name=</span><span class="method-args">(new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="node_name-3D-source"> <pre class="c" data-language="c">static VALUE
set_name(VALUE self, VALUE new_name)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlNodeSetName(node, (xmlChar *)StringValueCStr(new_name));
  return new_name;
}</pre> </div> <p>Set the name for this <a href="node"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-name-3D">name=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_type"> <span class="method-name">node_type</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="node_type-source"> <pre class="c" data-language="c">static VALUE
node_type(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return INT2NUM((long)node-&gt;type);
}</pre> </div> <p>Get the type for this <a href="node"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-type">type</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parent"> <span class="method-callseq"> parent </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parent-source"> <pre class="c" data-language="c">static VALUE
get_parent(VALUE self)
{
  xmlNodePtr node, parent;
  Data_Get_Struct(self, xmlNode, node);

  parent = node-&gt;parent;
  if (!parent) { return Qnil; }

  return noko_xml_node_wrap(Qnil, parent) ;
}</pre> </div> <p>Get the parent <a href="node"><code>Node</code></a> for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse"> <span class="method-name">parse</span><span class="method-args">(string_or_io, options = nil) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 936
def parse(string_or_io, options = nil)
  ##
  # When the current node is unparented and not an element node, use the
  # document as the parsing context instead. Otherwise, the in-context
  # parser cannot find an element or a document node.
  # Document Fragments are also not usable by the in-context parser.
  if !element? &amp;&amp; !document? &amp;&amp; (!parent || parent.fragment?)
    return document.parse(string_or_io, options)
  end

  options ||= (document.html? ? ParseOptions::DEFAULT_HTML : ParseOptions::DEFAULT_XML)
  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
  yield options if block_given?

  contents = if string_or_io.respond_to?(:read)
    string_or_io.read
  else
    string_or_io
  end

  return Nokogiri::XML::NodeSet.new(document) if contents.empty?

  # libxml2 does not obey the +recover+ option after encountering errors during +in_context+
  # parsing, and so this horrible hack is here to try to emulate recovery behavior.
  #
  # Unfortunately, this means we're no longer parsing "in context" and so namespaces that
  # would have been inherited from the context node won't be handled correctly. This hack was
  # written in 2010, and I regret it, because it's silently degrading functionality in a way
  # that's not easily prevented (or even detected).
  #
  # I think preferable behavior would be to either:
  #
  # a. add an error noting that we "fell back" and pointing the user to turning off the +recover+ option
  # b. don't recover, but raise a sensible exception
  #
  # For context and background: https://github.com/sparklemotion/nokogiri/issues/313
  # FIXME bug report: https://github.com/sparklemotion/nokogiri/issues/2092
  error_count = document.errors.length
  node_set = in_context(contents, options.to_i)
  if node_set.empty? &amp;&amp; (document.errors.length &gt; error_count)
    if options.recover?
      fragment = document.related_class("DocumentFragment").parse(contents)
      node_set = fragment.children
    else
      raise document.errors[error_count]
    end
  end
  node_set
end</pre> </div> <p>Parse <code>string_or_io</code> as a document fragment within the context of <strong>this</strong> node. Returns a <a href="nodeset"><code>XML::NodeSet</code></a> containing the nodes parsed from <code>string_or_io</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-path"> <span class="method-callseq"> path </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="path-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_path(VALUE rb_node)
{
  xmlNodePtr c_node;
  xmlChar *c_path ;
  VALUE rval;

  Data_Get_Struct(rb_node, xmlNode, c_node);

  c_path = xmlGetNodePath(c_node);
  if (c_path == NULL) {
    // see https://github.com/sparklemotion/nokogiri/issues/2250
    // this behavior is clearly undesirable, but is what libxml &lt;= 2.9.10 returned, and so we
    // do this for now to preserve the behavior across libxml2 versions.
    rval = NOKOGIRI_STR_NEW2("?");
  } else {
    rval = NOKOGIRI_STR_NEW2(c_path);
    xmlFree(c_path);
  }

  return rval ;
}</pre> </div> <p>Returns the path associated with this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pointer_id"> <span class="method-callseq"> pointer_id() → Integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pointer_id-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_pointer_id(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM((long)(node));
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>A unique id for this node based on the internal memory structures. This method is used by <a href="node#method-i-3D-3D"><code>#==</code></a> to determine node identity.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-previous_element"> <span class="method-callseq"> previous_element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="previous_element-source"> <pre class="c" data-language="c">static VALUE
previous_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  /*
   *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.
   */
  sibling = node-&gt;prev;
  if (!sibling) { return Qnil; }

  while (sibling &amp;&amp; sibling-&gt;type != XML_ELEMENT_NODE) {
    sibling = sibling-&gt;prev;
  }

  return sibling ? noko_xml_node_wrap(Qnil, sibling) : Qnil ;
}</pre> </div> <p>Returns the previous <a href="element"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-previous_sibling"> <span class="method-name">previous_sibling</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="previous_sibling-source"> <pre class="c" data-language="c">static VALUE
previous_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;prev;
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling);
}</pre> </div> <p>Returns the previous sibling node</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-previous">previous</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-processing_instruction-3F"> <span class="method-name">processing_instruction?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="processing_instruction-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1056
def processing_instruction?
  type == PI_NODE
end</pre> </div> <p>Returns true if this is a <a href="processinginstruction"><code>ProcessingInstruction</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read_only-3F"> <span class="method-name">read_only?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read_only-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1080
def read_only?
  # According to gdome2, these are read-only node types
  [NOTATION_NODE, ENTITY_NODE, ENTITY_DECL].include?(type)
end</pre> </div> <p>Is this a read only node?</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-text"> <span class="method-callseq"> text() → String </span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-text-3F"> <span class="method-name">text?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="text-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1061
def text?
  type == TEXT_NODE
end</pre> </div> <p>Returns true if this is a <a href="text"><code>Text</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1095
def to_s
  document.xml? ? to_xml : to_html
end</pre> </div> <p>Turn this node in to a string. If the document is <a href="../html4"><code>HTML</code></a>, this method returns html. If the document is <a href="../xml"><code>XML</code></a>, this method returns <a href="../xml"><code>XML</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_str"> <span class="method-callseq"> to_str() → String </span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-traverse"> <span class="method-name">traverse</span><span class="method-args">() { |self| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="traverse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1137
def traverse(&amp;block)
  children.each { |j| j.traverse(&amp;block) }
  yield(self)
end</pre> </div> <p>Yields self and all children to <code>block</code> recursively.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-type"> <span class="method-name">type</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-node_type">node_type</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unlink"> <span class="method-callseq"> unlink() → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unlink-source"> <pre class="c" data-language="c">static VALUE
unlink_node(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlUnlinkNode(node);
  noko_xml_document_pin_node(node);
  return self;
}</pre> </div> <p>Unlink this node from its current context.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-remove">remove</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-xml-3F"> <span class="method-name">xml?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="xml-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1041
def xml?
  type == DOCUMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="document"><code>XML::Document</code></a> node</p>  </div> </div> </section> <section id="protected-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Protected Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-coerce"> <span class="method-name">coerce</span><span class="method-args">(data)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="coerce-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1312
      def coerce(data)
        case data
        when XML::NodeSet
          return data
        when XML::DocumentFragment
          return data.children
        when String
          return fragment(data).children
        when Document, XML::Attr
          # unacceptable
        when XML::Node
          return data
        end

        raise ArgumentError, &lt;&lt;~EOERR
          Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.
          (You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)
        EOERR
      end</pre> </div>  </div> </div> </section> </section> <section id="Manipulating+Document+Structure" class="documentation-section"> <header class="documentation-section-title"> <h2> Manipulating Document Structure </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Manipulating+Document+Structure-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3C"> <span class="method-name">&lt;&lt;</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 190
def &lt;&lt;(node_or_tags)
  add_child(node_or_tags)
  self
end</pre> </div> <p>Add <code>node_or_tags</code> as a child of this <a href="node"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls (e.g., root &lt;&lt; child1 &lt;&lt; child2)</p> <p>Also see related method <code>add_child</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_child"> <span class="method-name">add_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 145
def add_child(node_or_tags)
  node_or_tags = coerce(node_or_tags)
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }
  else
    add_child_node_and_reparent_attrs(node_or_tags)
  end
  node_or_tags
end</pre> </div> <p>Add <code>node_or_tags</code> as a child of this <a href="node"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method +&lt;&lt;+.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-add_namespace"> <span class="method-callseq"> add_namespace(prefix, href) → Nokogiri::XML::Namespace </span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-add_namespace_definition">add_namespace_definition</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_namespace_definition"> <span class="method-name">add_namespace_definition</span><span class="method-args">(prefix, href) → Nokogiri::XML::Namespace</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_namespace_definition-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_add_namespace_definition(VALUE rb_node, VALUE rb_prefix, VALUE rb_href)
{
  xmlNodePtr c_node, element;
  xmlNsPtr c_namespace;
  const xmlChar *c_prefix = (const xmlChar *)(NIL_P(rb_prefix) ? NULL : StringValueCStr(rb_prefix));

  Data_Get_Struct(rb_node, xmlNode, c_node);
  element = c_node ;

  c_namespace = xmlSearchNs(c_node-&gt;doc, c_node, c_prefix);

  if (!c_namespace) {
    if (c_node-&gt;type != XML_ELEMENT_NODE) {
      element = c_node-&gt;parent;
    }
    c_namespace = xmlNewNs(element, (const xmlChar *)StringValueCStr(rb_href), c_prefix);
  }

  if (!c_namespace) {
    return Qnil ;
  }

  if (NIL_P(rb_prefix) || c_node != element) {
    xmlSetNs(c_node, c_namespace);
  }

  return noko_xml_namespace_wrap(c_namespace, c_node-&gt;doc);
}</pre> </div> <p>Adds a namespace definition to this node with <code>prefix</code> using <code>href</code> value, as if this node had included an attribute “xmlns:prefix=href”.</p> <p>A default namespace definition for this node can be added by passing <code>nil</code> for <code>prefix</code>.</p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul>
<li> <p><code>prefix</code> (String, <code>nil</code>) An <a href="https://www.w3.org/TR/xml-names/#ns-decl">XML Name</a></p> </li>
<li> <p><code>href</code> (String) The <a href="https://www.w3.org/TR/xml-names/#sec-namespaces">URI reference</a></p> </li>
</ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The new <a href="namespace"><code>Nokogiri::XML::Namespace</code></a></p> </dd>
</dl> <p><strong>Example:</strong> adding a non-default namespace definition</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;store&gt;&lt;inventory&gt;&lt;/inventory&gt;&lt;/store&gt;")
inventory = doc.at_css("inventory")
inventory.add_namespace_definition("automobile", "http://alices-autos.com/")
inventory.add_namespace_definition("bicycle", "http://bobs-bikes.com/")
inventory.add_child("&lt;automobile:tire&gt;Michelin model XGV, size 75R&lt;/automobile:tire&gt;")
doc.to_xml
# =&gt; "&lt;?xml version=\"1.0\"?&gt;\n" +
#    "&lt;store&gt;\n" +
#    "  &lt;inventory xmlns:automobile=\"http://alices-autos.com/\" xmlns:bicycle=\"http://bobs-bikes.com/\"&gt;\n" +
#    "    &lt;automobile:tire&gt;Michelin model XGV, size 75R&lt;/automobile:tire&gt;\n" +
#    "  &lt;/inventory&gt;\n" +
#    "&lt;/store&gt;\n"
</pre> <p><strong>Example:</strong> adding a default namespace definition</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;store&gt;&lt;inventory&gt;&lt;tire&gt;Michelin model XGV, size 75R&lt;/tire&gt;&lt;/inventory&gt;&lt;/store&gt;")
doc.at_css("tire").add_namespace_definition(nil, "http://bobs-bikes.com/")
doc.to_xml
# =&gt; "&lt;?xml version=\"1.0\"?&gt;\n" +
#    "&lt;store&gt;\n" +
#    "  &lt;inventory&gt;\n" +
#    "    &lt;tire xmlns=\"http://bobs-bikes.com/\"&gt;Michelin model XGV, size 75R&lt;/tire&gt;\n" +
#    "  &lt;/inventory&gt;\n" +
#    "&lt;/store&gt;\n"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-add_namespace">add_namespace</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_next_sibling"> <span class="method-name">add_next_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_next_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 216
def add_next_sibling(node_or_tags)
  raise ArgumentError,
    "A document may not have multiple root nodes." if parent&amp;.document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling(:next, node_or_tags)
end</pre> </div> <p>Insert <code>node_or_tags</code> after this <a href="node"><code>Node</code></a> (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>after</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-next-3D">next=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_previous_sibling"> <span class="method-name">add_previous_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_previous_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 202
def add_previous_sibling(node_or_tags)
  raise ArgumentError,
    "A document may not have multiple root nodes." if parent&amp;.document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling(:previous, node_or_tags)
end</pre> </div> <p>Insert <code>node_or_tags</code> before this <a href="node"><code>Node</code></a> (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>before</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-previous-3D">previous=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-after"> <span class="method-name">after</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="after-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 242
def after(node_or_tags)
  add_next_sibling(node_or_tags)
  self
end</pre> </div> <p>Insert <code>node_or_tags</code> after this node (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>add_next_sibling</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-before"> <span class="method-name">before</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="before-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 230
def before(node_or_tags)
  add_previous_sibling(node_or_tags)
  self
end</pre> </div> <p>Insert <code>node_or_tags</code> before this node (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>add_previous_sibling</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-children-3D"> <span class="method-name">children=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="children-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 261
def children=(node_or_tags)
  node_or_tags = coerce(node_or_tags)
  children.unlink
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }
  else
    add_child_node_and_reparent_attrs(node_or_tags)
  end
end</pre> </div> <p>Set the inner html for this <a href="node"><code>Node</code></a> <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p> <p>Also see related method <code>inner_html=</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-content-3D"> <span class="method-name">content=</span><span class="method-args">(string)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="content-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 317
def content=(string)
  self.native_content = encode_special_chars(string.to_s)
end</pre> </div> <p>Set the Node’s content to a <a href="text"><code>Text</code></a> node containing <code>string</code>. The string gets <a href="../xml"><code>XML</code></a> escaped, not interpreted as markup.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default_namespace-3D"> <span class="method-name">default_namespace=</span><span class="method-args">(url)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 333
def default_namespace=(url)
  add_namespace_definition(nil, url)
end</pre> </div> <p>Adds a default namespace supplied as a string <code>url</code> href, to self. The consequence is as an xmlns attribute with supplied argument were present in parsed <a href="../xml"><code>XML</code></a>. A default namespace set with this method will now show up in <a href="node#method-i-attributes"><code>#attributes</code></a>, but when this node is serialized to <a href="../xml"><code>XML</code></a> an “xmlns” attribute will appear. See also <a href="node#method-i-namespace"><code>#namespace</code></a> and <a href="node#method-i-namespace-3D"><code>#namespace=</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_xinclude"> <span class="method-name">do_xinclude</span><span class="method-args">(options = XML::ParseOptions::DEFAULT_XML) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_xinclude-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 360
def do_xinclude(options = XML::ParseOptions::DEFAULT_XML)
  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
  yield options if block_given?

  # call c extension
  process_xincludes(options.to_i)
end</pre> </div> <p>Do xinclude substitution on the subtree below node. If given a block, a <a href="parseoptions"><code>Nokogiri::XML::ParseOptions</code></a> object initialized from <code>options</code>, will be passed to it, allowing more convenient modification of the parser options.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inner_html-3D"> <span class="method-name">inner_html=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inner_html-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 252
def inner_html=(node_or_tags)
  self.children = node_or_tags
end</pre> </div> <p>Set the inner html for this <a href="node"><code>Node</code></a> to <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p> <p>Also see related method <code>children=</code></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-name-3D"> <span class="method-callseq"> name=(new_name) </span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-node_name-3D">node_name=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace-3D"> <span class="method-name">namespace=</span><span class="method-args">(ns)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 343
def namespace=(ns)
  return set_namespace(ns) unless ns

  unless Nokogiri::XML::Namespace === ns
    raise TypeError, "#{ns.class} can't be coerced into Nokogiri::XML::Namespace"
  end
  if ns.document != document
    raise ArgumentError, "namespace must be declared on the same document"
  end

  set_namespace(ns)
end</pre> </div> <p>Set the default namespace on this node (as would be defined with an “xmlns=” attribute in <a href="../xml"><code>XML</code></a> source), as a <a href="namespace"><code>Namespace</code></a> object <code>ns</code>. Note that a <a href="namespace"><code>Namespace</code></a> added this way will NOT be serialized as an xmlns attribute for this node. You probably want <a href="node#method-i-default_namespace-3D"><code>#default_namespace=</code></a> instead, or perhaps <a href="node#method-i-add_namespace_definition"><code>#add_namespace_definition</code></a> with a nil prefix argument.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-next"> <span class="method-name">next</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-next_sibling">next_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-next-3D"> <span class="method-name">next=</span><span class="method-args">(node_or_tags)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-add_next_sibling">add_next_sibling</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parent-3D"> <span class="method-name">parent=</span><span class="method-args">(parent_node)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parent-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 323
def parent=(parent_node)
  parent_node.add_child(self)
end</pre> </div> <p>Set the parent <a href="node"><code>Node</code></a> for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-prepend_child"> <span class="method-name">prepend_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="prepend_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 162
def prepend_child(node_or_tags)
  if (first = children.first)
    # Mimic the error add_child would raise.
    raise "Document already has a root node" if document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)
    first.__send__(:add_sibling, :previous, node_or_tags)
  else
    add_child(node_or_tags)
  end
end</pre> </div> <p>Add <code>node_or_tags</code> as the first child of this <a href="node"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>add_child</code>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-previous"> <span class="method-name">previous</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-previous_sibling">previous_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-previous-3D"> <span class="method-name">previous=</span><span class="method-args">(node_or_tags)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-add_previous_sibling">add_previous_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-remove"> <span class="method-name">remove</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-unlink">unlink</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-replace"> <span class="method-name">replace</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="replace-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 278
def replace(node_or_tags)
  raise("Cannot replace a node with no parent") unless parent

  # We cannot replace a text node directly, otherwise libxml will return
  # an internal error at parser.c:13031, I don't know exactly why
  # libxml is trying to find a parent node that is an element or document
  # so I can't tell if this is bug in libxml or not. issue #775.
  if text?
    replacee = Nokogiri::XML::Node.new("dummy", document)
    add_previous_sibling_node(replacee)
    unlink
    return replacee.replace(node_or_tags)
  end

  node_or_tags = parent.coerce(node_or_tags)

  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_previous_sibling(n) }
    unlink
  else
    replace_node(node_or_tags)
  end
  node_or_tags
end</pre> </div> <p>Replace this <a href="node"><code>Node</code></a> with <code>node_or_tags</code>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>swap</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-swap"> <span class="method-name">swap</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="swap-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 310
def swap(node_or_tags)
  replace(node_or_tags)
  self
end</pre> </div> <p>Swap this <a href="node"><code>Node</code></a> for <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>replace</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-wrap"> <span class="method-name">wrap</span><span class="method-args">(html)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="wrap-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 176
def wrap(html)
  new_parent = document.parse(html).first
  add_next_sibling(new_parent)
  new_parent.add_child(self)
  self
end</pre> </div> <p>Add html around this node</p> <p>Returns self</p>  </div> </div> </section> </section> <section id="Serialization+and+Generating+Output" class="documentation-section"> <header class="documentation-section-title"> <h2> Serialization and Generating Output </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Serialization+and+Generating+Output-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-canonicalize"> <span class="method-name">canonicalize</span><span class="method-args">(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="canonicalize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1300
def canonicalize(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false)
  c14n_root = self
  document.canonicalize(mode, inclusive_namespaces, with_comments) do |node, parent|
    tn = node.is_a?(XML::Node) ? node : parent
    tn == c14n_root || tn.ancestors.include?(c14n_root)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-serialize"> <span class="method-name">serialize</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="serialize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1181
def serialize(*args, &amp;block)
  options = if args.first.is_a?(Hash)
    args.shift
  else
    {
      encoding: args[0],
      save_with: args[1],
    }
  end

  encoding = options[:encoding] || document.encoding
  options[:encoding] = encoding

  outstring = +""
  outstring.force_encoding(Encoding.find(encoding || "utf-8"))
  io = StringIO.new(outstring)
  write_to(io, options, &amp;block)
  io.string
end</pre> </div> <p>Serialize <a href="node"><code>Node</code></a> using <code>options</code>. Save options can also be set using a block. See <a href="node/saveoptions"><code>SaveOptions</code></a>.</p> <p>These two statements are equivalent:</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8', :save_with =&gt; FORMAT | AS_XML)
</pre> <p>or</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8') do |config|
  config.format.as_xml
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_html"> <span class="method-name">to_html</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1208
def to_html(options = {})
  to_format(SaveOptions::DEFAULT_HTML, options)
end</pre> </div> <p>Serialize this <a href="node"><code>Node</code></a> to <a href="../html4"><code>HTML</code></a></p> <pre class="ruby" data-language="ruby">doc.to_html
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code>. For formatted output, use <a href="node#method-i-to_xhtml"><code>Node#to_xhtml</code></a> instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_xhtml"> <span class="method-name">to_xhtml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_xhtml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1229
def to_xhtml(options = {})
  to_format(SaveOptions::DEFAULT_XHTML, options)
end</pre> </div> <p>Serialize this <a href="node"><code>Node</code></a> to XHTML using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xhtml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_xml"> <span class="method-name">to_xml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_xml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1218
def to_xml(options = {})
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  serialize(options)
end</pre> </div> <p>Serialize this <a href="node"><code>Node</code></a> to <a href="../xml"><code>XML</code></a> using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_html_to"> <span class="method-name">write_html_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_html_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1277
def write_html_to(io, options = {})
  write_format_to(SaveOptions::DEFAULT_HTML, io, options)
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> as <a href="../html4"><code>HTML</code></a> to <code>io</code> with <code>options</code></p> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_to"> <span class="method-name">write_to</span><span class="method-args">(io, *options) { |config| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1250
def write_to(io, *options)
  options = options.first.is_a?(Hash) ? options.shift : {}
  encoding = options[:encoding] || options[0]
  if Nokogiri.jruby?
    save_options = options[:save_with] || options[1]
    indent_times = options[:indent] || 0
  else
    save_options = options[:save_with] || options[1] || SaveOptions::FORMAT
    indent_times = options[:indent] || 2
  end
  indent_text = options[:indent_text] || " "

  # Any string times 0 returns an empty string. Therefore, use the same
  # string instead of generating a new empty string for every node with
  # zero indentation.
  indentation = indent_times.zero? ? "" : (indent_text * indent_times)

  config = SaveOptions.new(save_options.to_i)
  yield config if block_given?

  native_write_to(io, encoding, indentation, config.options)
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> to <code>io</code> with <code>options</code>. <code>options</code> modify the output of this method. Valid options are:</p> <ul>
<li> <p><code>:encoding</code> for changing the encoding</p> </li>
<li> <p><code>:indent_text</code> the indentation text, defaults to one space</p> </li>
<li> <p><code>:indent</code> the number of <code>:indent_text</code> to use, defaults to 2</p> </li>
<li> <p><code>:save_with</code> a combination of <a href="node/saveoptions"><code>SaveOptions</code></a> constants.</p> </li>
</ul> <p>To save with UTF-8 indented twice:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :encoding =&gt; 'UTF-8', :indent =&gt; 2)
</pre> <p>To save indented with two dashes:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :indent_text =&gt; '-', :indent =&gt; 2)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_xhtml_to"> <span class="method-name">write_xhtml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_xhtml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1285
def write_xhtml_to(io, options = {})
  write_format_to(SaveOptions::DEFAULT_XHTML, io, options)
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> as XHTML to <code>io</code> with <code>options</code></p> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_xml_to"> <span class="method-name">write_xml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_xml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 1295
def write_xml_to(io, options = {})
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  write_to(io, options)
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> as <a href="../xml"><code>XML</code></a> to <code>io</code> with <code>options</code></p> <pre class="ruby" data-language="ruby">doc.write_xml_to io, :encoding =&gt; 'UTF-8'
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of options</p>  </div> </div> </section> </section> <section id="Traversing+Document+Structure" class="documentation-section"> <header class="documentation-section-title"> <h2> Traversing Document Structure </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Traversing+Document+Structure-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-child"> <span class="method-callseq"> child() → Nokogiri::XML::Node </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="child-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>First of this node’s children, or <code>nil</code> if there are no children</p> </dd>
</dl> <p>This is a convenience method and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.children.first
</pre> <p>See related: <a href="node#method-i-children"><code>#children</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-children"> <span class="method-callseq"> children() → Nokogiri::XML::NodeSet </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="children-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if (!child) { return noko_xml_node_set_wrap(set, document); }

  child = child-&gt;next;
  while (NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = child-&gt;next;
  }

  node_set = noko_xml_node_set_wrap(set, document);

  return node_set;
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><a href="nodeset"><code>Nokogiri::XML::NodeSet</code></a> containing this node’s children.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-document"> <span class="method-callseq"> document() → Nokogiri::XML::Document </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="document-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_document(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return DOC_RUBY_OBJECT(node-&gt;doc);
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Parent <a href="document"><code>Nokogiri::XML::Document</code></a> for this node</p> </dd>
</dl>  </div> </div> </section> </section> <section id="Working+With+Node+Attributes" class="documentation-section"> <header class="documentation-section-title"> <h2> Working With Node Attributes </h2> <span class="section-click-top"> <a href="#top">↑ top</a> </span> </header> <section id="public-instance-Working+With+Node+Attributes-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> [](name) → (String, nil) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 418
def [](name)
  get(name.to_s)
end</pre> </div> <p>Fetch an attribute from this node.</p> <p>⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes, use <a href="node#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>.</p> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>(String, nil) value of the attribute <code>name</code>, or <code>nil</code> if no matching attribute exists</p> </dd>
</dl> <p><strong>Example</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;")
child = doc.at_css("child")
child["size"] # =&gt; "large"
child["class"] # =&gt; "big wide tall"
</pre> <p><strong>Example:</strong> Namespaced attributes will not be returned.</p> <p>⚠ Note namespaced attributes may be accessed with <a href="node#method-i-attribute"><code>#attribute</code></a> or <a href="node#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'&gt;
    &lt;child width:size='broad'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child")["size"] # =&gt; nil
doc.at_css("child").attribute("size").value # =&gt; "broad"
doc.at_css("child").attribute_with_ns("size", "http://example.com/widths").value
# =&gt; "broad"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-get_attribute">get_attribute</a>, <a href="node#method-i-attr">attr</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> []=(name, value) → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 456
def []=(name, value)
  set(name.to_s, value.to_s)
end</pre> </div> <p>Update the attribute <code>name</code> to <code>value</code>, or create the attribute if it does not exist.</p> <p>⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes for update, use <a href="node#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>. To add a namespaced attribute, see the example below.</p> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>value</code></p> </dd>
</dl> <p><strong>Example</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child/&gt;&lt;/root&gt;")
child = doc.at_css("child")
child["size"] = "broad"
child.to_html
# =&gt; "&lt;child size=\"broad\"&gt;&lt;/child&gt;"
</pre> <p><strong>Example:</strong> Add a namespaced attribute.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'&gt;
    &lt;child/&gt;
  &lt;/root&gt;
EOF
child = doc.at_css("child")
child["size"] = "broad"
ns = doc.root.namespace_definitions.find { |ns| ns.prefix == "width" }
child.attribute("size").namespace = ns
doc.to_html
# =&gt; "&lt;root xmlns:width=\"http://example.com/widths\"&gt;\n" +
#    "  &lt;child width:size=\"broad\"&gt;&lt;/child&gt;\n" +
#    "&lt;/root&gt;\n"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-set_attribute">set_attribute</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_class"> <span class="method-callseq"> add_class(names) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 621
def add_class(names)
  kwattr_add("class", names)
end</pre> </div> <p>Ensure <a href="../html4"><code>HTML</code></a> <a href="../css"><code>CSS</code></a> classes are present on <code>self</code>. Any <a href="../css"><code>CSS</code></a> classes in <code>names</code> that already exist in the “class” attribute are <em>not</em> added. Note that any existing duplicates in the “class” attribute are not removed. Compare with <a href="node#method-i-append_class"><code>#append_class</code></a>.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_add("class", names)
</pre> <p>See related: <a href="node#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node#method-i-classes"><code>#classes</code></a>, <a href="node#method-i-append_class"><code>#append_class</code></a>, <a href="node#method-i-remove_class"><code>#remove_class</code></a></p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul><li> <p><code>names</code> (String, Array&lt;String&gt;)</p> <p><a href="../css"><code>CSS</code></a> class names to be added to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will not be added. Any class names not present will be added. If no “class” attribute exists, one is created.</p> </li></ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>self</code> (<a href="node"><code>Node</code></a>) for ease of chaining method calls.</p> </dd>
</dl> <p><strong>Example:</strong> Ensure that the node has <a href="../css"><code>CSS</code></a> class “section”</p> <pre class="ruby" data-language="ruby">node                      # =&gt; &lt;div&gt;&lt;/div&gt;
node.add_class("section") # =&gt; &lt;div class="section"&gt;&lt;/div&gt;
node.add_class("section") # =&gt; &lt;div class="section"&gt;&lt;/div&gt; # duplicate not added
</pre> <p><strong>Example:</strong> Ensure that the node has <a href="../css"><code>CSS</code></a> classes “section” and “header”, via a String argument</p> <p>Note that the <a href="../css"><code>CSS</code></a> class “section” is not added because it is already present. Note also that the pre-existing duplicate <a href="../css"><code>CSS</code></a> class “section” is not removed.</p> <pre class="ruby" data-language="ruby">node                             # =&gt; &lt;div class="section section"&gt;&lt;/div&gt;
node.add_class("section header") # =&gt; &lt;div class="section section header"&gt;&lt;/div&gt;
</pre> <p><strong>Example:</strong> Ensure that the node has <a href="../css"><code>CSS</code></a> classes “section” and “header”, via an Array argument</p> <pre class="ruby" data-language="ruby">node                                  # =&gt; &lt;div&gt;&lt;/div&gt;
node.add_class(["section", "header"]) # =&gt; &lt;div class="section header"&gt;&lt;/div&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-append_class"> <span class="method-callseq"> append_class(names) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="append_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 665
def append_class(names)
  kwattr_append("class", names)
end</pre> </div> <p>Add <a href="../html4"><code>HTML</code></a> <a href="../css"><code>CSS</code></a> classes to <code>self</code>, regardless of duplication. Compare with <a href="node#method-i-add_class"><code>#add_class</code></a>.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_append("class", names)
</pre> <p>See related: <a href="node#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="node#method-i-classes"><code>#classes</code></a>, <a href="node#method-i-add_class"><code>#add_class</code></a>, <a href="node#method-i-remove_class"><code>#remove_class</code></a></p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul><li> <p><code>names</code> (String, Array&lt;String&gt;)</p> <p><a href="../css"><code>CSS</code></a> class names to be appended to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. All class names passed in will be appended to the “class” attribute even if they are already present in the attribute value. If no “class” attribute exists, one is created.</p> </li></ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>self</code> (<a href="node"><code>Node</code></a>) for ease of chaining method calls.</p> </dd>
</dl> <p><strong>Example:</strong> Append “section” to the node’s <a href="../css"><code>CSS</code></a> “class” attribute</p> <pre class="ruby" data-language="ruby">node                         # =&gt; &lt;div&gt;&lt;/div&gt;
node.append_class("section") # =&gt; &lt;div class="section"&gt;&lt;/div&gt;
node.append_class("section") # =&gt; &lt;div class="section section"&gt;&lt;/div&gt; # duplicate added!
</pre> <p><strong>Example:</strong> Append “section” and “header” to the noded’s <a href="../css"><code>CSS</code></a> “class” attribute, via a String argument</p> <p>Note that the <a href="../css"><code>CSS</code></a> class “section” is appended even though it is already present</p> <pre class="ruby" data-language="ruby">node                                # =&gt; &lt;div class="section section"&gt;&lt;/div&gt;
node.append_class("section header") # =&gt; &lt;div class="section section section header"&gt;&lt;/div&gt;
</pre> <p><strong>Example:</strong> Append “section” and “header” to the node’s <a href="../css"><code>CSS</code></a> “class” attribute, via an Array argument</p> <pre class="ruby" data-language="ruby">node                                     # =&gt; &lt;div&gt;&lt;/div&gt;
node.append_class(["section", "header"]) # =&gt; &lt;div class="section header"&gt;&lt;/div&gt;
node.append_class(["section", "header"]) # =&gt; &lt;div class="section header section header"&gt;&lt;/div&gt;
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-attr"> <span class="method-name">attr</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute"> <span class="method-callseq"> attribute(name) → Nokogiri::XML::Attr </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attribute-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_attribute(VALUE self, VALUE name)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));

  if (! prop) { return Qnil; }
  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Attribute (<a href="attr"><code>Nokogiri::XML::Attr</code></a>) belonging to this node with name <code>name</code>.</p> </dd>
</dl> <p>⚠ Note that attribute namespaces are ignored and only the simple (non-namespace-prefixed) name is used to find a matching attribute. In case of a simple name collision, only one of the matching attributes will be returned. In this case, you will need to use <a href="node#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>.</p> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;")
child = doc.at_css("child")
child.attribute("size") # =&gt; #&lt;Nokogiri::XML::Attr:0x550 name="size" value="large"&gt;
child.attribute("class") # =&gt; #&lt;Nokogiri::XML::Attr:0x564 name="class" value="big wide tall"&gt;
</pre> <p><strong>Example</strong> showing that namespaced attributes will not be returned:</p> <p>⚠ Note that only one of the two matching attributes is returned.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attribute("size")
# =&gt; #(Attr:0x550 {
#      name = "size",
#      namespace = #(Namespace:0x564 {
#        prefix = "width",
#        href = "http://example.com/widths"
#        }),
#      value = "broad"
#      })
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute_nodes"> <span class="method-callseq"> attribute_nodes() → Array&lt;Nokogiri::XML::Attr&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attribute_nodes-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_attribute_nodes(VALUE rb_node)
{
  xmlNodePtr c_node;

  Data_Get_Struct(rb_node, xmlNode, c_node);

  return noko_xml_node_attrs(c_node);
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Attributes (an Array of <a href="attr"><code>Nokogiri::XML::Attr</code></a>) belonging to this node.</p> </dd>
</dl> <p>Note that this is the preferred alternative to <a href="node#method-i-attributes"><code>#attributes</code></a> when the simple (non-namespace-prefixed) attribute names may collide.</p> <p><strong>Example:</strong></p> <p>Contrast this with the colliding-name example from <a href="node#method-i-attributes"><code>#attributes</code></a>.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attribute_nodes
# =&gt; [#(Attr:0x550 {
#       name = "size",
#       namespace = #(Namespace:0x564 {
#         prefix = "width",
#         href = "http://example.com/widths"
#         }),
#       value = "broad"
#       }),
#     #(Attr:0x578 {
#       name = "size",
#       namespace = #(Namespace:0x58c {
#         prefix = "height",
#         href = "http://example.com/heights"
#         }),
#       value = "tall"
#       })]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute_with_ns"> <span class="method-callseq"> attribute_with_ns(name, namespace) → Nokogiri::XML::Attr </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attribute_with_ns-source"> <pre class="c" data-language="c">static VALUE
rb_xml_node_attribute_with_ns(VALUE self, VALUE name, VALUE namespace)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasNsProp(node, (xmlChar *)StringValueCStr(name),
                      NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace));

  if (! prop) { return Qnil; }
  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
}</pre> </div> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Attribute (<a href="attr"><code>Nokogiri::XML::Attr</code></a>) belonging to this node with matching <code>name</code> and <code>namespace</code>.</p> </dd>
</dl> <ul>
<li> <p><code>name</code> (String): the simple (non-namespace-prefixed) name of the attribute</p> </li>
<li> <p><code>namespace</code> (String): the URI of the attribute’s namespace</p> </li>
</ul> <p>See related: <a href="node#method-i-attribute"><code>#attribute</code></a></p> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attribute_with_ns("size", "http://example.com/widths")
# =&gt; #(Attr:0x550 {
#      name = "size",
#      namespace = #(Namespace:0x564 {
#        prefix = "width",
#        href = "http://example.com/widths"
#        }),
#      value = "broad"
#      })
doc.at_css("child").attribute_with_ns("size", "http://example.com/heights")
# =&gt; #(Attr:0x578 {
#      name = "size",
#      namespace = #(Namespace:0x58c {
#        prefix = "height",
#        href = "http://example.com/heights"
#        }),
#      value = "tall"
#      })
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attributes"> <span class="method-callseq"> attributes() → Hash&lt;String ⇒ Nokogiri::XML::Attr&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attributes-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 515
def attributes
  attribute_nodes.each_with_object({}) do |node, hash|
    hash[node.node_name] = node
  end
end</pre> </div> <p>Fetch this node’s attributes.</p> <p>⚠ Because the keys do not include any namespace information for the attribute, in case of a simple name collision, not all attributes will be returned. In this case, you will need to use <a href="node#method-i-attribute_nodes"><code>#attribute_nodes</code></a>.</p> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>Hash containing attributes belonging to <code>self</code>. The hash keys are String attribute names (without the namespace), and the hash values are <a href="attr"><code>Nokogiri::XML::Attr</code></a>.</p> </dd>
</dl> <p><strong>Example</strong> with no namespaces:</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;")
doc.at_css("child").attributes
# =&gt; {"size"=&gt;#(Attr:0x550 { name = "size", value = "large" }),
#     "class"=&gt;#(Attr:0x564 { name = "class", value = "big wide tall" })}
</pre> <p><strong>Example</strong> with a namespace:</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML("&lt;root xmlns:desc='http://example.com/sizes'&gt;&lt;child desc:size='large'/&gt;&lt;/root&gt;")
doc.at_css("child").attributes
# =&gt; {"size"=&gt;
#      #(Attr:0x550 {
#        name = "size",
#        namespace = #(Namespace:0x564 {
#          prefix = "desc",
#          href = "http://example.com/sizes"
#          }),
#        value = "large"
#        })}
</pre> <p><strong>Example</strong> with an attribute name collision:</p> <p>⚠ Note that only one of the attributes is returned in the Hash.</p> <pre class="ruby" data-language="ruby">doc = Nokogiri::XML(&lt;&lt;~EOF)
  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
EOF
doc.at_css("child").attributes
# =&gt; {"size"=&gt;
#      #(Attr:0x550 {
#        name = "size",
#        namespace = #(Namespace:0x564 {
#          prefix = "height",
#          href = "http://example.com/heights"
#          }),
#        value = "tall"
#        })}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-classes"> <span class="method-callseq"> classes() → Array&lt;String&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="classes-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 575
def classes
  kwattr_values("class")
end</pre> </div> <p>Fetch <a href="../css"><code>CSS</code></a> class names of a <a href="node"><code>Node</code></a>.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_values("class")
</pre> <p>See related: <a href="node#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node#method-i-add_class"><code>#add_class</code></a>, <a href="node#method-i-append_class"><code>#append_class</code></a>, <a href="node#method-i-remove_class"><code>#remove_class</code></a></p> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>The <a href="../css"><code>CSS</code></a> classes (Array of String) present in the Node’s “class” attribute. If the attribute is empty or non-existent, the return value is an empty array.</p> </dd>
</dl> <p><strong>Example</strong></p> <pre class="ruby" data-language="ruby">node         # =&gt; &lt;div class="section title header"&gt;&lt;/div&gt;
node.classes # =&gt; ["section", "title", "header"]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-remove_attribute">remove_attribute</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">() { |node_name, value| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 541
def each
  attribute_nodes.each do |node|
    yield [node.node_name, node.value]
  end
end</pre> </div> <p>Iterate over each attribute name and value pair for this <a href="node"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-get_attribute"> <span class="method-name">get_attribute</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-has_attribute-3F"> <span class="method-name">has_attribute?</span><span class="method-args">(p1)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-key-3F">key?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-keys"> <span class="method-name">keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="keys-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 535
def keys
  attribute_nodes.map(&amp;:node_name)
end</pre> </div> <p>Get the attribute names for this <a href="node"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-kwattr_add"> <span class="method-callseq"> kwattr_add(attribute_name, keywords) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_add-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 798
def kwattr_add(attribute_name, keywords)
  keywords = keywordify(keywords)
  current_kws = kwattr_values(attribute_name)
  new_kws = (current_kws + (keywords - current_kws)).join(" ")
  set_attribute(attribute_name, new_kws)
  self
end</pre> </div> <p>Ensure that values are present in a keyword attribute.</p> <p>Any values in <code>keywords</code> that already exist in the Node’s attribute values are <em>not</em> added. Note that any existing duplicates in the attribute values are not removed. Compare with <a href="node#method-i-kwattr_append"><code>#kwattr_append</code></a>.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4"><code>HTML</code></a> “class” attribute used to contain <a href="../css"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node#method-i-add_class"><code>#add_class</code></a>, <a href="node#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="node#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul>
<li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p> </li>
<li> <p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be added to the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. Any values already present will not be added. Any values not present will be added. If the named attribute does not exist, it is created.</p> </li>
</ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>self</code> (<a href="node"><code>Nokogiri::XML::Node</code></a>) for ease of chaining method calls.</p> </dd>
</dl> <p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” in its <code>rel</code> attribute.</p> <p>Note that duplicates are not added.</p> <pre class="ruby" data-language="ruby">node                               # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_add("rel", "nofollow") # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
node.kwattr_add("rel", "nofollow") # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
</pre> <p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” and “noreferrer” in its <code>rel</code> attribute, via a String argument.</p> <pre>Note that "nofollow" is not added because it is already present. Note also that the
pre-existing duplicate "nofollow" is not removed.

 node                                          # =&gt; &lt;a rel="nofollow nofollow"&gt;&lt;/a&gt;
 node.kwattr_add("rel", "nofollow noreferrer") # =&gt; &lt;a rel="nofollow nofollow noreferrer"&gt;&lt;/a&gt;</pre> <p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” and “noreferrer” in its <code>rel</code> attribute, via an Array argument.</p> <pre class="ruby" data-language="ruby">node                                               # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_add("rel", ["nofollow", "noreferrer"]) # =&gt; &lt;a rel="nofollow noreferrer"&gt;&lt;/a&gt;
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-kwattr_append"> <span class="method-callseq"> kwattr_append(attribute_name, keywords) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_append-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 851
def kwattr_append(attribute_name, keywords)
  keywords = keywordify(keywords)
  current_kws = kwattr_values(attribute_name)
  new_kws = (current_kws + keywords).join(" ")
  set_attribute(attribute_name, new_kws)
  self
end</pre> </div> <p>Add keywords to a Node’s keyword attribute, regardless of duplication. Compare with <a href="node#method-i-kwattr_add"><code>#kwattr_add</code></a>.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4"><code>HTML</code></a> “class” attribute used to contain <a href="../css"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node#method-i-append_class"><code>#append_class</code></a>, <a href="node#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul>
<li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p> </li>
<li> <p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be added to the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. All values passed in will be appended to the named attribute even if they are already present in the attribute. If the named attribute does not exist, it is created.</p> </li>
</ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>self</code> (<a href="node"><code>Node</code></a>) for ease of chaining method calls.</p> </dd>
</dl> <p><strong>Example:</strong> Append “nofollow” to the <code>rel</code> attribute.</p> <p>Note that duplicates are added.</p> <pre class="ruby" data-language="ruby">node                                  # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_append("rel", "nofollow") # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
node.kwattr_append("rel", "nofollow") # =&gt; &lt;a rel="nofollow nofollow"&gt;&lt;/a&gt;
</pre> <p><strong>Example:</strong> Append “nofollow” and “noreferrer” to the <code>rel</code> attribute, via a String argument.</p> <p>Note that “nofollow” is appended even though it is already present.</p> <pre class="ruby" data-language="ruby">node                                             # =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;
node.kwattr_append("rel", "nofollow noreferrer") # =&gt; &lt;a rel="nofollow nofollow noreferrer"&gt;&lt;/a&gt;
</pre> <p><strong>Example:</strong> Append “nofollow” and “noreferrer” to the <code>rel</code> attribute, via an Array argument.</p> <pre class="ruby" data-language="ruby">node                                                  # =&gt; &lt;a&gt;&lt;/a&gt;
node.kwattr_append("rel", ["nofollow", "noreferrer"]) # =&gt; &lt;a rel="nofollow noreferrer"&gt;&lt;/a&gt;
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-kwattr_remove"> <span class="method-callseq"> kwattr_remove(attribute_name, keywords) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_remove-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 894
def kwattr_remove(attribute_name, keywords)
  if keywords.nil?
    remove_attribute(attribute_name)
    return self
  end

  keywords = keywordify(keywords)
  current_kws = kwattr_values(attribute_name)
  new_kws = current_kws - keywords
  if new_kws.empty?
    remove_attribute(attribute_name)
  else
    set_attribute(attribute_name, new_kws.join(" "))
  end
  self
end</pre> </div> <p>Remove keywords from a keyword attribute. Any matching keywords that exist in the named attribute are removed, including any multiple entries.</p> <p>If no keywords remain after this operation, or if <code>keywords</code> is <code>nil</code>, the attribute is deleted from the node.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4"><code>HTML</code></a> “class” attribute used to contain <a href="../css"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node#method-i-remove_class"><code>#remove_class</code></a>, <a href="node#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="node#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node#method-i-kwattr_append"><code>#kwattr_append</code></a></p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul>
<li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p> </li>
<li> <p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be removed from the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. Any keywords present in the named attribute will be removed. If no keywords remain, or if <code>keywords</code> is nil, the attribute is deleted.</p> </li>
</ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>self</code> (<a href="node"><code>Node</code></a>) for ease of chaining method calls.</p> </dd>
</dl> <p><strong>Example:</strong></p> <p>Note that the <code>rel</code> attribute is deleted when empty.</p> <pre class="ruby" data-language="ruby">node                                    # =&gt; &lt;a rel="nofollow noreferrer"&gt;link&lt;/a&gt;
node.kwattr_remove("rel", "nofollow")   # =&gt; &lt;a rel="noreferrer"&gt;link&lt;/a&gt;
node.kwattr_remove("rel", "noreferrer") # =&gt; &lt;a&gt;link&lt;/a&gt;
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-kwattr_values"> <span class="method-callseq"> kwattr_values(attribute_name) → Array&lt;String&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="kwattr_values-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 744
def kwattr_values(attribute_name)
  keywordify(get_attribute(attribute_name) || [])
end</pre> </div> <p>Fetch values from a keyword attribute of a <a href="node"><code>Node</code></a>.</p> <p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../html4"><code>HTML</code></a> “class” attribute used to contain <a href="../css"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p> <p>See also <a href="node#method-i-classes"><code>#classes</code></a>, <a href="node#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="node#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="node#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul><li> <p><code>attribute_name</code> (String) The name of the keyword attribute to be inspected.</p> </li></ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p>(Array&lt;String&gt;) The values present in the Node’s <code>attribute_name</code> attribute. If the attribute is empty or non-existent, the return value is an empty array.</p> </dd>
</dl> <p><strong>Example:</strong></p> <pre class="ruby" data-language="ruby">node                      # =&gt; &lt;a rel="nofollow noopener external"&gt;link&lt;/a&gt;
node.kwattr_values("rel") # =&gt; ["nofollow", "noopener", "external"]
</pre> <p>Since v1.11.0</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_attribute"> <span class="method-name">remove_attribute</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_attribute-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 549
def remove_attribute(name)
  attr = attributes[name].remove if key?(name)
  clear_xpath_context if Nokogiri.jruby?
  attr
end</pre> </div> <p>Remove the attribute named <code>name</code></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-delete">delete</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_class"> <span class="method-callseq"> remove_class(css_classes) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 715
def remove_class(names = nil)
  kwattr_remove("class", names)
end</pre> </div> <p>Remove <a href="../html4"><code>HTML</code></a> <a href="../css"><code>CSS</code></a> classes from this node. Any <a href="../css"><code>CSS</code></a> class names in <code>css_classes</code> that exist in this node’s “class” attribute are removed, including any multiple entries.</p> <p>If no <a href="../css"><code>CSS</code></a> classes remain after this operation, or if <code>css_classes</code> is <code>nil</code>, the “class” attribute is deleted from the node.</p> <p>This is a convenience function and is equivalent to:</p> <pre class="ruby" data-language="ruby">node.kwattr_remove("class", css_classes)
</pre> <p>Also see <a href="node#method-i-kwattr_remove"><code>#kwattr_remove</code></a>, <a href="node#method-i-classes"><code>#classes</code></a>, <a href="node#method-i-add_class"><code>#add_class</code></a>, <a href="node#method-i-append_class"><code>#append_class</code></a></p> <dl class="rdoc-list label-list">
<dt>Parameters </dt>

</dl> <ul><li> <p><code>css_classes</code> (String, Array&lt;String&gt;)</p> <p><a href="../css"><code>CSS</code></a> class names to be removed from the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will be removed. If no <a href="../css"><code>CSS</code></a> classes remain, the “class” attribute is deleted.</p> </li></ul> <dl class="rdoc-list label-list">
<dt>Returns </dt>
<dd> <p><code>self</code> (<a href="node"><code>Nokogiri::XML::Node</code></a>) for ease of chaining method calls.</p> </dd>
</dl> <p><strong>Example</strong>: Deleting a <a href="../css"><code>CSS</code></a> class</p> <p>Note that all instances of the class “section” are removed from the “class” attribute.</p> <pre class="ruby" data-language="ruby">node                         # =&gt; &lt;div class="section header section"&gt;&lt;/div&gt;
node.remove_class("section") # =&gt; &lt;div class="header"&gt;&lt;/div&gt;
</pre> <p><strong>Example</strong>: Deleting the only remaining <a href="../css"><code>CSS</code></a> class</p> <p>Note that the attribute is removed once there are no remaining classes.</p> <pre class="ruby" data-language="ruby">node                         # =&gt; &lt;div class="section"&gt;&lt;/div&gt;
node.remove_class("section") # =&gt; &lt;div&gt;&lt;/div&gt;
</pre> <p><strong>Example</strong>: Deleting multiple <a href="../css"><code>CSS</code></a> classes</p> <p>Note that the “class” attribute is deleted once it’s empty.</p> <pre class="ruby" data-language="ruby">node                                    # =&gt; &lt;div class="section header float"&gt;&lt;/div&gt;
node.remove_class(["section", "float"]) # =&gt; &lt;div class="header"&gt;&lt;/div&gt;
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-set_attribute"> <span class="method-name">set_attribute</span><span class="method-args">(name, value)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-5B-5D-3D">[]=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-value-3F"> <span class="method-name">value?</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="value-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 529
def value?(value)
  values.include?(value)
end</pre> </div> <p>Does this Node’s attributes include &lt;value&gt;</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values"> <span class="method-name">values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 523
def values
  attribute_nodes.map(&amp;:value)
end</pre> </div> <p>Get the attribute values for this <a href="node"><code>Node</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2008–2018 Aaron Patterson, Mike Dalessio, Charles Nutter, Sergio Arbeo,<br>Patrick Mahoney, Yoko Harada, Akinori MUSHA, John Shahid, Lars Kanis<br>Licensed under the MIT License.<br>
    <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Node.html" class="_attribution-link">https://nokogiri.org/rdoc/Nokogiri/XML/Node.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
