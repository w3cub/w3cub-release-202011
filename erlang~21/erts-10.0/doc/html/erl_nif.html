
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Erl_nif - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content=" erl_nif ">
  <meta name="keywords" content="erl, nif, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/erts-10.0/doc/html/erl_nif.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/erlang~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>erl_nif</h1> <h2><span onmouseover="document.getElementById('ghlink-c-library-id235762').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-c-library-id235762').style.visibility = 'hidden';" id="c-library">C Library</span></h2> <p class="REFBODY c-library-body">erl_nif</p> <h2><span onmouseover="document.getElementById('ghlink-library-summary-id235766').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-library-summary-id235766').style.visibility = 'hidden';" id="library-summary">Library Summary</span></h2> <p class="REFBODY library-summary-body">API functions for an Erlang NIF library.</p> <h2><span onmouseover="document.getElementById('ghlink-description-id235770').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-id235770').style.visibility = 'hidden';" id="description">Description</span></h2> 
<p>A NIF library contains native implementation of some functions of an Erlang module. The native implemented functions (NIFs) are called like any other functions without any difference to the caller. Each NIF must have an implementation in Erlang that is invoked if the function is called before the NIF library is successfully loaded. A typical such stub implementation is to throw an exception. But it can also be used as a fallback implementation if the NIF library is not implemented for some architecture.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p><strong>Use this functionality with extreme care.</strong></p> <p>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM <strong>cannot</strong> provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the native function does not behave well, the whole VM will misbehave.</p> <ul> <li> <p>A native function that crash will crash the whole VM.</p> </li> <li> <p>An erroneously implemented native function can cause a VM internal state inconsistency, which can cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the native function.</p> </li> <li> <p>A native function doing <code><a href="#lengthy_work">lengthy work</a></code> before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</p> </li> </ul> </div> </div> <p>A minimal example of a NIF library can look as follows:</p> <pre data-language="erlang">/* niftest.c */
#include &lt;erl_nif.h&gt;

static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    return enif_make_string(env, "Hello world!", ERL_NIF_LATIN1);
}

static ErlNifFunc nif_funcs[] =
{
    {"hello", 0, hello}
};

ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL)</pre> <p>The Erlang module can look as follows:</p> <pre data-language="erlang">-module(niftest).

-export([init/0, hello/0]).

init() -&gt;
      erlang:load_nif("./niftest", 0).

hello() -&gt;
      "NIF library not loaded".</pre> <p>Compile and test can look as follows (on Linux):</p> <pre data-language="erlang">$&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
$&gt; erl

1&gt; c(niftest).
{ok,niftest}
2&gt; niftest:hello().
"NIF library not loaded"
3&gt; niftest:init().
ok
4&gt; niftest:hello().
"Hello world!"</pre> <p>A better solution for a real module is to take advantage of the new directive <code class="code">on_load</code> (see section <code>Running a Function When a Module is Loaded</code> in the Erlang Reference Manual) to load the NIF library automatically when the module is loaded.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A NIF does not have to be exported, it can be local to the module. However, unused local stub functions will be optimized away by the compiler, causing loading of the NIF library to fail.</p> </div> </div> <p>Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</p>  <h2><span onmouseover="document.getElementById('ghlink-functionality-id235912').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-functionality-id235912').style.visibility = 'hidden';" id="functionality">Functionality</span></h2>  <p>All interaction between NIF code and the Erlang runtime system is performed by calling NIF API functions. Functions exist for the following functionality:</p> <dl> <dt><strong>Read and write Erlang terms</strong></dt> <dd> <p>Any Erlang terms can be passed to a NIF as function arguments and be returned as function return values. The terms are of C-type <code><a href="#ERL_NIF_TERM"><span class="code">ERL_NIF_TERM</span></a></code> and can only be read or written using API functions. Most functions to read the content of a term are prefixed <code class="code">enif_get_</code> and usually return <code class="code">true</code> (or <code class="code">false</code>) if the term is of the expected type (or not). The functions to write terms are all prefixed <code class="code">enif_make_</code> and usually return the created <code class="code">ERL_NIF_TERM</code>. There are also some functions to query terms, like <code class="code">enif_is_atom</code>, <code class="code">enif_is_identical</code>, and <code class="code">enif_compare</code>.</p> <p>All terms of type <code class="code">ERL_NIF_TERM</code> belong to an environment of type <code><a href="#ErlNifEnv"><span class="code">ErlNifEnv</span></a></code>. The lifetime of a term is controlled by the lifetime of its environment object. All API functions that read or write terms has the environment that the term belongs to as the first function argument.</p> </dd> <dt><strong>Binaries</strong></dt> <dd> <p>Terms of type binary are accessed with the help of struct type <code><a href="#ErlNifBinary"><span class="code">ErlNifBinary</span></a></code>, which contains a pointer (<code class="code">data</code>) to the raw binary data and the length (<code class="code">size</code>) of the data in bytes. Both <code class="code">data</code> and <code class="code">size</code> are read-only and are only to be written using calls to API functions. Instances of <code class="code">ErlNifBinary</code> are, however, always allocated by the user (usually as local variables).</p> <p>The raw data pointed to by <code class="code">data</code> is only mutable after a call to <code><a href="#enif_alloc_binary"><span class="code">enif_alloc_binary</span></a></code> or <code><a href="#enif_realloc_binary"><span class="code">enif_realloc_binary</span></a></code>. All other functions that operate on a binary leave the data as read-only. A mutable binary must in the end either be freed with <code><a href="#enif_release_binary"><span class="code">enif_release_binary</span></a></code> or made read-only by transferring it to an Erlang term with <code><a href="#enif_make_binary"><span class="code">enif_make_binary</span></a></code>. However, it does not have to occur in the same NIF call. Read-only binaries do not have to be released.</p> <p><code><a href="#enif_make_new_binary"><span class="code">enif_make_new_binary</span></a></code> can be used as a shortcut to allocate and return a binary in the same NIF call.</p> <p>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</p> </dd> <dt><strong>Resource objects</strong></dt> <dd> <p>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is only a block of memory allocated with <code><a href="#enif_alloc_resource"><span class="code">enif_alloc_resource</span></a></code>. A handle ("safe pointer") to this memory block can then be returned to Erlang by the use of <code><a href="#enif_make_resource"><span class="code">enif_make_resource</span></a></code>. The term returned by <code class="code">enif_make_resource</code> is opaque in nature. It can be stored and passed between processes, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call <code><a href="#enif_get_resource"><span class="code">enif_get_resource</span></a></code> and get back a pointer to the memory block, which is guaranteed to still be valid. A resource object is not deallocated until the last handle term is garbage collected by the VM and the resource is released with <code><a href="#enif_release_resource"><span class="code">enif_release_resource</span></a></code> (not necessarily in that order).</p> <p>All resource objects are created as instances of some <strong>resource type</strong>. This makes resources from different modules to be distinguishable. A resource type is created by calling <code><a href="#enif_open_resource_type"><span class="code">enif_open_resource_type</span></a></code> when a library is loaded. Objects of that resource type can then later be allocated and <code class="code">enif_get_resource</code> verifies that the resource is of the expected type. A resource type can have a user-supplied destructor function, which is automatically called when resources of that type are released (by either the garbage collector or <code class="code">enif_release_resource</code>). Resource types are uniquely identified by a supplied name string and the name of the implementing module.</p>  <p id="enif_resource_example">The following is a template example of how to create and return a resource object.</p> <pre data-language="erlang">ERL_NIF_TERM term;
MyStruct* obj = enif_alloc_resource(my_resource_type, sizeof(MyStruct));

/* initialize struct ... */

term = enif_make_resource(env, obj);

if (keep_a_reference_of_our_own) {
    /* store 'obj' in static variable, private data or other resource object */
}
else {
    enif_release_resource(obj);
    /* resource now only owned by "Erlang" */
}
return term;</pre> <p>Notice that once <code class="code">enif_make_resource</code> creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely only on the garbage collector to deallocate the resource object eventually when it collects the term.</p> <p>Another use of resource objects is to create binary terms with user-defined memory management. <code><a href="#enif_make_resource_binary"><span class="code">enif_make_resource_binary</span></a></code> creates a binary term that is connected to a resource object. The destructor of the resource is called when the binary is garbage collected, at which time the binary data can be released. An example of this can be a binary term consisting of data from a <code class="code">mmap</code>'ed file. The destructor can then do <code class="code">munmap</code> to release the memory region.</p> <p>Resource types support upgrade in runtime by allowing a loaded NIF library to take over an already existing resource type and by that "inherit" all existing objects of that type. The destructor of the new library is thereafter called for the inherited objects and the library with the old destructor function can be safely unloaded. Existing resource objects, of a module that is upgraded, must either be deleted or taken over by the new NIF library. The unloading of a library is postponed as long as there exist resource objects with a destructor function in the library.</p> </dd> <dt><strong>Module upgrade and static data</strong></dt> <dd> <p>A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded, the new module instance needs to load its own NIF library (or maybe choose not to). The new module instance can, however, choose to load the exact same NIF library as the old code if it wants to. Sharing the dynamic library means that static data defined by the library is shared as well. To avoid unintentionally shared static data between module instances, each Erlang module version can keep its own private data. This private data can be set when the NIF library is loaded and later retrieved by calling <code><a href="#enif_priv_data"><span class="code">enif_priv_data</span></a></code>.</p> </dd> <dt><strong>Threads and concurrency</strong></dt> <dd> <p>A NIF is thread-safe without any explicit synchronization as long as it acts as a pure function and only reads the supplied arguments. When you write to a shared state either through static variables or <code><a href="#enif_priv_data"><span class="code">enif_priv_data</span></a></code>, you need to supply your own explicit synchronization. This includes terms in process-independent environments that are shared between threads. Resource objects also require synchronization if you treat them as mutable.</p> <p>The library initialization callbacks <code class="code">load</code> and <code class="code">upgrade</code> are thread-safe even for shared state data.</p> </dd> <dt><strong id="version_management">Version Management</strong></dt> <dd> <p>When a NIF library is built, information about the NIF API version is compiled into the library. When a NIF library is loaded, the runtime system verifies that the library is of a compatible version. <code class="code">erl_nif.h</code> defines the following:</p> <dl> <dt><strong><code class="code">ERL_NIF_MAJOR_VERSION</code></strong></dt> <dd> <p>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the <code class="code">ERL_NIF_MAJOR_VERSION</code> has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</p> </dd> <dt><strong><code class="code">ERL_NIF_MINOR_VERSION</code></strong></dt> <dd> <p>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</p> </dd> </dl> <p>The runtime system normally refuses to load a NIF library if the major versions differ, or if the major versions are equal and the minor version used by the NIF library is greater than the one used by the runtime system. Old NIF libraries with lower major versions are, however, allowed after a bump of the major version during a transition period of two major releases. Such old NIF libraries can however fail if deprecated features are used.</p> </dd> <dt><strong id="time_measurement">Time Measurement</strong></dt> <dd> <p>Support for time measurement in NIF libraries:</p> <ul> <li><code><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code></li> <li><code><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code></li> <li><code><a href="#enif_monotonic_time"><span class="code">enif_monotonic_time()</span></a></code></li> <li><code><a href="#enif_time_offset"><span class="code">enif_time_offset()</span></a></code></li> <li><code><a href="#enif_convert_time_unit"><span class="code">enif_convert_time_unit()</span></a></code></li> </ul> </dd> <dt><strong id="enif_ioq">I/O Queues</strong></dt> <dd> <p>The Erlang nif library contains function for easily working with I/O vectors as used by the unix system call <code class="code">writev</code>. The I/O Queue is not thread safe, so some other synchronization mechanism has to be used.</p> <ul> <li><code><a href="#SysIOVec"><span class="code">SysIOVec</span></a></code></li> <li><code><a href="#ErlNifIOVec"><span class="code">ErlNifIOVec</span></a></code></li> <li><code><a href="#enif_ioq_create"><span class="code">enif_ioq_create()</span></a></code></li> <li><code><a href="#enif_ioq_destroy"><span class="code">enif_ioq_destroy()</span></a></code></li> <li><code><a href="#enif_ioq_enq_binary"><span class="code">enif_ioq_enq_binary()</span></a></code></li> <li><code><a href="#enif_ioq_enqv"><span class="code">enif_ioq_enqv()</span></a></code></li> <li><code><a href="#enif_ioq_deq"><span class="code">enif_ioq_deq()</span></a></code></li> <li><code><a href="#enif_ioq_peek"><span class="code">enif_ioq_peek()</span></a></code></li> <li><code><a href="#enif_ioq_peek_head"><span class="code">enif_ioq_peek_head()</span></a></code></li> <li><code><a href="#enif_inspect_iovec"><span class="code">enif_inspect_iovec()</span></a></code></li> <li><code><a href="#enif_free_iovec"><span class="code">enif_free_iovec()</span></a></code></li> </ul> <p>Typical usage when writing to a file descriptor looks like this:</p> <pre data-language="erlang">int writeiovec(ErlNifEnv *env, ERL_NIF_TERM term, ERL_NIF_TERM *tail,
               ErlNifIOQueue *q, int fd) {

    ErlNifIOVec vec, *iovec = &amp;vec;
    SysIOVec *sysiovec;
    int saved_errno;
    int iovcnt, n;

    if (!enif_inspect_iovec(env, 64, term, tail, &amp;iovec))
        return -2;

    if (enif_ioq_size(q) &gt; 0) {
        /* If the I/O queue contains data we enqueue the iovec and
           then peek the data to write out of the queue. */
        if (!enif_ioq_enqv(q, iovec, 0))
            return -3;

        sysiovec = enif_ioq_peek(q, &amp;iovcnt);
    } else {
        /* If the I/O queue is empty we skip the trip through it. */
        iovcnt = iovec-&gt;iovcnt;
        sysiovec = iovec-&gt;iov;
    }

    /* Attempt to write the data */
    n = writev(fd, sysiovec, iovcnt);
    saved_errno = errno;

    if (enif_ioq_size(q) == 0) {
        /* If the I/O queue was initially empty we enqueue any
           remaining data into the queue for writing later. */
        if (n &gt;= 0 &amp;&amp; !enif_ioq_enqv(q, iovec, n))
            return -3;
    } else {
        /* Dequeue any data that was written from the queue. */
        if (n &gt; 0 &amp;&amp; !enif_ioq_deq(q, n, NULL))
            return -4;
    }

    /* return n, which is either number of bytes written or -1 if
       some error happened */
    errno = saved_errno;
    return n;
}</pre> </dd> <dt><strong id="lengthy_work">Long-running NIFs</strong></dt> <dd> <p>As mentioned in the <code><a href="#WARNING">warning</a></code> text at the beginning of this manual page, it is of <strong>vital importance</strong> that a native function returns relatively fast. It is difficult to give an exact maximum amount of time that a native function is allowed to work, but usually a well-behaving native function is to return to its caller within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times. This is, however, not always possible, for example when calling third-party libraries.</p> <p>The <code><a href="#enif_consume_timeslice"><span class="code">enif_consume_timeslice()</span></a></code> function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</p> <p>If the NIF call is too lengthy, this must be handled in one of the following ways to avoid degraded responsiveness, scheduler load balancing problems, and other strange behaviors:</p> <dl> <dt><strong>Yielding NIF</strong></dt> <dd> <p>If the functionality of a long-running NIF can be split so that its work can be achieved through a series of shorter NIF calls, the application has two options:</p> <ul> <li> <p>Make that series of NIF calls from the Erlang level.</p> </li> <li> <p>Call a NIF that first performs a chunk of the work, then invokes the <code><a href="#enif_schedule_nif"><span class="code">enif_schedule_nif</span></a></code> function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</p> </li> </ul> <p>Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs.</p> <p>This approach is always preferred over the other alternatives described below. This both from a performance perspective and a system characteristics perspective.</p> </dd> <dt><strong>Threaded NIF</strong></dt> <dd> <p>This is accomplished by dispatching the work to another thread managed by the NIF library, return from the NIF, and wait for the result. The thread can send the result back to the Erlang process using <code><a href="#enif_send"><span class="code">enif_send</span></a></code>. Information about thread primitives is provided below.</p> </dd> <dt><strong id="dirty_nifs">Dirty NIF</strong></dt> <dd> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Dirty NIF support is available only when the emulator is configured with dirty scheduler support. As of ERTS version 9.0, dirty scheduler support is enabled by default on the runtime system with SMP support. The Erlang runtime without SMP support does <strong>not</strong> support dirty schedulers even when the dirty scheduler support is explicitly enabled. To check at runtime for the presence of dirty scheduler threads, code can use the <code><a href="#enif_system_info"><span class="code">enif_system_info()</span></a></code> API function.</p> </div> </div> <p>A NIF that cannot be split and cannot execute in a millisecond or less is called a "dirty NIF", as it performs work that the ordinary schedulers of the Erlang runtime system cannot handle cleanly. Applications that make use of such functions must indicate to the runtime that the functions are dirty so they can be handled specially. This is handled by executing dirty jobs on a separate set of schedulers called dirty schedulers. A dirty NIF executing on a dirty scheduler does not have the same duration restriction as a normal NIF. </p> <p> It is important to classify the dirty job correct. An I/O bound job should be classified as such, and a CPU bound job should be classified as such. If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are expected to either block waiting for I/O, and/or spend a limited amount of time moving data. </p> <p> To schedule a dirty NIF for execution, the application has two options:</p> <ul> <li> <p>Set the appropriate flags value for the dirty NIF in its <code><a href="#ErlNifFunc"><span class="code">ErlNifFunc</span></a></code> entry.</p> </li> <li> <p>Call <code><a href="#enif_schedule_nif"><span class="code">enif_schedule_nif</span></a></code>, pass to it a pointer to the dirty NIF to be executed, and indicate with argument <code class="code">flags</code> whether it expects the operation to be CPU-bound or I/O-bound.</p> </li> </ul> <p>A job that alternates between I/O bound and CPU bound can be reclassified and rescheduled using <code class="code">enif_schedule_nif</code> so that it executes on the correct type of dirty scheduler at all times. For more information see the documentation of the <code class="code">erl(1)</code> command line arguments <code><a href="erl#+SDcpu"><span class="code">+SDcpu</span></a></code>, and <code><a href="erl#+SDio"><span class="code">+SDio</span></a></code>.</p> <p>While a process executes a dirty NIF, some operations that communicate with it can take a very long time to complete. Suspend or garbage collection of a process executing a dirty NIF cannot be done until the dirty NIF has returned. Thus, other processes waiting for such operations to complete might have to wait for a very long time. Blocking multi-scheduling, that is, calling <code><a href="erlang#system_flag_multi_scheduling"><span class="code">erlang:system_flag(multi_scheduling, block)</span></a></code>, can also take a very long time to complete. This is because all ongoing dirty operations on all dirty schedulers must complete before the block operation can complete.</p> <p>Many operations communicating with a process executing a dirty NIF can, however, complete while it executes the dirty NIF. For example, retrieving information about it through <code><span class="code">erlang:process_info</span></code>, setting its group leader, register/unregister its name, and so on.</p> <p>Termination of a process executing a dirty NIF can only be completed up to a certain point while it executes the dirty NIF. All Erlang resources, such as its registered name and its ETS tables, are released. All links and monitors are triggered. The execution of the NIF is, however, <strong>not</strong> stopped. The NIF can safely continue execution, allocate heap memory, and so on, but it is of course better to stop executing as soon as possible. The NIF can check whether a current process is alive using <code><a href="#enif_is_current_process_alive"><span class="code">enif_is_current_process_alive</span></a></code>. Communication using <code><a href="#enif_send"><span class="code">enif_send</span></a></code> and <code><a href="#enif_port_command"><span class="code">enif_port_command</span></a></code> is also dropped when the sending process is not alive. Deallocation of certain internal resources, such as process heap and process control block, is delayed until the dirty NIF has completed.</p> </dd> </dl> </dd> </dl>  <h2><span onmouseover="document.getElementById('ghlink-initialization-id236907').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-initialization-id236907').style.visibility = 'hidden';" id="initialization">Initialization</span></h2>  <dl> <dt><strong><code class="code" id="ERL_NIF_INIT">ERL_NIF_INIT(MODULE, ErlNifFunc funcs[], load, NULL, upgrade, unload)</code></strong></dt> <dd> <p>This is the magic macro to initialize a NIF library. It is to be evaluated in global file scope.</p> <p><code class="code">MODULE</code> is the name of the Erlang module as an identifier without string quotations. It is stringified by the macro.</p> <p><code class="code">funcs</code> is a static array of function descriptors for all the implemented NIFs in this library.</p> <p><code class="code">load</code>, <code class="code">upgrade</code> and <code class="code">unload</code> are pointers to functions. One of <code class="code">load</code> or <code class="code">upgrade</code> is called to initialize the library. <code class="code">unload</code> is called to release the library. All are described individually below.</p> <p>The fourth argument <code class="code">NULL</code> is ignored. It was earlier used for the deprecated <code class="code">reload</code> callback which is no longer supported since OTP 20.</p> <p>If compiling a NIF for static inclusion through <code class="code">--enable-static-nifs</code>, you must define <code class="code">STATIC_ERLANG_NIF</code> before the <code class="code">ERL_NIF_INIT</code> declaration.</p> </dd> <dt><strong><code class="code" id="load">int (*load)(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)</code></strong></dt> <dd> <p><code class="code">load</code> is called when the NIF library is loaded and no previously loaded library exists for this module.</p> <p><code class="code">*priv_data</code> can be set to point to some private data if the library needs to keep a state between NIF calls. <code class="code">enif_priv_data</code> returns this pointer. <code class="code">*priv_data</code> is initialized to <code class="code">NULL</code> when <code class="code">load</code> is called.</p> <p><code class="code">load_info</code> is the second argument to <code><a href="erlang#load_nif-2"><span class="code">erlang:load_nif/2</span></a></code>.</p> <p>The library fails to load if <code class="code">load</code> returns anything other than <code class="code">0</code>. <code class="code">load</code> can be <code class="code">NULL</code> if initialization is not needed.</p> </dd> <dt><strong><code class="code" id="upgrade">int (*upgrade)(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info)</code></strong></dt> <dd> <p><code class="code">upgrade</code> is called when the NIF library is loaded and there is old code of this module with a loaded NIF library.</p> <p>Works as <code class="code">load</code>, except that <code class="code">*old_priv_data</code> already contains the value set by the last call to <code class="code">load</code> or <code class="code">upgrade</code> for the old module code. <code class="code">*priv_data</code> is initialized to <code class="code">NULL</code> when <code class="code">upgrade</code> is called. It is allowed to write to both <code class="code">*priv_data</code> and <code class="code">*old_priv_data.</code></p> <p>The library fails to load if <code class="code">upgrade</code> returns anything other than <code class="code">0</code> or if <code class="code">upgrade</code> is <code class="code">NULL</code>.</p> </dd> <dt><strong><code class="code" id="unload">void (*unload)(ErlNifEnv* env, void* priv_data)</code></strong></dt> <dd> <p><code class="code">unload</code> is called when the module code that the NIF library belongs to is purged as old. New code of the same module may or may not exist.</p> </dd> </dl>  <h2><span onmouseover="document.getElementById('ghlink-data-types-id237173').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-data-types-id237173').style.visibility = 'hidden';" id="data-types">Data Types</span></h2>  <dl> <dt><strong><code class="code" id="ERL_NIF_TERM">ERL_NIF_TERM</code></strong></dt> <dd> <p>Variables of type <code class="code">ERL_NIF_TERM</code> can refer to any Erlang term. This is an opaque type and values of it can only by used either as arguments to API functions or as return values from NIFs. All <code class="code">ERL_NIF_TERM</code>s belong to an environment (<code><a href="#ErlNifEnv"><span class="code">ErlNifEnv</span></a></code>). A term cannot be destructed individually, it is valid until its environment is destructed.</p> </dd> <dt><strong><code class="code" id="ErlNifEnv">ErlNifEnv</code></strong></dt> <dd> <p><code class="code">ErlNifEnv</code> represents an environment that can host Erlang terms. All terms in an environment are valid as long as the environment is valid. <code class="code">ErlNifEnv</code> is an opaque type; pointers to it can only be passed on to API functions. Two types of environments exist:</p> <dl> <dt><strong>Process-bound environment</strong></dt> <dd> <p>Passed as the first argument to all NIFs. All function arguments passed to a NIF belong to that environment. The return value from a NIF must also be a term belonging to the same environment.</p> <p>A process-bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process-bound environments between NIF calls.</p> </dd> <dt><strong>Process-independent environment</strong></dt> <dd> <p>Created by calling <code><a href="#enif_alloc_env"><span class="code">enif_alloc_env</span></a></code>. This environment can be used to store terms between NIF calls and to send terms with <code><a href="#enif_send"><span class="code">enif_send</span></a></code>. A process-independent environment with all its terms is valid until you explicitly invalidate it with <code><a href="#enif_free_env"><span class="code">enif_free_env</span></a></code> or <code class="code">enif_send</code>.</p> </dd> </dl> <p>All contained terms of a list/tuple/map must belong to the same environment as the list/tuple/map itself. Terms can be copied between environments with <code><a href="#enif_make_copy"><span class="code">enif_make_copy</span></a></code>.</p> </dd> <dt><strong><code class="code" id="ErlNifFunc">ErlNifFunc</code></strong></dt> <dd> <pre data-language="erlang">typedef struct {
    const char* name;
    unsigned arity;
    ERL_NIF_TERM (*fptr)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
    unsigned flags;
} ErlNifFunc;</pre> <p>Describes a NIF by its name, arity, and implementation.</p> <dl> <dt><strong><code class="code">fptr</code></strong></dt> <dd> <p>A pointer to the function that implements the NIF.</p> </dd> <dt><strong><code class="code">argv</code></strong></dt> <dd> <p>Contains the function arguments passed to the NIF.</p> </dd> <dt><strong><code class="code">argc</code></strong></dt> <dd> <p>The array length, that is, the function arity. <code class="code">argv[N-1]</code> thus denotes the Nth argument to the NIF. Notice that the argument <code class="code">argc</code> allows for the same C function to implement several Erlang functions with different arity (but probably with the same name).</p> </dd> <dt><strong><code class="code">flags</code></strong></dt> <dd> <p>Is <code class="code">0</code> for a regular NIF (and so its value can be omitted for statically initialized <code class="code">ErlNifFunc</code> instances).</p> <p><code class="code">flags</code> can be used to indicate that the NIF is a <code><a href="#dirty_nifs">dirty NIF</a></code> that is to be executed on a dirty scheduler thread.</p> <p>If the dirty NIF is expected to be CPU-bound, its <code class="code">flags</code> field is to be set to <code class="code">ERL_NIF_DIRTY_JOB_CPU_BOUND</code> or <code class="code">ERL_NIF_DIRTY_JOB_IO_BOUND</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If one of the <code class="code">ERL_NIF_DIRTY_JOB_*_BOUND</code> flags is set, and the runtime system has no support for dirty schedulers, the runtime system refuses to load the NIF library.</p> </div> </div> </dd> </dl> </dd> <dt><strong><code class="code" id="ErlNifBinary">ErlNifBinary</code></strong></dt> <dd> <pre data-language="erlang">typedef struct {
    unsigned size;
    unsigned char* data;
} ErlNifBinary;</pre> <p><code class="code">ErlNifBinary</code> contains transient information about an inspected binary term. <code class="code">data</code> is a pointer to a buffer of <code class="code">size</code> bytes with the raw content of the binary.</p> <p>Notice that <code class="code">ErlNifBinary</code> is a semi-opaque type and you are only allowed to read fields <code class="code">size</code> and <code class="code">data</code>.</p> </dd> <dt><strong><code class="code" id="ErlNifBinaryToTerm">ErlNifBinaryToTerm</code></strong></dt> <dd> <p>An enumeration of the options that can be specified to <code><a href="#enif_binary_to_term"><span class="code">enif_binary_to_term</span></a></code>. For default behavior, use value <code class="code">0</code>.</p> <p>When receiving data from untrusted sources, use option <code class="code">ERL_NIF_BIN2TERM_SAFE</code>.</p> </dd> <dt><strong><code class="code" id="ErlNifMonitor">ErlNifMonitor</code></strong></dt> <dd> <p>This is an opaque data type that identifies a monitor.</p> <p>The nif writer is to provide the memory for storing the monitor when calling <code><a href="#enif_monitor_process"><span class="code">enif_monitor_process</span></a></code>. The address of the data is not stored by the runtime system, so <code class="code">ErlNifMonitor</code> can be used as any other data, it can be copied, moved in memory, forgotten, and so on. To compare two monitors, <code><a href="#enif_compare_monitors"><span class="code">enif_compare_monitors</span></a></code> must be used.</p> </dd> <dt><strong><code class="code" id="ErlNifPid">ErlNifPid</code></strong></dt> <dd> <p>A process identifier (pid). In contrast to pid terms (instances of <code class="code">ERL_NIF_TERM</code>), <code class="code">ErlNifPid</code>s are self-contained and not bound to any <code><a href="#ErlNifEnv">environment</a></code>. <code class="code">ErlNifPid</code> is an opaque type.</p> </dd> <dt><strong><code class="code" id="ErlNifPort">ErlNifPort</code></strong></dt> <dd> <p>A port identifier. In contrast to port ID terms (instances of <code class="code">ERL_NIF_TERM</code>), <code class="code">ErlNifPort</code>s are self-contained and not bound to any <code><a href="#ErlNifEnv">environment</a></code>. <code class="code">ErlNifPort</code> is an opaque type.</p> </dd> <dt><strong><code class="code" id="ErlNifResourceType">ErlNifResourceType</code></strong></dt> <dd> <p>Each instance of <code class="code">ErlNifResourceType</code> represents a class of memory-managed resource objects that can be garbage collected. Each resource type has a unique name and a destructor function that is called when objects of its type are released.</p> </dd> <dt><strong><code class="code" id="ErlNifResourceTypeInit">ErlNifResourceTypeInit</code></strong></dt> <dd> <pre data-language="erlang">typedef struct {
    ErlNifResourceDtor* dtor;
    ErlNifResourceStop* stop;
    ErlNifResourceDown* down;
} ErlNifResourceTypeInit;</pre> <p>Initialization structure read by <code><a href="#enif_open_resource_type_x">enif_open_resource_type_x</a></code>.</p> </dd> <dt><strong><code class="code" id="ErlNifResourceDtor">ErlNifResourceDtor</code></strong></dt> <dd> <pre data-language="erlang">typedef void ErlNifResourceDtor(ErlNifEnv* env, void* obj);</pre> <p>The function prototype of a resource destructor function.</p> <p>The <code class="code">obj</code> argument is a pointer to the resource. The only allowed use for the resource in the destructor is to access its user data one final time. The destructor is guaranteed to be the last callback before the resource is deallocated.</p> </dd> <dt><strong><code class="code" id="ErlNifResourceDown">ErlNifResourceDown</code></strong></dt> <dd> <pre data-language="erlang">typedef void ErlNifResourceDown(ErlNifEnv* env, void* obj, ErlNifPid* pid, ErlNifMonitor* mon);</pre> <p>The function prototype of a resource down function, called on the behalf of <code><a href="#enif_monitor_process">enif_monitor_process</a></code>. <code class="code">obj</code> is the resource, <code class="code">pid</code> is the identity of the monitored process that is exiting, and <code class="code">mon</code> is the identity of the monitor. </p> </dd> <dt><strong><code class="code" id="ErlNifResourceStop">ErlNifResourceStop</code></strong></dt> <dd> <pre data-language="erlang">typedef void ErlNifResourceStop(ErlNifEnv* env, void* obj, ErlNifEvent event, int is_direct_call);</pre> <p>The function prototype of a resource stop function, called on the behalf of <code><a href="#enif_select">enif_select</a></code>. <code class="code">obj</code> is the resource, <code class="code">event</code> is OS event, <code class="code">is_direct_call</code> is true if the call is made directly from <code class="code">enif_select</code> or false if it is a scheduled call (potentially from another thread).</p> </dd> <dt><strong><code class="code" id="ErlNifCharEncoding">ErlNifCharEncoding</code></strong></dt> <dd> <pre data-language="erlang">typedef enum {
    ERL_NIF_LATIN1
}ErlNifCharEncoding;</pre> <p>The character encoding used in strings and atoms. The only supported encoding is <code class="code">ERL_NIF_LATIN1</code> for ISO Latin-1 (8-bit ASCII).</p> </dd> <dt><strong><code class="code" id="ErlNifSysInfo">ErlNifSysInfo</code></strong></dt> <dd> <p>Used by <code><a href="#enif_system_info"><span class="code">enif_system_info</span></a></code> to return information about the runtime system. Contains the same content as <code><a href="erl_driver#ErlDrvSysInfo"><span class="code">ErlDrvSysInfo</span></a></code>.</p> </dd> <dt><strong><code class="code" id="ErlNifSInt64">ErlNifSInt64</code></strong></dt> <dd> <p>A native signed 64-bit integer type.</p> </dd> <dt><strong><code class="code" id="ErlNifUInt64">ErlNifUInt64</code></strong></dt> <dd> <p>A native unsigned 64-bit integer type.</p> </dd> <dt><strong><code class="code" id="ErlNifTime">ErlNifTime</code></strong></dt> <dd> <p>A signed 64-bit integer type for representation of time.</p> </dd> <dt><strong><code class="code" id="ErlNifTimeUnit">ErlNifTimeUnit</code></strong></dt> <dd> <p>An enumeration of time units supported by the NIF API:</p> <dl> <dt><strong><code class="code">ERL_NIF_SEC</code></strong></dt> <dd>Seconds</dd> <dt><strong><code class="code">ERL_NIF_MSEC</code></strong></dt> <dd>Milliseconds</dd> <dt><strong><code class="code">ERL_NIF_USEC</code></strong></dt> <dd>Microseconds</dd> <dt><strong><code class="code">ERL_NIF_NSEC</code></strong></dt> <dd>Nanoseconds</dd> </dl> </dd> <dt><strong><code class="code" id="ErlNifUniqueInteger">ErlNifUniqueInteger</code></strong></dt> <dd> <p>An enumeration of the properties that can be requested from <code><a href="#enif_make_unique_integer"><span class="code">enif_make_unique_integer</span></a></code>. For default properties, use value <code class="code">0</code>.</p> <dl> <dt><strong><code class="code">ERL_NIF_UNIQUE_POSITIVE</code></strong></dt> <dd> <p>Return only positive integers.</p> </dd> <dt><strong><code class="code">ERL_NIF_UNIQUE_MONOTONIC</code></strong></dt> <dd> <p>Return only <code><a href="time_correction#Strictly_Monotonically_Increasing">strictly monotonically increasing</a></code> integer corresponding to creation time.</p> </dd> </dl> </dd> <dt><strong><code class="code" id="ErlNifHash">ErlNifHash</code></strong></dt> <dd> <p>An enumeration of the supported hash types that can be generated using <code><a href="#enif_hash"><span class="code">enif_hash</span></a></code>. </p> <dl> <dt><strong><code class="code">ERL_NIF_INTERNAL_HASH</code></strong></dt> <dd> <p>Non-portable hash function that only guarantees the same hash for the same term within one Erlang VM instance.</p> <p>It takes 32-bit salt values and generates hashes within <code class="code">0..2^32-1</code>.</p> </dd> <dt><strong><code class="code">ERL_NIF_PHASH2</code></strong></dt> <dd> <p>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version.</p> <p><strong>It ignores salt values</strong> and generates hashes within <code class="code">0..2^27-1</code>.</p> <p>Slower than <code class="code">ERL_NIF_INTERNAL_HASH.</code> It corresponds to <code><a href="erlang#phash2-1"><span class="code">erlang:phash2/1</span></a></code>. </p> </dd> </dl> </dd> <dt><strong><code class="code" id="SysIOVec">SysIOVec</code></strong></dt> <dd> <p>A system I/O vector, as used by <code class="code">writev</code> on Unix and <code class="code">WSASend</code> on Win32. It is used in <code class="code">ErlNifIOVec</code> and by <code><a href="#enif_ioq_peek"><span class="code">enif_ioq_peek</span></a></code>.</p> </dd> <dt><strong><code class="code" id="ErlNifIOVec">ErlNifIOVec</code></strong></dt> <dd> <pre data-language="erlang">typedef struct {
  int iovcnt;
  size_t size;
  SysIOVec* iov;
} ErlNifIOVec;</pre> <p>An I/O vector containing <code class="code">iovcnt</code> <code class="code">SysIOVec</code>s pointing to the data. It is used by <code><a href="#enif_inspect_iovec"><span class="code">enif_inspect_iovec</span></a></code> and <code><a href="#enif_ioq_enqv"><span class="code">enif_ioq_enqv</span></a></code>.</p> </dd> <dt><strong><code class="code" id="ErlNifIOQueueOpts">ErlNifIOQueueOpts</code></strong></dt> <dd> Options to configure a <code class="code">ErlNifIOQueue</code>. <dl> <dt><strong>ERL_NIF_IOQ_NORMAL</strong></dt> <dd><p>Create a normal I/O Queue</p></dd> </dl> </dd> </dl>  <h2><span onmouseover="document.getElementById('ghlink-exports-id238234').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-id238234').style.visibility = 'hidden';" id="exports">Exports</span></h2> <div class="exports-body"> <h3><code>void *enif_alloc(size_t size)</code></h3> 
<p>Allocates memory of <code class="code">size</code> bytes.</p> <p>Returns <code class="code">NULL</code> if the allocation fails.</p> <p>The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.</p>  <h3><code>int enif_alloc_binary(size_t size, ErlNifBinary* bin)</code></h3> 
<p>Allocates a new binary of size <code class="code">size</code> bytes. Initializes the structure pointed to by <code class="code">bin</code> to refer to the allocated binary. The binary must either be released by <code><a href="#enif_release_binary"><span class="code">enif_release_binary</span></a></code> or ownership transferred to an Erlang term with <code><a href="#enif_make_binary"><span class="code">enif_make_binary</span></a></code>. An allocated (and owned) <code class="code">ErlNifBinary</code> can be kept between NIF calls.</p> <p>If you do not need to reallocate or keep the data alive across NIF calls, consider using <code><a href="#enif_make_new_binary"><span class="code">enif_make_new_binary</span></a></code> instead as it will allocate small binaries on the process heap when possible.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if allocation fails.</p>  <h3><code>ErlNifEnv *enif_alloc_env()</code></h3> 
<p>Allocates a new process-independent environment. The environment can be used to hold terms that are not bound to any process. Such terms can later be copied to a process environment with <code><a href="#enif_make_copy"><span class="code">enif_make_copy</span></a></code> or be sent to a process as a message with <code><a href="#enif_send"><span class="code">enif_send</span></a></code>.</p> <p>Returns pointer to the new environment.</p>  <h3><code>void *enif_alloc_resource(ErlNifResourceType* type, unsigned size)</code></h3> 
<p>Allocates a memory-managed resource object of type <code class="code">type</code> and size <code class="code">size</code> bytes.</p>  <h3><code>size_t enif_binary_to_term(ErlNifEnv *env, const unsigned char* data, size_t size, ERL_NIF_TERM *term, ErlNifBinaryToTerm opts)</code></h3> 
<p>Creates a term that is the result of decoding the binary data at <code class="code">data</code>, which must be encoded according to the Erlang external term format. No more than <code class="code">size</code> bytes are read from <code class="code">data</code>. Argument <code class="code">opts</code> corresponds to the second argument to <code><a href="erlang#binary_to_term-2"><span class="code">erlang:binary_to_term/2</span></a></code> and must be either <code class="code">0</code> or <code class="code">ERL_NIF_BIN2TERM_SAFE</code>.</p> <p>On success, stores the resulting term at <code class="code">*term</code> and returns the number of bytes read. Returns <code class="code">0</code> if decoding fails or if <code class="code">opts</code> is invalid.</p> <p>See also <code><a href="#ErlNifBinaryToTerm"><span class="code">ErlNifBinaryToTerm</span></a></code>, <code><a href="erlang#binary_to_term-2"><span class="code">erlang:binary_to_term/2</span></a></code>, and <code><a href="#enif_term_to_binary"><span class="code">enif_term_to_binary</span></a></code>.</p>  <h3><code>void enif_clear_env(ErlNifEnv* env)</code></h3> 
<p>Frees all terms in an environment and clears it for reuse. The environment must have been allocated with <code><a href="#enif_alloc_env"><span class="code">enif_alloc_env</span></a></code>.</p>  <h3><code>int enif_compare(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs)</code></h3> 
<p>Returns an integer &lt; <code class="code">0</code> if <code class="code">lhs</code> &lt; <code class="code">rhs</code>, <code class="code">0</code> if <code class="code">lhs</code> = <code class="code">rhs</code>, and &gt; <code class="code">0</code> if <code class="code">lhs</code> &gt; <code class="code">rhs</code>. Corresponds to the Erlang operators <code class="code">==</code>, <code class="code">/=</code>, <code class="code">=&lt;</code>, <code class="code">&lt;</code>, <code class="code">&gt;=</code>, and <code class="code">&gt;</code> (but <strong>not</strong> <code class="code">=:=</code> or <code class="code">=/=</code>).</p>  <h3><code>int enif_compare_monitors(const ErlNifMonitor *monitor1, const ErlNifMonitor *monitor2)</code></h3> 
<p>Compares two <code><a href="#ErlNifMonitor"><span class="code">ErlNifMonitor</span></a></code>s. Can also be used to imply some artificial order on monitors, for whatever reason.</p> <p>Returns <code class="code">0</code> if <code class="code">monitor1</code> and <code class="code">monitor2</code> are equal, &lt; <code class="code">0</code> if <code class="code">monitor1</code> &lt; <code class="code">monitor2</code>, and &gt; <code class="code">0</code> if <code class="code">monitor1</code> &gt; <code class="code">monitor2</code>.</p>  <h3><code>void enif_cond_broadcast(ErlNifCond *cnd)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_cond_broadcast"><span class="code">erl_drv_cond_broadcast</span></a></code>.</p>  <h3><code>ErlNifCond *enif_cond_create(char *name)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_cond_create"><span class="code">erl_drv_cond_create</span></a></code>.</p>  <h3><code>void enif_cond_destroy(ErlNifCond *cnd)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_cond_destroy"><span class="code">erl_drv_cond_destroy</span></a></code>.</p>  <h3><code>char*enif_cond_name(ErlNifCond* cnd)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_cond_name"><span class="code">erl_drv_cond_name</span></a></code>.</p>  <h3><code>void enif_cond_signal(ErlNifCond *cnd)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_cond_signal"><span class="code">erl_drv_cond_signal</span></a></code>.</p>  <h3><code>void enif_cond_wait(ErlNifCond *cnd, ErlNifMutex *mtx)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_cond_wait"><span class="code">erl_drv_cond_wait</span></a></code>.</p>  <h3><code>int enif_consume_timeslice(ErlNifEnv *env, int percent)</code></h3> 
<p>Gives the runtime system a hint about how much CPU time the current NIF call has consumed since the last hint, or since the start of the NIF if no previous hint has been specified. The time is specified as a percent of the timeslice that a process is allowed to execute Erlang code until it can be suspended to give time for other runnable processes. The scheduling timeslice is not an exact entity, but can usually be approximated to about 1 millisecond.</p> <p>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call <code class="code">enif_consume_timeslice</code> to determine if it is allowed to continue execution.</p> <p>Argument <code class="code">percent</code> must be an integer between 1 and 100. This function must only be called from a NIF-calling thread, and argument <code class="code">env</code> must be the environment of the calling process.</p> <p>Returns <code class="code">1</code> if the timeslice is exhausted, otherwise <code class="code">0</code>. If <code class="code">1</code> is returned, the NIF is to return as soon as possible in order for the process to yield.</p> <p>This function is provided to better support co-operative scheduling, improve system responsiveness, and make it easier to prevent misbehaviors of the VM because of a NIF monopolizing a scheduler thread. It can be used to divide <code><a href="#lengthy_work">length work</a></code> into a number of repeated NIF calls without the need to create threads.</p> <p>See also the <code><a href="#WARNING">warning</a></code> text at the beginning of this manual page.</p>  <h3><code>ErlNifTime enif_convert_time_unit(ErlNifTime val, ErlNifTimeUnit from, ErlNifTimeUnit to)</code></h3> 
<p>Converts the <code class="code">val</code> value of time unit <code class="code">from</code> to the corresponding value of time unit <code class="code">to</code>. The result is rounded using the floor function.</p> <dl> <dt><strong><code class="code">val</code></strong></dt> <dd>Value to convert time unit for.</dd> <dt><strong><code class="code">from</code></strong></dt> <dd>Time unit of <code class="code">val</code>.</dd> <dt><strong><code class="code">to</code></strong></dt> <dd>Time unit of returned value.</dd> </dl> <p>Returns <code class="code">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument.</p> <p>See also <code><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code> and <code><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code>.</p>  <h3><code>ERL_NIF_TERM enif_cpu_time(ErlNifEnv *)</code></h3> 
<p>Returns the CPU time in the same format as <code><a href="erlang#timestamp-0"><span class="code">erlang:timestamp()</span></a></code>. The CPU time is the time the current logical CPU has spent executing since some arbitrary point in the past. If the OS does not support fetching this value, <code class="code">enif_cpu_time</code> invokes <code><a href="#enif_make_badarg"><span class="code">enif_make_badarg</span></a></code>.</p>  <h3><code>int enif_demonitor_process(ErlNifEnv* env, void* obj, const ErlNifMonitor* mon)</code></h3> 
<p>Cancels a monitor created earlier with <code><a href="#enif_monitor_process"><span class="code">enif_monitor_process</span></a></code>. Argument <code class="code">obj</code> is a pointer to the resource holding the monitor and <code class="code">*mon</code> identifies the monitor.</p> <p>Returns <code class="code">0</code> if the monitor was successfully identified and removed. Returns a non-zero value if the monitor could not be identified, which means it was either</p> <ul> <li>never created for this resource</li> <li>already cancelled</li> <li>already triggered</li> <li>just about to be triggered by a concurrent thread</li> </ul> <p>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</p>  <h3><code>int enif_equal_tids(ErlNifTid tid1, ErlNifTid tid2)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_equal_tids"><span class="code">erl_drv_equal_tids</span></a></code>.</p>  <h3><code>int enif_fprintf(FILE *stream, const char *format, ...)</code></h3> 
<p>Similar to <code class="code">fprintf</code> but this format string also accepts <code class="code">"%T"</code>, which formats Erlang terms.</p> <p>This function was originally intenden for debugging purpose. It is not recommended to print very large terms with <code class="code">%T</code>. The function may change <code class="code">errno</code>, even if successful.</p>  <h3><code>void enif_free(void* ptr)</code></h3> 
<p>Frees memory allocated by <code><a href="#enif_alloc"><span class="code">enif_alloc</span></a></code>.</p>  <h3><code>void enif_free_env(ErlNifEnv* env)</code></h3> 
<p>Frees an environment allocated with <code><a href="#enif_alloc_env"><span class="code">enif_alloc_env</span></a></code>. All terms created in the environment are freed as well.</p>  <h3><code>void enif_free_iovec(ErlNifIOvec* iov)</code></h3> 
<p>Frees an io vector returned from <code><a href="#enif_inspect_iovec"><span class="code">enif_inspect_iovec</span></a></code>. This is needed only if a <code class="code">NULL</code> environment is passed to <code><a href="#enif_inspect_iovec"><span class="code">enif_inspect_iovec</span></a></code>.</p> <pre data-language="erlang">ErlNifIOVec *iovec = NULL;
size_t max_elements = 128;
ERL_NIF_TERM tail;
if (!enif_inspect_iovec(NULL, max_elements, term, &amp;tail, &amp;iovec))
  return 0;

// Do things with the iovec

/* Free the iovector, possibly in another thread or nif function call */
enif_free_iovec(iovec);</pre>  <h3><code>int enif_get_atom(ErlNifEnv* env, ERL_NIF_TERM term, char* buf, unsigned size, ErlNifCharEncoding encode)</code></h3> 
<p>Writes a <code class="code">NULL</code>-terminated string in the buffer pointed to by <code class="code">buf</code> of size <code class="code">size</code>, consisting of the string representation of the atom <code class="code">term</code> with encoding <code><a href="#ErlNifCharEncoding">encode</a></code>.</p> <p>Returns the number of bytes written (including terminating <code class="code">NULL</code> character) or <code class="code">0</code> if <code class="code">term</code> is not an atom with maximum length of <code class="code">size-1</code>.</p>  <h3><code>int enif_get_atom_length(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len, ErlNifCharEncoding encode)</code></h3> 
<p>Sets <code class="code">*len</code> to the length (number of bytes excluding terminating <code class="code">NULL</code> character) of the atom <code class="code">term</code> with encoding <code class="code">encode</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not an atom.</p>  <h3><code>int enif_get_double(ErlNifEnv* env, ERL_NIF_TERM term, double* dp)</code></h3> 
<p>Sets <code class="code">*dp</code> to the floating-point value of <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not a float.</p>  <h3><code>int enif_get_int(ErlNifEnv* env, ERL_NIF_TERM term, int* ip)</code></h3> 
<p>Sets <code class="code">*ip</code> to the integer value of <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not an integer or is outside the bounds of type <code class="code">int</code>.</p>  <h3><code>int enif_get_int64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifSInt64* ip)</code></h3> 
<p>Sets <code class="code">*ip</code> to the integer value of <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not an integer or is outside the bounds of a signed 64-bit integer.</p>  <h3><code>int enif_get_local_pid(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifPid* pid)</code></h3> 
<p>If <code class="code">term</code> is the pid of a node local process, this function initializes the pid variable <code class="code">*pid</code> from it and returns <code class="code">true</code>. Otherwise returns <code class="code">false</code>. No check is done to see if the process is alive.</p>  <h3><code>int enif_get_local_port(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifPort* port_id)</code></h3> 
<p>If <code class="code">term</code> identifies a node local port, this function initializes the port variable <code class="code">*port_id</code> from it and returns <code class="code">true</code>. Otherwise returns <code class="code">false</code>. No check is done to see if the port is alive.</p>  <h3><code>int enif_get_list_cell(ErlNifEnv* env, ERL_NIF_TERM list, ERL_NIF_TERM* head, ERL_NIF_TERM* tail)</code></h3> 
<p>Sets <code class="code">*head</code> and <code class="code">*tail</code> from list <code class="code">list</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if it is not a list or the list is empty.</p>  <h3><code>int enif_get_list_length(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len)</code></h3> 
<p>Sets <code class="code">*len</code> to the length of list <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not a proper list.</p>  <h3><code>int enif_get_long(ErlNifEnv* env, ERL_NIF_TERM term, long int* ip)</code></h3> 
<p>Sets <code class="code">*ip</code> to the long integer value of <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not an integer or is outside the bounds of type <code class="code">long int</code>.</p>  <h3><code>int enif_get_map_size(ErlNifEnv* env, ERL_NIF_TERM term, size_t *size)</code></h3> 
<p>Sets <code class="code">*size</code> to the number of key-value pairs in the map <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not a map.</p>  <h3><code>int enif_get_map_value(ErlNifEnv* env, ERL_NIF_TERM map, ERL_NIF_TERM key, ERL_NIF_TERM* value)</code></h3> 
<p>Sets <code class="code">*value</code> to the value associated with <code class="code">key</code> in the map <code class="code">map</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">map</code> is not a map or if <code class="code">map</code> does not contain <code class="code">key</code>.</p>  <h3><code>int enif_get_resource(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifResourceType* type, void** objp)</code></h3> 
<p>Sets <code class="code">*objp</code> to point to the resource object referred to by <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not a handle to a resource object of type <code class="code">type</code>.</p>  <h3><code>int enif_get_string(ErlNifEnv* env, ERL_NIF_TERM list, char* buf, unsigned size, ErlNifCharEncoding encode)</code></h3> 
<p>Writes a <code class="code">NULL</code>-terminated string in the buffer pointed to by <code class="code">buf</code> with size <code class="code">size</code>, consisting of the characters in the string <code class="code">list</code>. The characters are written using encoding <code><a href="#ErlNifCharEncoding">encode</a></code>.</p> <p>Returns one of the following:</p> <ul> <li>The number of bytes written (including terminating <code class="code">NULL</code> character)</li> <li> <code class="code">-size</code> if the string was truncated because of buffer space</li> <li> <code class="code">0</code> if <code class="code">list</code> is not a string that can be encoded with <code class="code">encode</code> or if <code class="code">size</code> was &lt; <code class="code">1</code>.</li> </ul> <p>The written string is always <code class="code">NULL</code>-terminated, unless buffer <code class="code">size</code> is &lt; <code class="code">1</code>.</p>  <h3><code>int enif_get_tuple(ErlNifEnv* env, ERL_NIF_TERM term, int* arity, const ERL_NIF_TERM** array)</code></h3> 
<p>If <code class="code">term</code> is a tuple, this function sets <code class="code">*array</code> to point to an array containing the elements of the tuple, and sets <code class="code">*arity</code> to the number of elements. Notice that the array is read-only and <code class="code">(*array)[N-1]</code> is the Nth element of the tuple. <code class="code">*array</code> is undefined if the arity of the tuple is zero.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not a tuple.</p>  <h3><code>int enif_get_uint(ErlNifEnv* env, ERL_NIF_TERM term, unsigned int* ip)</code></h3> 
<p>Sets <code class="code">*ip</code> to the unsigned integer value of <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not an unsigned integer or is outside the bounds of type <code class="code">unsigned int</code>.</p>  <h3><code>int enif_get_uint64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifUInt64* ip)</code></h3> 
<p>Sets <code class="code">*ip</code> to the unsigned integer value of <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not an unsigned integer or is outside the bounds of an unsigned 64-bit integer.</p>  <h3><code>int enif_get_ulong(ErlNifEnv* env, ERL_NIF_TERM term, unsigned long* ip)</code></h3> 
<p>Sets <code class="code">*ip</code> to the unsigned long integer value of <code class="code">term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">term</code> is not an unsigned integer or is outside the bounds of type <code class="code">unsigned long</code>.</p>  <h3><code>int enif_getenv(const char* key, char* value, size_t *value_size)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_getenv"><span class="code">erl_drv_getenv</span></a></code>.</p>  <h3><code>int enif_has_pending_exception(ErlNifEnv* env, ERL_NIF_TERM* reason)</code></h3> 
<p>Returns <code class="code">true</code> if a pending exception is associated with the environment <code class="code">env</code>. If <code class="code">reason</code> is a <code class="code">NULL</code> pointer, ignore it. Otherwise, if a pending exception associated with <code class="code">env</code> exists, set <code class="code">*reason</code> to the value of the exception term. For example, if <code><a href="#enif_make_badarg"><span class="code">enif_make_badarg</span></a></code> is called to set a pending <code class="code">badarg</code> exception, a later call to <code class="code">enif_has_pending_exception(env, &amp;reason)</code> sets <code class="code">*reason</code> to the atom <code class="code">badarg</code>, then return <code class="code">true</code>.</p> <p>See also <code><a href="#enif_make_badarg"><span class="code">enif_make_badarg</span></a></code> and <code><a href="#enif_raise_exception"><span class="code">enif_raise_exception</span></a></code>.</p>  <h3><code>ErlNifUInt64 enif_hash(ErlNifHash type, ERL_NIF_TERM term, ErlNifUInt64 salt)</code></h3> 
<p>Hashes <code class="code">term</code> according to the specified <code><a href="#ErlNifHash"><span class="code">ErlNifHash</span></a></code> <code class="code">type</code>.</p> <p>Ranges of taken salt (if any) and returned value depend on the hash type.</p>  <h3><code>int enif_inspect_binary(ErlNifEnv* env, ERL_NIF_TERM bin_term, ErlNifBinary* bin)</code></h3> 
<p>Initializes the structure pointed to by <code class="code">bin</code> with information about binary term <code class="code">bin_term</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">bin_term</code> is not a binary.</p>  <h3><code>int enif_inspect_iolist_as_binary(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifBinary* bin)</code></h3> 
<p>Initializes the structure pointed to by <code class="code">bin</code> with a continuous buffer with the same byte content as <code class="code">iolist</code>. As with <code class="code">inspect_binary</code>, the data pointed to by <code class="code">bin</code> is transient and does not need to be released.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">iolist</code> is not an iolist.</p>  <h3><code>int enif_inspect_iovec(ErlNifEnv* env, size_t max_elements, ERL_NIF_TERM iovec_term, ERL_NIF_TERM* tail, ErlNifIOVec** iovec)</code></h3> 
<p>Fills <code class="code">iovec</code> with the list of binaries provided in <code class="code">iovec_term</code>. The number of elements handled in the call is limited to <code class="code">max_elements</code>, and <code class="code">tail</code> is set to the remainder of the list. Note that the output may be longer than <code class="code">max_elements</code> on some platforms. </p> <p>To create a list of binaries from an arbitrary iolist, use <code><span class="code">erlang:iolist_to_iovec/1</span></code>.</p> <p>When calling this function, <code class="code">iovec</code> should contain a pointer to <code class="code">NULL</code> or a ErlNifIOVec structure that should be used if possible. e.g. </p> <pre data-language="erlang">/* Don't use a pre-allocated structure */
ErlNifIOVec *iovec = NULL;
enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);

/* Use a stack-allocated vector as an optimization for vectors with few elements */
ErlNifIOVec vec, *iovec = &amp;vec;
enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);</pre> <p>The contents of the <code class="code">iovec</code> is valid until the called nif function returns. If the <code class="code">iovec</code> should be valid after the nif call returns, it is possible to call this function with a <code class="code">NULL</code> environment. If no environment is given the <code class="code">iovec</code> owns the data in the vector and it has to be explicitly freed using <code><a href="#enif_free_iovec"><span class="code">enif_free_iovec</span></a></code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">iovec_term</code> not an iovec.</p>  <h3><code>ErlNifIOQueue *enif_ioq_create(ErlNifIOQueueOpts opts)</code></h3> 
<p>Create a new I/O Queue that can be used to store data. <code class="code">opts</code> has to be set to <code class="code">ERL_NIF_IOQ_NORMAL</code>. </p>  <h3><code>void enif_ioq_destroy(ErlNifIOQueue *q)</code></h3> 
<p>Destroy the I/O queue and free all of it's contents</p>  <h3><code>int enif_ioq_deq(ErlNifIOQueue *q, size_t count, size_t *size)</code></h3> 
<p>Dequeue <code class="code">count</code> bytes from the I/O queue. If <code class="code">size</code> is not <code class="code">NULL</code>, the new size of the queue is placed there.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if the I/O does not contain <code class="code">count</code> bytes. On failure the queue is left un-altered.</p>  <h3><code>int enif_ioq_enq_binary(ErlNifIOQueue *q, ErlNifBinary *bin, size_t skip)</code></h3> 
<p>Enqueue the <code class="code">bin</code> into <code class="code">q</code> skipping the first <code class="code">skip</code> bytes.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">skip</code> is greater than the size of <code class="code">bin</code>. Any ownership of the binary data is transferred to the queue and <code class="code">bin</code> is to be considered read-only for the rest of the NIF call and then as released.</p>  <h3><code>int enif_ioq_enqv(ErlNifIOQueue *q, ErlNifIOVec *iovec, size_t skip)</code></h3> 
<p>Enqueue the <code class="code">iovec</code> into <code class="code">q</code> skipping the first <code class="code">skip</code> bytes.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">skip</code> is greater than the size of <code class="code">iovec</code>.</p>  <h3><code>SysIOVec *enif_ioq_peek(ErlNifIOQueue *q, int *iovlen)</code></h3> 
<p>Get the I/O queue as a pointer to an array of <code class="code">SysIOVec</code>s. It also returns the number of elements in <code class="code">iovlen</code>.</p> <p>Nothing is removed from the queue by this function, that must be done with <code><a href="#enif_ioq_deq"><span class="code">enif_ioq_deq</span></a></code>.</p> <p>The returned array is suitable to use with the Unix system call <code class="code">writev</code>.</p>  <h3><code>int enif_ioq_peek_head(ErlNifEnv *env, ErlNifIOQueue *q, size_t *size, ERL_NIF_TERM *bin_term)</code></h3> 
<p>Get the head of the IO Queue as a binary term.</p> <p>If <code class="code">size</code> is not <code class="code">NULL</code>, the size of the head is placed there.</p> <p>Nothing is removed from the queue by this function, that must be done with <code><a href="#enif_ioq_deq"><span class="code">enif_ioq_deq</span></a></code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if the queue is empty.</p>  <h3><code>size_t enif_ioq_size(ErlNifIOQueue *q)</code></h3> 
<p>Get the size of <code class="code">q</code>.</p>  <h3><code>int enif_is_atom(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is an atom.</p>  <h3><code>int enif_is_binary(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a binary.</p>  <h3><code>int enif_is_current_process_alive(ErlNifEnv* env)</code></h3> 
<p>Returns <code class="code">true</code> if the currently executing process is currently alive, otherwise <code class="code">false</code>.</p> <p>This function can only be used from a NIF-calling thread, and with an environment corresponding to currently executing processes.</p>  <h3><code>int enif_is_empty_list(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is an empty list.</p>  <h3><code>int enif_is_exception(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Return true if <code class="code">term</code> is an exception.</p>  <h3><code>int enif_is_fun(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a fun.</p>  <h3><code>int enif_is_identical(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs)</code></h3> 
<p>Returns <code class="code">true</code> if the two terms are identical. Corresponds to the Erlang operators <code class="code">=:=</code> and <code class="code">=/=</code>.</p>  <h3><code>int enif_is_list(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a list.</p>  <h3><code>int enif_is_map(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a map, otherwise <code class="code">false</code>.</p>  <h3><code>int enif_is_number(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a number.</p>  <h3><code>int enif_is_pid(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a pid.</p>  <h3><code>int enif_is_port(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a port.</p>  <h3><code>int enif_is_port_alive(ErlNifEnv* env, ErlNifPort *port_id)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">port_id</code> is alive.</p> <p>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</p>  <h3><code>int enif_is_process_alive(ErlNifEnv* env, ErlNifPid *pid)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">pid</code> is alive.</p> <p>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</p>  <h3><code>int enif_is_ref(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a reference.</p>  <h3><code>int enif_is_tuple(ErlNifEnv* env, ERL_NIF_TERM term)</code></h3> 
<p>Returns <code class="code">true</code> if <code class="code">term</code> is a tuple.</p>  <h3><code>int enif_keep_resource(void* obj)</code></h3> 
<p>Adds a reference to resource object <code class="code">obj</code> obtained from <code><a href="#enif_alloc_resource"><span class="code">enif_alloc_resource</span></a></code>. Each call to <code class="code">enif_keep_resource</code> for an object must be balanced by a call to <code><a href="#enif_release_resource"><span class="code">enif_release_resource</span></a></code> before the object is destructed.</p>  <h3><code>ERL_NIF_TERM enif_make_atom(ErlNifEnv* env, const char* name)</code></h3> 
<p>Creates an atom term from the <code class="code">NULL</code>-terminated C-string <code class="code">name</code> with ISO Latin-1 encoding. If the length of <code class="code">name</code> exceeds the maximum length allowed for an atom (255 characters), <code class="code">enif_make_atom</code> invokes <code><a href="#enif_make_badarg"><span class="code">enif_make_badarg</span></a></code>.</p>  <h3><code>ERL_NIF_TERM enif_make_atom_len(ErlNifEnv* env, const char* name, size_t len)</code></h3> 
<p>Create an atom term from the string <code class="code">name</code> with length <code class="code">len</code>. <code class="code">NULL</code> characters are treated as any other characters. If <code class="code">len</code> exceeds the maximum length allowed for an atom (255 characters), <code class="code">enif_make_atom</code> invokes <code><a href="#enif_make_badarg"><span class="code">enif_make_badarg</span></a></code>.</p>  <h3><code>ERL_NIF_TERM enif_make_badarg(ErlNifEnv* env)</code></h3> 
<p>Makes a <code class="code">badarg</code> exception to be returned from a NIF, and associates it with environment <code class="code">env</code>. Once a NIF or any function it calls invokes <code class="code">enif_make_badarg</code>, the runtime ensures that a <code class="code">badarg</code> exception is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead.</p> <p>The return value from <code class="code">enif_make_badarg</code> can be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to <code><a href="#enif_is_exception"><span class="code">enif_is_exception</span></a></code>, but not to any other NIF API function.</p> <p>See also <code><a href="#enif_has_pending_exception"><span class="code">enif_has_pending_exception</span></a></code> and <code><a href="#enif_raise_exception"><span class="code">enif_raise_exception</span></a></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Before ERTS 7.0 (Erlang/OTP 18), the return value from <code class="code">enif_make_badarg</code> had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if <code class="code">enif_make_badarg</code> has been invoked.</p> </div> </div>  <h3><code>ERL_NIF_TERM enif_make_binary(ErlNifEnv* env, ErlNifBinary* bin)</code></h3> 
<p>Makes a binary term from <code class="code">bin</code>. Any ownership of the binary data is transferred to the created term and <code class="code">bin</code> is to be considered read-only for the rest of the NIF call and then as released.</p>  <h3><code>ERL_NIF_TERM enif_make_copy(ErlNifEnv* dst_env, ERL_NIF_TERM src_term)</code></h3> 
<p>Makes a copy of term <code class="code">src_term</code>. The copy is created in environment <code class="code">dst_env</code>. The source term can be located in any environment.</p>  <h3><code>ERL_NIF_TERM enif_make_double(ErlNifEnv* env, double d)</code></h3> 
<p>Creates a floating-point term from a <code class="code">double</code>. If argument <code class="code">double</code> is not finite or is NaN, <code class="code">enif_make_double</code> invokes <code><a href="#enif_make_badarg"><span class="code">enif_make_badarg</span></a></code>.</p>  <h3><code>int enif_make_existing_atom(ErlNifEnv* env, const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding encode)</code></h3> 
<p>Tries to create the term of an already existing atom from the <code class="code">NULL</code>-terminated C-string <code class="code">name</code> with encoding <code><a href="#ErlNifCharEncoding">encode</a></code>.</p> <p>If the atom already exists, this function stores the term in <code class="code">*atom</code> and returns <code class="code">true</code>, otherwise <code class="code">false</code>. Also returns <code class="code">false</code> if the length of <code class="code">name</code> exceeds the maximum length allowed for an atom (255 characters).</p>  <h3><code>int enif_make_existing_atom_len(ErlNifEnv* env, const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding encoding)</code></h3> 
<p>Tries to create the term of an already existing atom from the string <code class="code">name</code> with length <code class="code">len</code> and encoding <code><a href="#ErlNifCharEncoding">encode</a></code>. <code class="code">NULL</code> characters are treated as any other characters.</p> <p>If the atom already exists, this function stores the term in <code class="code">*atom</code> and returns <code class="code">true</code>, otherwise <code class="code">false</code>. Also returns <code class="code">false</code> if <code class="code">len</code> exceeds the maximum length allowed for an atom (255 characters).</p>  <h3><code>ERL_NIF_TERM enif_make_int(ErlNifEnv* env, int i)</code></h3> 
<p>Creates an integer term.</p>  <h3><code>ERL_NIF_TERM enif_make_int64(ErlNifEnv* env, ErlNifSInt64 i)</code></h3> 
<p>Creates an integer term from a signed 64-bit integer.</p>  <h3><code>ERL_NIF_TERM enif_make_list(ErlNifEnv* env, unsigned cnt, ...)</code></h3> 
<p>Creates an ordinary list term of length <code class="code">cnt</code>. Expects <code class="code">cnt</code> number of arguments (after <code class="code">cnt</code>) of type <code class="code">ERL_NIF_TERM</code> as the elements of the list.</p> <p>Returns an empty list if <code class="code">cnt</code> is 0.</p>  <h3>
<code>ERL_NIF_TERM enif_make_list1(ErlNifEnv* env, ERL_NIF_TERM e1)</code><code>ERL_NIF_TERM enif_make_list2(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2)</code><code>ERL_NIF_TERM enif_make_list3(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)</code><code>ERL_NIF_TERM enif_make_list4(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)</code><code>ERL_NIF_TERM enif_make_list5(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)</code><code>ERL_NIF_TERM enif_make_list6(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)</code><code>ERL_NIF_TERM enif_make_list7(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)</code><code>ERL_NIF_TERM enif_make_list8(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)</code><code>ERL_NIF_TERM enif_make_list9(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)</code>
</h3> 
<p>Creates an ordinary list term with length indicated by the function name. Prefer these functions (macros) over the variadic <code class="code">enif_make_list</code> to get a compile-time error if the number of arguments does not match.</p>  <h3><code>ERL_NIF_TERM enif_make_list_cell(ErlNifEnv* env, ERL_NIF_TERM head, ERL_NIF_TERM tail)</code></h3> 
<p>Creates a list cell <code class="code">[head | tail]</code>.</p>  <h3><code>ERL_NIF_TERM enif_make_list_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)</code></h3> 
<p>Creates an ordinary list containing the elements of array <code class="code">arr</code> of length <code class="code">cnt</code>.</p> <p>Returns an empty list if <code class="code">cnt</code> is 0.</p>  <h3><code>ERL_NIF_TERM enif_make_long(ErlNifEnv* env, long int i)</code></h3> 
<p>Creates an integer term from a <code class="code">long int</code>.</p>  <h3><code>int enif_make_map_put(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value, ERL_NIF_TERM* map_out)</code></h3> 
<p>Makes a copy of map <code class="code">map_in</code> and inserts <code class="code">key</code> with <code class="code">value</code>. If <code class="code">key</code> already exists in <code class="code">map_in</code>, the old associated value is replaced by <code class="code">value</code>.</p> <p>If successful, this function sets <code class="code">*map_out</code> to the new map and returns <code class="code">true</code>. Returns <code class="code">false</code> if <code class="code">map_in</code> is not a map.</p> <p>The <code class="code">map_in</code> term must belong to environment <code class="code">env</code>.</p>  <h3><code>int enif_make_map_remove(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM* map_out)</code></h3> 
<p>If map <code class="code">map_in</code> contains <code class="code">key</code>, this function makes a copy of <code class="code">map_in</code> in <code class="code">*map_out</code>, and removes <code class="code">key</code> and the associated value. If map <code class="code">map_in</code> does not contain <code class="code">key</code>, <code class="code">*map_out</code> is set to <code class="code">map_in</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if <code class="code">map_in</code> is not a map.</p> <p>The <code class="code">map_in</code> term must belong to environment <code class="code">env</code>.</p>  <h3><code>int enif_make_map_update(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM new_value, ERL_NIF_TERM* map_out)</code></h3> 
<p>Makes a copy of map <code class="code">map_in</code> and replace the old associated value for <code class="code">key</code> with <code class="code">new_value</code>.</p> <p>If successful, this function sets <code class="code">*map_out</code> to the new map and returns <code class="code">true</code>. Returns <code class="code">false</code> if <code class="code">map_in</code> is not a map or if it does not contain <code class="code">key</code>.</p> <p>The <code class="code">map_in</code> term must belong to environment <code class="code">env</code>.</p>  <h3><code>int enif_make_map_from_arrays(ErlNifEnv* env, ERL_NIF_TERM keys[], ERL_NIF_TERM values[], size_t cnt, ERL_NIF_TERM *map_out)</code></h3> 
<p>Makes a map term from the given keys and values.</p> <p>If successful, this function sets <code class="code">*map_out</code> to the new map and returns <code class="code">true</code>. Returns <code class="code">false</code> there are any duplicate keys.</p> <p>All keys and values must belong to <code class="code">env</code>.</p>  <h3><code>unsigned char *enif_make_new_binary(ErlNifEnv* env, size_t size, ERL_NIF_TERM* termp)</code></h3> 
<p>Allocates a binary of size <code class="code">size</code> bytes and creates an owning term. The binary data is mutable until the calling NIF returns. This is a quick way to create a new binary without having to use <code><a href="#ErlNifBinary"><span class="code">ErlNifBinary</span></a></code>. The drawbacks are that the binary cannot be kept between NIF calls and it cannot be reallocated.</p> <p>Returns a pointer to the raw binary data and sets <code class="code">*termp</code> to the binary term.</p>  <h3><code>ERL_NIF_TERM enif_make_new_map(ErlNifEnv* env)</code></h3> 
<p>Makes an empty map term.</p>  <h3><code>ERL_NIF_TERM enif_make_pid(ErlNifEnv* env, const ErlNifPid* pid)</code></h3> 
<p>Makes a pid term from <code class="code">*pid</code>.</p>  <h3><code>ERL_NIF_TERM enif_make_ref(ErlNifEnv* env)</code></h3> 
<p>Creates a reference like <code><a href="erlang#make_ref-0"><span class="code">erlang:make_ref/0</span></a></code>.</p>  <h3><code>ERL_NIF_TERM enif_make_resource(ErlNifEnv* env, void* obj)</code></h3> 
<p>Creates an opaque handle to a memory-managed resource object obtained by <code><a href="#enif_alloc_resource"><span class="code">enif_alloc_resource</span></a></code>. No ownership transfer is done, as the resource object still needs to be released by <code><a href="#enif_release_resource"><span class="code">enif_release_resource</span></a></code>. However, notice that the call to <code class="code">enif_release_resource</code> can occur immediately after obtaining the term from <code class="code">enif_make_resource</code>, in which case the resource object is deallocated when the term is garbage collected. For more details, see the <code><a href="#enif_resource_example">example of creating and returning a resource object</a></code> in the User's Guide.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Since ERTS 9.0 (OTP-20.0), resource terms have a defined behavior when compared and serialized through <code class="code">term_to_binary</code> or passed between nodes.</p> <ul> <li> <p>Two resource terms will compare equal iff they would yield the same resource object pointer when passed to <code><a href="#enif_get_resource"><span class="code">enif_get_resource</span></a></code>.</p> </li> <li> <p>A resource term can be serialized with <code class="code">term_to_binary</code> and later be fully recreated if the resource object is still alive when <code class="code">binary_to_term</code> is called. A <strong>stale</strong> resource term will be returned from <code class="code">binary_to_term</code> if the resource object has been deallocated. <code><a href="#enif_get_resource"><span class="code">enif_get_resource</span></a></code> will return false for stale resource terms.</p> <p>The same principles of serialization apply when passing resource terms in messages to remote nodes and back again. A resource term will act stale on all nodes except the node where its resource object is still alive in memory.</p> </li> </ul> <p>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other and to empty binaries (<code class="code">&lt;&lt;&gt;&gt;</code>). If serialized, they would be recreated as plain empty binaries.</p> </div> </div>  <h3><code>ERL_NIF_TERM enif_make_resource_binary(ErlNifEnv* env, void* obj, const void* data, size_t size)</code></h3> 
<p>Creates a binary term that is memory-managed by a resource object <code class="code">obj</code> obtained by <code><a href="#enif_alloc_resource"><span class="code">enif_alloc_resource</span></a></code>. The returned binary term consists of <code class="code">size</code> bytes pointed to by <code class="code">data</code>. This raw binary data must be kept readable and unchanged until the destructor of the resource is called. The binary data can be stored external to the resource object, in which case the destructor is responsible for releasing the data.</p> <p>Several binary terms can be managed by the same resource object. The destructor is not called until the last binary is garbage collected. This can be useful to return different parts of a larger binary buffer.</p> <p>As with <code><a href="#enif_make_resource"><span class="code">enif_make_resource</span></a></code>, no ownership transfer is done. The resource still needs to be released with <code><a href="#enif_release_resource"><span class="code">enif_release_resource</span></a></code>.</p>  <h3><code>int enif_make_reverse_list(ErlNifEnv* env, ERL_NIF_TERM list_in, ERL_NIF_TERM *list_out)</code></h3> 
<p>Sets <code class="code">*list_out</code> to the reverse list of the list <code class="code">list_in</code> and returns <code class="code">true</code>, or returns <code class="code">false</code> if <code class="code">list_in</code> is not a list.</p> <p>This function is only to be used on short lists, as a copy is created of the list, which is not released until after the NIF returns.</p> <p>The <code class="code">list_in</code> term must belong to environment <code class="code">env</code>.</p>  <h3><code>ERL_NIF_TERM enif_make_string(ErlNifEnv* env, const char* string, ErlNifCharEncoding encoding)</code></h3> 
<p>Creates a list containing the characters of the <code class="code">NULL</code>-terminated string <code class="code">string</code> with encoding <code><a href="#ErlNifCharEncoding">encoding</a></code>.</p>  <h3><code>ERL_NIF_TERM enif_make_string_len(ErlNifEnv* env, const char* string, size_t len, ErlNifCharEncoding encoding)</code></h3> 
<p>Creates a list containing the characters of the string <code class="code">string</code> with length <code class="code">len</code> and encoding <code><a href="#ErlNifCharEncoding">encoding</a></code>. <code class="code">NULL</code> characters are treated as any other characters.</p>  <h3><code>ERL_NIF_TERM enif_make_sub_binary(ErlNifEnv* env, ERL_NIF_TERM bin_term, size_t pos, size_t size)</code></h3> 
<p>Makes a subbinary of binary <code class="code">bin_term</code>, starting at zero-based position <code class="code">pos</code> with a length of <code class="code">size</code> bytes. <code class="code">bin_term</code> must be a binary or bitstring. <code class="code">pos+size</code> must be less or equal to the number of whole bytes in <code class="code">bin_term</code>.</p>  <h3><code>ERL_NIF_TERM enif_make_tuple(ErlNifEnv* env, unsigned cnt, ...)</code></h3> 
<p>Creates a tuple term of arity <code class="code">cnt</code>. Expects <code class="code">cnt</code> number of arguments (after <code class="code">cnt</code>) of type <code class="code">ERL_NIF_TERM</code> as the elements of the tuple.</p>  <h3>
<code>ERL_NIF_TERM enif_make_tuple1(ErlNifEnv* env, ERL_NIF_TERM e1)</code><code>ERL_NIF_TERM enif_make_tuple2(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2)</code><code>ERL_NIF_TERM enif_make_tuple3(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)</code><code>ERL_NIF_TERM enif_make_tuple4(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)</code><code>ERL_NIF_TERM enif_make_tuple5(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)</code><code>ERL_NIF_TERM enif_make_tuple6(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)</code><code>ERL_NIF_TERM enif_make_tuple7(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)</code><code>ERL_NIF_TERM enif_make_tuple8(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)</code><code>ERL_NIF_TERM enif_make_tuple9(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)</code>
</h3> 
<p>Creates a tuple term with length indicated by the function name. Prefer these functions (macros) over the variadic <code class="code">enif_make_tuple</code> to get a compile-time error if the number of arguments does not match.</p>  <h3><code>ERL_NIF_TERM enif_make_tuple_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)</code></h3> 
<p>Creates a tuple containing the elements of array <code class="code">arr</code> of length <code class="code">cnt</code>.</p>  <h3><code>ERL_NIF_TERM enif_make_uint(ErlNifEnv* env, unsigned int i)</code></h3> 
<p>Creates an integer term from an <code class="code">unsigned int</code>.</p>  <h3><code>ERL_NIF_TERM enif_make_uint64(ErlNifEnv* env, ErlNifUInt64 i)</code></h3> 
<p>Creates an integer term from an unsigned 64-bit integer.</p>  <h3><code>ERL_NIF_TERM enif_make_ulong(ErlNifEnv* env, unsigned long i)</code></h3> 
<p>Creates an integer term from an <code class="code">unsigned long int</code>.</p>  <h3><code>ERL_NIF_TERM enif_make_unique_integer(ErlNifEnv *env, ErlNifUniqueInteger properties)</code></h3> 
<p>Returns a unique integer with the same properties as specified by <code><a href="erlang#unique_integer-1"><span class="code">erlang:unique_integer/1</span></a></code>.</p> <p><code class="code">env</code> is the environment to create the integer in.</p> <p><code class="code">ERL_NIF_UNIQUE_POSITIVE</code> and <code class="code">ERL_NIF_UNIQUE_MONOTONIC</code> can be passed as the second argument to change the properties of the integer returned. They can be combined by OR:ing the two values together.</p> <p>See also <code><a href="#ErlNifUniqueInteger"><span class="code">ErlNifUniqueInteger</span></a></code>.</p>  <h3><code>int enif_map_iterator_create(ErlNifEnv *env, ERL_NIF_TERM map, ErlNifMapIterator *iter, ErlNifMapIteratorEntry entry)</code></h3> 
<p>Creates an iterator for the map <code class="code">map</code> by initializing the structure pointed to by <code class="code">iter</code>. Argument <code class="code">entry</code> determines the start position of the iterator: <code class="code">ERL_NIF_MAP_ITERATOR_FIRST</code> or <code class="code">ERL_NIF_MAP_ITERATOR_LAST</code>.</p> <p>Returns <code class="code">true</code> on success, or false if <code class="code">map</code> is not a map.</p> <p>A map iterator is only useful during the lifetime of environment <code class="code">env</code> that the <code class="code">map</code> belongs to. The iterator must be destroyed by calling <code><a href="#enif_map_iterator_destroy"><span class="code">enif_map_iterator_destroy</span></a></code>:</p> <pre data-language="erlang">ERL_NIF_TERM key, value;
ErlNifMapIterator iter;
enif_map_iterator_create(env, my_map, &amp;iter, ERL_NIF_MAP_ITERATOR_FIRST);

while (enif_map_iterator_get_pair(env, &amp;iter, &amp;key, &amp;value)) {
    do_something(key,value);
    enif_map_iterator_next(env, &amp;iter);
}
enif_map_iterator_destroy(env, &amp;iter);</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The key-value pairs of a map have no defined iteration order. The only guarantee is that the iteration order of a single map instance is preserved during the lifetime of the environment that the map belongs to.</p> </div> </div>  <h3><code>void enif_map_iterator_destroy(ErlNifEnv *env, ErlNifMapIterator *iter)</code></h3> 
<p>Destroys a map iterator created by <code><a href="#enif_map_iterator_create"><span class="code">enif_map_iterator_create</span></a></code>.</p>  <h3><code>int enif_map_iterator_get_pair(ErlNifEnv *env, ErlNifMapIterator *iter, ERL_NIF_TERM *key, ERL_NIF_TERM *value)</code></h3> 
<p>Gets key and value terms at the current map iterator position.</p> <p>On success, sets <code class="code">*key</code> and <code class="code">*value</code> and returns <code class="code">true</code>. Returns <code class="code">false</code> if the iterator is positioned at head (before first entry) or tail (beyond last entry).</p>  <h3><code>int enif_map_iterator_is_head(ErlNifEnv *env, ErlNifMapIterator *iter)</code></h3> 
<p>Returns <code class="code">true</code> if map iterator <code class="code">iter</code> is positioned before the first entry.</p>  <h3><code>int enif_map_iterator_is_tail(ErlNifEnv *env, ErlNifMapIterator *iter)</code></h3> 
<p>Returns <code class="code">true</code> if map iterator <code class="code">iter</code> is positioned after the last entry.</p>  <h3><code>int enif_map_iterator_next(ErlNifEnv *env, ErlNifMapIterator *iter)</code></h3> 
<p>Increments map iterator to point to the next key-value entry.</p> <p>Returns <code class="code">true</code> if the iterator is now positioned at a valid key-value entry, or <code class="code">false</code> if the iterator is positioned at the tail (beyond the last entry).</p>  <h3><code>int enif_map_iterator_prev(ErlNifEnv *env, ErlNifMapIterator *iter)</code></h3> 
<p>Decrements map iterator to point to the previous key-value entry.</p> <p>Returns <code class="code">true</code> if the iterator is now positioned at a valid key-value entry, or <code class="code">false</code> if the iterator is positioned at the head (before the first entry).</p>  <h3><code>int enif_monitor_process(ErlNifEnv* env, void* obj, const ErlNifPid* target_pid, ErlNifMonitor* mon)</code></h3> 
<p>Starts monitoring a process from a resource. When a process is monitored, a process exit results in a call to the provided <code><a href="#ErlNifResourceDown"><span class="code">down</span></a></code> callback associated with the resource type.</p> <p>Argument <code class="code">obj</code> is pointer to the resource to hold the monitor and <code class="code">*target_pid</code> identifies the local process to be monitored.</p> <p>If <code class="code">mon</code> is not <code class="code">NULL</code>, a successful call stores the identity of the monitor in the <code><a href="#ErlNifMonitor"><span class="code">ErlNifMonitor</span></a></code> struct pointed to by <code class="code">mon</code>. This identifier is used to refer to the monitor for later removal with <code><a href="#enif_demonitor_process"><span class="code">enif_demonitor_process</span></a></code> or compare with <code><a href="#enif_compare_monitors"><span class="code">enif_compare_monitors</span></a></code>. A monitor is automatically removed when it triggers or when the resource is deallocated.</p> <p>Returns <code class="code">0</code> on success, &lt; 0 if no <code class="code">down</code> callback is provided, and &gt; 0 if the process is no longer alive.</p> <p>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</p>  <h3><code>ErlNifTime enif_monotonic_time(ErlNifTimeUnit time_unit)</code></h3> 
<p>Returns the current <code><a href="time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a></code>. Notice that it is not uncommon with negative values.</p> <p><code class="code">time_unit</code> is the time unit of the returned value.</p> <p>Returns <code class="code">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument, or if called from a thread that is not a scheduler thread.</p> <p>See also <code><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code> and <code><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code>. </p>  <h3><code>ErlNifMutex *enif_mutex_create(char *name)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_mutex_create"><span class="code">erl_drv_mutex_create</span></a></code>.</p>  <h3><code>void enif_mutex_destroy(ErlNifMutex *mtx)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_mutex_destroy"><span class="code">erl_drv_mutex_destroy</span></a></code>.</p>  <h3><code>void enif_mutex_lock(ErlNifMutex *mtx)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_mutex_lock"><span class="code">erl_drv_mutex_lock</span></a></code>.</p>  <h3><code>char*enif_mutex_name(ErlNifMutex* mtx)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_mutex_name"><span class="code">erl_drv_mutex_name</span></a></code>.</p>  <h3><code>int enif_mutex_trylock(ErlNifMutex *mtx)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_mutex_trylock"><span class="code">erl_drv_mutex_trylock</span></a></code>.</p>  <h3><code>void enif_mutex_unlock(ErlNifMutex *mtx)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_mutex_unlock"><span class="code">erl_drv_mutex_unlock</span></a></code>.</p>  <h3><code>ERL_NIF_TERM enif_now_time(ErlNifEnv *env)</code></h3> 
<p>Returns an <code><a href="erlang#now-0"><span class="code">erlang:now()</span></a></code> time stamp.</p> <p><strong>This function is deprecated.</strong></p>  <h3><code>ErlNifResourceType *enif_open_resource_type(ErlNifEnv* env, const char* module_str, const char* name, ErlNifResourceDtor* dtor, ErlNifResourceFlags flags, ErlNifResourceFlags* tried)</code></h3> 
<p>Creates or takes over a resource type identified by the string <code class="code">name</code> and gives it the destructor function pointed to by <code><a href="#ErlNifResourceDtor"><span class="code">dtor</span></a></code>. Argument <code class="code">flags</code> can have the following values:</p> <dl> <dt><strong><code class="code">ERL_NIF_RT_CREATE</code></strong></dt> <dd>Creates a new resource type that does not already exist.</dd> <dt><strong><code class="code">ERL_NIF_RT_TAKEOVER</code></strong></dt> <dd>Opens an existing resource type and takes over ownership of all its instances. The supplied destructor <code class="code">dtor</code> is called both for existing instances and new instances not yet created by the calling NIF library.</dd> </dl> <p>The two flag values can be combined with bitwise OR. The resource type name is local to the calling module. Argument <code class="code">module_str</code> is not (yet) used and must be <code class="code">NULL</code>. <code class="code">dtor</code> can be <code class="code">NULL</code> if no destructor is needed.</p> <p>On success, the function returns a pointer to the resource type and <code class="code">*tried</code> is set to either <code class="code">ERL_NIF_RT_CREATE</code> or <code class="code">ERL_NIF_RT_TAKEOVER</code> to indicate what was done. On failure, returns <code class="code">NULL</code> and sets <code class="code">*tried</code> to <code class="code">flags</code>. It is allowed to set <code class="code">tried</code> to <code class="code">NULL</code>.</p> <p>Notice that <code class="code">enif_open_resource_type</code> is only allowed to be called in the two callbacks <code><a href="#load"><span class="code">load</span></a></code> and <code><a href="#upgrade"><span class="code">upgrade</span></a></code>.</p> <p>See also <code><a href="#enif_open_resource_type_x"><span class="code">enif_open_resource_type_x</span></a></code>.</p>  <h3><code>ErlNifResourceType *enif_open_resource_type_x(ErlNifEnv* env, const char* name, const ErlNifResourceTypeInit* init, ErlNifResourceFlags flags, ErlNifResourceFlags* tried)</code></h3> 
<p>Same as <code><a href="#enif_open_resource_type"><span class="code">enif_open_resource_type</span></a></code> except it accepts additional callback functions for resource types that are used together with <code><a href="#enif_select"><span class="code">enif_select</span></a></code> and <code><a href="#enif_monitor_process"><span class="code">enif_monitor_process</span></a></code>.</p> <p>Argument <code class="code">init</code> is a pointer to an <code><a href="#ErlNifResourceTypeInit"><span class="code">ErlNifResourceTypeInit</span></a></code> structure that contains the function pointers for destructor, down and stop callbacks for the resource type.</p>  <h3><code>int enif_port_command(ErlNifEnv* env, const ErlNifPort* to_port, ErlNifEnv *msg_env, ERL_NIF_TERM msg)</code></h3> 
<p>Works as <code><a href="erlang#port_command-2"><span class="code">erlang:port_command/2</span></a></code>, except that it is always completely asynchronous.</p> <dl> <dt><strong><code class="code">env</code></strong></dt> <dd>The environment of the calling process. Must not be <code class="code">NULL</code>.</dd> <dt><strong><code class="code">*to_port</code></strong></dt> <dd>The port ID of the receiving port. The port ID is to refer to a port on the local node.</dd> <dt><strong><code class="code">msg_env</code></strong></dt> <dd>The environment of the message term. Can be a process-independent environment allocated with <code><a href="#enif_alloc_env"><span class="code">enif_alloc_env</span></a></code> or <code class="code">NULL</code>.</dd> <dt><strong><code class="code">msg</code></strong></dt> <dd>The message term to send. The same limitations apply as on the payload to <code><a href="erlang#port_command-2"><span class="code">erlang:port_command/2</span></a></code>.</dd> </dl> <p>Using a <code class="code">msg_env</code> of <code class="code">NULL</code> is an optimization, which groups together calls to <code class="code">enif_alloc_env</code>, <code class="code">enif_make_copy</code>, <code class="code">enif_port_command</code>, and <code class="code">enif_free_env</code> into one call. This optimization is only useful when a majority of the terms are to be copied from <code class="code">env</code> to <code class="code">msg_env</code>.</p> <p>Returns <code class="code">true</code> if the command is successfully sent. Returns <code class="code">false</code> if the command fails, for example:</p> <ul> <li> <code class="code">*to_port</code> does not refer to a local port.</li> <li>The currently executing process (that is, the sender) is not alive.</li> <li> <code class="code">msg</code> is invalid.</li> </ul> <p>See also <code><a href="#enif_get_local_port"><span class="code">enif_get_local_port</span></a></code>.</p>  <h3><code>void *enif_priv_data(ErlNifEnv* env)</code></h3> 
<p>Returns the pointer to the private data that was set by <code><a href="#load"><span class="code">load</span></a></code> or <code><a href="#upgrade"><span class="code">upgrade</span></a></code>.</p>  <h3><code>ERL_NIF_TERM enif_raise_exception(ErlNifEnv* env, ERL_NIF_TERM reason)</code></h3> 
<p>Creates an error exception with the term <code class="code">reason</code> to be returned from a NIF, and associates it with environment <code class="code">env</code>. Once a NIF or any function it calls invokes <code class="code">enif_raise_exception</code>, the runtime ensures that the exception it creates is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead.</p> <p>The return value from <code class="code">enif_raise_exception</code> can only be used as the return value from the NIF that invoked it (directly or indirectly) or be passed to <code><a href="#enif_is_exception"><span class="code">enif_is_exception</span></a></code>, but not to any other NIF API function.</p> <p>See also <code><a href="#enif_has_pending_exception"><span class="code">enif_has_pending_exception</span></a></code> and <code><a href="#enif_make_badarg"><span class="code">enif_make_badarg</span></a></code>.</p>  <h3><code>void *enif_realloc(void* ptr, size_t size)</code></h3> 
<p>Reallocates memory allocated by <code><a href="#enif_alloc"><span class="code">enif_alloc</span></a></code> to <code class="code">size</code> bytes.</p> <p>Returns <code class="code">NULL</code> if the reallocation fails.</p> <p>The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.</p>  <h3><code>int enif_realloc_binary(ErlNifBinary* bin, size_t size)</code></h3> 
<p>Changes the size of a binary <code class="code">bin</code>. The source binary can be read-only, in which case it is left untouched and a mutable copy is allocated and assigned to <code class="code">*bin</code>.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if memory allocation failed.</p>  <h3><code>void enif_release_binary(ErlNifBinary* bin)</code></h3> 
<p>Releases a binary obtained from <code><a href="#enif_alloc_binary"><span class="code">enif_alloc_binary</span></a></code>.</p>  <h3><code>void enif_release_resource(void* obj)</code></h3> 
<p>Removes a reference to resource object <code class="code">obj</code> obtained from <code><a href="#enif_alloc_resource"><span class="code">enif_alloc_resource</span></a></code>. The resource object is destructed when the last reference is removed. Each call to <code class="code">enif_release_resource</code> must correspond to a previous call to <code class="code">enif_alloc_resource</code> or <code><a href="#enif_keep_resource"><span class="code">enif_keep_resource</span></a></code>. References made by <code><a href="#enif_make_resource"><span class="code">enif_make_resource</span></a></code> can only be removed by the garbage collector.</p>  <h3><code>ErlNifRWLock *enif_rwlock_create(char *name)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_create"><span class="code">erl_drv_rwlock_create</span></a></code>.</p>  <h3><code>void enif_rwlock_destroy(ErlNifRWLock *rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_destroy"><span class="code">erl_drv_rwlock_destroy</span></a></code>.</p>  <h3><code>char*enif_rwlock_name(ErlNifRWLock* rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_name"><span class="code">erl_drv_rwlock_name</span></a></code>.</p>  <h3><code>void enif_rwlock_rlock(ErlNifRWLock *rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_rlock"><span class="code">erl_drv_rwlock_rlock</span></a></code>.</p>  <h3><code>void enif_rwlock_runlock(ErlNifRWLock *rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_runlock"><span class="code">erl_drv_rwlock_runlock</span></a></code>.</p>  <h3><code>void enif_rwlock_rwlock(ErlNifRWLock *rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_rwlock"><span class="code">erl_drv_rwlock_rwlock</span></a></code>.</p>  <h3><code>void enif_rwlock_rwunlock(ErlNifRWLock *rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_rwunlock"><span class="code">erl_drv_rwlock_rwunlock</span></a></code>.</p>  <h3><code>int enif_rwlock_tryrlock(ErlNifRWLock *rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_tryrlock"><span class="code">erl_drv_rwlock_tryrlock</span></a></code>.</p>  <h3><code>int enif_rwlock_tryrwlock(ErlNifRWLock *rwlck)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_rwlock_tryrwlock"><span class="code">erl_drv_rwlock_tryrwlock</span></a></code>.</p>  <h3><code>ERL_NIF_TERM enif_schedule_nif(ErlNifEnv* env, const char* fun_name, int flags, ERL_NIF_TERM (*fp)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]), int argc, const ERL_NIF_TERM argv[])</code></h3> 
<p>Schedules NIF <code class="code">fp</code> to execute. This function allows an application to break up long-running work into multiple regular NIF calls or to schedule a <code><a href="#dirty_nifs">dirty NIF</a></code> to execute on a dirty scheduler thread.</p> <dl> <dt><strong><code class="code">fun_name</code></strong></dt> <dd> <p>Provides a name for the NIF that is scheduled for execution. If it cannot be converted to an atom, <code class="code">enif_schedule_nif</code> returns a <code class="code">badarg</code> exception.</p> </dd> <dt><strong><code class="code">flags</code></strong></dt> <dd> <p>Must be set to <code class="code">0</code> for a regular NIF. If the emulator was built with dirty scheduler support enabled, <code class="code">flags</code> can be set to either <code class="code">ERL_NIF_DIRTY_JOB_CPU_BOUND</code> if the job is expected to be CPU-bound, or <code class="code">ERL_NIF_DIRTY_JOB_IO_BOUND</code> for jobs that will be I/O-bound. If dirty scheduler threads are not available in the emulator, an attempt to schedule such a job results in a <code class="code">notsup</code> exception.</p> </dd> <dt><strong><code class="code">argc</code> and <code class="code">argv</code></strong></dt> <dd> <p>Can either be the originals passed into the calling NIF, or can be values created by the calling NIF.</p> </dd> </dl> <p>The calling NIF must use the return value of <code class="code">enif_schedule_nif</code> as its own return value.</p> <p>Be aware that <code class="code">enif_schedule_nif</code>, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return. This means that the calling NIF cannot expect to receive the scheduled NIF return value and use it for further operations.</p>  <h3><code>int enif_select(ErlNifEnv* env, ErlNifEvent event, enum ErlNifSelectFlags mode, void* obj, const ErlNifPid* pid, ERL_NIF_TERM ref)</code></h3> 
<p>This function can be used to receive asynchronous notifications when OS-specific event objects become ready for either read or write operations.</p> <p>Argument <code class="code">event</code> identifies the event object. On Unix systems, the functions <code class="code">select</code>/<code class="code">poll</code> are used. The event object must be a socket, pipe or other file descriptor object that <code class="code">select</code>/<code class="code">poll</code> can use.</p> <p>Argument <code class="code">mode</code> describes the type of events to wait for. It can be <code class="code">ERL_NIF_SELECT_READ</code>, <code class="code">ERL_NIF_SELECT_WRITE</code> or a bitwise OR combination to wait for both. It can also be <code class="code">ERL_NIF_SELECT_STOP</code> which is described further below. When a read or write event is triggered, a notification message like this is sent to the process identified by <code class="code">pid</code>:</p> <pre data-language="erlang">{select, Obj, Ref, ready_input | ready_output}</pre> <p><code class="code">ready_input</code> or <code class="code">ready_output</code> indicates if the event object is ready for reading or writing.</p> <p>Argument <code class="code">pid</code> may be <code class="code">NULL</code> to indicate the calling process.</p> <p>Argument <code class="code">obj</code> is a resource object obtained from <code><a href="#enif_alloc_resource"><span class="code">enif_alloc_resource</span></a></code>. The purpose of the resource objects is as a container of the event object to manage its state and lifetime. A handle to the resource is received in the notification message as <code class="code">Obj</code>.</p> <p>Argument <code class="code">ref</code> must be either a reference obtained from <code><a href="erlang#make_ref-0"><span class="code">erlang:make_ref/0</span></a></code> or the atom <code class="code">undefined</code>. It will be passed as <code class="code">Ref</code> in the notifications. If a selective <code class="code">receive</code> statement is used to wait for the notification then a reference created just before the <code class="code">receive</code> will exploit a runtime optimization that bypasses all earlier received messages in the queue.</p> <p>The notifications are one-shot only. To receive further notifications of the same type (read or write), repeated calls to <code class="code">enif_select</code> must be made after receiving each notification.</p> <p>Use <code class="code">ERL_NIF_SELECT_STOP</code> as <code class="code">mode</code> in order to safely close an event object that has been passed to <code class="code">enif_select</code>. The <code><a href="#ErlNifResourceStop"><span class="code">stop</span></a></code> callback of the resource <code class="code">obj</code> will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received and no further calls to <code class="code">enif_select</code> have been made.</p> <p>The first call to <code class="code">enif_select</code> for a specific OS <code class="code">event</code> will establish a relation between the event object and the containing resource. All subsequent calls for an <code class="code">event</code> must pass its containing resource as argument <code class="code">obj</code>. The relation is dissolved when <code class="code">enif_select</code> has been called with <code class="code">mode</code> as <code class="code">ERL_NIF_SELECT_STOP</code> and the corresponding <code class="code">stop</code> callback has returned. A resource can contain several event objects but one event object can only be contained within one resource. A resource will not be destructed until all its contained relations have been dissolved.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Use <code><a href="#enif_monitor_process"><span class="code">enif_monitor_process</span></a></code> together with <code class="code">enif_select</code> to detect failing Erlang processes and prevent them from causing permanent leakage of resources and their contained OS event objects.</p> </div> </div> <p>Returns a non-negative value on success where the following bits can be set:</p> <dl> <dt><strong><code class="code">ERL_NIF_SELECT_STOP_CALLED</code></strong></dt> <dd>The stop callback was called directly by <code class="code">enif_select</code>.</dd> <dt><strong><code class="code">ERL_NIF_SELECT_STOP_SCHEDULED</code></strong></dt> <dd>The stop callback was scheduled to run on some other thread or later by this thread.</dd> </dl> <p>Returns a negative value if the call failed where the following bits can be set:</p> <dl> <dt><strong><code class="code">ERL_NIF_SELECT_INVALID_EVENT</code></strong></dt> <dd>Argument <code class="code">event</code> is not a valid OS event object.</dd> <dt><strong><code class="code">ERL_NIF_SELECT_FAILED</code></strong></dt> <dd>The system call failed to add the event object to the poll set.</dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Use bitwise AND to test for specific bits in the return value. New significant bits may be added in future releases to give more detailed information for both failed and successful calls. Do NOT use equality tests like <code class="code">==</code>, as that may cause your application to stop working.</p> <p>Example:</p> <pre data-language="erlang">retval = enif_select(env, fd, ERL_NIF_SELECT_STOP, resource, ref);
if (retval &lt; 0) {
    /* handle error */
}
/* Success! */
if (retval &amp; ERL_NIF_SELECT_STOP_CALLED) {
    /* ... */
}</pre> </div> </div>  <h3><code>ErlNifPid *enif_self(ErlNifEnv* caller_env, ErlNifPid* pid)</code></h3> 
<p>Initializes the <code><a href="#ErlNifPid"><span class="code">ErlNifPid</span></a></code> variable at <code class="code">*pid</code> to represent the calling process.</p> <p>Returns <code class="code">pid</code> if successful, or NULL if <code class="code">caller_env</code> is not a <code><a href="#ErlNifEnv">process-bound environment</a></code>.</p>  <h3><code>int enif_send(ErlNifEnv* env, ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg)</code></h3> 
<p>Sends a message to a process.</p> <dl> <dt><strong><code class="code">env</code></strong></dt> <dd>The environment of the calling process. Must be <code class="code">NULL</code> only if calling from a created thread.</dd> <dt><strong><code class="code">*to_pid</code></strong></dt> <dd>The pid of the receiving process. The pid is to refer to a process on the local node.</dd> <dt><strong><code class="code">msg_env</code></strong></dt> <dd>The environment of the message term. Must be a process-independent environment allocated with <code><a href="#enif_alloc_env"><span class="code">enif_alloc_env</span></a></code> or NULL.</dd> <dt><strong><code class="code">msg</code></strong></dt> <dd>The message term to send.</dd> </dl> <p>Returns <code class="code">true</code> if the message is successfully sent. Returns <code class="code">false</code> if the send operation fails, that is:</p> <ul> <li> <code class="code">*to_pid</code> does not refer to an alive local process.</li> <li>The currently executing process (that is, the sender) is not alive.</li> </ul> <p>The message environment <code class="code">msg_env</code> with all its terms (including <code class="code">msg</code>) is invalidated by a successful call to <code class="code">enif_send</code>. The environment is to either be freed with <code><a href="#enif_free_env"><span class="code">enif_free_env</span></a></code> of cleared for reuse with <code><a href="#enif_clear_env"><span class="code">enif_clear_env</span></a></code>.</p> <p>If <code class="code">msg_env</code> is set to <code class="code">NULL</code>, the <code class="code">msg</code> term is copied and the original term and its environment is still valid after the call.</p> <p>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Passing <code class="code">msg_env</code> as <code class="code">NULL</code> is only supported as from ERTS 8.0 (Erlang/OTP 19).</p> </div> </div>  <h3><code>unsigned enif_sizeof_resource(void* obj)</code></h3> 
<p>Gets the byte size of resource object <code class="code">obj</code> obtained by <code><a href="#enif_alloc_resource"><span class="code">enif_alloc_resource</span></a></code>.</p>  <h3><code>int enif_snprintf(char *str, size_t size, const char *format, ...)</code></h3> 
<p>Similar to <code class="code">snprintf</code> but this format string also accepts <code class="code">"%T"</code>, which formats Erlang terms.</p> <p>This function was originally intenden for debugging purpose. It is not recommended to print very large terms with <code class="code">%T</code>. The function may change <code class="code">errno</code>, even if successful.</p>  <h3><code>void enif_system_info(ErlNifSysInfo *sys_info_ptr, size_t size)</code></h3> 
<p>Same as <code><a href="erl_driver#driver_system_info"><span class="code">driver_system_info</span></a></code>.</p>  <h3><code>int enif_term_to_binary(ErlNifEnv *env, ERL_NIF_TERM term, ErlNifBinary *bin)</code></h3> 
<p>Allocates a new binary with <code><a href="#enif_alloc_binary"><span class="code">enif_alloc_binary</span></a></code> and stores the result of encoding <code class="code">term</code> according to the Erlang external term format.</p> <p>Returns <code class="code">true</code> on success, or <code class="code">false</code> if the allocation fails.</p> <p>See also <code><a href="erlang#term_to_binary-1"><span class="code">erlang:term_to_binary/1</span></a></code> and <code><a href="#enif_binary_to_term"><span class="code">enif_binary_to_term</span></a></code>.</p>  <h3><code>int enif_thread_create(char *name,ErlNifTid *tid,void * (*func)(void *),void *args,ErlNifThreadOpts *opts)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_thread_create"><span class="code">erl_drv_thread_create</span></a></code>.</p>  <h3><code>void enif_thread_exit(void *resp)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_thread_exit"><span class="code">erl_drv_thread_exit</span></a></code>.</p>  <h3><code>int enif_thread_join(ErlNifTid, void **respp)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_thread_join"><span class="code">erl_drv_thread_join</span></a></code>.</p>  <h3><code>char*enif_thread_name(ErlNifTid tid)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_thread_name"><span class="code">erl_drv_thread_name</span></a></code>.</p>  <h3><code>ErlNifThreadOpts *enif_thread_opts_create(char *name)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_thread_opts_create"><span class="code">erl_drv_thread_opts_create</span></a></code>.</p>  <h3><code>void enif_thread_opts_destroy(ErlNifThreadOpts *opts)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_thread_opts_destroy"><span class="code">erl_drv_thread_opts_destroy</span></a></code>.</p>  <h3><code>ErlNifTid enif_thread_self(void)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_thread_self"><span class="code">erl_drv_thread_self</span></a></code>.</p>  <h3><code>int enif_thread_type(void)</code></h3> 
<p>Determine the type of currently executing thread. A positive value indicates a scheduler thread while a negative value or zero indicates another type of thread. Currently the following specific types exist (which may be extended in the future):</p> <dl> <dt><strong><code class="code">ERL_NIF_THR_UNDEFINED</code></strong></dt> <dd><p>Undefined thread that is not a scheduler thread.</p></dd> <dt><strong><code class="code">ERL_NIF_THR_NORMAL_SCHEDULER</code></strong></dt> <dd><p>A normal scheduler thread.</p></dd> <dt><strong><code class="code">ERL_NIF_THR_DIRTY_CPU_SCHEDULER</code></strong></dt> <dd><p>A dirty CPU scheduler thread.</p></dd> <dt><strong><code class="code">ERL_NIF_THR_DIRTY_IO_SCHEDULER</code></strong></dt> <dd><p>A dirty I/O scheduler thread.</p></dd> </dl>  <h3><code>ErlNifTime enif_time_offset(ErlNifTimeUnit time_unit)</code></h3> 
<p>Returns the current time offset between <code><a href="time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and <code><a href="time_correction#Erlang_System_Time">Erlang system time</a></code> converted into the <code class="code">time_unit</code> passed as argument.</p> <p><code class="code">time_unit</code> is the time unit of the returned value.</p> <p>Returns <code class="code">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument or if called from a thread that is not a scheduler thread.</p> <p>See also <code><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code> and <code><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code>.</p>  <h3><code>void *enif_tsd_get(ErlNifTSDKey key)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_tsd_get"><span class="code">erl_drv_tsd_get</span></a></code>.</p>  <h3><code>int enif_tsd_key_create(char *name, ErlNifTSDKey *key)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_tsd_key_create"><span class="code">erl_drv_tsd_key_create</span></a></code>.</p>  <h3><code>void enif_tsd_key_destroy(ErlNifTSDKey key)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_tsd_key_destroy"><span class="code">erl_drv_tsd_key_destroy</span></a></code>.</p>  <h3><code>void enif_tsd_set(ErlNifTSDKey key, void *data)</code></h3> 
<p>Same as <code><a href="erl_driver#erl_drv_tsd_set"><span class="code">erl_drv_tsd_set</span></a></code>.</p>  <h3><code>int enif_vfprintf(FILE *stream, const char *format, va_list ap)</code></h3> 
<p>Equivalent to <code><a href="#enif_fprintf"><span class="code">enif_fprintf</span></a></code> except that its called with a <code class="code">va_list</code> instead of a variable number of arguments.</p>  <h3><code>int enif_vsnprintf(char *str, size_t size, const char *format, va_list ap)</code></h3> 
<p>Equivalent to <code><a href="#enif_snprintf"><span class="code">enif_snprintf</span></a></code> except that its called with a <code class="code">va_list</code> instead of a variable number of arguments.</p>  <h3><code>int enif_whereis_pid(ErlNifEnv *env, ERL_NIF_TERM name, ErlNifPid *pid)</code></h3> 
<p>Looks up a process by its registered name.</p> <dl> <dt><strong><code class="code">env</code></strong></dt> <dd>The environment of the calling process. Must be <code class="code">NULL</code> only if calling from a created thread.</dd> <dt><strong><code class="code">name</code></strong></dt> <dd>The name of a registered process, as an atom.</dd> <dt><strong><code class="code">*pid</code></strong></dt> <dd>The <code><a href="#ErlNifPid"><span class="code">ErlNifPid</span></a></code> in which the resolved process id is stored.</dd> </dl> <p>On success, sets <code class="code">*pid</code> to the local process registered with <code class="code">name</code> and returns <code class="code">true</code>. If <code class="code">name</code> is not a registered process, or is not an atom, <code class="code">false</code> is returned and <code class="code">*pid</code> is unchanged.</p> <p>Works as <code><a href="erlang#whereis-1"><span class="code">erlang:whereis/1</span></a></code>, but restricted to processes. See <code><a href="#enif_whereis_port"><span class="code">enif_whereis_port</span></a></code> to resolve registered ports.</p>  <h3><code>int enif_whereis_port(ErlNifEnv *env, ERL_NIF_TERM name, ErlNifPort *port)</code></h3> 
<p>Looks up a port by its registered name.</p> <dl> <dt><strong><code class="code">env</code></strong></dt> <dd>The environment of the calling process. Must be <code class="code">NULL</code> only if calling from a created thread.</dd> <dt><strong><code class="code">name</code></strong></dt> <dd>The name of a registered port, as an atom.</dd> <dt><strong><code class="code">*port</code></strong></dt> <dd>The <code><a href="#ErlNifPort"><span class="code">ErlNifPort</span></a></code> in which the resolved port id is stored.</dd> </dl> <p>On success, sets <code class="code">*port</code> to the port registered with <code class="code">name</code> and returns <code class="code">true</code>. If <code class="code">name</code> is not a registered port, or is not an atom, <code class="code">false</code> is returned and <code class="code">*port</code> is unchanged.</p> <p>Works as <code><a href="erlang#whereis-1"><span class="code">erlang:whereis/1</span></a></code>, but restricted to ports. See <code><a href="#enif_whereis_pid"><span class="code">enif_whereis_pid</span></a></code> to resolve registered processes.</p>  </div> <h2><span onmouseover="document.getElementById('ghlink-see-also-id247224').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-see-also-id247224').style.visibility = 'hidden';" id="see-also">See Also</span></h2>  <p><code><a href="erlang#load_nif-2"><span class="code">erlang:load_nif/2</span></a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
     20102017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
