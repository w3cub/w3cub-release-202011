
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Erts_alloc - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content=" erts_alloc ">
  <meta name="keywords" content="erts, alloc, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/erts-10.0/doc/html/erts_alloc.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>erts_alloc</h1> <h2><span onmouseover="document.getElementById('ghlink-c-library-id233193').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-c-library-id233193').style.visibility = 'hidden';" id="c-library">C Library</span></h2> <p class="REFBODY c-library-body">erts_alloc</p> <h2><span onmouseover="document.getElementById('ghlink-library-summary-id233197').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-library-summary-id233197').style.visibility = 'hidden';" id="library-summary">Library Summary</span></h2> <p class="REFBODY library-summary-body">An Erlang runtime system internal memory allocator library. </p> <h2><span onmouseover="document.getElementById('ghlink-description-id233201').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-id233201').style.visibility = 'hidden';" id="description">Description</span></h2> 
<p><code class="code">erts_alloc</code> is an Erlang runtime system internal memory allocator library. <code class="code">erts_alloc</code> provides the Erlang runtime system with a number of memory allocators.</p>  <h2><span onmouseover="document.getElementById('ghlink-allocators-id233218').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-allocators-id233218').style.visibility = 'hidden';" id="allocators">Allocators</span></h2>   <p id="allocators">The following allocators are present:</p> <dl> <dt><strong><code class="code">temp_alloc</code></strong></dt> <dd>Allocator used for temporary allocations.</dd> <dt><strong><code class="code">eheap_alloc</code></strong></dt> <dd>Allocator used for Erlang heap data, such as Erlang process heaps. </dd> <dt><strong><code class="code">binary_alloc</code></strong></dt> <dd>Allocator used for Erlang binary data.</dd> <dt><strong><code class="code">ets_alloc</code></strong></dt> <dd>Allocator used for <code class="code">ets</code> data.</dd> <dt><strong><code class="code">driver_alloc</code></strong></dt> <dd>Allocator used for driver data.</dd> <dt><strong><code class="code">literal_alloc</code></strong></dt> <dd>Allocator used for constant terms in Erlang code.</dd> <dt><strong><code class="code">sl_alloc</code></strong></dt> <dd>Allocator used for memory blocks that are expected to be short-lived.</dd> <dt><strong><code class="code">ll_alloc</code></strong></dt> <dd>Allocator used for memory blocks that are expected to be long-lived, for example, Erlang code.</dd> <dt><strong><code class="code">fix_alloc</code></strong></dt> <dd>A fast allocator used for some frequently used fixed size data types.</dd> <dt><strong><code class="code">exec_alloc</code></strong></dt> <dd>Allocator used by the <code><span class="code">HiPE</span></code> application for native executable code.</dd> <dt><strong><code class="code">std_alloc</code></strong></dt> <dd>Allocator used for most memory blocks not allocated through any of the other allocators described above.</dd> <dt><strong><code class="code">sys_alloc</code></strong></dt> <dd>This is normally the default <code class="code">malloc</code> implementation used on the specific OS.</dd> <dt><strong><code class="code">mseg_alloc</code></strong></dt> <dd>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the <code class="code">mmap</code> system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</dd> </dl> <p><code class="code">sys_alloc</code>, <code class="code">literal_alloc</code> and <code class="code">temp_alloc</code> are always enabled and cannot be disabled. <code class="code">exec_alloc</code> is only available if it is needed and cannot be disabled. <code class="code">mseg_alloc</code> is always enabled if it is available and an allocator that uses it is enabled. All other allocators can be <code><a href="#M_e">enabled or disabled</a></code>. By default all allocators are enabled. When an allocator is disabled, <code class="code">sys_alloc</code> is used instead of the disabled allocator.</p> <p>The main idea with the <code class="code">erts_alloc</code> library is to separate memory blocks that are used differently into different memory areas, to achieve less memory fragmentation. By putting less effort in finding a good fit for memory blocks that are frequently allocated than for those less frequently allocated, a performance gain can be achieved.</p>  <h2> <span onmouseover="document.getElementById('ghlink-the-alloc_util-framework-id233421').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-alloc_util-framework-id233421').style.visibility = 'hidden';" id="alloc_util">The alloc_util Framework</span> </h2>  <p>Internally a framework called <code class="code">alloc_util</code> is used for implementing allocators. <code class="code">sys_alloc</code> and <code class="code">mseg_alloc</code> do not use this framework, so the following does <strong>not</strong> apply to them.</p> <p>An allocator manages multiple areas, called carriers, in which memory blocks are placed. A carrier is either placed in a separate memory segment (allocated through <code class="code">mseg_alloc</code>), or in the heap segment (allocated through <code class="code">sys_alloc</code>).</p> <ul> <li> <p>Multiblock carriers are used for storage of several blocks.</p> </li> <li> <p>Singleblock carriers are used for storage of one block.</p> </li> <li> <p>Blocks that are larger than the value of the singleblock carrier threshold (<code><a href="#M_sbct"><span class="code">sbct</span></a></code>) parameter are placed in singleblock carriers.</p> </li> <li> <p>Blocks that are smaller than the value of parameter <code class="code">sbct</code> are placed in multiblock carriers.</p> </li> </ul> <p>Normally an allocator creates a "main multiblock carrier". Main multiblock carriers are never deallocated. The size of the main multiblock carrier is determined by the value of parameter <code><a href="#M_mmbcs"><span class="code">mmbcs</span></a></code>.</p> <p>Sizes of multiblock carriers allocated through <code class="code" id="mseg_mbc_sizes">mseg_alloc</code> are decided based on the following parameters:</p> <ul> <li>The values of the largest multiblock carrier size (<code><a href="#M_lmbcs"><span class="code">lmbcs</span></a></code>)</li> <li>The smallest multiblock carrier size (<code><a href="#M_smbcs"><span class="code">smbcs</span></a></code>)</li> <li>The multiblock carrier growth stages (<code><a href="#M_mbcgs"><span class="code">mbcgs</span></a></code>)</li> </ul> <p>If <code class="code">nc</code> is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next <code class="code">mseg_alloc</code> multiblock carrier allocated by this allocator is roughly <code class="code">smbcs+nc*(lmbcs-smbcs)/mbcgs</code> when <code class="code">nc &lt;= mbcgs</code>, and <code class="code">lmbcs</code> when <code class="code">nc &gt; mbcgs</code>. If the value of parameter <code class="code">sbct</code> is larger than the value of parameter <code class="code">lmbcs</code>, the allocator may have to create multiblock carriers that are larger than the value of parameter <code class="code">lmbcs</code>, though. Singleblock carriers allocated through <code class="code">mseg_alloc</code> are sized to whole pages.</p> <p>Sizes of carriers allocated through <code class="code">sys_alloc</code> are decided based on the value of the <code class="code">sys_alloc</code> carrier size (<code><a href="#Muycs"><span class="code">ycs</span></a></code>) parameter. The size of a carrier is the least number of multiples of the value of parameter <code class="code">ycs</code> satisfying the request.</p> <p>Coalescing of free blocks are always performed immediately. Boundary tags (headers and footers) in free blocks are used, which makes the time complexity for coalescing constant.</p> <p>The memory allocation strategy used for multiblock carriers by an allocator can be configured using parameter <code id="strategy"><a href="#M_as"><span class="code">as</span></a></code>. The following strategies are available:</p> <dl> <dt><strong>Best fit</strong></dt> <dd> <p>Strategy: Find the smallest block satisfying the requested block size.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</p> </dd> <dt><strong>Address order best fit</strong></dt> <dd> <p>Strategy: Find the smallest block satisfying the requested block size. If multiple blocks are found, choose the one with the lowest address.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit</strong></dt> <dd> <p>Strategy: Find the block with the lowest address satisfying the requested block size.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit carrier best fit</strong></dt> <dd> <p>Strategy: Find the <strong>carrier</strong> with the lowest address that can satisfy the requested block size, then find a block within that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit carrier address order best fit</strong></dt> <dd> <p>Strategy: Find the <strong>carrier</strong> with the lowest address that can satisfy the requested block size, then find a block within that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Age order first fit carrier address order first fit</strong></dt> <dd> <p>Strategy: Find the <strong>oldest carrier</strong> that can satisfy the requested block size, then find a block within that carrier using the "address order first fit" strategy.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Age order first fit carrier best fit</strong></dt> <dd> <p>Strategy: Find the <strong>oldest carrier</strong> that can satisfy the requested block size, then find a block within that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Age order first fit carrier address order best fit</strong></dt> <dd> <p>Strategy: Find the <strong>oldest carrier</strong> that can satisfy the requested block size, then find a block within that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Good fit</strong></dt> <dd> <p>Strategy: Try to find the best fit, but settle for the best fit found during a limited search.</p> <p>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter <code><a href="#M_mbsd"><span class="code">mbsd</span></a></code>.</p> </dd> <dt><strong>A fit</strong></dt> <dd> <p>Strategy: Do not search for a fit, inspect only one free block to see if it satisfies the request. This strategy is only intended to be used for temporary allocations.</p> <p>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</p> <p>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than <code class="code">temp_alloc</code>. This because it only causes problems for other allocators.</p> </dd> </dl> <p>Apart from the ordinary allocators described above, some pre-allocators are used for some specific data types. These pre-allocators pre-allocate a fixed amount of memory for certain data types when the runtime system starts. As long as pre-allocated memory is available, it is used. When no pre-allocated memory is available, memory is allocated in ordinary allocators. These pre-allocators are typically much faster than the ordinary allocators, but can only satisfy a limited number of requests.</p>  <h2> <span onmouseover="document.getElementById('ghlink-system-flags-effecting-erts_alloc-id233888').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-system-flags-effecting-erts_alloc-id233888').style.visibility = 'hidden';" id="flags">System Flags Effecting erts_alloc</span> </h2>  <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</p> </div> </div> <p>Memory allocator system flags have the following syntax: <code class="code">+M&lt;S&gt;&lt;P&gt; &lt;V&gt;</code>, where <code class="code">&lt;S&gt;</code> is a letter identifying a subsystem, <code class="code">&lt;P&gt;</code> is a parameter, and <code class="code">&lt;V&gt;</code> is the value to use. The flags can be passed to the Erlang emulator (<code><a href="erl"><span class="code">erl(1)</span></a></code>) as command-line arguments.</p> <p>System flags effecting specific allocators have an uppercase letter as <code class="code">&lt;S&gt;</code>. The following letters are used for the allocators:</p> <ul> <li><code class="code">B: binary_alloc</code></li> <li><code class="code">D: std_alloc</code></li> <li><code class="code">E: ets_alloc</code></li> <li><code class="code">F: fix_alloc</code></li> <li><code class="code">H: eheap_alloc</code></li> <li><code class="code">I: literal_alloc</code></li> <li><code class="code">L: ll_alloc</code></li> <li><code class="code">M: mseg_alloc</code></li> <li><code class="code">R: driver_alloc</code></li> <li><code class="code">S: sl_alloc</code></li> <li><code class="code">T: temp_alloc</code></li> <li><code class="code">X: exec_alloc</code></li> <li><code class="code">Y: sys_alloc</code></li> </ul> <h4>Flags for Configuration of mseg_alloc</h4>  <dl> <dt><strong><code class="code" id="MMamcbf">+MMamcbf &lt;size&gt;</code></strong></dt> <dd> <p>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to <code class="code">4096</code>.</p> </dd> <dt><strong><code class="code" id="MMrmcbf">+MMrmcbf &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative maximum cache bad fit (in percent). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than relative maximum cache bad fit percent of the requested size. Defaults to <code class="code">20</code>.</p> </dd> <dt><strong><code class="code" id="MMsco">+MMsco true|false</code></strong></dt> <dd> <p>Sets <code><a href="#MMscs">super carrier</a></code> only flag. Defaults to <code class="code">true</code>. When a super carrier is used and this flag is <code class="code">true</code>, <code class="code">mseg_alloc</code> only creates carriers in the super carrier. Notice that the <code class="code">alloc_util</code> framework can create <code class="code">sys_alloc</code> carriers, so if you want all carriers to be created in the super carrier, you therefore want to disable use of <code class="code">sys_alloc</code> carriers by also passing <code><a href="#Musac"><span class="code">+Musac false</span></a></code>. When the flag is <code class="code">false</code>, <code class="code">mseg_alloc</code> tries to create carriers outside of the super carrier when the super carrier is full.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Setting this flag to <code class="code">false</code> is not supported on all systems. The flag is then ignored.</p> </div> </div> </dd> <dt><strong><code class="code" id="MMscrfsd">+MMscrfsd &lt;amount&gt;</code></strong></dt> <dd> <p>Sets <code><a href="#MMscs">super carrier</a></code> reserved free segment descriptors. Defaults to <code class="code">65536</code>. This parameter determines the amount of memory to reserve for free segment descriptors used by the super carrier. If the system runs out of reserved memory for free segment descriptors, other memory is used. This can however cause fragmentation issues, so you want to ensure that this never happens. The maximum amount of free segment descriptors used can be retrieved from the <code class="code">erts_mmap</code> tuple part of the result from calling <code><span class="code">erlang:system_info({allocator, mseg_alloc})</span></code>.</p> </dd> <dt><strong><code class="code" id="MMscrpm">+MMscrpm true|false</code></strong></dt> <dd> <p>Sets <code><a href="#MMscs">super carrier</a></code> reserve physical memory flag. Defaults to <code class="code">true</code>. When this flag is <code class="code">true</code>, physical memory is reserved for the whole super carrier at once when it is created. The reservation is after that left unchanged. When this flag is set to <code class="code">false</code>, only virtual address space is reserved for the super carrier upon creation. The system attempts to reserve physical memory upon carrier creations in the super carrier, and attempt to unreserve physical memory upon carrier destructions in the super carrier.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>What reservation of physical memory means, highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behavior.</p> <p>Setting this flag to <code class="code">false</code> is possibly not supported on all systems. The flag is then ignored.</p> </div> </div> </dd> <dt><strong><code class="code" id="MMscs">+MMscs &lt;size in MB&gt;</code></strong></dt> <dd> <p>Sets super carrier size (in MB). Defaults to <code class="code">0</code>, that is, the super carrier is by default disabled. The super carrier is a large continuous area in the virtual address space. <code class="code">mseg_alloc</code> always tries to create new carriers in the super carrier if it exists. Notice that the <code class="code">alloc_util</code> framework can create <code class="code">sys_alloc</code> carriers. For more information, see <code><a href="#MMsco"><span class="code">+MMsco</span></a></code>.</p> </dd> <dt><strong><code class="code" id="MMmcs">+MMmcs &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum cached segments. The maximum number of memory segments stored in the memory segment cache. Valid range is <code class="code">[0, 30]</code>. Defaults to <code class="code">10</code>.</p> </dd> </dl>  <h4>Flags for Configuration of sys_alloc</h4>  <dl> <dt><strong><code class="code" id="MYe">+MYe true</code></strong></dt> <dd> <p>Enables <code class="code">sys_alloc</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">sys_alloc</code> cannot be disabled.</p> </div> </div> </dd> <dt><strong><code class="code" id="MYm">+MYm libc</code></strong></dt> <dd> <p><code class="code">malloc</code> library to use. Only <code class="code">libc</code> is available. <code class="code">libc</code> enables the standard <code class="code">libc</code> <code class="code">malloc</code> implementation. By default <code class="code">libc</code> is used.</p> </dd> <dt><strong><code class="code" id="MYtt">+MYtt &lt;size&gt;</code></strong></dt> <dd> <p>Trim threshold size (in kilobytes). This is the maximum amount of free memory at the top of the heap (allocated by <code class="code">sbrk</code>) that is kept by <code class="code">malloc</code> (not released to the operating system). When the amount of free memory at the top of the heap exceeds the trim threshold, <code class="code">malloc</code> releases it (by calling <code class="code">sbrk</code>). Trim threshold is specified in kilobytes. Defaults to <code class="code">128</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This flag has effect only when the emulator is linked with the GNU C library, and uses its <code class="code">malloc</code> implementation.</p> </div> </div> </dd> <dt><strong><code class="code" id="MYtp">+MYtp &lt;size&gt;</code></strong></dt> <dd> <p>Top pad size (in kilobytes). This is the amount of extra memory that is allocated by <code class="code">malloc</code> when <code class="code">sbrk</code> is called to get more memory from the operating system. Defaults to <code class="code">0</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This flag has effect only when the emulator is linked with the GNU C library, and uses its <code class="code">malloc</code> implementation.</p> </div> </div> </dd> </dl>  <h4>Flags for Configuration of Allocators Based on alloc_util</h4>  <p>If <code class="code">u</code> is used as subsystem identifier (that is, <code class="code">&lt;S&gt; = u</code>), all allocators based on <code class="code">alloc_util</code> are effected. If <code class="code">B</code>, <code class="code">D</code>, <code class="code">E</code>, <code class="code">F</code>, <code class="code">H</code>, <code class="code">L</code>, <code class="code">R</code>, <code class="code">S</code>, or <code class="code">T</code> is used as subsystem identifier, only the specific allocator identifier is effected.</p> <dl> <dt><strong><code class="code" id="M_acul">+M&lt;S&gt;acul &lt;utilization&gt;|de</code> </strong></dt> <dd> <p>Abandon carrier utilization limit. A valid <code class="code">&lt;utilization&gt;</code> is an integer in the range <code class="code">[0, 100]</code> representing utilization in percent. When a utilization value &gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If <code class="code">de</code> (default enabled) is passed instead of a <code class="code">&lt;utilization&gt;</code>, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to <code class="code">de</code>, but this can be changed in the future.</p> <p>Carriers are abandoned when memory utilization in the allocator instance falls below the utilization value used. Once a carrier is abandoned, no new allocations are made in it. When an allocator instance gets an increased multiblock carrier need, it first tries to fetch an abandoned carrier from an allocator instance of the same allocator type. If no abandoned carrier can be fetched, it creates a new empty carrier. When an abandoned carrier has been fetched, it will function as an ordinary carrier. This feature has special requirements on the <code><a href="#M_as">allocation strategy</a></code> used. Only the strategies <code class="code">aoff</code>, <code class="code">aoffcbf</code>, <code class="code">aoffcaobf</code>, <code class="code">ageffcaoff</code>m, <code class="code">ageffcbf</code> and <code class="code">ageffcaobf</code> support abandoned carriers.</p> <p>This feature also requires <code><a href="#M_t">multiple thread specific instances</a></code> to be enabled. When enabling this feature, multiple thread-specific instances are enabled if not already enabled, and the <code class="code">aoffcbf</code> strategy is enabled if the current strategy does not support abandoned carriers. This feature can be enabled on all allocators based on the <code class="code">alloc_util</code> framework, except <code class="code">temp_alloc</code> (which would be pointless).</p> </dd> <dt><strong><code class="code" id="M_acfml">+M&lt;S&gt;acfml &lt;bytes&gt;</code> </strong></dt> <dd> <p>Abandon carrier free block min limit. A valid <code class="code">&lt;bytes&gt;</code> is a positive integer representing a block size limit. The largest free block in a carrier must be at least <code class="code">bytes</code> large, for the carrier to be abandoned. The default is zero but can be changed in the future.</p> <p>See also <code><a href="#M_acul"><span class="code">acul</span></a></code>.</p> </dd> <dt><strong><code class="code" id="M_acnl">+M&lt;S&gt;acnl &lt;amount&gt;</code> </strong></dt> <dd> <p>Abandon carrier number limit. A valid <code class="code">&lt;amount&gt;</code> is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</p> <p>See also <code><a href="#M_acul"><span class="code">acul</span></a></code>.</p> </dd> <dt><strong> <code class="code" id="M_as">+M&lt;S&gt;as bf|aobf|aoff|aoffcbf|aoffcaobf|ageffcaoff|ageffcbf|ageffcaobf|gf|af</code></strong></dt> <dd> <p>Allocation strategy. The following strategies are valid:</p> <ul> <li> <code class="code">bf</code> (best fit)</li> <li> <code class="code">aobf</code> (address order best fit)</li> <li> <code class="code">aoff</code> (address order first fit)</li> <li> <code class="code">aoffcbf</code> (address order first fit carrier best fit) </li> <li> <code class="code">aoffcaobf</code> (address order first fit carrier address order best fit)</li> <li> <code class="code">ageffcaoff</code> (age order first fit carrier address order first fit)</li> <li> <code class="code">ageffcbf</code> (age order first fit carrier best fit) </li> <li> <code class="code">ageffcaobf</code> (age order first fit carrier address order best fit)</li> <li> <code class="code">gf</code> (good fit)</li> <li> <code class="code">af</code> (a fit)</li> </ul> <p>See the description of allocation strategies in section <code><a href="#strategy">The alloc_util Framework</a></code>.</p> </dd> <dt><strong><code class="code" id="M_asbcst">+M&lt;S&gt;asbcst &lt;size&gt;</code></strong></dt> <dd> <p>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an <code class="code">mseg_alloc</code> singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also <code><a href="#M_rsbcst"><span class="code">rsbcst</span></a></code>.</p> </dd> <dt><strong><code class="code" id="M_atags">+M&lt;S&gt;atags true|false</code></strong></dt> <dd> <p>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. Use the <code><span class="code">instrument</span></code> module to inspect this information.</p> <p>The runtime overhead is one word per allocation when enabled. This may change at any time in the future.</p> <p>The default is <code class="code">true</code> for <code class="code">binary_alloc</code> and <code class="code">driver_alloc</code>, and <code class="code">false</code> for the other allocator types.</p> </dd> <dt><strong><code class="code" id="M_e">+M&lt;S&gt;e true|false</code></strong></dt> <dd> <p>Enables allocator <code class="code">&lt;S&gt;</code>.</p> </dd> <dt><strong><code class="code" id="M_lmbcs">+M&lt;S&gt;lmbcs &lt;size&gt;</code></strong></dt> <dd> <p>Largest (<code class="code">mseg_alloc</code>) multiblock carrier size (in kilobytes). See the description on how sizes for <code class="code">mseg_alloc</code> multiblock carriers are decided in section <code><a href="#mseg_mbc_sizes">The alloc_util Framework</a></code>. On 32-bit Unix style OS this limit cannot be set &gt; 128 MB.</p> </dd> <dt><strong><code class="code" id="M_mbcgs">+M&lt;S&gt;mbcgs &lt;ratio&gt;</code></strong></dt> <dd> <p>(<code class="code">mseg_alloc</code>) multiblock carrier growth stages. See the description on how sizes for <code class="code">mseg_alloc</code> multiblock carriers are decided in section <code><a href="#mseg_mbc_sizes">The alloc_util Framework</a></code>.</p> </dd> <dt><strong><code class="code" id="M_mbsd">+M&lt;S&gt;mbsd &lt;depth&gt;</code></strong></dt> <dd> <p>Maximum block search depth. This flag has effect only if the good fit strategy is selected for allocator <code class="code">&lt;S&gt;</code>. When the good fit strategy is used, free blocks are placed in segregated free-lists. Each free-list contains blocks of sizes in a specific range. The maxiumum block search depth sets a limit on the maximum number of blocks to inspect in a free-list during a search for suitable block satisfying the request.</p> </dd> <dt><strong><code class="code" id="M_mmbcs">+M&lt;S&gt;mmbcs &lt;size&gt;</code></strong></dt> <dd> <p>Main multiblock carrier size. Sets the size of the main multiblock carrier for allocator <code class="code">&lt;S&gt;</code>. The main multiblock carrier is allocated through <code class="code">sys_alloc</code> and is never deallocated.</p> </dd> <dt><strong><code class="code" id="M_mmmbc">+M&lt;S&gt;mmmbc &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum <code class="code">mseg_alloc</code> multiblock carriers. Maximum number of multiblock carriers allocated through <code class="code">mseg_alloc</code> by allocator <code class="code">&lt;S&gt;</code>. When this limit is reached, new multiblock carriers are allocated through <code class="code">sys_alloc</code>.</p> </dd> <dt><strong><code class="code" id="M_mmsbc">+M&lt;S&gt;mmsbc &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum <code class="code">mseg_alloc</code> singleblock carriers. Maximum number of singleblock carriers allocated through <code class="code">mseg_alloc</code> by allocator <code class="code">&lt;S&gt;</code>. When this limit is reached, new singleblock carriers are allocated through <code class="code">sys_alloc</code>.</p> </dd> <dt><strong><code class="code" id="M_ramv">+M&lt;S&gt;ramv &lt;bool&gt;</code></strong></dt> <dd> <p>Realloc always moves. When enabled, reallocate operations are more or less translated into an allocate, copy, free sequence. This often reduces memory fragmentation, but costs performance.</p> </dd> <dt><strong><code class="code" id="M_rmbcmt">+M&lt;S&gt;rmbcmt &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative multiblock carrier move threshold (in percent). When a block located in a multiblock carrier is shrunk, the block is moved if the ratio of the size of the returned memory compared to the previous size is more than this threshold, otherwise the block is shrunk at the current location.</p> </dd> <dt><strong><code class="code" id="M_rsbcmt">+M&lt;S&gt;rsbcmt &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative singleblock carrier move threshold (in percent). When a block located in a singleblock carrier is shrunk to a size smaller than the value of parameter <code><a href="#M_sbct"><span class="code">sbct</span></a></code>, the block is left unchanged in the singleblock carrier if the ratio of unused memory is less than this threshold, otherwise it is moved into a multiblock carrier.</p> </dd> <dt><strong><code class="code" id="M_rsbcst">+M&lt;S&gt;rsbcst &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative singleblock carrier shrink threshold (in percent). When a block located in an <code class="code">mseg_alloc</code> singleblock carrier is shrunk, the carrier is left unchanged if the ratio of unused memory is less than this threshold, otherwise the carrier is shrunk. See also <code><a href="#M_asbcst"><span class="code">asbcst</span></a></code>.</p> </dd> <dt><strong><code class="code" id="M_sbct">+M&lt;S&gt;sbct &lt;size&gt;</code></strong></dt> <dd> <p>Singleblock carrier threshold (in kilobytes). Blocks larger than this threshold are placed in singleblock carriers. Blocks smaller than this threshold are placed in multiblock carriers. On 32-bit Unix style OS this threshold cannot be set &gt; 8 MB.</p> </dd> <dt><strong><code class="code" id="M_smbcs">+M&lt;S&gt;smbcs &lt;size&gt;</code></strong></dt> <dd> <p>Smallest (<code class="code">mseg_alloc</code>) multiblock carrier size (in kilobytes). See the description on how sizes for <code class="code">mseg_alloc</code> multiblock carriers are decided in section <code><a href="#mseg_mbc_sizes">The alloc_util Framework</a></code>.</p> </dd> <dt><strong><code class="code" id="M_t">+M&lt;S&gt;t true|false</code></strong></dt> <dd> <p>Multiple, thread-specific instances of the allocator. This option has only effect on the runtime system with SMP support. Default behavior on the runtime system with SMP support is <code class="code">NoSchedulers+1</code> instances. Each scheduler uses a lock-free instance of its own and other threads use a common instance.</p> <p>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</p> </dd> </dl>  <h4>Flags for Configuration of alloc_util</h4>  <p>All allocators based on <code class="code">alloc_util</code> are effected.</p> <dl> <dt><strong><code class="code" id="Muycs">+Muycs &lt;size&gt;</code></strong></dt> <dd> <p><code class="code">sys_alloc</code> carrier size. Carriers allocated through <code class="code">sys_alloc</code> are allocated in sizes that are multiples of the <code class="code">sys_alloc</code> carrier size. This is not true for main multiblock carriers and carriers allocated during a memory shortage, though.</p> </dd> <dt><strong><code class="code" id="Mummc">+Mummc &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum <code class="code">mseg_alloc</code> carriers. Maximum number of carriers placed in separate memory segments. When this limit is reached, new carriers are placed in memory retrieved from <code class="code">sys_alloc</code>.</p> </dd> <dt><strong><code class="code" id="Musac">+Musac &lt;bool&gt;</code></strong></dt> <dd> <p>Allow <code class="code">sys_alloc</code> carriers. Defaults to <code class="code">true</code>. If set to <code class="code">false</code>, <code class="code">sys_alloc</code> carriers are never created by allocators using the <code class="code">alloc_util</code> framework.</p> </dd> </dl>  <h4>Special Flag for literal_alloc</h4>  <dl> <dt><strong><code class="code" id="MIscs">+MIscs &lt;size in MB&gt;</code></strong></dt> <dd> <p><code class="code">literal_alloc</code> super carrier size (in MB). The amount of <strong>virtual</strong> address space reserved for literal terms in Erlang code on 64-bit architectures. Defaults to <code class="code">1024</code> (that is, 1 GB), which is usually sufficient. The flag is ignored on 32-bit architectures.</p> </dd> </dl>  <h4>Instrumentation Flags</h4>  <dl> <dt><strong><code class="code">+M&lt;S&gt;atags</code></strong></dt> <dd> <p>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. See <code><a href="#M_atags"><span class="code">+M&lt;S&gt;atags</span></a></code> for a more complete description.</p> </dd> <dt><strong><code class="code" id="Mit">+Mit X</code></strong></dt> <dd> <p>Reserved for future use. Do <strong>not</strong> use this flag.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</p> </div> </div>  <h4>Other Flags</h4>  <dl> <dt><strong><code class="code" id="Mea">+Mea min|max|r9c|r10b|r11b|config</code></strong></dt> <dd> <p>Options:</p> <dl> <dt><strong><code class="code">min</code></strong></dt> <dd> <p>Disables all allocators that can be disabled.</p> </dd> <dt><strong><code class="code">max</code></strong></dt> <dd> <p>Enables all allocators (default).</p> </dd> <dt><strong><code class="code">r9c|r10b|r11b</code></strong></dt> <dd> <p>Configures all allocators as they were configured in respective Erlang/OTP release. These will eventually be removed.</p> </dd> <dt><strong><code class="code">config</code></strong></dt> <dd> <p>Disables features that cannot be enabled while creating an allocator configuration with <code><span class="code">erts_alloc_config(3)</span></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This option is to be used only while running <code class="code">erts_alloc_config(3)</code>, <strong>not</strong> when using the created configuration.</p> </div> </div> </dd> </dl> </dd> <dt><strong><code class="code" id="Mlpm">+Mlpm all|no</code></strong></dt> <dd> <p>Lock physical memory. Defaults to <code class="code">no</code>, that is, no physical memory is locked. If set to <code class="code">all</code>, all memory mappings made by the runtime system are locked into physical memory. If set to <code class="code">all</code>, the runtime system fails to start if this feature is not supported, the user has not got enough privileges, or the user is not allowed to lock enough physical memory. The runtime system also fails with an out of memory condition if the user limit on the amount of locked memory is reached.</p> </dd> </dl>   <h2><span onmouseover="document.getElementById('ghlink-notes-id235591').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-notes-id235591').style.visibility = 'hidden';" id="notes">Notes</span></h2>  <p>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see <code><span class="code">erlang:system_info(allocator)</span></code> and <code><span class="code">erlang:system_info({allocator, Alloc})</span></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Most of these flags are highly implementation-dependent and can be changed or removed without prior notice.</p> <p><code class="code">erts_alloc</code> is not obliged to strictly use the settings that have been passed to it (it can even ignore them).</p> </div> </div> <p>The <code><span class="code">erts_alloc_config(3)</span></code> tool can be used to aid creation of an <code class="code">erts_alloc</code> configuration that is suitable for a limited number of runtime scenarios.</p>  <h2><span onmouseover="document.getElementById('ghlink-see-also-id235655').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-see-also-id235655').style.visibility = 'hidden';" id="see-also">See Also</span></h2>  <p><code><a href="erl"><span class="code">erl(1)</span></a></code>, <code><a href="erlang"><span class="code">erlang(3)</span></a></code>, <code><span class="code">erts_alloc_config(3)</span></code>, <code><span class="code">instrument(3)</span></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
