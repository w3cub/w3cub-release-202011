
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6. Miscellaneous Mnesia Features - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content="The previous sections describe how to get started with Mnesia and how to build a Mnesia database. This section describes the more advanced features &hellip;">
  <meta name="keywords" content="miscellaneous, mnesia, features, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/mnesia-4.15.4/doc/html/mnesia_chap5.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/erlang~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>6 Miscellaneous Mnesia Features</h1> <p>The previous sections describe how to get started with <code class="code">Mnesia</code> and how to build a <code class="code">Mnesia</code> database. This section describes the more advanced features available when building a distributed, fault-tolerant <code class="code">Mnesia</code> database. The following topics are included:</p> <ul> <li>Indexing</li> <li>Distribution and fault tolerance</li> <li>Table fragmentation</li> <li>Local content tables</li> <li>Disc-less nodes</li> <li>More about schema management</li> <li> <code class="code">Mnesia</code> event handling</li> <li>Debugging <code class="code">Mnesia</code> applications</li> <li>Concurrent processes in <code class="code">Mnesia</code> </li> <li>Prototyping</li> <li>Object-based programming with <code class="code">Mnesia</code> </li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-indexing-id81402').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-indexing-id81402').style.visibility = 'hidden';" id="indexing">6.1 Indexing</span> </h2> <p>Data retrieval and matching can be performed efficiently if the key for the record is known. Conversely, if the key is unknown, all records in a table must be searched. The larger the table, the more time consuming it becomes. To remedy this problem, <code class="code">Mnesia</code> indexing capabilities are used to improve data retrieval and matching of records.</p> <p>The following two functions manipulate indexes on existing tables:</p> <ul> <li><code><a href="mnesia#add_table_index-2">mnesia:add_table_index(Tab, AttributeName) -&gt; {aborted, R} |{atomic, ok}</a></code></li> <li><code><a href="mnesia#del_table_index-2">mnesia:del_table_index(Tab, AttributeName) -&gt; {aborted, R} |{atomic, ok}</a></code></li> </ul> <p>These functions create or delete a table index on a field defined by <code class="code">AttributeName</code>. To illustrate this, add an index to the table definition <code class="code">(employee, {emp_no, name, salary, sex, phone, room_no})</code>, which is the example table from the <code class="code">Company</code> database. The function that adds an index on element <code class="code">salary</code> can be expressed as <code class="code">mnesia:add_table_index(employee, salary)</code>.</p> <p>The indexing capabilities of <code class="code">Mnesia</code> are used with the following three functions, which retrieve and match records based on index entries in the database:</p> <ul> <li> <code><a href="mnesia#index_read-3">mnesia:index_read(Tab, SecondaryKey, AttributeName) -&gt; transaction abort | RecordList</a></code> avoids an exhaustive search of the entire table, by looking up <code class="code">SecondaryKey</code> in the index to find the primary keys. </li> <li> <code><a href="mnesia#index_match_object-2">mnesia:index_match_object(Pattern, AttributeName) -&gt; transaction abort | RecordList</a></code> avoids an exhaustive search of the entire table, by looking up the secondary key in the index to find the primary keys. The secondary key is found in field <code class="code">AttributeName</code> of <code class="code">Pattern</code>. The secondary key must be bound. </li> <li> <code><a href="mnesia#match_object-1">mnesia:match_object(Pattern) -&gt; transaction abort | RecordList</a></code> uses indexes to avoid exhaustive search of the entire table. Unlike the previous functions, this function can use any index as long as the secondary key is bound.</li> </ul> <p>These functions are further described and exemplified in <code><a href="mnesia_chap4#matching">Pattern Matching</a></code>. </p> <h2><span onmouseover="document.getElementById('ghlink-distribution-and-fault-tolerance-id81549').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-distribution-and-fault-tolerance-id81549').style.visibility = 'hidden';" id="distribution-and-fault-tolerance">6.2 Distribution and Fault Tolerance</span></h2> <p><code class="code">Mnesia</code> is a distributed, fault-tolerant DBMS. Tables can be replicated on different Erlang nodes in various ways. The <code class="code">Mnesia</code> programmer does not need to state where the different tables reside, only the names of the different tables need to be specified in the program code. This is known as "location transparency" and is an important concept. In particular:</p> <ul> <li> <p>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</p> <p>Notice that the program runs slower if the data is located on a remote node.</p> </li> <li>The database can be reconfigured, and tables can be moved between nodes. These operations do not affect the user programs. </li> </ul> <p>It has previously been shown that each table has a number of system attributes, such as <code class="code">index</code> and <code class="code">type</code>.</p> <p>Table attributes are specified when the table is created. For example, the following function creates a table with two RAM replicas:</p> <pre data-language="erlang">
mnesia:create_table(foo,
                    [{ram_copies, [N1, N2]},
                     {attributes, record_info(fields, foo)}]).</pre> <p>Tables can also have the following properties, where each attribute has a list of Erlang nodes as its value:</p> <ul> <li> <p><code class="code">ram_copies</code>. The value of the node list is a list of Erlang nodes, and a RAM replica of the table resides on each node in the list.</p> <p>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</p> <ul> <li>The function <code><a href="mnesia#dump_tables-1">mnesia:dump_tables/1</a></code> can be used to dump RAM table replicas to disc. </li> <li>The table replicas can be backed up, either from RAM, or from disc if dumped there with this function. </li> </ul> </li> <li> <code class="code">disc_copies</code>. The value of the attribute is a list of Erlang nodes, and a replica of the table resides both in RAM and on disc on each node in the list. Write operations addressed to the table address both the RAM and the disc copy of the table. </li> <li> <code class="code">disc_only_copies</code>. The value of the attribute is a list of Erlang nodes, and a replica of the table resides only as a disc copy on each node in the list. The major disadvantage of this type of table replica is the access speed. The major advantage is that the table does not occupy space in memory. </li> </ul> <p>In addition, table properties can be set and changed. For details, see <code><a href="mnesia_chap3#def_schema">Define a Schema</a></code>. </p> <p>There are basically two reasons for using more than one table replica: fault tolerance and speed. Notice that table replication provides a solution to both of these system requirements.</p> <p>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</p> <p>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</p> <h2><span onmouseover="document.getElementById('ghlink-table-fragmentation-id81711').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-table-fragmentation-id81711').style.visibility = 'hidden';" id="table-fragmentation">6.3 Table Fragmentation</span></h2> <h4><span onmouseover="document.getElementById('ghlink-concept-id81720').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-concept-id81720').style.visibility = 'hidden';" id="concept">Concept</span></h4> <p>A concept of table fragmentation has been introduced to cope with large tables. The idea is to split a table into several manageable fragments. Each fragment is implemented as a first class <code class="code">Mnesia</code> table and can be replicated, have indexes, and so on, as any other table. But the tables cannot have <code class="code">local_content</code> or have the <code class="code">snmp</code> connection activated.</p> <p>To be able to access a record in a fragmented table, <code class="code">Mnesia</code> must determine to which fragment the actual record belongs. This is done by module <code class="code">mnesia_frag</code>, which implements the <code class="code">mnesia_access</code> callback behavior. It is recommended to read the documentation about the function <code><a href="mnesia#activity-4">mnesia:activity/4</a></code> to see how <code class="code">mnesia_frag</code> can be used as a <code class="code">mnesia_access</code> callback module.</p> <p>At each record access, <code class="code">mnesia_frag</code> first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</p> <p>Notice that in <code class="code">ordered_set</code> tables, the records are ordered per fragment, and the order is undefined in results returned by <code class="code">select</code> and <code class="code">match_object</code>, as well as <code class="code">first</code>, <code class="code">next</code>, <code class="code">prev</code> and <code class="code">last</code>.</p> <p>The following code illustrates how a <code class="code">Mnesia</code> table is converted to be a fragmented table and how more fragments are added later:</p> <pre data-language="erlang">Eshell V4.7.3.3  (abort with ^G)
(a@sam)1&gt; mnesia:start().
ok
(a@sam)2&gt; mnesia:system_info(running_db_nodes).
[b@sam,c@sam,a@sam]
(a@sam)3&gt; Tab = dictionary.
dictionary
(a@sam)4&gt; mnesia:create_table(Tab, [{ram_copies, [a@sam, b@sam]}]).
{atomic,ok}
(a@sam)5&gt; Write = fun(Keys) -&gt; [mnesia:write({Tab,K,-K}) || K &lt;- Keys], ok end.
#Fun&lt;erl_eval&gt;
(a@sam)6&gt; mnesia:activity(sync_dirty, Write, [lists:seq(1, 256)], mnesia_frag).
ok
(a@sam)7&gt; mnesia:change_table_frag(Tab, {activate, []}).
{atomic,ok}
(a@sam)8&gt; mnesia:table_info(Tab, frag_properties).
[{base_table,dictionary},
 {foreign_key,undefined},
 {n_doubles,0},
 {n_fragments,1},
 {next_n_to_split,1},
 {node_pool,[a@sam,b@sam,c@sam]}]
(a@sam)9&gt; Info = fun(Item) -&gt; mnesia:table_info(Tab, Item) end.
#Fun&lt;erl_eval&gt;
(a@sam)10&gt; Dist = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{c@sam,0},{a@sam,1},{b@sam,1}]
(a@sam)11&gt; mnesia:change_table_frag(Tab, {add_frag, Dist}).
{atomic,ok}
(a@sam)12&gt; Dist2 = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{b@sam,1},{c@sam,1},{a@sam,2}]
(a@sam)13&gt; mnesia:change_table_frag(Tab, {add_frag, Dist2}).
{atomic,ok}
(a@sam)14&gt; Dist3 = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{a@sam,2},{b@sam,2},{c@sam,2}]
(a@sam)15&gt; mnesia:change_table_frag(Tab, {add_frag, Dist3}).
{atomic,ok}
(a@sam)16&gt; Read = fun(Key) -&gt; mnesia:read({Tab, Key}) end.
#Fun&lt;erl_eval&gt;
(a@sam)17&gt; mnesia:activity(transaction, Read, [12], mnesia_frag).
[{dictionary,12,-12}]
(a@sam)18&gt; mnesia:activity(sync_dirty, Info, [frag_size], mnesia_frag).
[{dictionary,64},
 {dictionary_frag2,64},
 {dictionary_frag3,64},
 {dictionary_frag4,64}]
(a@sam)19&gt; </pre> <h4><span onmouseover="document.getElementById('ghlink-fragmentation-properties-id81846').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-fragmentation-properties-id81846').style.visibility = 'hidden';" id="fragmentation-properties">Fragmentation Properties</span></h4> <p>The table property <code class="code">frag_properties</code> can be read with the function <code><a href="mnesia#table_info-2">mnesia:table_info(Tab, frag_properties)</a></code>. The fragmentation properties are a list of tagged tuples with arity 2. By default the list is empty, but when it is non-empty it triggers <code class="code">Mnesia</code> to regard the table as fragmented. The fragmentation properties are as follows:</p> <dl> <dt><strong><code class="code">{n_fragments, Int}</code></strong></dt> <dd> <p><code class="code">n_fragments</code> regulates how many fragments that the table currently has. This property can explicitly be set at table creation and later be changed with <code class="code">{add_frag, NodesOrDist}</code> or <code class="code">del_frag</code>. <code class="code">n_fragments</code> defaults to <code class="code">1</code>.</p> </dd> <dt><strong><code class="code">{node_pool, List}</code></strong></dt> <dd> <p>The node pool contains a list of nodes and can explicitly be set at table creation and later be changed with <code class="code">{add_node, Node}</code> or <code class="code">{del_node, Node}</code>. At table creation <code class="code">Mnesia</code> tries to distribute the replicas of each fragment evenly over all the nodes in the node pool. Hopefully all nodes end up with the same number of replicas. <code class="code">node_pool</code> defaults to the return value from the function <code><a href="mnesia#system_info-1">mnesia:system_info(db_nodes)</a></code>.</p> </dd> <dt><strong><code class="code">{n_ram_copies, Int}</code></strong></dt> <dd> <p>Regulates how many <code class="code">ram_copies</code> replicas that each fragment is to have. This property can explicitly be set at table creation. Defaults is <code class="code">0</code>, but if <code class="code">n_disc_copies</code> and <code class="code">n_disc_only_copies</code> also are <code class="code">0</code>, <code class="code">n_ram_copies</code> defaults to <code class="code">1</code>.</p> </dd> <dt><strong><code class="code">{n_disc_copies, Int}</code></strong></dt> <dd> <p>Regulates how many <code class="code">disc_copies</code> replicas that each fragment is to have. This property can explicitly be set at table creation. Default is <code class="code">0</code>.</p> </dd> <dt><strong><code class="code">{n_disc_only_copies, Int}</code></strong></dt> <dd> <p>Regulates how many <code class="code">disc_only_copies</code> replicas that each fragment is to have. This property can explicitly be set at table creation. Defaults is <code class="code">0</code>.</p> </dd> <dt><strong><code class="code">{foreign_key, ForeignKey}</code></strong></dt> <dd> <p><code class="code">ForeignKey</code> can either be the atom <code class="code">undefined</code> or the tuple <code class="code">{ForeignTab, Attr}</code>, where <code class="code">Attr</code> denotes an attribute that is to be interpreted as a key in another fragmented table named <code class="code">ForeignTab</code>. <code class="code">Mnesia</code> ensures that the number of fragments in this table and in the foreign table are always the same.</p> <p>When fragments are added or deleted, <code class="code">Mnesia</code> automatically propagates the operation to all fragmented tables that have a foreign key referring to this table. Instead of using the record key to determine which fragment to access, the value of field <code class="code">Attr</code> is used. This feature makes it possible to colocate records automatically in different tables to the same node. <code class="code">foreign_key</code> defaults to <code class="code">undefined</code>. However, if the foreign key is set to something else, it causes the default values of the other fragmentation properties to be the same values as the actual fragmentation properties of the foreign table.</p> </dd> <dt><strong><code class="code">{hash_module, Atom}</code></strong></dt> <dd> <p>Enables definition of an alternative hashing scheme. The module must implement the <code><a href="mnesia_frag_hash">mnesia_frag_hash</a></code> callback behavior. This property can explicitly be set at table creation. Default is <code class="code">mnesia_frag_hash</code>.</p> </dd> <dt><strong><code class="code">{hash_state, Term}</code></strong></dt> <dd> <p>Enables a table-specific parameterization of a generic hash module. This property can explicitly be set at table creation. Default is <code class="code">undefined</code>.</p> <pre data-language="erlang">Eshell V4.7.3.3  (abort with ^G)
(a@sam)1&gt; mnesia:start().
ok
(a@sam)2&gt; PrimProps = [{n_fragments, 7}, {node_pool, [node()]}].
[{n_fragments,7},{node_pool,[a@sam]}]
(a@sam)3&gt; mnesia:create_table(prim_dict, 
                              [{frag_properties, PrimProps},
                               {attributes,[prim_key,prim_val]}]).
{atomic,ok}
(a@sam)4&gt; SecProps = [{foreign_key, {prim_dict, sec_val}}].
[{foreign_key,{prim_dict,sec_val}}]
(a@sam)5&gt; mnesia:create_table(sec_dict, 
                              [{frag_properties, SecProps},
(a@sam)5&gt;                      {attributes, [sec_key, sec_val]}]).
{atomic,ok}
(a@sam)6&gt; Write = fun(Rec) -&gt; mnesia:write(Rec) end.
#Fun&lt;erl_eval&gt;
(a@sam)7&gt; PrimKey = 11.
11
(a@sam)8&gt; SecKey = 42.
42
(a@sam)9&gt; mnesia:activity(sync_dirty, Write,
                          [{prim_dict, PrimKey, -11}], mnesia_frag).
ok
(a@sam)10&gt; mnesia:activity(sync_dirty, Write,
                           [{sec_dict, SecKey, PrimKey}], mnesia_frag).
ok
(a@sam)11&gt; mnesia:change_table_frag(prim_dict, {add_frag, [node()]}).
{atomic,ok}
(a@sam)12&gt; SecRead = fun(PrimKey, SecKey) -&gt;
               mnesia:read({sec_dict, PrimKey}, SecKey, read) end.
#Fun&lt;erl_eval&gt;
(a@sam)13&gt; mnesia:activity(transaction, SecRead,
                           [PrimKey, SecKey], mnesia_frag).
[{sec_dict,42,11}]
(a@sam)14&gt; Info = fun(Tab, Item) -&gt; mnesia:table_info(Tab, Item) end.
#Fun&lt;erl_eval&gt;
(a@sam)15&gt; mnesia:activity(sync_dirty, Info,
                           [prim_dict, frag_size], mnesia_frag).
[{prim_dict,0},
 {prim_dict_frag2,0},
 {prim_dict_frag3,0},
 {prim_dict_frag4,1},
 {prim_dict_frag5,0},
 {prim_dict_frag6,0},
 {prim_dict_frag7,0},
 {prim_dict_frag8,0}]
(a@sam)16&gt; mnesia:activity(sync_dirty, Info,
                           [sec_dict, frag_size], mnesia_frag).
[{sec_dict,0},
 {sec_dict_frag2,0},
 {sec_dict_frag3,0},
 {sec_dict_frag4,1},
 {sec_dict_frag5,0},
 {sec_dict_frag6,0},
 {sec_dict_frag7,0},
 {sec_dict_frag8,0}]
(a@sam)17&gt;</pre> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-management-of-fragmented-tables-id82151').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-management-of-fragmented-tables-id82151').style.visibility = 'hidden';" id="management-of-fragmented-tables">Management of Fragmented Tables</span></h4> <p>The function <code class="code">mnesia:change_table_frag(Tab, Change)</code> is intended to be used for reconfiguration of fragmented tables. Argument <code class="code">Change</code> is to have one of the following values:</p> <dl> <dt><strong><code class="code">{activate, FragProps}</code></strong></dt> <dd> <p>Activates the fragmentation properties of an existing table. <code class="code">FragProps</code> is either to contain <code class="code">{node_pool, Nodes}</code> or be empty.</p> </dd> <dt><strong><code class="code">deactivate</code></strong></dt> <dd> <p>Deactivates the fragmentation properties of a table. The number of fragments must be <code class="code">1</code>. No other table can refer to this table in its foreign key.</p> </dd> <dt><strong><code class="code">{add_frag, NodesOrDist}</code></strong></dt> <dd> <p>Adds a fragment to a fragmented table. All records in one of the old fragments are rehashed and about half of them are moved to the new (last) fragment. All other fragmented tables, which refer to this table in their foreign key, automatically get a new fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</p> <p>Argument <code class="code">NodesOrDist</code> can either be a list of nodes or the result from the function <code><a href="mnesia#table_info-2">mnesia:table_info(Tab, frag_dist)</a></code>. Argument <code class="code">NodesOrDist</code> is assumed to be a sorted list with the best nodes to host new replicas first in the list. The new fragment gets the same number of replicas as the first fragment (see <code class="code">n_ram_copies</code>, <code class="code">n_disc_copies</code>, and <code class="code">n_disc_only_copies</code>). The <code class="code">NodesOrDist</code> list must at least contain one element for each replica that needs to be allocated.</p> </dd> <dt><strong><code class="code">del_frag</code></strong></dt> <dd> <p>Deletes a fragment from a fragmented table. All records in the last fragment are moved to one of the other fragments. All other fragmented tables, which refer to this table in their foreign key, automatically lose their last fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</p> </dd> <dt><strong><code class="code">{add_node, Node}</code></strong></dt> <dd> <p>Adds a node to <code class="code">node_pool</code>. The new node pool affects the list returned from the function <code><a href="mnesia#table_info-2">mnesia:table_info(Tab, frag_dist)</a></code>. </p> </dd> <dt><strong><code class="code">{del_node, Node}</code></strong></dt> <dd> <p>Deletes a node from <code class="code">node_pool</code>. The new node pool affects the list returned from the function <code><a href="mnesia#table_info-2">mnesia:table_info(Tab, frag_dist)</a></code>. </p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-extensions-of-existing-functions-id82326').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-extensions-of-existing-functions-id82326').style.visibility = 'hidden';" id="extensions-of-existing-functions">Extensions of Existing Functions</span></h4> <p>The function <code><a href="mnesia#create_table-2">mnesia:create_table/2</a></code> creates a brand new fragmented table, by setting table property <code class="code">frag_properties</code> to some proper values.</p> <p>The function <code><a href="mnesia#delete_table-1">mnesia:delete_table/1</a></code> deletes a fragmented table including all its fragments. There must however not exist any other fragmented tables that refer to this table in their foreign key.</p> <p>The function <code><a href="mnesia#table_info-2">mnesia:table_info/2</a></code> now understands item <code class="code">frag_properties</code>.</p> <p>If the function <code class="code">mnesia:table_info/2</code> is started in the activity context of module <code class="code">mnesia_frag</code>, information of several new items can be obtained:</p> <dl> <dt><strong><code class="code">base_table</code></strong></dt> <dd>The name of the fragmented table</dd> <dt><strong><code class="code">n_fragments</code></strong></dt> <dd>The actual number of fragments</dd> <dt><strong><code class="code">node_pool</code></strong></dt> <dd>The pool of nodes</dd> <dt><strong><code class="code">n_ram_copies</code></strong></dt>  <dt><strong><code class="code">n_disc_copies</code></strong></dt>  <dt><strong><code class="code">n_disc_only_copies</code></strong></dt> <dd> <p>The number of replicas with storage type <code class="code">ram_copies</code>, <code class="code">disc_copies</code>, and <code class="code">disc_only_copies</code>, respectively. The actual values are dynamically derived from the first fragment. The first fragment serves as a protype. When the actual values need to be computed (for example, when adding new fragments) they are determined by counting the number of each replica for each storage type. This means that when the functions <code><a href="mnesia#add_table_copy-3">mnesia:add_table_copy/3</a></code>, <code><a href="mnesia#del_table_copy-2">mnesia:del_table_copy/2</a></code>, and <code><a href="mnesia#change_table_copy_type-3">mnesia:change_table_copy_type/2</a></code> are applied on the first fragment, it affects the settings on <code class="code">n_ram_copies</code>, <code class="code">n_disc_copies</code>, and <code class="code">n_disc_only_copies</code>.</p> </dd> <dt><strong><code class="code">foreign_key</code></strong></dt> <dd> <p>The foreign key</p> </dd> <dt><strong><code class="code">foreigners</code></strong></dt> <dd> <p>All other tables that refer to this table in their foreign key</p> </dd> <dt><strong><code class="code">frag_names</code></strong></dt> <dd> <p>The names of all fragments</p> </dd> <dt><strong><code class="code">frag_dist</code></strong></dt> <dd> <p>A sorted list of <code class="code">{Node, Count}</code> tuples that are sorted in increasing <code class="code">Count</code> order. <code class="code">Count</code> is the total number of replicas that this fragmented table hosts on each <code class="code">Node</code>. The list always contains at least all nodes in <code class="code">node_pool</code>. Nodes that do not belong to <code class="code">node_pool</code> are put last in the list even if their <code class="code">Count</code> is lower.</p> </dd> <dt><strong><code class="code">frag_size</code></strong></dt> <dd> <p>A list of <code class="code">{Name, Size}</code> tuples, where <code class="code">Name</code> is a fragment <code class="code">Name</code>, and <code class="code">Size</code> is how many records it contains</p> </dd> <dt><strong><code class="code">frag_memory</code></strong></dt> <dd> <p>A list of <code class="code">{Name, Memory}</code> tuples, where <code class="code">Name</code> is a fragment <code class="code">Name</code>, and <code class="code">Memory</code> is how much memory it occupies</p> </dd> <dt><strong><code class="code">size</code></strong></dt> <dd> <p>Total size of all fragments</p> </dd> <dt><strong><code class="code">memory</code></strong></dt> <dd> <p>Total memory of all fragments</p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-load-balancing-id82646').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-load-balancing-id82646').style.visibility = 'hidden';" id="load-balancing">Load Balancing</span></h4> <p>There are several algorithms for distributing records in a fragmented table evenly over a pool of nodes. No one is best, it depends on the application needs. The following examples of situations need some attention:</p> <ul> <li> <code class="code">permanent change of nodes</code>. When a new permanent <code class="code">db_node</code> is introduced or dropped, it can be time to change the pool of nodes and redistribute the replicas evenly over the new pool of nodes. It can also be time to add or delete a fragment before the replicas are redistributed. </li> <li> <code class="code">size/memory threshold</code>. When the total size or total memory of a fragmented table (or a single fragment) exceeds some application-specific threshold, it can be time to add a new fragment dynamically to obtain a better distribution of records. </li> <li> <code class="code">temporary node down</code>. When a node temporarily goes down, it can be time to compensate some fragments with new replicas to keep the desired level of redundancy. When the node comes up again, it can be time to remove the superfluous replica. </li> <li> <code class="code">overload threshold</code>. When the load on some node exceeds some application-specific threshold, it can be time to either add or move some fragment replicas to nodes with lower load. Take extra care if the table has a foreign key relation to some other table. To avoid severe performance penalties, the same redistribution must be performed for all the related tables. </li> </ul> <p>Use the function <code class="code">mnesia:change_table_frag/2</code> to add new fragments and apply the usual schema manipulation functions (such as <code><a href="mnesia#add_table_copy-3">mnesia:add_table_copy/3</a></code>, <code><a href="mnesia#del_table_copy-2">mnesia:del_table_copy/2</a></code>, and <code><a href="mnesia#change_table_copy_type-3">mnesia:change_table_copy_type/2</a></code>) on each fragment to perform the actual redistribution.</p> <h2><span onmouseover="document.getElementById('ghlink-local-content-tables-id82734').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-local-content-tables-id82734').style.visibility = 'hidden';" id="local-content-tables">6.4 Local Content Tables</span></h2> <p>Replicated tables have the same content on all nodes where they are replicated. However, it is sometimes advantageous to have tables, but different content on different nodes.</p> <p>If attribute <code class="code">{local_content, true}</code> is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</p> <p>Furthermore, when the table is initialized at startup, the table is only initialized locally, and the table content is not copied from another node.</p> <h2><span onmouseover="document.getElementById('ghlink-disc-less-nodes-id82763').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-disc-less-nodes-id82763').style.visibility = 'hidden';" id="disc-less-nodes">6.5 Disc-Less Nodes</span></h2> <p><code class="code">Mnesia</code> can be run on nodes that do not have a disc. Replicas of <code class="code">disc_copies</code> or <code class="code">disc_only_copies</code> are not possible on such nodes. This is especially troublesome for the <code class="code">schema</code> table, as <code class="code">Mnesia</code> needs the schema to initialize itself.</p> <p>The schema table can, as other tables, reside on one or more nodes. The storage type of the schema table can either be <code class="code">disc_copies</code> or <code class="code">ram_copies</code> (but not <code class="code">disc_only_copies</code>). At startup, <code class="code">Mnesia</code> uses its schema to determine with which nodes it is to try to establish contact. If any other node is started already, the starting node merges its table definitions with the table definitions brought from the other nodes. This also applies to the definition of the schema table itself. Application parameter <code class="code">extra_db_nodes</code> contains a list of nodes that <code class="code">Mnesia</code> also is to establish contact with besides those found in the schema. Default is <code class="code">[]</code> (empty list).</p> <p>Hence, when a disc-less node needs to find the schema definitions from a remote node on the network, this information must be supplied through application parameter <code class="code">-mnesia extra_db_nodes NodeList</code>. Without this configuration parameter set, <code class="code">Mnesia</code> starts as a single node system. Also, the function <code><a href="mnesia#change_config-2">mnesia:change_config/2</a></code> can be used to assign a value to <code class="code">extra_db_nodes</code> and force a connection after <code class="code">Mnesia</code> has been started, that is, <code class="code">mnesia:change_config(extra_db_nodes, NodeList)</code>.</p> <p>Application parameter <code class="code">schema_location</code> controls where <code class="code">Mnesia</code> searches for its schema. The parameter can be one of the following atoms:</p> <dl> <dt><strong><code class="code">disc</code></strong></dt> <dd> <p>Mandatory disc. The schema is assumed to be located in the <code class="code">Mnesia</code> directory. If the schema cannot be found, <code class="code">Mnesia</code> refuses to start.</p> </dd> <dt><strong><code class="code">ram</code></strong></dt> <dd> <p>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema contains only the definition of the schema table and resides on the local node only. Since no other nodes are found in the default schema, configuration parameter <code class="code">extra_db_nodes</code> must be used to let the node share its table definitions with other nodes. (Parameter <code class="code">extra_db_nodes</code> can also be used on disc-full nodes.)</p> </dd> <dt><strong><code class="code">opt_disc</code></strong></dt> <dd> <p>Optional disc. The schema can reside on either disc or RAM. If the schema is found on disc, <code class="code">Mnesia</code> starts as a disc-full node (the storage type of the schema table is disc_copies). If no schema is found on disc, <code class="code">Mnesia</code> starts as a disc-less node (the storage type of the schema table is <code class="code">ram_copies</code>). The default for the application parameter is <code class="code">opt_disc</code>.</p> </dd> </dl> <p>When <code class="code">schema_location</code> is set to <code class="code">opt_disc</code>, the function <code><a href="mnesia#change_table_copy_type-3">mnesia:change_table_copy_type/3</a></code> can be used to change the storage type of the schema. This is illustrated as follows:</p> <pre data-language="erlang">
1&gt; mnesia:start().
ok
2&gt; mnesia:change_table_copy_type(schema, node(), disc_copies).
{atomic, ok}</pre> <p>Assuming that the call to <code><a href="mnesia#start-0">mnesia:start/0</a></code> does not find any schema to read on the disc, <code class="code">Mnesia</code> starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</p> <h2><span onmouseover="document.getElementById('ghlink-more-about-schema-management-id82987').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-more-about-schema-management-id82987').style.visibility = 'hidden';" id="more-about-schema-management">6.6 More about Schema Management</span></h2> <p>Nodes can be added to and removed from a <code class="code">Mnesia</code> system. This can be done by adding a copy of the schema to those nodes.</p> <p>The functions <code><a href="mnesia#add_table_copy-3">mnesia:add_table_copy/3</a></code> and <code><a href="mnesia#del_table_copy-2">mnesia:del_table_copy/2</a></code> can be used to add and delete replicas of the schema table. Adding a node to the list of nodes where the schema is replicated affects the following:</p> <ul> <li>It allows other tables to be replicated to this node. </li> <li>It causes <code class="code">Mnesia</code> to try to contact the node at startup of disc-full nodes. </li> </ul> <p>The function call <code class="code">mnesia:del_table_copy(schema, mynode@host)</code> deletes node <code class="code">mynode@host</code> from the <code class="code">Mnesia</code> system. The call fails if <code class="code">Mnesia</code> is running on <code class="code">mynode@host</code>. The other <code class="code">Mnesia</code> nodes never try to connect to that node again. Notice that if there is a disc resident schema on node <code class="code">mynode@host</code>, the entire <code class="code">Mnesia</code> directory is to be deleted. This is done with the function <code><a href="mnesia#delete_schema-1">mnesia:delete_schema/1</a></code>. If <code class="code">Mnesia</code> is started again on node <code class="code">mynode@host</code> and the directory has not been cleared, the behavior of <code class="code">Mnesia</code> is undefined.</p> <p>If the storage type of the schema is <code class="code">ram_copies</code>, that is, a disc-less node, <code class="code">Mnesia</code> does not use the disc on that particular node. The disc use is enabled by changing the storage type of table <code class="code">schema</code> to <code class="code">disc_copies</code>.</p> <p>New schemas are created explicitly with the function <code><a href="mnesia#create_schema-1">mnesia:create_schema/1</a></code> or implicitly by starting <code class="code">Mnesia</code> without a disc resident schema. Whenever a table (including the schema table) is created, it is assigned its own unique cookie. The schema table is not created with the function <code><a href="mnesia#create_table-2">mnesia:create_table/2</a></code> as normal tables.</p> <p>At startup, <code class="code">Mnesia</code> connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, <code class="code">Mnesia</code> performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise <code class="code">Mnesia</code> shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</p> <p>Merging different versions of the schema table does not always require the cookies to be the same. If the storage type of the schema table is <code class="code">disc_copies</code>, the cookie is immutable, and all other <code class="code">db_nodes</code> must have the same cookie. When the schema is stored as type <code class="code">ram_copies</code>, its cookie can be replaced with a cookie from another node (<code class="code">ram_copies</code> or <code class="code">disc_copies</code>). The cookie replacement (during merge of the schema table definition) is performed each time a RAM node connects to another node.</p> <p>Further, the following applies:</p> <ul> <li> <code><a href="mnesia#system_info-1">mnesia:system_info(schema_location)</a></code> and <code><a href="mnesia#system_info-1">mnesia:system_info(extra_db_nodes)</a></code> can be used to determine the actual values of <code class="code">schema_location</code> and <code class="code">extra_db_nodes</code>, respectively. </li> <li> <code><a href="mnesia#system_info-1">mnesia:system_info(use_dir)</a></code> can be used to determine whether <code class="code">Mnesia</code> is actually using the <code class="code">Mnesia</code> directory. </li> <li> <code class="code">use_dir</code> can be determined even before <code class="code">Mnesia</code> is started. </li> </ul> <p>The function <code><a href="mnesia#info-0">mnesia:info/0</a></code> can now be used to print some system information even before <code class="code">Mnesia</code> is started. When <code class="code">Mnesia</code> is started, the function prints more information.</p> <p>Transactions that update the definition of a table requires that <code class="code">Mnesia</code> is started on all nodes where the storage type of the schema is <code class="code">disc_copies</code>. All replicas of the table on these nodes must also be loaded. There are a few exceptions to these availability rules:</p> <ul> <li>Tables can be created and new replicas can be added without starting all the disc-full nodes. </li> <li>New replicas can be added before all other replicas of the table have been loaded, provided that at least one other replica is active. </li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-mnesia-event-handling-id83287').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-mnesia-event-handling-id83287').style.visibility = 'hidden';" id="event_handling">6.7 Mnesia Event Handling</span> </h2> <p>System events and table events are the two event categories that <code class="code">Mnesia</code> generates in various situations.</p> <p>A user process can subscribe on the events generated by <code class="code">Mnesia</code>. The following two functions are provided:</p> <dl> <dt><strong><code><a href="mnesia#subscribe-1">mnesia:subscribe(Event-Category)</a></code> </strong></dt> <dd>Ensures that a copy of all events of type <code class="code">Event-Category</code> are sent to the calling process</dd> <dt><strong><code><a href="mnesia#unsubscribe-1">mnesia:unsubscribe(Event-Category)</a></code> </strong></dt> <dd>Removes the subscription on events of type <code class="code">Event-Category</code> </dd> </dl> <p><code class="code">Event-Category</code> can be either of the following:</p> <ul> <li>The atom <code class="code">system</code> </li> <li>The atom <code class="code">activity</code> </li> <li>The tuple <code class="code">{table, Tab, simple}</code> </li> <li>The tuple <code class="code">{table, Tab, detailed}</code> </li> </ul> <p>The old event category <code class="code">{table, Tab}</code> is the same event category as <code class="code">{table, Tab, simple}</code>.</p> <p>The subscribe functions activate a subscription of events. The events are delivered as messages to the process evaluating the function <code><a href="mnesia#subscribe-1">mnesia:subscribe/1</a></code> The syntax is as follows:</p> <ul> <li> <code class="code">{mnesia_system_event, Event}</code> for system events </li> <li> <code class="code">{mnesia_activity_event, Event}</code> for activity events </li> <li> <code class="code">{mnesia_table_event, Event}</code> for table events </li> </ul> <p>The event types are described in the next sections.</p> <p>All system events are subscribed by the <code class="code">Mnesia</code> <code class="code">gen_event</code> handler. The default <code class="code">gen_event</code> handler is <code class="code">mnesia_event</code>, but it can be changed by using application parameter <code class="code">event_module</code>. The value of this parameter must be the name of a module implementing a complete handler, as specified by the <code>gen_event</code> module in <code class="code">STDLIB</code>.</p> <p><code><a href="mnesia#system_info-1">mnesia:system_info(subscribers)</a></code> and <code><a href="mnesia#table_info-2">mnesia:table_info(Tab, subscribers)</a></code> can be used to determine which processes are subscribed to various events.</p> <h4><span onmouseover="document.getElementById('ghlink-system-events-id83496').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-system-events-id83496').style.visibility = 'hidden';" id="system-events">System Events</span></h4> <p>The system events are as follows:</p> <dl> <dt><strong><code class="code">{mnesia_up, Node}</code></strong></dt> <dd>Mnesia is started on a node. <code class="code">Node</code> is the node name. By default this event is ignored. </dd> <dt><strong><code class="code">{mnesia_down, Node}</code></strong></dt> <dd>Mnesia is stopped on a node. <code class="code">Node</code> is the node name. By default this event is ignored. </dd> <dt><strong><code class="code">{mnesia_checkpoint_activated, Checkpoint}</code></strong></dt> <dd>A checkpoint with the name <code class="code">Checkpoint</code> is activated and the current node is involved in the checkpoint. Checkpoints can be activated explicitly with the function <code><a href="mnesia#activate_checkpoint-1">mnesia:activate_checkpoint/1</a></code> or implicitly at backup, when adding table replicas, at internal transfer of data between nodes, and so on. By default this event is ignored. </dd> <dt><strong><code class="code">{mnesia_checkpoint_deactivated, Checkpoint}</code></strong></dt> <dd>A checkpoint with the name <code class="code">Checkpoint</code> is deactivated and the current node is involved in the checkpoint. Checkpoints can be deactivated explicitly with the function <code><a href="mnesia#deactivate_checkpoint-1">mnesia:deactivate/1</a></code> or implicitly when the last replica of a table (involved in the checkpoint) becomes unavailable, for example, at node-down. By default this event is ignored. </dd> <dt><strong><code class="code">{mnesia_overload, Details}</code></strong></dt> <dd> <p><code class="code">Mnesia</code> on the current node is overloaded and the subscriber is to take action.</p> <p>A typical overload situation occurs when the applications perform more updates on disc resident tables than <code class="code">Mnesia</code> can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</p> <p>Each update is appended to the transaction log and occasionally (depending on how it is configured) dumped to the tables files. The table file storage is more compact than the transaction log storage, especially if the same record is updated repeatedly. If the thresholds for dumping the transaction log are reached before the previous dump is finished, an overload event is triggered.</p> <p>Another typical overload situation is when the transaction manager cannot commit transactions at the same pace as the applications perform updates of disc resident tables. When this occurs, the message queue of the transaction manager continues to grow until the memory is exhausted or the load decreases.</p> <p>The same problem can occur for dirty updates. The overload is detected locally on the current node, but its cause can be on another node. Application processes can cause high load if any table resides on another node (replicated or not). By default this event is reported to <code class="code">error_logger.</code></p> </dd> <dt><strong><code class="code">{inconsistent_database, Context, Node}</code></strong></dt> <dd> <code class="code">Mnesia</code> regards the database as potential inconsistent and gives its applications a chance to recover from the inconsistency. For example, by installing a consistent backup as fallback and then restart the system. An alternative is to pick a <code class="code">MasterNode</code> from <code><a href="mnesia#system_info-1">mnesia:system_info(db_nodes)</a></code> and invoke <code><a href="mnesia#set_master_nodes-1">mnesia:set_master_node([MasterNode])</a></code>. By default an error is reported to <code class="code">error_logger</code>. </dd> <dt><strong><code class="code">{mnesia_fatal, Format, Args, BinaryCore}</code></strong></dt> <dd> <p><code class="code">Mnesia</code> detected a fatal error and terminates soon. The fault reason is explained in <code class="code">Format</code> and <code class="code">Args</code>, which can be given as input to <code class="code">io:format/2</code> or sent to <code class="code">error_logger</code>. By default it is sent to <code class="code">error_logger</code>.</p> <p><code class="code">BinaryCore</code> is a binary containing a summary of the <code class="code">Mnesia</code> internal state at the time when the fatal error was detected. By default the binary is written to a unique filename on the current directory. On RAM nodes, the core is ignored.</p> </dd> <dt><strong><code class="code">{mnesia_info, Format, Args}</code></strong></dt> <dd> <code class="code">Mnesia</code> detected something that can be of interest when debugging the system. This is explained in <code class="code">Format</code> and <code class="code">Args</code>, which can appear as input to <code class="code">io:format/2</code> or sent to <code class="code">error_logger</code>. By default this event is printed with <code class="code">io:format/2</code>. </dd> <dt><strong><code class="code">{mnesia_error, Format, Args}</code></strong></dt> <dd> <code class="code">Mnesia</code> has detected an error. The fault reason is explained in <code class="code">Format</code> and <code class="code">Args</code>, which can be given as input to <code class="code">io:format/2</code> or sent to <code class="code">error_logger</code>. By default this event is reported to <code class="code">error_logger</code>. </dd> <dt><strong><code class="code">{mnesia_user, Event}</code></strong></dt> <dd>An application started the function <code><a href="mnesia#report_event-1">mnesia:report_event(Event)</a></code>. <code class="code">Event</code> can be any Erlang data structure. When tracing a system of <code class="code">Mnesia</code> applications, it is useful to be able to interleave own events of <code class="code">Mnesia</code> with application-related events that give information about the application context. Whenever the application starts with a new and demanding <code class="code">Mnesia</code> activity, or enters a new and interesting phase in its execution, it can be a good idea to use <code class="code">mnesia:report_event/1</code>. </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-activity-events-id83808').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-activity-events-id83808').style.visibility = 'hidden';" id="activity-events">Activity Events</span></h4> <p>Currently, there is only one type of activity event:</p> <dl> <dt><strong><code class="code">{complete, ActivityID}</code></strong></dt> <dd> <p>This event occurs when a transaction that caused a modification to the database is completed. It is useful for determining when a set of table events (see the next section), caused by a given activity, have been sent. Once this event is received, it is guaranteed that no further table events with the same <code class="code">ActivityID</code> will be received. Notice that this event can still be received even if no table events with a corresponding <code class="code">ActivityID</code> were received, depending on the tables to which the receiving process is subscribed.</p> <p>Dirty operations always contain only one update and thus no activity event is sent.</p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-table-events-id83854').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-table-events-id83854').style.visibility = 'hidden';" id="table-events">Table Events</span></h4> <p>Table events are events related to table updates. There are two types of table events, simple and detailed.</p> <p>The <strong>simple table events</strong> are tuples like <code class="code">{Oper, Record, ActivityId}</code>, where:</p> <ul> <li> <code class="code">Oper</code> is the operation performed. </li> <li> <code class="code">Record</code> is the record involved in the operation. </li> <li> <code class="code">ActivityId</code> is the identity of the transaction performing the operation. </li> </ul> <p>Notice that the record name is the table name even when <code class="code">record_name</code> has another setting.</p> <p>The table-related events that can occur are as follows:</p> <dl> <dt><strong><code class="code">{write, NewRecord, ActivityId}</code></strong></dt> <dd>A new record has been written. <code class="code">NewRecord</code> contains the new record value. </dd> <dt><strong><code class="code">{delete_object, OldRecord, ActivityId}</code></strong></dt> <dd>A record has possibly been deleted with <code><a href="mnesia#delete_object-1">mnesia:delete_object/1</a></code>. <code class="code">OldRecord</code> contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type <code class="code">bag</code>. </dd> <dt><strong><code class="code">{delete, {Tab, Key}, ActivityId}</code></strong></dt> <dd>One or more records have possibly been deleted. All records with the key <code class="code">Key</code> in the table <code class="code">Tab</code> have been deleted. </dd> </dl> <p>The <strong>detailed table events</strong> are tuples like <code class="code">{Oper, Table, Data, [OldRecs], ActivityId}</code>, where:</p> <ul> <li> <code class="code">Oper</code> is the operation performed. </li> <li> <code class="code">Table</code> is the table involved in the operation. </li> <li> <code class="code">Data</code> is the record/OID written/deleted. </li> <li> <code class="code">OldRecs</code> is the contents before the operation. </li> <li> <code class="code">ActivityId</code> is the identity of the transaction performing the operation. </li> </ul> <p>The table-related events that can occur are as follows:</p> <dl> <dt><strong><code class="code">{write, Table, NewRecord, [OldRecords], ActivityId}</code></strong></dt> <dd>A new record has been written. <code class="code">NewRecord</code> contains the new record value and <code class="code">OldRecords</code> contains the records before the operation is performed. Notice that the new content depends on the table type. </dd> <dt><strong><code class="code">{delete, Table, What, [OldRecords], ActivityId}</code></strong></dt> <dd>Records have possibly been deleted. <code class="code">What</code> is either <code class="code">{Table, Key}</code> or a record <code class="code">{RecordName, Key, ...}</code> that was deleted. Notice that the new content depends on the table type. </dd> </dl> <h2><span onmouseover="document.getElementById('ghlink-debugging-mnesia-applications-id84072').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-debugging-mnesia-applications-id84072').style.visibility = 'hidden';" id="debugging-mnesia-applications">6.8 Debugging Mnesia Applications</span></h2> <p>Debugging a <code class="code">Mnesia</code> application can be difficult for various reasons, primarily related to difficulties in understanding how the transaction and table load mechanisms work. Another source of confusion can be the semantics of nested transactions.</p> <p>The debug level of <code class="code">Mnesia</code> is set by calling the function <code><a href="mnesia#set_debug_level-1">mnesia:set_debug_level(Level)</a></code>, where <code class="code">Level</code>is one of the following:</p> <dl> <dt><strong><code class="code">none</code></strong></dt> <dd>No trace outputs. This is the default. </dd> <dt><strong><code class="code">verbose</code></strong></dt> <dd>Activates tracing of important debug events. These events generate <code class="code">{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with the function <code><a href="mnesia#subscribe-1">mnesia:subscribe/1</a></code>. The events are always sent to the <code class="code">Mnesia</code> event handler. </dd> <dt><strong><code class="code">debug</code></strong></dt> <dd>Activates all events at the verbose level plus traces of all debug events. These debug events generate <code class="code">{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with <code class="code">mnesia:subscribe/1</code>. The events are always sent to the <code class="code">Mnesia</code> event handler. On this debug level, the <code class="code">Mnesia</code> event handler starts subscribing to updates in the schema table. </dd> <dt><strong><code class="code">trace</code></strong></dt> <dd>Activates all events at the debug level. On this level, the <code class="code">Mnesia</code> event handler starts subscribing to updates on all <code class="code">Mnesia</code> tables. This level is intended only for debugging small toy systems, as many large events can be generated. </dd> <dt><strong><code class="code">false</code></strong></dt> <dd>An alias for none. </dd> <dt><strong><code class="code">true</code></strong></dt> <dd>An alias for debug. </dd> </dl> <p>The debug level of <code class="code">Mnesia</code> itself is also an application parameter, making it possible to start an Erlang system to turn on <code class="code">Mnesia</code> debug in the initial startup phase by using the following code:</p> <pre data-language="erlang">
% erl -mnesia debug verbose</pre> <h2><span onmouseover="document.getElementById('ghlink-concurrent-processes-in-mnesia-id84223').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-concurrent-processes-in-mnesia-id84223').style.visibility = 'hidden';" id="concurrent-processes-in-mnesia">6.9 Concurrent Processes in Mnesia</span></h2> <p>Programming concurrent Erlang systems is the subject of a separate book. However, it is worthwhile to draw attention to the following features, which permit concurrent processes to exist in a <code class="code">Mnesia</code> system:</p> <ul> <li> <p>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</p> <p>All programs accessing the database through the transaction system can be written as if they had sole access to the data. This is a desirable property, as all synchronization is taken care of by the transaction handler. If a program reads or writes data, the system ensures that no other program tries to manipulate the same data at the same time.</p> </li> <li>Tables can be moved or deleted, and the layout of a table can be reconfigured in various ways. An important aspect of the implementation of these functions is that user programs can continue to use a table while it is being reconfigured. For example, it is possible to move a table and perform write operations to the table at the same time. This is important for many applications that require continuously available services. For more information, see <code><a href="mnesia_chap4#trans_prop">Transactions and Other Access Contexts</a></code>. </li> </ul> <h2><span onmouseover="document.getElementById('ghlink-prototyping-id84277').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-prototyping-id84277').style.visibility = 'hidden';" id="prototyping">6.10 Prototyping</span></h2> <p>If and when you would like to start and manipulate <code class="code">Mnesia</code>, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. <code class="code">Mnesia</code> can be initialized with data read from a text file. The following two functions can be used to work with text files.</p> <ul> <li> <code><a href="mnesia#load_textfile-1">mnesia:load_textfile(Filename)</a></code> loads a series of local table definitions and data found in the file into <code class="code">Mnesia</code>. This function also starts <code class="code">Mnesia</code> and possibly creates a new schema. The function operates on the local node only. </li> <li> <code><a href="mnesia#dump_to_textfile-1">mnesia:dump_to_textfile(Filename)</a></code> dumps all local tables of a <code class="code">Mnesia</code> system into a text file, which can be edited (with a normal text editor) and later reloaded. </li> </ul> <p>These functions are much slower than the ordinary store and load functions of <code class="code">Mnesia</code>. However, this is mainly intended for minor experiments and initial prototyping. The major advantage of these functions is that they are easy to use.</p> <p>The format of the text file is as follows:</p> <pre data-language="erlang">
{tables, [{Typename, [Options]},
{Typename2 ......}]}.

{Typename, Attribute1, Attribute2 ....}.
{Typename, Attribute1, Attribute2 ....}.</pre> <p><code class="code">Options</code> is a list of <code class="code">{Key,Value}</code> tuples conforming to the options that you can give to <code><a href="mnesia#create_table-2">mnesia:create_table/2</a></code>. </p> <p>For example, to start playing with a small database for healthy foods, enter the following data into file <code class="code">FRUITS</code>:</p> <pre data-language="erlang">{tables,
 [{fruit, [{attributes, [name, color, taste]}]},
  {vegetable, [{attributes, [name, color, taste, price]}]}]}.


{fruit, orange, orange, sweet}.
{fruit, apple, green, sweet}.
{vegetable, carrot, orange, carrotish, 2.55}.
{vegetable, potato, yellow, none, 0.45}.</pre> <p>The following session with the Erlang shell shows how to load the <code class="code">FRUITS</code> database:</p> <pre data-language="erlang">
% erl
Erlang (BEAM) emulator version 4.9
 
Eshell V4.9  (abort with ^G)
1&gt; mnesia:load_textfile("FRUITS").
New table fruit
New table vegetable
{atomic,ok}
2&gt; mnesia:info().
---&gt; Processes holding locks &lt;--- 
---&gt; Processes waiting for locks &lt;--- 
---&gt; Pending (remote) transactions &lt;--- 
---&gt; Active (local) transactions &lt;---
---&gt; Uncertain transactions &lt;--- 
---&gt; Active tables &lt;--- 
vegetable      : with 2 records occuping 299 words of mem 
fruit          : with 2 records occuping 291 words of mem 
schema         : with 3 records occuping 401 words of mem 
===&gt; System info in version "1.1", debug level = none &lt;===
opt_disc. Directory "/var/tmp/Mnesia.nonode@nohost" is used.
use fallback at restart = false
running db nodes = [nonode@nohost]
stopped db nodes = [] 
remote           = []
ram_copies       = [fruit,vegetable]
disc_copies      = [schema]
disc_only_copies = []
[{nonode@nohost,disc_copies}] = [schema]
[{nonode@nohost,ram_copies}] = [fruit,vegetable]
3 transactions committed, 0 aborted, 0 restarted, 2 logged to disc
0 held locks, 0 in queue; 0 local transactions, 0 remote
0 transactions waits for other nodes: []
ok
3&gt; 
    </pre> <p>It can be seen that the DBMS was initiated from a regular text file.</p> <h2><span onmouseover="document.getElementById('ghlink-object-based-programming-with-mnesia-id84420').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-object-based-programming-with-mnesia-id84420').style.visibility = 'hidden';" id="object-based-programming-with-mnesia">6.11 Object-Based Programming with Mnesia</span></h2> <p>The <code class="code">Company</code> database, introduced in <code><a href="mnesia_chap2#getting_started">Getting Started</a></code>, has three tables that store records (<code class="code">employee</code>, <code class="code">dept</code>, <code class="code">project</code>), and three tables that store relationships (<code class="code">manager</code>, <code class="code">at_dep</code>, <code class="code">in_proj</code>). This is a normalized data model, which has some advantages over a non-normalized data model.</p> <p>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</p> <pre data-language="erlang">remove_proj(ProjName) -&gt;
    F = fun() -&gt;
                Ip = qlc:e(qlc:q([X || X &lt;- mnesia:table(in_proj),
				       X#in_proj.proj_name == ProjName]
				)),
                mnesia:delete({project, ProjName}),
                del_in_projs(Ip)
        end,
    mnesia:transaction(F).

del_in_projs([Ip|Tail]) -&gt;
    mnesia:delete_object(Ip),
    del_in_projs(Tail);
del_in_projs([]) -&gt;
    done.</pre> <p>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. <code class="code">Mnesia</code> is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A <code class="code">Mnesia</code> database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets <code class="code">Mnesia</code> apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</p> <p>Many telecommunications applications have unique requirements on lookup times for certain types of records. If the <code class="code">Company</code> database had been a part of a telecommunications system, it could be to minimize the lookup time of an employee <strong>together</strong> with a list of the projects the employee is working on. If this is the case, a drastically different data model without direct relationships can be chosen. You would then have only the records themselves, and different records could contain either direct references to other records, or contain other records that are not part of the <code class="code">Mnesia</code> schema.</p> <p>The following record definitions can be created:</p> <pre data-language="erlang">-record(employee, {emp_no,
		   name,
		   salary,
		   sex,
		   phone,
		   room_no,
		   dept,
		   projects,
		   manager}).
		   

-record(dept, {id, 
               name}).

-record(project, {name,
                  number,
                  location}).</pre> <p>A record that describes an employee can look as follows:</p> <pre data-language="erlang">
Me = #employee{emp_no= 104732,
name = klacke,
salary = 7,
sex = male,
phone = 99586,
room_no = {221, 015},
dept = 'B/SFR',
projects = [erlang, mnesia, otp],
manager = 114872},</pre> <p>This model has only three different tables, and the employee records contain references to other records. The record has the following references:</p> <ul> <li> <code class="code">'B/SFR'</code> refers to a <code class="code">dept</code> record. </li> <li> <code class="code">[erlang, mnesia, otp]</code> is a list of three direct references to three different <code class="code">projects</code> records. </li> <li> <code class="code">114872</code> refers to another employee record. </li> </ul> <p>The <code class="code">Mnesia</code> record identifiers (<code class="code">{Tab, Key}</code>) can also be used as references. In this case, attribute <code class="code">dept</code> would be set to value <code class="code">{dept, 'B/SFR'}</code> instead of <code class="code">'B/SFR'</code>.</p> <p>With this data model, some operations execute considerably faster than they do with the normalized data model in the <code class="code">Company</code> database. However, some other operations become much more complicated. In particular, it becomes more difficult to ensure that records do not contain dangling pointers to other non-existent, or deleted, records.</p> <p>The following code exemplifies a search with a non-normalized data model. To find all employees at department <code class="code">Dep</code> with a salary higher than <code class="code">Salary</code>, use the following code:</p> <pre data-language="erlang">get_emps(Salary, Dep) -&gt;
    Q = qlc:q( 
          [E || E &lt;- mnesia:table(employee),
                E#employee.salary &gt; Salary,
                E#employee.dept == Dep]
	 ),
    F = fun() -&gt; qlc:e(Q) end,
    transaction(F).</pre> <p>This code is easier to write and to understand, and it also executes much faster.</p> <p>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function <code class="code">get_emps/2</code> is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</p>
<div class="_attribution">
  <p class="_attribution-p">
     20102017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
