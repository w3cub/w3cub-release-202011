
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>5. Transactions and Other Access Contexts - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content="This section describes the Mnesia transaction system and the transaction properties that make Mnesia a fault-tolerant, distributed Database &hellip;">
  <meta name="keywords" content="transactions, and, other, access, contexts, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/mnesia-4.15.4/doc/html/mnesia_chap4.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>5 Transactions and Other Access Contexts</h1> <p>This section describes the <code class="code">Mnesia</code> transaction system and the transaction properties that make <code class="code">Mnesia</code> a fault-tolerant, distributed Database Management System (DBMS).</p> <p>This section also describes the locking functions, including table locks and sticky locks, as well as alternative functions that bypass the transaction system in favor of improved speed and reduced overhead. These functions are called "dirty operations". The use of nested transactions is also described. The following topics are included:</p> <ul> <li>Transaction properties, which include atomicity, consistency, isolation, and durability</li> <li>Locking</li> <li>Dirty operations</li> <li>Record names versus table names</li> <li>Activity concept and various access contexts</li> <li>Nested transactions</li> <li>Pattern matching</li> <li>Iteration</li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-transaction-properties-id78446').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-transaction-properties-id78446').style.visibility = 'hidden';" id="trans_prop">5.1 Transaction Properties</span> </h2> <p>Transactions are important when designing fault-tolerant, distributed systems. A <code class="code">Mnesia</code> transaction is a mechanism by which a series of database operations can be executed as one functional block. The functional block that is run as a transaction is called a Functional Object (Fun), and this code can read, write, and delete <code class="code">Mnesia</code> records. The Fun is evaluated as a transaction that either commits or terminates. If a transaction succeeds in executing the Fun, it replicates the action on all nodes involved, or terminates if an error occurs.</p> <p>The following example shows a transaction that raises the salary of certain employee numbers:</p> <pre data-language="erlang">raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read(employee, Eno, write),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                mnesia:write(New)
        end,
    mnesia:transaction(F).</pre> <p>The function <code class="code">raise/2</code> contains a Fun made up of four code lines. This Fun is called by the statement <code class="code">mnesia:transaction(F)</code> and returns a value.</p> <p>The <code class="code">Mnesia</code> transaction system facilitates the construction of reliable, distributed systems by providing the following important properties:</p> <ul> <li>The transaction handler ensures that a Fun, which is placed inside a transaction, does not interfere with operations embedded in other transactions when it executes a series of operations on tables. </li> <li>The transaction handler ensures that either all operations in the transaction are performed successfully on all nodes atomically, or the transaction fails without permanent effect on any node. </li> <li>The <code class="code">Mnesia</code> transactions have four important properties, called <strong>A</strong>tomicity, <strong>C</strong>onsistency, <strong>I</strong>solation, and <strong>D</strong>urability (ACID). These properties are described in the following sections.</li> </ul> <h4><span onmouseover="document.getElementById('ghlink-atomicity-id78548').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-atomicity-id78548').style.visibility = 'hidden';" id="atomicity">Atomicity</span></h4> <p>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</p> <p>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function <code class="code">raise/2</code>, shown in the previous example, writes one record only. The function <code class="code">insert_emp/3</code>, shown in the program listing in <code><a href="mnesia_chap2#getting_started">Getting Started</a></code>, writes the record <code class="code">employee</code> as well as employee relations, such as <code class="code">at_dep</code> and <code class="code">in_proj</code>, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</p> <p><code class="code">Mnesia</code> is a distributed DBMS where data can be replicated on several nodes. In many applications, it is important that a series of write operations are performed atomically inside a transaction. The atomicity property ensures that a transaction takes effect on all nodes, or none.</p> <h4><span onmouseover="document.getElementById('ghlink-consistency-id78604').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-consistency-id78604').style.visibility = 'hidden';" id="consistency">Consistency</span></h4> <p>The consistency property ensures that a transaction always leaves the DBMS in a consistent state. For example, <code class="code">Mnesia</code> ensures that no inconsistencies occur if Erlang, <code class="code">Mnesia</code>, or the computer crashes while a write operation is in progress.</p> <h4><span onmouseover="document.getElementById('ghlink-isolation-id78627').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-isolation-id78627').style.visibility = 'hidden';" id="isolation">Isolation</span></h4> <p>The isolation property ensures that transactions that execute on different nodes in a network, and access and manipulate the same data records, do not interfere with each other. The isolation property makes it possible to execute the function <code class="code">raise/2</code> concurrently. A classical problem in concurrency control theory is the "lost update problem".</p> <p>The isolation property is in particular useful if the following circumstances occur where an employee (with employee number 123) and two processes (P1 and P2) are concurrently trying to raise the salary for the employee:</p> <ul> <li> <strong>Step 1:</strong> The initial value of the employees salary is, for example, 5. Process P1 starts to execute, reads the employee record, and adds 2 to the salary.</li> <li> <strong>Step 2:</strong> Process P1 is for some reason pre-empted and process P2 has the opportunity to run.</li> <li> <strong>Step 3:</strong> Process P2 reads the record, adds 3 to the salary, and finally writes a new employee record with the salary set to 8.</li> <li> <strong>Step 4:</strong> Process P1 starts to run again and writes its employee record with salary set to 7, thus effectively overwriting and undoing the work performed by process P2. The update performed by P2 is lost.</li> </ul> <p>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</p> <h4><span onmouseover="document.getElementById('ghlink-durability-id78695').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-durability-id78695').style.visibility = 'hidden';" id="durability">Durability</span></h4> <p>The durability property ensures that changes made to the DBMS by a transaction are permanent. Once a transaction is committed, all changes made to the database are durable, that is, they are written safely to disc and do not become corrupted and do not disappear.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The described durability feature does not entirely apply to situations where <code class="code">Mnesia</code> is configured as a "pure" primary memory database.</p> </div> </div> <h2><span onmouseover="document.getElementById('ghlink-locking-id78724').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-locking-id78724').style.visibility = 'hidden';" id="locking">5.2 Locking</span></h2> <p>Different transaction managers employ different strategies to satisfy the isolation property. <code class="code">Mnesia</code> uses the standard technique of two phase locking. That is, locks are set on records before they are read or written. <code class="code">Mnesia</code> uses the following lock types:</p> <ul> <li> <strong>Read locks</strong>. A read lock is set on one replica of a record before it can be read. </li> <li> <strong>Write locks</strong>. Whenever a transaction writes to a record, write locks are first set on all replicas of that particular record. </li> <li> <strong>Read table locks</strong>. If a transaction traverses an entire table in search for a record that satisfies some particular property, it is most inefficient to set read locks on the records one by one. It is also memory consuming, as the read locks themselves can take up considerable space if the table is large. Therefore, <code class="code">Mnesia</code> can set a read lock on an entire table. </li> <li> <strong>Write table locks</strong>. If a transaction writes many records to one table, a write lock can be set on the entire table. </li> <li> <strong>Sticky locks</strong>. These are write locks that stay in place at a node after the transaction that initiated the lock has terminated.</li> </ul> <p><code class="code">Mnesia</code> employs a strategy whereby functions, such as <code><a href="mnesia#read-1">mnesia:read/1</a></code> acquire the necessary locks dynamically as the transactions execute. <code class="code">Mnesia</code> automatically sets and releases the locks and the programmer does not need to code these operations.</p> <p>Deadlocks can occur when concurrent processes set and release locks on the same records. <code class="code">Mnesia</code> employs a "wait-die" strategy to resolve these situations. If <code class="code">Mnesia</code> suspects that a deadlock can occur when a transaction tries to set a lock, the transaction is forced to release all its locks and sleep for a while. The Fun in the transaction is evaluated once more.</p> <p>It is therefore important that the code inside the Fun given to <code><a href="mnesia#transaction-2"><span class="code">mnesia:transaction/1</span></a></code> is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</p> <pre data-language="erlang">bad_raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read({employee, Eno}),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                io:format("Trying to write ... ~n", []),
                mnesia:write(New)
        end,
    mnesia:transaction(F).</pre> <p>This transaction can write the text <code class="code">"Trying to write ... "</code> 1000 times to the terminal. However, <code class="code">Mnesia</code> guarantees that each transaction will eventually run. As a result, <code class="code">Mnesia</code> is not only deadlock free, but also livelock free.</p> <p>The <code class="code">Mnesia</code> programmer cannot prioritize one particular transaction to execute before other transactions that are waiting to execute. As a result, the <code class="code">Mnesia</code> DBMS transaction system is not suitable for hard real-time applications. However, <code class="code">Mnesia</code> contains other features that have real-time properties.</p> <p><code class="code">Mnesia</code> dynamically sets and releases locks as transactions execute. It is therefore dangerous to execute code with transaction side-effects. In particular, a <code class="code">receive</code> statement inside a transaction can lead to a situation where the transaction hangs and never returns, which in turn can cause locks not to release. This situation can bring the whole system to a standstill, as other transactions that execute in other processes, or on other nodes, are forced to wait for the defective transaction.</p> <p>If a transaction terminates abnormally, <code class="code">Mnesia</code> automatically releases the locks held by the transaction.</p> <p>Up to now, examples of a number of functions that can be used inside a transaction have been shown. The following list shows the <strong>simplest</strong> <code class="code">Mnesia</code> functions that work with transactions. Notice that these functions must be embedded in a transaction. If no enclosing transaction (or other enclosing <code class="code">Mnesia</code> activity) exists, they all fail.</p> <ul> <li> <code><a href="mnesia#transaction-2">mnesia:transaction(Fun) -&gt; {aborted, Reason} |{atomic, Value}</a></code> executes one transaction with the functional object <code class="code">Fun</code> as the single parameter. </li> <li> <code><a href="mnesia#read-1">mnesia:read({Tab, Key}) -&gt; transaction abort | RecordList</a></code> reads all records with <code class="code">Key</code> as key from table <code class="code">Tab</code>. This function has the same semantics regardless of the location of <code class="code">Table</code>. If the table is of type <code class="code">bag</code>, <code class="code">read({Tab, Key})</code> can return an arbitrarily long list. If the table is of type <code class="code">set</code>, the list is either of length one or <code class="code">[]</code>. </li> <li> <code><a href="mnesia#wread-1">mnesia:wread({Tab, Key}) -&gt; transaction abort | RecordList</a></code> behaves the same way as the previously listed function <code class="code">read/1</code>, except that it acquires a write lock instead of a read lock. To execute a transaction that reads a record, modifies the record, and then writes the record, it is slightly more efficient to set the write lock immediately. When a <code><a href="mnesia#read-1">mnesia:read/1</a></code> is issued, followed by a <code><a href="mnesia#write-1">mnesia:write/1</a></code> the first read lock must be upgraded to a write lock when the write operation is executed. </li> <li> <code><a href="mnesia#write-1">mnesia:write(Record) -&gt; transaction abort | ok</a></code> writes a record into the database. Argument <code class="code">Record</code> is an instance of a record. The function returns <code class="code">ok</code>, or terminates the transaction if an error occurs. </li> <li> <code><a href="mnesia#delete-1">mnesia:delete({Tab, Key}) -&gt; transaction abort | ok</a></code> deletes all records with the given key. </li> <li> <code><a href="mnesia#delete_object-1">mnesia:delete_object(Record) -&gt; transaction abort | ok</a></code> deletes records with the OID <code class="code">Record</code>. Use this function to delete only some records in a table of type <code class="code">bag</code>.</li> </ul> <h4><span onmouseover="document.getElementById('ghlink-sticky-locks-id79045').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-sticky-locks-id79045').style.visibility = 'hidden';" id="sticky-locks">Sticky Locks</span></h4> <p>As previously stated, the locking strategy used by <code class="code">Mnesia</code> is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use <code class="code">Mnesia</code> mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</p> <p>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</p> <pre data-language="erlang">F = fun() -&gt;
      mnesia:write(#foo{a = kalle})
    end,
mnesia:transaction(F).</pre> <p>The <code class="code">foo</code> table is replicated on the two nodes <code class="code">N1</code> and <code class="code">N2</code>.</p> <p>Normal locking requires the following:</p> <ul> <li>One network RPC (two messages) to acquire the write lock </li> <li>Three network messages to execute the two-phase commit protocol </li> </ul> <p>If sticky locks are used, the code must first be changed as follows:</p> <pre data-language="erlang">F = fun() -&gt;
      mnesia:s_write(#foo{a = kalle})
    end,
mnesia:transaction(F).</pre> <p>This code uses the function <code><a href="mnesia#s_write-1">s_write/1</a></code> instead of the function <code><a href="mnesia#write-1">write/1</a></code> The function <code class="code">s_write/1</code> sets a sticky lock instead of a normal lock. If the table is not replicated, sticky locks have no special effect. If the table is replicated, and a sticky lock is set on node <code class="code">N1</code>, this lock then sticks to node <code class="code">N1</code>. The next time you try to set a sticky lock on the same record at node <code class="code">N1</code>, <code class="code">Mnesia</code> detects that the lock is already set and do no network operation to acquire the lock.</p> <p>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</p> <p>If a record is stuck at node <code class="code">N1</code> and you try to set a sticky lock for the record on node <code class="code">N2</code>, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue <code class="code">s_write/1</code> requests at <code class="code">N2</code>.</p> <h4><span onmouseover="document.getElementById('ghlink-table-locks-id79190').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-table-locks-id79190').style.visibility = 'hidden';" id="table-locks">Table Locks</span></h4> <p><code class="code">Mnesia</code> supports read and write locks on whole tables as a complement to the normal locks on single records. As previously stated, <code class="code">Mnesia</code> sets and releases locks automatically, and the programmer does not need to code these operations. However, transactions that read and write many records in a specific table execute more efficiently if the transaction is started by setting a table lock on this table. This blocks other concurrent transactions from the table. The following two functions are used to set explicit table locks for read and write operations:</p> <ul> <li> <code><a href="mnesia#read_lock_table-1">mnesia:read_lock_table(Tab)</a></code> sets a read lock on table <code class="code">Tab</code>.</li> <li> <code><a href="mnesia#write_lock_table-1">mnesia:write_lock_table(Tab)</a></code> sets a write lock on table <code class="code">Tab</code>.</li> </ul> <p>Alternative syntax for acquisition of table locks is as follows:</p> <pre data-language="erlang">mnesia:lock({table, Tab}, read)
mnesia:lock({table, Tab}, write)</pre> <p>The matching operations in <code class="code">Mnesia</code> can either lock the entire table or only a single record (when the key is bound in the pattern).</p> <h4><span onmouseover="document.getElementById('ghlink-global-locks-id79266').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-global-locks-id79266').style.visibility = 'hidden';" id="global-locks">Global Locks</span></h4> <p>Write locks are normally acquired on all nodes where a replica of the table resides (and is active). Read locks are acquired on one node (the local one if a local replica exists).</p> <p>The function <code><a href="mnesia#lock-2">mnesia:lock/2</a></code> is intended to support table locks (as mentioned previously) but also for situations when locks need to be acquired regardless of how tables have been replicated:</p> <pre data-language="erlang">mnesia:lock({global, GlobalKey, Nodes}, LockKind)

LockKind ::= read | write | ...</pre> <p>The lock is acquired on <code class="code">LockItem</code> on all nodes in the node list.</p> <h2><span onmouseover="document.getElementById('ghlink-dirty-operations-id79308').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-dirty-operations-id79308').style.visibility = 'hidden';" id="dirty-operations">5.3 Dirty Operations</span></h2> <p>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</p> <p>Dirty operation are often useful, for example, in a datagram routing application where <code class="code">Mnesia</code> stores the routing table, and it is time consuming to start a whole transaction every time a packet is received. <code class="code">Mnesia</code> has therefore functions that manipulate tables without using transactions. This alternative to processing is known as a dirty operation. However, notice the trade-off in avoiding the overhead of transaction processing:</p> <ul> <li>The atomicity and the isolation properties of <code class="code">Mnesia</code> are lost. </li> <li>The isolation property is compromised, because other Erlang processes, which use transaction to manipulate the data, do not get the benefit of isolation if dirty operations simultaneously are used to read and write records from the same table. </li> </ul> <p>The major advantage of dirty operations is that they execute much faster than equivalent operations that are processed as functional objects within a transaction.</p> <p>Dirty operations are written to disc if they are performed on a table of type <code class="code">disc_copies</code> or type <code class="code">disc_only_copies</code>. <code class="code">Mnesia</code> also ensures that all replicas of a table are updated if a dirty write operation is performed on a table.</p> <p>A dirty operation ensures a certain level of consistency. For example, dirty operations cannot return garbled records. Hence, each individual read or write operation is performed in an atomic manner.</p> <p>All dirty functions execute a call to <code class="code">exit({aborted, Reason})</code> on failure. Even if the following functions are executed inside a transaction no locks are acquired. The following functions are available:</p> <ul> <li> <code><a href="mnesia#dirty_read-1">mnesia:dirty_read({Tab, Key})</a></code> reads one or more records from <code class="code">Mnesia</code>. </li> <li> <code><a href="mnesia#dirty_write-1">mnesia:dirty_write(Record)</a></code> writes the record <code class="code">Record</code>. </li> <li> <code><a href="mnesia#dirty_delete-1">mnesia:dirty_delete({Tab, Key})</a></code> deletes one or more records with key <code class="code">Key</code>. </li> <li> <code><a href="mnesia#dirty_delete_object-1">mnesia:dirty_delete_object(Record)</a></code> is the dirty operation alternative to the function <code><a href="mnesia#delete_object-1">delete_object/1</a></code>. </li> <li> <p><code><a href="mnesia#dirty_first-1">mnesia:dirty_first(Tab)</a></code> returns the "first" key in table <code class="code">Tab</code>.</p> <p>Records in <code class="code">set</code> or <code class="code">bag</code> tables are not sorted. However, there is a record order that is unknown to the user. This means that a table can be traversed by this function with the function <code><a href="mnesia#dirty_next-2">mnesia:dirty_next/2</a></code>.</p> <p>If there are no records in the table, this function returns the atom <code class="code">'$end_of_table'</code>. It is not recommended to use this atom as the key for any user records.</p> </li> <li> <p><code><a href="mnesia#dirty_next-2">mnesia:dirty_next(Tab, Key)</a></code> returns the "next" key in table <code class="code">Tab</code>. This function makes it possible to traverse a table and perform some operation on all records in the table. When the end of the table is reached, the special key <code class="code">'$end_of_table'</code> is returned. Otherwise, the function returns a key that can be used to read the actual record.</p> <p>The behavior is undefined if any process performs a write operation on the table while traversing the table with the function <code><a href="mnesia#dirty_next-2">dirty_next/2</a></code> This is because <code class="code">write</code> operations on a <code class="code">Mnesia</code> table can lead to internal reorganizations of the table itself. This is an implementation detail, but remember that the dirty functions are low-level functions.</p> </li> <li> <code><a href="mnesia#dirty_last-1">mnesia:dirty_last(Tab)</a></code> works exactly like <code><a href="mnesia#dirty_first-1">mnesia:dirty_first/1</a></code> but returns the last object in Erlang term order for the table type <code class="code">ordered_set</code>. For all other table types, <code class="code">mnesia:dirty_first/1</code> and <code class="code">mnesia:dirty_last/1</code> are synonyms. </li> <li> <code><a href="mnesia#dirty_prev-2">mnesia:dirty_prev(Tab, Key)</a></code> works exactly like <code class="code">mnesia:dirty_next/2</code> but returns the previous object in Erlang term order for the table type <code class="code">ordered_set</code>. For all other table types, <code class="code">mnesia:dirty_next/2</code> and <code class="code">mnesia:dirty_prev/2</code> are synonyms. </li> <li> <p><code><a href="mnesia#dirty_slot-2">mnesia:dirty_slot(Tab, Slot)</a></code> returns the list of records that are associated with <code class="code">Slot</code> in a table. It can be used to traverse a table in a manner similar to the function <code class="code">dirty_next/2</code>. A table has a number of slots that range from zero to some unknown upper bound. The function <code class="code">dirty_slot/2</code> returns the special atom <code class="code">'$end_of_table'</code> when the end of the table is reached.</p> <p>The behavior of this function is undefined if the table is written on while being traversed. The function <code><a href="mnesia#read_lock_table-1">mnesia:read_lock_table(Tab)</a></code> can be used to ensure that no transaction-protected writes are performed during the iteration.</p> </li> <li> <p><code><a href="mnesia#dirty_update_counter-2">mnesia:dirty_update_counter({Tab,Key}, Val)</a></code>. Counters are positive integers with a value greater than or equal to zero. Updating a counter adds <code class="code">Val</code> and the counter where <code class="code">Val</code> is a positive or negative integer.</p> <p><code class="code">Mnesia</code> has no special counter records. However, records of the form <code class="code">{TabName, Key, Integer}</code> can be used as counters, and can be persistent.</p> <p>Transaction-protected updates of counter records are not possible.</p> <p>There are two significant differences when using this function instead of reading the record, performing the arithmetic, and writing the record:</p> <ul> <li>It is much more efficient. </li> <li>The funcion <code><a href="mnesia#dirty_update_counter-2">dirty_update_counter/2</a></code> is performed as an atomic operation although it is not protected by a transaction. Therfore no table update is lost if two processes simultaneously execute the function <code class="code">dirty_update_counter/2</code>. </li> </ul> </li> <li> <code><a href="mnesia#dirty_match_object-2">mnesia:dirty_match_object(Pat)</a></code> is the dirty equivalent of <code><a href="mnesia#match_object-1">mnesia:match_object/1</a></code>. </li> <li> <code><a href="mnesia#dirty_select-2">mnesia:dirty_select(Tab, Pat)</a></code> is the dirty equivalent of <code><a href="mnesia#select-2">mnesia:select/2</a></code>. </li> <li> <code><a href="mnesia#dirty_index_match_object-2">mnesia:dirty_index_match_object(Pat, Pos)</a></code> is the dirty equivalent of <code><a href="mnesia#index_match_object-2">mnesia:index_match_object/2</a></code>. </li> <li> <code><a href="mnesia#dirty_index_read-3">mnesia:dirty_index_read(Tab, SecondaryKey, Pos)</a></code> is the dirty equivalent of <code><a href="mnesia#index_read-3">mnesia:index_read/3</a></code>. </li> <li> <code><a href="mnesia#dirty_all_keys-1">mnesia:dirty_all_keys(Tab)</a></code> is the dirty equivalent of <code><a href="mnesia#all_keys-1">mnesia:all_keys/1</a></code>. </li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-record-names-versus-table-names-id79768').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-record-names-versus-table-names-id79768').style.visibility = 'hidden';" id="recordnames_tablenames">5.4 Record Names versus Table Names</span> </h2> <p>In <code class="code">Mnesia</code>, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property <code class="code">record_name</code>, the following code ensures that all records in the tables have the same name as the table:</p> <pre data-language="erlang">mnesia:create_table(subscriber, [])</pre> <p>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</p> <pre data-language="erlang">TabDef = [{record_name, subscriber}],
mnesia:create_table(my_subscriber, TabDef),
mnesia:create_table(your_subscriber, TabDef).</pre> <p>To access such tables, simplified access functions (as described earlier) cannot be used. For example, writing a subscriber record into a table requires the function <code><a href="mnesia#write-3">mnesia:write/3</a></code> instead of the simplified functions <code><a href="mnesia#write-1">mnesia:write/1</a></code> and <code><a href="mnesia#s_write-1">mnesia:s_write/1</a></code>:</p> <pre data-language="erlang">mnesia:write(subscriber, #subscriber{}, write)
mnesia:write(my_subscriber, #subscriber{}, sticky_write)
mnesia:write(your_subscriber, #subscriber{}, write)</pre> <p>The following simple code illustrates the relationship between the simplified access functions used in most of the examples and their more flexible counterparts:</p> <pre data-language="erlang">mnesia:dirty_write(Record) -&gt;
  Tab = element(1, Record),
  mnesia:dirty_write(Tab, Record).

mnesia:dirty_delete({Tab, Key}) -&gt;
  mnesia:dirty_delete(Tab, Key).

mnesia:dirty_delete_object(Record) -&gt;
  Tab = element(1, Record),
  mnesia:dirty_delete_object(Tab, Record) 

mnesia:dirty_update_counter({Tab, Key}, Incr) -&gt;
  mnesia:dirty_update_counter(Tab, Key, Incr).

mnesia:dirty_read({Tab, Key}) -&gt;
  Tab = element(1, Record),
  mnesia:dirty_read(Tab, Key).

mnesia:dirty_match_object(Pattern) -&gt;
  Tab = element(1, Pattern),
  mnesia:dirty_match_object(Tab, Pattern).

mnesia:dirty_index_match_object(Pattern, Attr) 
  Tab = element(1, Pattern),
  mnesia:dirty_index_match_object(Tab, Pattern, Attr).

mnesia:write(Record) -&gt;
  Tab = element(1, Record),
  mnesia:write(Tab, Record, write).

mnesia:s_write(Record) -&gt;
  Tab = element(1, Record),
  mnesia:write(Tab, Record, sticky_write).

mnesia:delete({Tab, Key}) -&gt;
  mnesia:delete(Tab, Key, write).

mnesia:s_delete({Tab, Key}) -&gt;
  mnesia:delete(Tab, Key, sticky_write).

mnesia:delete_object(Record) -&gt;
  Tab = element(1, Record),
  mnesia:delete_object(Tab, Record, write).

mnesia:s_delete_object(Record) -&gt;
  Tab = element(1, Record),
  mnesia:delete_object(Tab, Record, sticky_write).

mnesia:read({Tab, Key}) -&gt;
  mnesia:read(Tab, Key, read).

mnesia:wread({Tab, Key}) -&gt;
  mnesia:read(Tab, Key, write).

mnesia:match_object(Pattern) -&gt;
  Tab = element(1, Pattern),
  mnesia:match_object(Tab, Pattern, read).

mnesia:index_match_object(Pattern, Attr) -&gt;
  Tab = element(1, Pattern),
  mnesia:index_match_object(Tab, Pattern, Attr, read).</pre> <h2><span onmouseover="document.getElementById('ghlink-activity-concept-and-various-access-contexts-id79874').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-activity-concept-and-various-access-contexts-id79874').style.visibility = 'hidden';" id="activity-concept-and-various-access-contexts">5.5 Activity Concept and Various Access Contexts</span></h2> <p>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function <code><a href="mnesia#transaction-2">mnesia:transaction/1,2,3</a></code>: </p> <ul> <li> <code><a href="mnesia#write-3">mnesia:write/3 (write/1, s_write/1)</a></code> </li> <li> <code><a href="mnesia#delete-3">mnesia:delete/3</a></code> (<code><a href="mnesia#delete-1">mnesia:delete/1</a></code>, <code><a href="mnesia#s_delete-1">mnesia:s_delete/1</a></code>) </li> <li> <code><a href="mnesia#delete_object-3">mnesia:delete_object/3</a></code> (<code><a href="mnesia#delete_object-1">mnesia:delete_object/1</a></code>, <code><a href="mnesia#s_delete_object-1">mnesia:s_delete_object/1</a></code>) </li> <li> <code><a href="mnesia#read-3">mnesia:read/3</a></code> (<code><a href="mnesia#read-1">mnesia:read/1</a></code>, <code><a href="mnesia#wread-1">mnesia:wread/1</a></code>) </li> <li> <code><a href="mnesia#match_object-3">mnesia:match_object/2</a></code> (<code><a href="mnesia#match_object-1">mnesia:match_object/1</a></code>) </li> <li> <code><a href="mnesia#select-2">mnesia:select/3</a></code> (<code><a href="mnesia#select-2">mnesia:select/2</a></code>) </li> <li> <code><a href="mnesia#foldl-3">mnesia:foldl/3</a></code> (<code class="code">mnesia:foldl/4</code>, <code><a href="mnesia#foldr-3">mnesia:foldr/3</a></code>, <code class="code">mnesia:foldr/4</code>) </li> <li> <code><a href="mnesia#all_keys-1">mnesia:all_keys/1</a></code> </li> <li> <code><a href="mnesia#index_match_object-4">mnesia:index_match_object/4</a></code> (<code><a href="mnesia#index_match_object-2">mnesia:index_match_object/2</a></code>) </li> <li> <code><a href="mnesia#index_read-3">mnesia:index_read/3</a></code> </li> <li> <code><a href="mnesia#lock-2">mnesia:lock/2</a></code> (<code><a href="mnesia#read_lock_table-1">mnesia:read_lock_table/1</a></code>, <code><a href="mnesia#write_lock_table-1">mnesia:write_lock_table/1</a></code>) </li> <li> <code><a href="mnesia#table_info-2">mnesia:table_info/2</a></code> </li> </ul> <p>These functions are performed in a transaction context involving mechanisms, such as locking, logging, replication, checkpoints, subscriptions, and commit protocols. However, the same function can also be evaluated in other activity contexts.</p> <p>The following activity access contexts are currently supported:</p> <ul> <li><code class="code">transaction</code></li> <li><code class="code">sync_transaction</code></li> <li><code class="code">async_dirty</code></li> <li><code class="code">sync_dirty</code></li> <li><code class="code">ets</code></li> </ul> <p>By passing the same "fun" as argument to the function <code><a href="mnesia#sync_transaction-3">mnesia:sync_transaction(Fun [, Args])</a></code> it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the <code class="code">mnesia:sync_transaction</code> call. Using <code class="code">sync_transaction</code> is useful in the following cases:</p> <ul> <li>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</li> <li>When a combining transaction writes with "dirty_reads", that is, the functions <code class="code">dirty_match_object</code>, <code class="code">dirty_read</code>, <code class="code">dirty_index_read</code>, <code class="code">dirty_select</code>, and so on.</li> <li>When an application performs frequent or voluminous updates that can overload <code class="code">Mnesia</code> on other nodes.</li> </ul> <p>By passing the same "fun" as argument to the function <code><a href="mnesia#async_dirty-2">mnesia:async_dirty(Fun [, Args])</a></code>, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated "dirty". Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</p> <p>By passing the same "fun" as an argument to the function <code><a href="mnesia#sync_dirty-2">mnesia:sync_dirty(Fun [, Args])</a></code>, it is performed in almost the same context as the function <code><a href="mnesia#async_dirty-2">mnesia:async_dirty/1,2</a></code>. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using <code class="code">mnesia:sync_dirty/1,2</code> is useful in the following cases:</p> <ul> <li>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</li> <li>When an application performs frequent or voluminous updates that can overload <code class="code">Mnesia</code> on the nodes.</li> </ul> <p>To check if your code is executed within a transaction, use the function <code><a href="mnesia#is_transaction-0">mnesia:is_transaction/0</a></code>. It returns <code class="code">true</code> when called inside a transaction context, otherwise <code class="code">false</code>.</p> <p><code class="code">Mnesia</code> tables with storage type <code class="code">RAM_copies</code> and <code class="code">disc_copies</code> are implemented internally as <code class="code">ets</code> tables. Applications can access the these tables directly. This is only recommended if all options have been weighed and the possible outcomes are understood. By passing the earlier mentioned "fun" to the function <code><a href="mnesia#ets-2">mnesia:ets(Fun [, Args])</a></code>, it is performed but in a raw context. The operations are performed directly on the local <code class="code">ets</code> tables, assuming that the local storage type is <code class="code">RAM_copies</code> and that the table is not replicated on other nodes.</p> <p>Subscriptions are not triggered and no checkpoints are updated, but this operation is blindingly fast. Disc resident tables are not to be updated with the <code class="code">ets</code> function, as the disc is not updated.</p> <p>The Fun can also be passed as an argument to the function <code><a href="mnesia#activity-4">mnesia:activity/2,3,4</a></code>, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter <code class="code">access_module</code>. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</p> <p>The callback module does not have to access real <code class="code">Mnesia</code> tables, it is free to do whatever it wants as long as the callback interface is fulfilled.</p> <p><code><a href="mnesia_app_b">Appendix B, Activity Access Callback Interface</a></code> provides the source code, <code class="code">mnesia_frag.erl</code>, for one alternative implementation. The context-sensitive function <code><a href="mnesia#table_info-2">mnesia:table_info/2</a></code> can be used to provide virtual information about a table. One use of this is to perform <code class="code">QLC</code> queries within an activity context with a customized callback module. By providing table information about table indexes and other <code class="code">QLC</code> requirements, <code class="code">QLC</code> can be used as a generic query language to access virtual tables.</p> <p>QLC queries can be performed in all these activity contexts (<code class="code">transaction</code>, <code class="code">sync_transaction</code>, <code class="code">async_dirty</code>, <code class="code">sync_dirty</code>, and <code class="code">ets</code>). The <code class="code">ets</code> activity only works if the table has no indexes.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The function <code class="code">mnesia:dirty_*</code> always executes with <code class="code">async_dirty</code> semantics regardless of which activity access contexts that are started. It can even start contexts without any enclosing activity access context.</p> </div> </div> <h2><span onmouseover="document.getElementById('ghlink-nested-transactions-id80416').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-nested-transactions-id80416').style.visibility = 'hidden';" id="nested-transactions">5.6 Nested Transactions</span></h2> <p>Transactions can be nested in an arbitrary fashion. A child transaction must run in the same process as its parent. When a child transaction terminates, the caller of the child transaction gets return value <code class="code">{aborted, Reason}</code> and any work performed by the child is erased. If a child transaction commits, the records written by the child are propagated to the parent.</p> <p>No locks are released when child transactions terminate. Locks created by a sequence of nested transactions are kept until the topmost transaction terminates. Furthermore, any update performed by a nested transaction is only propagated in such a manner so that the parent of the nested transaction sees the updates. No final commitment is done until the top-level transaction terminates. So, although a nested transaction returns <code class="code">{atomic, Val}</code>, if the enclosing parent transaction terminates, the entire nested operation terminates.</p> <p>The ability to have nested transaction with identical semantics as top-level transaction makes it easier to write library functions that manipulate <code class="code">Mnesia</code> tables.</p> <p>Consider a function that adds a subscriber to a telephony system:</p> <pre data-language="erlang">
add_subscriber(S) -&gt;
    mnesia:transaction(fun() -&gt;
        case mnesia:read( ..........</pre> <p>This function needs to be called as a transaction. Assume that you wish to write a function that both calls the function <code class="code">add_subscriber/1</code> and is in itself protected by the context of a transaction. By calling <code class="code">add_subscriber/1</code> from within another transaction, a nested transaction is created.</p> <p>Also, different activity access contexts can be mixed while nesting. However, the dirty ones (<code class="code">async_dirty</code>, <code class="code">sync_dirty</code>, and <code class="code">ets</code>) inherit the transaction semantics if they are called inside a transaction and thus grab locks and use two or three phase commit.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
add_subscriber(S) -&gt;
    mnesia:transaction(fun() -&gt;
       %% Transaction context 
       mnesia:read({some_tab, some_data}),
       mnesia:sync_dirty(fun() -&gt;
           %% Still in a transaction context.
           case mnesia:read( ..) ..end), end).
add_subscriber2(S) -&gt;
    mnesia:sync_dirty(fun() -&gt;
       %% In dirty context 
       mnesia:read({some_tab, some_data}),
       mnesia:transaction(fun() -&gt;
           %% In a transaction context.
           case mnesia:read( ..) ..end), end).</pre> <h2><span onmouseover="document.getElementById('ghlink-pattern-matching-id80509').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-pattern-matching-id80509').style.visibility = 'hidden';" id="pattern-matching">5.7 Pattern Matching</span></h2>  <p id="matching">When the function <code><a href="mnesia#read-3">mnesia:read/3</a></code> cannot be used, <code class="code">Mnesia</code> provides the programmer with several functions for matching records against a pattern. The most useful ones are the following:</p> <pre data-language="erlang">mnesia:select(Tab, MatchSpecification, LockKind) -&gt;
    transaction abort | [ObjectList]
mnesia:select(Tab, MatchSpecification, NObjects, Lock) -&gt;  
    transaction abort | {[Object],Continuation} | '$end_of_table'
mnesia:select(Cont) -&gt;
    transaction abort | {[Object],Continuation} | '$end_of_table'
mnesia:match_object(Tab, Pattern, LockKind) -&gt;
    transaction abort | RecordList</pre> <p>These functions match a <code class="code">Pattern</code> against all records in table <code class="code">Tab</code>. In a <code><a href="mnesia#select-2">mnesia:select</a></code> call, <code class="code">Pattern</code> is a part of <code class="code">MatchSpecification</code> described in the following. It is not necessarily performed as an exhaustive search of the entire table. By using indexes and bound values in the key of the pattern, the actual work done by the function can be condensed into a few hash lookups. Using <code class="code">ordered_set</code> tables can reduce the search space if the keys are partially bound.</p> <p>The pattern provided to the functions must be a valid record, and the first element of the provided tuple must be the <code class="code">record_name</code> of the table. The special element <code class="code">'_'</code> matches any data structure in Erlang (also known as an Erlang term). The special elements <code class="code">'$&lt;number&gt;'</code> behave as Erlang variables, that is, they match anything, bind the first occurrence, and match the coming occurrences of that variable against the bound value.</p> <p>Use function <code><a href="mnesia#table_info-2">mnesia:table_info(Tab, wild_pattern)</a></code> to obtain a basic pattern, which matches all records in a table, or use the default value in record creation. Do not make the pattern hard-coded, as this makes the code more vulnerable to future changes of the record definition.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">Wildpattern = mnesia:table_info(employee, wild_pattern), 
%% Or use
Wildpattern = #employee{_ = '_'},</pre> <p>For the employee table, the wild pattern looks as follows:</p> <pre data-language="erlang">{employee, '_', '_', '_', '_', '_',' _'}.</pre> <p>To constrain the match, it is needed to replace some of the <code class="code">'_'</code> elements. The code for matching out all female employees looks as follows:</p> <pre data-language="erlang">Pat = #employee{sex = female, _ = '_'},
F = fun() -&gt; mnesia:match_object(Pat) end,
Females = mnesia:transaction(F).</pre> <p>The match function can also be used to check the equality of different attributes. For example, to find all employees with an employee number equal to their room number:</p> <pre data-language="erlang">Pat = #employee{emp_no = '$1', room_no = '$1', _ = '_'},
F = fun() -&gt; mnesia:match_object(Pat) end,
Odd = mnesia:transaction(F).</pre> <p>The function <code><a href="mnesia#match_object-3">mnesia:match_object/3</a></code> lacks some important features that <code><a href="mnesia#select-2">mnesia:select/3</a></code> have. For example, <code class="code">mnesia:match_object/3</code> can only return the matching records, and it cannot express constraints other than equality. To find the names of the male employees on the second floor:</p> <pre data-language="erlang">MatchHead = #employee{name='$1', sex=male, room_no={'$2', '_'}, _='_'},
Guard = [{'&gt;=', '$2', 220},{'&lt;', '$2', 230}],
Result = '$1',
mnesia:select(employee,[{MatchHead, Guard, [Result]}])</pre> <p>The function <code class="code">select</code> can be used to add more constraints and create output that cannot be done with <code class="code">mnesia:match_object/3</code>.</p> <p>The second argument to <code class="code">select</code> is a <code class="code">MatchSpecification</code>. A <code class="code">MatchSpecification</code> is a list of <code class="code">MatchFunction</code>s, where each <code class="code">MatchFunction</code> consists of a tuple containing <code class="code">{MatchHead, MatchCondition, MatchBody}</code>:</p> <ul> <li> <code class="code">MatchHead</code> is the same pattern as used in <code class="code">mnesia:match_object/3</code> described earlier.</li> <li> <code class="code">MatchCondition</code> is a list of extra constraints applied to each record.</li> <li> <code class="code">MatchBody</code> constructs the return values.</li> </ul> <p>For details about the match specifications, see "Match Specifications in Erlang" in <code>ERTS</code> User's Guide. For more information, see the <code>ets</code> and <code>dets</code> manual pages in <code class="code">STDLIB</code>.</p> <p>The functions <code><a href="mnesia#select-4">select/4</a></code> and <code><a href="mnesia#select-2">select/1</a></code> are used to get a limited number of results, where <code class="code">Continuation</code> gets the next chunk of results. <code class="code">Mnesia</code> uses <code class="code">NObjects</code> as a recommendation only. Thus, more or less results than specified with <code class="code">NObjects</code> can be returned in the result list, even the empty list can be returned even if there are more results to collect.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>There is a severe performance penalty in using <code class="code">mnesia:select/[1|2|3|4]</code> after any modifying operation is done on that table in the same transaction. That is, avoid using <code><a href="mnesia#write-1">mnesia:write/1</a></code> or <code><a href="mnesia#delete-1">mnesia:delete/1</a></code> before <code class="code">mnesia:select</code> in the same transaction.</p> </div> </div> <p>If the key attribute is bound in a pattern, the match operation is efficient. However, if the key attribute in a pattern is given as <code class="code">'_'</code> or <code class="code">'$1'</code>, the whole <code class="code">employee</code> table must be searched for records that match. Hence if the table is large, this can become a time-consuming operation, but it can be remedied with indexes (see <code><a href="mnesia_chap5#indexing">Indexing</a></code>) if the function <code><a href="mnesia#match_object-1">mnesia:match_object</a></code> is used.</p> <p>QLC queries can also be used to search <code class="code">Mnesia</code> tables. By using the function <code><a href="mnesia#table-1">mnesia:table/[1|2]</a></code> as the generator inside a QLC query, you let the query operate on a <code class="code">Mnesia</code> table. <code class="code">Mnesia</code>-specific options to <code class="code">mnesia:table/2</code> are <code class="code">{lock, Lock}</code>, <code class="code">{n_objects,Integer}</code>, and <code class="code">{traverse, SelMethod}</code>:</p> <ul> <li> <code class="code">lock</code> specifies whether <code class="code">Mnesia</code> is to acquire a read or write lock on the table.</li> <li> <code class="code">n_objects</code> specifies how many results are to be returned in each chunk to QLC.</li> <li> <code class="code">traverse</code> specifies which function <code class="code">Mnesia</code> is to use to traverse the table. Default <code class="code">select</code> is used, but by using <code class="code">{traverse, {select, MatchSpecification}}</code> as an option to <code><a href="mnesia#table-1">mnesia:table/2</a></code> the user can specify its own view of the table.</li> </ul> <p>If no options are specified, a read lock is acquired, 100 results are returned in each chunk, and <code class="code">select</code> is used to traverse the table, that is:</p> <pre data-language="erlang">mnesia:table(Tab) -&gt;
    mnesia:table(Tab, [{n_objects,100},{lock, read}, {traverse, select}]).</pre> <p>The function <code><a href="mnesia#all_keys-1">mnesia:all_keys(Tab)</a></code> returns all keys in a table.</p> <h2><span onmouseover="document.getElementById('ghlink-iteration-id80980').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-iteration-id80980').style.visibility = 'hidden';" id="iteration">5.8 Iteration</span></h2>  <p id="iteration"><code class="code">Mnesia</code> provides the following functions that iterate over all the records in a table:</p> <pre data-language="erlang">mnesia:foldl(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
mnesia:foldr(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
mnesia:foldl(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort
mnesia:foldr(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort</pre> <p>These functions iterate over the <code class="code">Mnesia</code> table <code class="code">Tab</code> and apply the function <code class="code">Fun</code> to each record. <code class="code">Fun</code> takes two arguments, the first is a record from the table, and the second is the accumulator. <code class="code">Fun</code> returns a new accumulator.</p> <p>The first time <code class="code">Fun</code> is applied, <code class="code">Acc0</code> is the second argument. The next time <code class="code">Fun</code> is called, the return value from the previous call is used as the second argument. The term the last call to <code class="code">Fun</code> returns is the return value of the function <code><a href="mnesia#foldl-3">mnesia:foldl/3</a></code> or <code><a href="mnesia#foldr-3">mnesia:foldr/3</a></code>.</p> <p>The difference between these functions is the order the table is accessed for <code class="code">ordered_set</code> tables. For other table types the functions are equivalent.</p> <p><code class="code">LockType</code> specifies what type of lock that is to be acquired for the iteration, default is <code class="code">read</code>. If records are written or deleted during the iteration, a write lock is to be acquired.</p> <p>These functions can be used to find records in a table when it is impossible to write constraints for the function <code><a href="mnesia#match_object-3">mnesia:match_object/3</a></code>, or when you want to perform some action on certain records.</p> <p>For example, finding all the employees who have a salary less than 10 can look as follows:</p> <pre data-language="erlang">find_low_salaries() -&gt;
  Constraint = 
       fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
              [Emp | Acc];
          (_, Acc) -&gt;
              Acc
       end,
  Find = fun() -&gt; mnesia:foldl(Constraint, [], employee) end,
  mnesia:transaction(Find).</pre> <p>To raise the salary to 10 for everyone with a salary less than 10 and return the sum of all raises:</p> <pre data-language="erlang">increase_low_salaries() -&gt;
   Increase = 
       fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
              OldS = Emp#employee.salary,
              ok = mnesia:write(Emp#employee{salary = 10}),
              Acc + 10 - OldS;
          (_, Acc) -&gt;
              Acc
       end,
  IncLow = fun() -&gt; mnesia:foldl(Increase, 0, employee, write) end,
  mnesia:transaction(IncLow).</pre> <p>Many nice things can be done with the iterator functions but take some caution about performance and memory use for large tables.</p> <p>Call these iteration functions on nodes that contain a replica of the table. Each call to the function <code class="code">Fun</code> access the table and if the table resides on another node it generates much unnecessary network traffic.</p> <p><code class="code">Mnesia</code> also provides some functions that make it possible for the user to iterate over the table. The order of the iteration is unspecified if the table is not of type <code class="code">ordered_set</code>:</p> <pre data-language="erlang">mnesia:first(Tab) -&gt;  Key | transaction abort
mnesia:last(Tab)  -&gt;  Key | transaction abort
mnesia:next(Tab,Key)  -&gt;  Key | transaction abort
mnesia:prev(Tab,Key)  -&gt;  Key | transaction abort
mnesia:snmp_get_next_index(Tab,Index) -&gt; {ok, NextIndex} | endOfTable</pre> <p>The order of <code class="code">first</code>/<code class="code">last</code> and <code class="code">next</code>/<code class="code">prev</code> is only valid for <code class="code">ordered_set</code> tables, they are synonyms for other tables. When the end of the table is reached, the special key <code class="code">'$end_of_table'</code> is returned.</p> <p>If records are written and deleted during the traversal, use the function <code><a href="mnesia#foldl">mnesia:foldl/3</a></code> or <code><a href="mnesia#foldr">mnesia:foldr/3</a></code> with a <code class="code">write</code> lock. Or the function <code><a href="mnesia#write_lock_table-1">mnesia:write_lock_table/1</a></code> when using <code class="code">first</code> and <code class="code">next</code>.</p> <p>Writing or deleting in transaction context creates a local copy of each modified record. Thus, modifying each record in a large table uses much memory. <code class="code">Mnesia</code> compensates for every written or deleted record during the iteration in a transaction context, which can reduce the performance. If possible, avoid writing or deleting records in the same transaction before iterating over the table.</p> <p>In dirty context, that is, <code class="code">sync_dirty</code> or <code class="code">async_dirty</code>, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands <code><a href="mnesia#first-1">mnesia:first/1</a></code> and <code><a href="mnesia#next-2">mnesia:next/2</a></code>, the same drawbacks as described previously for <code><a href="mnesia#dirty_first-1">mnesia:dirty_first/1</a></code> and <code><a href="mnesia#dirty_next-2">mnesia:dirty_next/2</a></code> applies, that is, no writing to the table is to be done during iteration.</p>
<div class="_attribution">
  <p class="_attribution-p">
     20102017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
