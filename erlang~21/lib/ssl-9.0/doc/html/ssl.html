
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Ssl - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content=" ssl ">
  <meta name="keywords" content="ssl, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/ssl-9.0/doc/html/ssl.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/erlang~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>ssl</h1> <h2><span onmouseover="document.getElementById('ghlink-module-id62648').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-id62648').style.visibility = 'hidden';" id="module">Module</span></h2> <p class="REFBODY module-body">ssl</p> <h2><span onmouseover="document.getElementById('ghlink-module-summary-id62652').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-summary-id62652').style.visibility = 'hidden';" id="module-summary">Module Summary</span></h2> <p class="REFBODY module-summary-body">Interface Functions for Secure Socket Layer</p> <h2><span onmouseover="document.getElementById('ghlink-description-id62655').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-id62655').style.visibility = 'hidden';" id="description">Description</span></h2> 
<p> This module contains interface functions for the SSL/TLS/DTLS protocol. For detailed information about the supported standards see <code><span>ssl(6)</span></code>. </p>  <h2>Data types</h2>  <p>The following data types are used in the functions for SSL/TLS/DTLS:</p> <dl> <dt><strong><code class="code">boolean() =</code></strong></dt> <dd><p><code class="code">true | false</code></p></dd> <dt><strong><code class="code">option() =</code></strong></dt> <dd> <p><code class="code">socketoption() | ssl_option() | transport_option()</code></p> </dd> <dt><strong><code class="code">socketoption() =</code></strong></dt> <dd> <p><code class="code">proplists:property()</code></p> <p>The default socket options are <code class="code">[{mode,list},{packet, 0},{header, 0},{active, true}]</code>.</p> <p>For valid options, see the <code>inet(3)</code>, <code>gen_tcp(3)</code> and <code>gen_udp(3)</code> manual pages in Kernel. Note that stream oriented options such as packet are only relevant for SSL/TLS and not DTLS</p> </dd> <dt><strong><code class="code" id="type-ssloption">ssl_option() =</code></strong></dt> <dd> <p><code class="code">{verify, verify_type()}</code></p> <p><code class="code">| {verify_fun, {fun(), term()}}</code></p> <p><code class="code">| {fail_if_no_peer_cert, boolean()}</code></p> <p><code class="code">| {depth, integer()}</code></p> <p><code class="code">| {cert, public_key:der_encoded()}</code></p> <p><code class="code">| {certfile, path()}</code></p> <p><code class="code">| {key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey' | 'PrivateKeyInfo', public_key:der_encoded()} | #{algorithm := rsa | dss | ecdsa, engine := crypto:engine_ref(), key_id := crypto:key_id(), password =&gt; crypto:password()}</code></p> <p><code class="code">| {keyfile, path()}</code></p> <p><code class="code">| {password, string()}</code></p> <p><code class="code">| {cacerts, [public_key:der_encoded()]}</code></p> <p><code class="code">| {cacertfile, path()}</code></p> <p><code class="code">| {dh, public_key:der_encoded()}</code></p> <p><code class="code">| {dhfile, path()}</code></p> <p><code class="code">| {ciphers, ciphers()}</code></p> <p><code class="code">| {user_lookup_fun, {fun(), term()}}, {psk_identity, string()}, {srp_identity, {string(), string()}}</code></p> <p><code class="code">| {reuse_sessions, boolean()}</code></p> <p><code class="code">| {reuse_session, fun()} {next_protocols_advertised, [binary()]}</code></p> <p><code class="code">| {client_preferred_next_protocols, {client | server, [binary()]} | {client | server, [binary()], binary()}}</code></p> <p><code class="code">| {log_alert, boolean()}</code></p> <p><code class="code">| {server_name_indication, hostname() | disable}</code></p> <p><code class="code">| {customize_hostname_check, list()}</code></p> <p><code class="code">| {sni_hosts, [{hostname(), [ssl_option()]}]}</code></p> <p><code class="code">| {sni_fun, SNIfun::fun()}</code></p> </dd> <dt><strong><code class="code">transport_option() =</code></strong></dt> <dd> <p><code class="code">{cb_info, {CallbackModule::atom(), DataTag::atom(), ClosedTag::atom(), ErrTag:atom()}}</code></p> <p>Defaults to <code class="code">{gen_tcp, tcp, tcp_closed, tcp_error}</code> for TLS and <code class="code">{gen_udp, udp, udp_closed, udp_error}</code> for DTLS. Can be used to customize the transport layer. For TLS the callback module must implement a reliable transport protocol, behave as <code class="code">gen_tcp</code>, and have functions corresponding to <code class="code">inet:setopts/2</code>, <code class="code">inet:getopts/2</code>, <code class="code">inet:peername/1</code>, <code class="code">inet:sockname/1</code>, and <code class="code">inet:port/1</code>. The callback <code class="code">gen_tcp</code> is treated specially and calls <code class="code">inet</code> directly. For DTLS this feature must be considered exprimental.</p> <dl> <dt><strong><code class="code">CallbackModule =</code></strong></dt> <dd><p><code class="code">atom()</code></p></dd> <dt><strong><code class="code">DataTag =</code></strong></dt> <dd> <p><code class="code">atom()</code></p> <p>Used in socket data message.</p> </dd> <dt><strong><code class="code">ClosedTag =</code></strong></dt> <dd> <p><code class="code">atom()</code></p> <p>Used in socket close message.</p> </dd> </dl> </dd> <dt><strong><code class="code">verify_type() =</code></strong></dt> <dd><p><code class="code">verify_none | verify_peer</code></p></dd> <dt><strong><code class="code">path() =</code></strong></dt> <dd> <p><code class="code">string()</code></p> <p>Represents a file path.</p> </dd> <dt><strong><code class="code">public_key:der_encoded() =</code></strong></dt> <dd> <p><code class="code">binary()</code></p> <p>ASN.1 DER-encoded entity as an Erlang binary.</p> </dd> <dt><strong><code class="code">host() =</code></strong></dt> <dd><p><code class="code">hostname() | ipaddress()</code></p></dd> <dt><strong><code class="code">hostname() =</code></strong></dt> <dd><p><code class="code">string() - DNS hostname</code></p></dd> <dt><strong><code class="code">ip_address() =</code></strong></dt> <dd><p><code class="code">{N1,N2,N3,N4} % IPv4 | {K1,K2,K3,K4,K5,K6,K7,K8} % IPv6</code></p></dd> <dt><strong><code class="code">sslsocket() =</code></strong></dt> <dd><p>opaque()</p></dd> <dt><strong><code class="code" id="type-protocol">protocol_version() =</code></strong></dt> <dd><p><code class="code">ssl_tls_protocol() | dtls_protocol()</code></p></dd> <dd><p><code class="code">sslv3 | tlsv1 | 'tlsv1.1' | 'tlsv1.2'</code></p></dd> <dt><strong><code class="code" id="type-protocol">dtls_protocol() =</code></strong></dt> <dd><p><code class="code">'dtlsv1' | 'dtlsv1.2'</code></p></dd> <dt><strong><code class="code">ciphers() =</code></strong></dt> <dd> <p><code class="code">= [ciphersuite()]</code></p> <p>Tuples and string formats accepted by versions before ssl-8.2.4 will be converted for backwards compatibility</p> </dd> <dt><strong><code class="code">ciphersuite() =</code></strong></dt> <dd><p><code class="code">#{key_exchange := key_exchange(), cipher := cipher(), mac := MAC::hash() | aead, prf := PRF::hash() | default_prf}</code></p></dd> <dt><strong><code class="code">key_exchange()=</code></strong></dt> <dd><p><code class="code">rsa | dhe_dss | dhe_rsa | dh_anon | psk | dhe_psk | rsa_psk | srp_anon | srp_dss | srp_rsa | ecdh_anon | ecdh_ecdsa | ecdhe_ecdsa | ecdh_rsa | ecdhe_rsa</code></p></dd> <dt><strong><code class="code">cipher() =</code></strong></dt> <dd><p><code class="code">rc4_128 | des_cbc | '3des_ede_cbc' | aes_128_cbc | aes_256_cbc | aes_128_gcm | aes_256_gcm | chacha20_poly1305</code></p></dd> <dt><strong><code class="code">hash() =</code></strong></dt> <dd><p><code class="code">md5 | sha | sha224 | sha256 | sha348 | sha512</code></p></dd> <dt><strong><code class="code">prf_random() =</code></strong></dt> <dd><p><code class="code">client_random | server_random</code></p></dd> <dt><strong><code class="code">cipher_filters() =</code></strong></dt> <dd><p><code class="code">[{key_exchange | cipher | mac | prf, algo_filter()}])</code></p></dd> <dt><strong><code class="code">algo_filter() =</code></strong></dt> <dd><p>fun(key_exchange() | cipher() | hash() | aead | default_prf) -&gt; true | false </p></dd> <dt><strong><code class="code">srp_param_type() =</code></strong></dt> <dd><p><code class="code">srp_1024 | srp_1536 | srp_2048 | srp_3072 | srp_4096 | srp_6144 | srp_8192</code></p></dd> <dt><strong><code class="code">SNIfun::fun()</code></strong></dt> <dd><p><code class="code">= fun(ServerName :: string()) -&gt; [ssl_option()]</code></p></dd> <dt><strong><code class="code">named_curve() =</code></strong></dt> <dd><p><code class="code">sect571r1 | sect571k1 | secp521r1 | brainpoolP512r1 | sect409k1 | sect409r1 | brainpoolP384r1 | secp384r1 | sect283k1 | sect283r1 | brainpoolP256r1 | secp256k1 | secp256r1 | sect239k1 | sect233k1 | sect233r1 | secp224k1 | secp224r1 | sect193r1 | sect193r2 | secp192k1 | secp192r1 | sect163k1 | sect163r1 | sect163r2 | secp160k1 | secp160r1 | secp160r2</code></p></dd> <dt><strong><code class="code">hello_extensions() =</code></strong></dt> <dd><p><code class="code">#{renegotiation_info =&gt; signature_algs =&gt; [{hash(), ecsda| rsa| dsa}] | undefined alpn =&gt; binary() | undefined, next_protocol_negotiation, srp =&gt; string() | undefined, ec_point_formats , elliptic_curves = [oid] | undefined sni = string()} }</code></p></dd> </dl>  <h2><span onmouseover="document.getElementById('ghlink-tls-dtls-option-descriptions---common-for-server-and-client-id60928').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-tls-dtls-option-descriptions---common-for-server-and-client-id60928').style.visibility = 'hidden';" id="tls-dtls-option-descriptions---common-for-server-and-client">TLS/DTLS OPTION DESCRIPTIONS - COMMON for SERVER and CLIENT</span></h2>  <p>The following options have the same meaning in the client and the server:</p> <dl> <dt><strong><code class="code">{protocol, tls | dtls}</code></strong></dt> <dd><p>Choose TLS or DTLS protocol for the transport layer security. Defaults to <code class="code">tls</code> Introduced in OTP 20, DTLS support is considered experimental in this release. Other transports than UDP are not yet supported.</p></dd> <dt><strong><code class="code">{handshake, hello | full}</code></strong></dt> <dd><p> Defaults to <code class="code">full</code>. If hello is specified the handshake will pause after the hello message and give the user a possibility make decisions based on hello extensions before continuing or aborting the handshake by calling <code><a href="#handshake_continue-3">handshake_continue/3</a></code> or <code><a href="#handshake_cancel-1">handshake_cancel/1</a></code> </p></dd> <dt><strong><code class="code">{cert, public_key:der_encoded()}</code></strong></dt> <dd><p>The DER-encoded users certificate. If this option is supplied, it overrides option <code class="code">certfile</code>.</p></dd> <dt><strong><code class="code">{certfile, path()}</code></strong></dt> <dd><p>Path to a file containing the user certificate.</p></dd> <dt><strong>  <code class="code" id="key_option_def">{key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey' |'PrivateKeyInfo', public_key:der_encoded()} | #{algorithm := rsa | dss | ecdsa, engine := crypto:engine_ref(), key_id := crypto:key_id(), password =&gt; crypto:password()}</code></strong></dt> <dd><p>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso <code>crypto:engine_load/4</code> and <code>Crypto's Users Guide</code>. If this option is supplied, it overrides option <code class="code">keyfile</code>.</p></dd> <dt><strong><code class="code">{keyfile, path()}</code></strong></dt> <dd><p>Path to the file containing the user's private PEM-encoded key. As PEM-files can contain several entries, this option defaults to the same file as given by option <code class="code">certfile</code>.</p></dd> <dt><strong><code class="code">{password, string()}</code></strong></dt> <dd><p>String containing the user's password. Only used if the private keyfile is password-protected.</p></dd> <dt><strong><code class="code">{ciphers, ciphers()}</code></strong></dt> <dd><p>Supported cipher suites. The function <code class="code">cipher_suites/0</code> can be used to find all ciphers that are supported by default. <code class="code">cipher_suites(all)</code> can be called to find all available cipher suites. Pre-Shared Key (<code><a href="http://www.ietf.org/rfc/rfc4279.txt">RFC 4279</a></code> and <code><a href="http://www.ietf.org/rfc/rfc5487.txt">RFC 5487</a></code>), Secure Remote Password (<code><a href="http://www.ietf.org/rfc/rfc5054.txt">RFC 5054</a></code>), RC4 cipher suites, and anonymous cipher suites only work if explicitly enabled by this option; they are supported/enabled by the peer also. Anonymous cipher suites are supported for testing purposes only and are not be used when security matters.</p></dd> <dt><strong><code class="code">{eccs, [named_curve()]}</code></strong></dt> <dd><p> Allows to specify the order of preference for named curves and to restrict their usage when using a cipher suite supporting them. </p></dd> <dt><strong><code class="code">{secure_renegotiate, boolean()}</code></strong></dt> <dd> <p>Specifies if to reject renegotiation attempt that does not live up to <code><a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a></code>. By default <code class="code">secure_renegotiate</code> is set to <code class="code">true</code>, that is, secure renegotiation is enforced. If set to <code class="code">false</code> secure renegotiation will still be used if possible, but it falls back to insecure renegotiation if the peer does not support <code><a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a></code>.</p> </dd> <dt><strong><code class="code">{depth, integer()}</code></strong></dt> <dd><p>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 1.</p></dd> <dt><strong><code class="code" id="verify_fun">{verify_fun, {Verifyfun :: fun(), InitialUserState :: term()}}</code></strong></dt> <dd> <p>The verification fun is to be defined as follows:</p> <pre data-language="erlang">fun(OtpCert :: #'OTPCertificate'{}, Event :: {bad_cert, Reason :: atom() | {revoked,
atom()}} |
	     {extension, #'Extension'{}}, InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} | {valid_peer, UserState :: term()} |
	{fail, Reason :: term()} | {unknown, UserState :: term()}.</pre> <p>The verification fun is called during the X509-path validation when an error or an extension unknown to the SSL application is encountered. It is also called when a certificate is considered valid by the path validation to allow access to each certificate in the path to the user application. It differentiates between the peer certificate and the CA certificates by using <code class="code">valid_peer</code> or <code class="code">valid</code> as second argument to the verification fun. See the <code>public_key User's Guide</code> for definition of <code class="code">#'OTPCertificate'{}</code> and <code class="code">#'Extension'{}</code>.</p> <ul> <li><p>If the verify callback fun returns <code class="code">{fail, Reason}</code>, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</p></li> <li><p>If the verify callback fun returns <code class="code">{valid, UserState}</code>, the verification process continues.</p></li> <li><p>If the verify callback fun always returns <code class="code">{valid, UserState}</code>, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</p></li> <li> <p>If called with an extension unknown to the user application, return value <code class="code">{unknown, UserState}</code> is to be used.</p> <p>Note that if the fun returns <code class="code">unknown</code> for an extension marked as critical, validation will fail.</p> </li> </ul> <p>Default option <code class="code">verify_fun</code> in <code class="code">verify_peer mode</code>:</p> <pre data-language="erlang">{fun(_,{bad_cert, _} = Reason, _) -&gt;
	 {fail, Reason};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}</pre> <p>Default option <code class="code">verify_fun</code> in mode <code class="code">verify_none</code>:</p> <pre data-language="erlang">{fun(_,{bad_cert, _}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, #'Extension'{critical = true}}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}</pre> <p>The possible path validation errors are given on form <code class="code">{bad_cert, Reason}</code> where <code class="code">Reason</code> is:</p> <dl> <dt><strong><code class="code">unknown_ca</code></strong></dt> <dd> <p>No trusted CA was found in the trusted store. The trusted CA is normally a so called ROOT CA, which is a self-signed certificate. Trust can be claimed for an intermediate CA (trusted anchor does not have to be self-signed according to X-509) by using option <code class="code">partial_chain</code>.</p> </dd> <dt><strong><code class="code">selfsigned_peer</code></strong></dt> <dd><p>The chain consisted only of one self-signed certificate.</p></dd> <dt><strong><code class="code">PKIX X-509-path validation error</code></strong></dt> <dd><p>For possible reasons, see <code>public_key:pkix_path_validation/3</code> </p></dd> </dl> </dd> <dt><strong><code class="code">{crl_check, boolean() | peer | best_effort }</code></strong></dt> <dd> <p>Perform CRL (Certificate Revocation List) verification <code>(public_key:pkix_crls_validate/3)</code> on all the certificates during the path validation <code>(public_key:pkix_path_validation/3)</code> of the certificate chain. Defaults to <code class="code">false</code>.</p> <dl> <dt><strong><code class="code">peer</code></strong></dt> <dd>check is only performed on the peer certificate.</dd> <dt><strong><code class="code">best_effort</code></strong></dt> <dd>if certificate revocation status can not be determined it will be accepted as valid.</dd> </dl> <p>The CA certificates specified for the connection will be used to construct the certificate chain validating the CRLs.</p> <p>The CRLs will be fetched from a local or external cache. See <code>ssl_crl_cache_api(3)</code>.</p> </dd> <dt><strong><code class="code">{crl_cache, {Module :: atom(), {DbHandle :: internal | term(), Args :: list()}}}</code></strong></dt> <dd> <p>Specify how to perform lookup and caching of certificate revocation lists. <code class="code">Module</code> defaults to <code>ssl_crl_cache</code> with <code class="code">DbHandle</code> being <code class="code">internal</code> and an empty argument list.</p> <p>There are two implementations available:</p> <dl> <dt><strong><code class="code">ssl_crl_cache</code></strong></dt> <dd> <p>This module maintains a cache of CRLs. CRLs can be added to the cache using the function <code>ssl_crl_cache:insert/1</code>, and optionally automatically fetched through HTTP if the following argument is specified:</p> <dl> <dt><strong><code class="code">{http, timeout()}</code></strong></dt> <dd> <p> Enables fetching of CRLs specified as http URIs in<code>X509 certificate extensions</code>. Requires the OTP inets application.</p> </dd> </dl> </dd> <dt><strong><code class="code">ssl_crl_hash_dir</code></strong></dt> <dd> <p>This module makes use of a directory where CRLs are stored in files named by the hash of the issuer name.</p> <p>The file names consist of eight hexadecimal digits followed by <code class="code">.rN</code>, where <code class="code">N</code> is an integer, e.g. <code class="code">1a2b3c4d.r0</code>. For the first version of the CRL, <code class="code">N</code> starts at zero, and for each new version, <code class="code">N</code> is incremented by one. The OpenSSL utility <code class="code">c_rehash</code> creates symlinks according to this pattern.</p> <p>For a given hash value, this module finds all consecutive <code class="code">.r*</code> files starting from zero, and those files taken together make up the revocation list. CRL files whose <code class="code">nextUpdate</code> fields are in the past, or that are issued by a different CA that happens to have the same name hash, are excluded.</p> <p>The following argument is required:</p> <dl> <dt><strong><code class="code">{dir, string()}</code></strong></dt> <dd><p>Specifies the directory in which the CRLs can be found.</p></dd> </dl> </dd> <dt><strong><code class="code">max_handshake_size</code></strong></dt> <dd> <p>Integer (24 bits unsigned). Used to limit the size of valid TLS handshake packets to avoid DoS attacks. Defaults to 256*1024.</p> </dd> </dl> </dd> <dt><strong><code class="code">{partial_chain, fun(Chain::[DerCert]) -&gt; {trusted_ca, DerCert} | unknown_ca }</code></strong></dt> <dd><p>Claim an intermediate CA in the chain as trusted. TLS then performs <code>public_key:pkix_path_validation/3</code> with the selected CA as trusted anchor and the rest of the chain.</p></dd> <dt><strong><code class="code">{versions, [protocol_version()]}</code></strong></dt> <dd><p>TLS protocol versions supported by started clients and servers. This option overrides the application environment option <code class="code">protocol_version</code> and <code class="code">dtls_protocol_version</code>. If the environment option is not set, it defaults to all versions, except SSL-3.0, supported by the SSL application. See also <code>ssl(6).</code></p></dd> <dt><strong><code class="code">{hibernate_after, integer()|undefined}</code></strong></dt> <dd><p>When an integer-value is specified, <code class="code">TLS/DTLS-connection</code> goes into hibernation after the specified number of milliseconds of inactivity, thus reducing its memory footprint. When <code class="code">undefined</code> is specified (this is the default), the process never goes into hibernation.</p></dd> <dt><strong><code class="code">{user_lookup_fun, {Lookupfun :: fun(), UserState :: term()}}</code></strong></dt> <dd> <p>The lookup fun is to defined as follows:</p> <pre data-language="erlang">fun(psk, PSKIdentity ::string(), UserState :: term()) -&gt;
	{ok, SharedSecret :: binary()} | error;
fun(srp, Username :: string(), UserState :: term()) -&gt;
	{ok, {SRPParams :: srp_param_type(), Salt :: binary(), DerivedKey :: binary()}} | error.</pre> <p>For Pre-Shared Key (PSK) cipher suites, the lookup fun is called by the client and server to determine the shared secret. When called by the client, <code class="code">PSKIdentity</code> is set to the hint presented by the server or to undefined. When called by the server, <code class="code">PSKIdentity</code> is the identity presented by the client.</p> <p>For Secure Remote Password (SRP), the fun is only used by the server to obtain parameters that it uses to generate its session keys. <code class="code">DerivedKey</code> is to be derived according to <code><a href="http://tools.ietf.org/html/rfc2945#section-3"> RFC 2945</a></code> and <code><a href="http://tools.ietf.org/html/rfc5054#section-2.4"> RFC 5054</a></code>: <code class="code">crypto:sha([Salt, crypto:sha([Username, &lt;&lt;$:&gt;&gt;, Password])])</code> </p> </dd> <dt><strong><code class="code">{padding_check, boolean()}</code></strong></dt> <dd> <p>Affects TLS-1.0 connections only. If set to <code class="code">false</code>, it disables the block cipher padding check to be able to interoperate with legacy software.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Using <code class="code">{padding_check, boolean()}</code> makes TLS vulnerable to the Poodle attack.</p>
</div> </div> </dd> <dt><strong><code class="code">{beast_mitigation, one_n_minus_one | zero_n | disabled}</code></strong></dt> <dd> <p>Affects SSL-3.0 and TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to <code class="code">one_n_minus_one</code>.</p> <p><code class="code">one_n_minus_one</code> - Perform 1/n-1 BEAST mitigation.</p> <p><code class="code">zero_n</code> - Perform 0/n BEAST mitigation.</p> <p><code class="code">disabled</code> - Disable BEAST mitigation.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Using <code class="code">{beast_mitigation, disabled}</code> makes SSL or TLS vulnerable to the BEAST attack.</p>
</div> </div> </dd> </dl>  <h2>Tls/dtls option descriptions - client side</h2>  <p>The following options are client-specific or have a slightly different meaning in the client than in the server:</p> <dl> <dt><strong><code class="code">{verify, verify_type()}</code></strong></dt> <dd> <p>In mode <code class="code">verify_none</code> the default behavior is to allow all x509-path validation errors. See also option <code class="code">verify_fun</code>.</p> </dd> <dt><strong><code class="code">{reuse_sessions, boolean()}</code></strong></dt> <dd><p>Specifies if the client is to try to reuse sessions when possible.</p></dd> <dt><strong><code class="code">{cacerts, [public_key:der_encoded()]}</code></strong></dt> <dd><p>The DER-encoded trusted certificates. If this option is supplied it overrides option <code class="code">cacertfile</code>.</p></dd> <dt><strong><code class="code">{cacertfile, path()}</code></strong></dt> <dd> <p>Path to a file containing PEM-encoded CA certificates. The CA certificates are used during server authentication and when building the client certificate chain.</p> </dd> <dt><strong><code class="code">{alpn_advertised_protocols, [binary()]}</code></strong></dt> <dd> <p>The list of protocols supported by the client to be sent to the server to be used for an Application-Layer Protocol Negotiation (ALPN). If the server supports ALPN then it will choose a protocol from this list; otherwise it will fail the connection with a "no_application_protocol" alert. A server that does not support ALPN will ignore this value.</p> <p>The list of protocols must not contain an empty binary.</p> <p>The negotiated protocol can be retrieved using the <code class="code">negotiated_protocol/1</code> function.</p> </dd> <dt><strong><code class="code">{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()]}}</code><br> <code class="code">{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()], Default :: binary()}}</code></strong></dt> <dd> <p>Indicates that the client is to try to perform Next Protocol Negotiation.</p> <p>If precedence is server, the negotiated protocol is the first protocol to be shown on the server advertised list, which is also on the client preference list.</p> <p>If precedence is client, the negotiated protocol is the first protocol to be shown on the client preference list, which is also on the server advertised list.</p> <p>If the client does not support any of the server advertised protocols or the server does not advertise any protocols, the client falls back to the first protocol in its list or to the default protocol (if a default is supplied). If the server does not support Next Protocol Negotiation, the connection terminates if no default protocol is supplied.</p> </dd> <dt><strong><code class="code">{psk_identity, string()}</code></strong></dt> <dd> <p>Specifies the identity the client presents to the server. The matching secret is found by calling <code class="code">user_lookup_fun</code>.</p> </dd> <dt><strong><code class="code">{srp_identity, {Username :: string(), Password :: string()}</code></strong></dt> <dd><p>Specifies the username and password to use to authenticate to the server.</p></dd> <dt><strong><code class="code">{server_name_indication, HostName :: hostname()}</code></strong></dt> <dd> <p>Specify the hostname to be used in TLS Server Name Indication extension. If not specified it will default to the <code class="code">Host</code> argument of <code><a href="#connect-3">connect/[3,4]</a></code> unless it is of type inet:ipaddress().</p> <p> The <code class="code">HostName</code> will also be used in the hostname verification of the peer certificate using <code>public_key:pkix_verify_hostname/2</code>. </p> </dd> <dt><strong><code class="code">{server_name_indication, disable}</code></strong></dt> <dd> <p> Prevents the Server Name Indication extension from being sent and disables the hostname verification check <code>public_key:pkix_verify_hostname/2</code> </p> </dd> <dt><strong><code class="code">{customize_hostname_check, Options::list()}</code></strong></dt> <dd> <p> Customizes the hostname verification of the peer certificate, as different protocols that use TLS such as HTTP or LDAP may want to do it differently, for possible options see <code>public_key:pkix_verify_hostname/3</code> </p> </dd> <dt><strong><code class="code">{fallback, boolean()}</code></strong></dt> <dd> <p> Send special cipher suite TLS_FALLBACK_SCSV to avoid undesired TLS version downgrade. Defaults to false</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Note this option is not needed in normal TLS usage and should not be used to implement new clients. But legacy clients that retries connections in the following manner</p> <p><code class="code">ssl:connect(Host, Port, [...{versions, ['tlsv2', 'tlsv1.1', 'tlsv1', 'sslv3']}])</code></p> <p><code class="code">ssl:connect(Host, Port, [...{versions, [tlsv1.1', 'tlsv1', 'sslv3']}, {fallback, true}])</code></p> <p><code class="code">ssl:connect(Host, Port, [...{versions, ['tlsv1', 'sslv3']}, {fallback, true}])</code></p> <p><code class="code">ssl:connect(Host, Port, [...{versions, ['sslv3']}, {fallback, true}])</code></p> <p>may use it to avoid undesired TLS version downgrade. Note that TLS_FALLBACK_SCSV must also be supported by the server for the prevention to work. </p>
</div> </div> </dd> <dt><strong><code class="code" id="client_signature_algs">{signature_algs, [{hash(), ecdsa | rsa | dsa}]}</code></strong></dt> <dd> <p>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension <code><a href="http://www.ietf.org/rfc/rfc5246.txt">Section 7.4.1.4.1 in RFC 5246</a></code> may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</p> <pre data-language="erlang">[
%% SHA2
{sha512, ecdsa},
{sha512, rsa},
{sha384, ecdsa},
{sha384, rsa},
{sha256, ecdsa},
{sha256, rsa},
{sha224, ecdsa},
{sha224, rsa},
%% SHA
{sha, ecdsa},
{sha, rsa},
{sha, dsa},
]</pre> <p> The algorithms should be in the preferred order. Selected signature algorithm can restrict which hash functions that may be selected. Default support for {md5, rsa} removed in ssl-8.0 </p> </dd> </dl>  <h2>Tls/dtls option descriptions - server side</h2>  <p>The following options are server-specific or have a slightly different meaning in the server than in the client:</p> <dl> <dt><strong><code class="code">{cacerts, [public_key:der_encoded()]}</code></strong></dt> <dd><p>The DER-encoded trusted certificates. If this option is supplied it overrides option <code class="code">cacertfile</code>.</p></dd> <dt><strong><code class="code">{cacertfile, path()}</code></strong></dt> <dd><p>Path to a file containing PEM-encoded CA certificates. The CA certificates are used to build the server certificate chain and for client authentication. The CAs are also used in the list of acceptable client CAs passed to the client when a certificate is requested. Can be omitted if there is no need to verify the client and if there are no intermediate CAs for the server certificate.</p></dd> <dt><strong><code class="code">{dh, public_key:der_encoded()}</code></strong></dt> <dd><p>The DER-encoded Diffie-Hellman parameters. If specified, it overrides option <code class="code">dhfile</code>.</p></dd> <dt><strong><code class="code">{dhfile, path()}</code></strong></dt> <dd><p>Path to a file containing PEM-encoded Diffie Hellman parameters to be used by the server if a cipher suite using Diffie Hellman key exchange is negotiated. If not specified, default parameters are used. </p></dd> <dt><strong><code class="code">{verify, verify_type()}</code></strong></dt> <dd><p>A server only does x509-path validation in mode <code class="code">verify_peer</code>, as it then sends a certificate request to the client (this message is not sent if the verify option is <code class="code">verify_none</code>). You can then also want to specify option <code class="code">fail_if_no_peer_cert</code>. </p></dd> <dt><strong><code class="code">{fail_if_no_peer_cert, boolean()}</code></strong></dt> <dd> <p>Used together with <code class="code">{verify, verify_peer}</code> by an TLS/DTLS server. If set to <code class="code">true</code>, the server fails if the client does not have a certificate to send, that is, sends an empty certificate. If set to <code class="code">false</code>, it fails only if the client sends an invalid certificate (an empty certificate is considered valid). Defaults to false.</p> </dd> <dt><strong><code class="code">{reuse_sessions, boolean()}</code></strong></dt> <dd><p>Specifies if the server is to agree to reuse sessions when requested by the clients. See also option <code class="code">reuse_session</code>. </p></dd> <dt><strong><code class="code">{reuse_session, fun(SuggestedSessionId, PeerCert, Compression, CipherSuite) -&gt; boolean()}</code></strong></dt> <dd><p>Enables the TLS/DTLS server to have a local policy for deciding if a session is to be reused or not. Meaningful only if <code class="code">reuse_sessions</code> is set to <code class="code">true</code>. <code class="code">SuggestedSessionId</code> is a <code class="code">binary()</code>, <code class="code">PeerCert</code> is a DER-encoded certificate, <code class="code">Compression</code> is an enumeration integer, and <code class="code">CipherSuite</code> is of type <code class="code">ciphersuite()</code>.</p></dd> <dt><strong><code class="code">{alpn_preferred_protocols, [binary()]}</code></strong></dt> <dd> <p>Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).</p> <p>The list of protocols is in order of preference. The protocol negotiated will be the first in the list that matches one of the protocols advertised by the client. If no protocol matches, the server will fail the connection with a "no_application_protocol" alert.</p> <p>The negotiated protocol can be retrieved using the <code class="code">negotiated_protocol/1</code> function.</p> </dd> <dt><strong><code class="code">{next_protocols_advertised, Protocols :: [binary()]}</code></strong></dt> <dd><p>List of protocols to send to the client if the client indicates that it supports the Next Protocol extension. The client can select a protocol that is not on this list. The list of protocols must not contain an empty binary. If the server negotiates a Next Protocol, it can be accessed using the <code class="code">negotiated_next_protocol/1</code> method.</p></dd> <dt><strong><code class="code">{psk_identity, string()}</code></strong></dt> <dd><p>Specifies the server identity hint, which the server presents to the client.</p></dd> <dt><strong><code class="code">{log_alert, boolean()}</code></strong></dt> <dd><p>If set to <code class="code">false</code>, error reports are not displayed.</p></dd> <dt><strong><code class="code">{honor_cipher_order, boolean()}</code></strong></dt> <dd><p>If set to <code class="code">true</code>, use the server preference for cipher selection. If set to <code class="code">false</code> (the default), use the client preference.</p></dd> <dt><strong><code class="code">{sni_hosts, [{hostname(), [ssl_option()]}]}</code></strong></dt> <dd><p>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the <code class="code">sni_hosts</code> option, the specific options for that host will override previously specified options. The option <code class="code">sni_fun</code>, and <code class="code">sni_hosts</code> are mutually exclusive.</p></dd> <dt><strong><code class="code">{sni_fun, SNIfun::fun()}</code></strong></dt> <dd><p>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve <code class="code">[ssl_option()]</code> for the indicated server. These options will be merged into predefined <code class="code">[ssl_option()]</code>. The function should be defined as: <code class="code">fun(ServerName :: string()) -&gt; [ssl_option()]</code> and can be specified as a fun or as named <code class="code">fun module:function/1</code> The option <code class="code">sni_fun</code>, and <code class="code">sni_hosts</code> are mutually exclusive.</p></dd> <dt><strong><code class="code">{client_renegotiation, boolean()}</code></strong></dt> <dd>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to <code class="code">false</code>. The default value is <code class="code">true</code>. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher. </dd> <dt><strong><code class="code">{honor_cipher_order, boolean()}</code></strong></dt> <dd>If true, use the server's preference for cipher selection. If false (the default), use the client's preference. </dd> <dt><strong><code class="code">{honor_ecc_order, boolean()}</code></strong></dt> <dd>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference. </dd> <dt><strong><code class="code">{signature_algs, [{hash(), ecdsa | rsa | dsa}]}</code></strong></dt> <dd> <p> The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the <code><a href="#client_signature_algs">corresponding client option</a></code>. </p> </dd> </dl>  <h2><span onmouseover="document.getElementById('ghlink-general-id69012').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-general-id69012').style.visibility = 'hidden';" id="general">General</span></h2>  <p>When an TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages:</p> <ul> <li><p><code class="code">{ssl, Socket, Data}</code></p></li> <li><p><code class="code">{ssl_closed, Socket}</code></p></li> <li><p><code class="code">{ssl_error, Socket, Reason}</code></p></li> </ul> <p>A <code class="code">Timeout</code> argument specifies a time-out in milliseconds. The default value for argument <code class="code">Timeout</code> is <code class="code">infinity</code>.</p>  <h2><span onmouseover="document.getElementById('ghlink-exports-id69066').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-id69066').style.visibility = 'hidden';" id="exports">Exports</span></h2> <div class="exports-body"> 
<div><span onmouseover="document.getElementById('ghlink-append_cipher_suites-2-id69073').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-append_cipher_suites-2-id69073').style.visibility = 'hidden';" id="append_cipher_suites-2">append_cipher_suites(Deferred, Suites) -&gt; ciphers() </span></div>  <h2 class="func-types-title">Types</h2>    
<p>Make <code class="code">Deferred</code> suites become the least preferred suites, that is put them at the end of the cipher suite list <code class="code">Suites</code> after removing them from <code class="code">Suites</code> if present. <code class="code">Deferred</code> may be a list of cipher suits or a list of filters in which case the filters are use on <code class="code">Suites</code> to extract the Deferred cipher list.</p>  
<div><span onmouseover="document.getElementById('ghlink-cipher_suites-0-id69124').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cipher_suites-0-id69124').style.visibility = 'hidden';" id="cipher_suites-0">cipher_suites() -&gt;</span></div>
<div><span onmouseover="document.getElementById('ghlink-cipher_suites-1-id69128').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cipher_suites-1-id69128').style.visibility = 'hidden';" id="cipher_suites-1">cipher_suites(Type) -&gt; old_ciphers()</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Deprecated in OTP 21, use <code><a href="#cipher_suites-2">cipher_suites/2</a></code> instead.</p>  
<div><span onmouseover="document.getElementById('ghlink-cipher_suites-2-id69163').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cipher_suites-2-id69163').style.visibility = 'hidden';" id="cipher_suites-2">cipher_suites(Supported, Version) -&gt; ciphers()</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Returns all default or all supported (except anonymous), or all anonymous cipher suites for a TLS version</p>  
<div><span onmouseover="document.getElementById('ghlink-eccs-0-id69195').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-eccs-0-id69195').style.visibility = 'hidden';" id="eccs-0">eccs() -&gt;</span></div>
<div><span onmouseover="document.getElementById('ghlink-eccs-1-id69199').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-eccs-1-id69199').style.visibility = 'hidden';" id="eccs-1">eccs(protocol_version()) -&gt; [named_curve()]</span></div> 
<p>Returns a list of supported ECCs. <code class="code">eccs()</code> is equivalent to calling <code class="code">eccs(Protocol)</code> with all supported protocols and then deduplicating the output.</p>  
<div><span onmouseover="document.getElementById('ghlink-clear_pem_cache-0-id69227').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-clear_pem_cache-0-id69227').style.visibility = 'hidden';" id="clear_pem_cache-0">clear_pem_cache() -&gt; ok </span></div> 
<p>PEM files, used by ssl API-functions, are cached. The cache is regularly checked to see if any cache entries should be invalidated, however this function provides a way to unconditionally clear the whole cache. </p>  
<div><span onmouseover="document.getElementById('ghlink-connect-2-id69249').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-connect-2-id69249').style.visibility = 'hidden';" id="connect-2">connect(Socket, SslOptions) -&gt; </span></div>
<div><span onmouseover="document.getElementById('ghlink-connect-3-id69253').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-connect-3-id69253').style.visibility = 'hidden';" id="connect-3">connect(Socket, SslOptions, Timeout) -&gt; {ok, SslSocket} | {ok, SslSocket, Ext} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>        
<p>Upgrades a <code class="code">gen_tcp</code>, or equivalent, connected socket to an TLS socket, that is, performs the client-side TLS handshake.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If the option <code class="code">verify</code> is set to <code class="code">verify_peer</code> the option <code class="code">server_name_indication</code> shall also be specified, if it is not no Server Name Indication extension will be sent, and <code>public_key:pkix_verify_hostname/2</code> will be called with the IP-address of the connection as <code class="code">ReferenceID</code>, which is proably not what you want.</p> </div> </div> <p> If the option <code class="code">{handshake, hello}</code> is used the handshake is paused after receiving the server hello message and the success response is <code class="code">{ok, SslSocket, Ext}</code> instead of <code class="code">{ok, SslSocket}</code>. Thereafter the handshake is continued or canceled by calling <code><a href="#handshake_continue-3"><span class="code">handshake_continue/3</span></a></code> or <code><a href="#handshake_cancel-1"><span class="code">handshake_cancel/1</span></a></code>. </p>  
<div><span onmouseover="document.getElementById('ghlink-connect-3-id66647').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-connect-3-id66647').style.visibility = 'hidden';" id="connect-3">connect(Host, Port, Options) -&gt;</span></div>
<div><span onmouseover="document.getElementById('ghlink-connect-4-id66651').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-connect-4-id66651').style.visibility = 'hidden';" id="connect-4">connect(Host, Port, Options, Timeout) -&gt; {ok, SslSocket}| {ok, SslSocket, Ext} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>        
<p>Opens an TLS/DTLS connection to <code class="code">Host</code>, <code class="code">Port</code>.</p> <p> When the option <code class="code">verify</code> is set to <code class="code">verify_peer</code> the check <code>public_key:pkix_verify_hostname/2</code> will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun <code><a href="#verify_fun">verify_fun</a></code>, where it is possible to do customized checks by using the full possibilities of the <code>public_key:pkix_verify_hostname/3</code> API. When the option <code class="code">server_name_indication</code> is provided, its value (the DNS name) will be used as <code class="code">ReferenceID</code> to <code>public_key:pkix_verify_hostname/2</code>. When no <code class="code">server_name_indication</code> option is given, the <code class="code">Host</code> argument will be used as Server Name Indication extension. The <code class="code">Host</code> argument will also be used for the <code>public_key:pkix_verify_hostname/2</code> check and if the <code class="code">Host</code> argument is an <code class="code">inet:ip_address()</code> the <code class="code">ReferenceID</code> used for the check will be <code class="code">{ip, Host}</code> otherwise <code class="code">dns_id</code> will be assumed with a fallback to <code class="code">ip</code> if that fails. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>According to good practices certificates should not use IP-addresses as "server names". It would be very surprising if this happen outside a closed network. </p>
</div> </div> <p> If the option <code class="code">{handshake, hello}</code> is used the handshake is paused after receiving the server hello message and the success response is <code class="code">{ok, SslSocket, Ext}</code> instead of <code class="code">{ok, SslSocket}</code>. Thereafter the handshake is continued or canceled by calling <code><a href="#handshake_continue-3"><span class="code">handshake_continue/3</span></a></code> or <code><a href="#handshake_cancel-1"><span class="code">handshake_cancel/1</span></a></code>. </p>  
<div><span onmouseover="document.getElementById('ghlink-close-1-id66838').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-close-1-id66838').style.visibility = 'hidden';" id="close-1">close(SslSocket) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Closes an TLS/DTLS connection.</p>  
<div><span onmouseover="document.getElementById('ghlink-close-2-id66869').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-close-2-id66869').style.visibility = 'hidden';" id="close-2">close(SslSocket, How) -&gt; ok | {ok, port()} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Closes or downgrades an TLS connection. In the latter case the transport connection will be handed over to the <code class="code">NewController</code> process after receiving the TLS close alert from the peer. The returned transport socket will have the following options set: <code class="code">[{active, false}, {packet, 0}, {mode, binary}]</code></p>  
<div><span onmouseover="document.getElementById('ghlink-controlling_process-2-id66913').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-controlling_process-2-id66913').style.visibility = 'hidden';" id="controlling_process-2">controlling_process(SslSocket, NewOwner) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Assigns a new controlling process to the SSL socket. A controlling process is the owner of an SSL socket, and receives all messages from the socket.</p>  
<div><span onmouseover="document.getElementById('ghlink-connection_information-1-id66950').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-connection_information-1-id66950').style.visibility = 'hidden';" id="connection_information-1">connection_information(SslSocket) -&gt; {ok, Result} | {error, Reason} </span></div>  <h2 class="func-types-title">Types</h2>   <p class="REFBODY rb-6">Meaningful atoms, not specified above, are the ssl option names.</p>    
<p>Returns the most relevant information about the connection, ssl options that are undefined will be filtered out. Note that values that affect the security of the connection will only be returned if explicitly requested by connection_information/2.</p>  
<div><span onmouseover="document.getElementById('ghlink-connection_information-2-id66996').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-connection_information-2-id66996').style.visibility = 'hidden';" id="connection_information-2">connection_information(SslSocket, Items) -&gt; {ok, Result} | {error, Reason} </span></div>  <h2 class="func-types-title">Types</h2>    <p class="REFBODY rb-6">Note that client_random, server_random and master_secret are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</p>    
<p>Returns the requested information items about the connection, if they are defined.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If only undefined options are requested the resulting list can be empty.</p>
</div> </div>  
<div><span onmouseover="document.getElementById('ghlink-filter_cipher_suites-2-id67051').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-filter_cipher_suites-2-id67051').style.visibility = 'hidden';" id="filter_cipher_suites-2">filter_cipher_suites(Suites, Filters) -&gt; ciphers()</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Removes cipher suites if any of the filter functions returns false for any part of the cipher suite. This function also calls default filter functions to make sure the cipher suites are supported by crypto. If no filter function is supplied for some part the default behaviour is fun(Algorithm) -&gt; true.</p>  
<div><span onmouseover="document.getElementById('ghlink-format_error-1-id67084').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-format_error-1-id67084').style.visibility = 'hidden';" id="format_error-1">format_error(Reason) -&gt; string()</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Presents the error returned by an SSL function as a printable string.</p>  
<div><span onmouseover="document.getElementById('ghlink-getopts-2-id67113').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-getopts-2-id67113').style.visibility = 'hidden';" id="getopts-2">getopts(SslSocket, OptionNames) -&gt; {ok, [socketoption()]} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Gets the values of the specified socket options. </p>  
<div><span onmouseover="document.getElementById('ghlink-getstat-1-id67146').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-getstat-1-id67146').style.visibility = 'hidden';" id="getstat-1">getstat(SslSocket) -&gt; {ok, OptionValues} | {error, inet:posix()}</span></div>
<div><span onmouseover="document.getElementById('ghlink-getstat-2-id67150').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-getstat-2-id67150').style.visibility = 'hidden';" id="getstat-2">getstat(SslSocket, OptionNames) -&gt; {ok, OptionValues} | {error, inet:posix()}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Gets one or more statistic options for the underlying TCP socket.</p> <p>See inet:getstat/2 for statistic options description.</p>  
<div><span onmouseover="document.getElementById('ghlink-handshake-1-id67883').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-handshake-1-id67883').style.visibility = 'hidden';" id="handshake-1">handshake(HsSocket) -&gt; </span></div>
<div><span onmouseover="document.getElementById('ghlink-handshake-2-id67887').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-handshake-2-id67887').style.visibility = 'hidden';" id="handshake-2">handshake(HsSocket, Timeout) -&gt; {ok, SslSocket} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Performs the SSL/TLS/DTLS server-side handshake.</p> <p>Returns a new TLS/DTLS socket if the handshake is successful.</p>  
<div><span onmouseover="document.getElementById('ghlink-handshake-2-id67928').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-handshake-2-id67928').style.visibility = 'hidden';" id="handshake-2">handshake(Socket, SslOptions) -&gt; </span></div>
<div><span onmouseover="document.getElementById('ghlink-handshake-3-id67932').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-handshake-3-id67932').style.visibility = 'hidden';" id="handshake-3">handshake(Socket, SslOptions, Timeout) -&gt; {ok, SslSocket} | {ok, SslSocket, Ext} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>        
<p>If <code class="code">Socket</code> is a ordinary <code class="code">socket()</code>: upgrades a <code class="code">gen_tcp</code>, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>The <code class="code">Socket</code> shall be in passive mode ({active, false}) before calling this function or else the behavior of this function is undefined. </p>
</div> </div> <p>If <code class="code">Socket</code> is an <code class="code">sslsocket()</code>: provides extra SSL/TLS/DTLS options to those specified in <code><a href="#listen-2">listen/2</a></code> and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</p> <p> If option <code class="code">{handshake, hello}</code> is specified the handshake is paused after receiving the client hello message and the success response is <code class="code">{ok, SslSocket, Ext}</code> instead of <code class="code">{ok, SslSocket}</code>. Thereafter the handshake is continued or canceled by calling <code><a href="#handshake_continue-3"><span class="code">handshake_continue/3</span></a></code> or <code><a href="#handshake_cancel-1"><span class="code">handshake_cancel/1</span></a></code>. </p>  
<div><span onmouseover="document.getElementById('ghlink-handshake_cancel-1-id68052').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-handshake_cancel-1-id68052').style.visibility = 'hidden';" id="handshake_cancel-1">handshake_cancel(SslSocket) -&gt; ok </span></div>  <h2 class="func-types-title">Types</h2>   
<p>Cancel the handshake with a fatal <code class="code">USER_CANCELED</code> alert.</p>  
<div><span onmouseover="document.getElementById('ghlink-handshake_continue-2-id68085').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-handshake_continue-2-id68085').style.visibility = 'hidden';" id="handshake_continue-2">handshake_continue(HsSocket, SSLOptions) -&gt; {ok, SslSocket} | {error, Reason}</span></div>
<div><span onmouseover="document.getElementById('ghlink-handshake_continue-3-id68089').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-handshake_continue-3-id68089').style.visibility = 'hidden';" id="handshake_continue-3">handshake_continue(HsSocket, SSLOptions, Timeout) -&gt; {ok, SslSocket} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>      
<p>Continue the SSL/TLS handshake possiby with new, additional or changed options.</p>  
<div><span onmouseover="document.getElementById('ghlink-listen-2-id68130').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-listen-2-id68130').style.visibility = 'hidden';" id="listen-2">listen(Port, Options) -&gt; {ok, ListenSocket} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Creates an SSL listen socket.</p>  
<div><span onmouseover="document.getElementById('ghlink-negotiated_protocol-1-id68167').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-negotiated_protocol-1-id68167').style.visibility = 'hidden';" id="negotiated_protocol-1">negotiated_protocol(SslSocket) -&gt; {ok, Protocol} | {error, protocol_not_negotiated}</span></div>  <h2 class="func-types-title">Types</h2>    
<p> Returns the protocol negotiated through ALPN or NPN extensions. </p>  
<div><span onmouseover="document.getElementById('ghlink-peercert-1-id68201').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-peercert-1-id68201').style.visibility = 'hidden';" id="peercert-1">peercert(SslSocket) -&gt; {ok, Cert} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>    
<p>The peer certificate is returned as a DER-encoded binary. The certificate can be decoded with <code>public_key:pkix_decode_cert/2</code> </p>  
<div><span onmouseover="document.getElementById('ghlink-peername-1-id68241').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-peername-1-id68241').style.visibility = 'hidden';" id="peername-1">peername(SslSocket) -&gt; {ok, {Address, Port}} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Returns the address and port number of the peer.</p>  
<div><span onmouseover="document.getElementById('ghlink-prepend_cipher_suites-2-id68278').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-prepend_cipher_suites-2-id68278').style.visibility = 'hidden';" id="prepend_cipher_suites-2">prepend_cipher_suites(Preferred, Suites) -&gt; ciphers()</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Make <code class="code">Preferred</code> suites become the most preferred suites that is put them at the head of the cipher suite list <code class="code">Suites</code> after removing them from <code class="code">Suites</code> if present. <code class="code">Preferred</code> may be a list of cipher suits or a list of filters in which case the filters are use on <code class="code">Suites</code> to extract the preferred cipher list. </p>  
<div><span onmouseover="document.getElementById('ghlink-prf-5-id68328').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-prf-5-id68328').style.visibility = 'hidden';" id="prf-5">prf(Socket, Secret, Label, Seed, WantedLength) -&gt; {ok, binary()} | {error, reason()}</span></div>  <h2 class="func-types-title">Types</h2>       
<p>Uses the Pseudo-Random Function (PRF) of a TLS session to generate extra key material. It either takes user-generated values for <code class="code">Secret</code> and <code class="code">Seed</code> or atoms directing it to use a specific value from the session security parameters.</p> <p>Can only be used with TLS/DTLS connections; <code class="code">{error, undefined}</code> is returned for SSLv3 connections.</p>  
<div><span onmouseover="document.getElementById('ghlink-recv-2-id68390').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-recv-2-id68390').style.visibility = 'hidden';" id="recv-2">recv(SslSocket, Length) -&gt; </span></div>
<div><span onmouseover="document.getElementById('ghlink-recv-3-id68394').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-recv-3-id68394').style.visibility = 'hidden';" id="recv-3">recv(SslSocket, Length, Timeout) -&gt; {ok, Data} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>      
<p>Receives a packet from a socket in passive mode. A closed socket is indicated by return value <code class="code">{error, closed}</code>.</p> <p>Argument <code class="code">Length</code> is meaningful only when the socket is in mode <code class="code">raw</code> and denotes the number of bytes to read. If <code class="code">Length</code> = 0, all available bytes are returned. If <code class="code">Length</code> &gt; 0, exactly <code class="code">Length</code> bytes are returned, or an error; possibly discarding less than <code class="code">Length</code> bytes of data when the socket gets closed from the other side.</p> <p>Optional argument <code class="code">Timeout</code> specifies a time-out in milliseconds. The default value is <code class="code">infinity</code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-renegotiate-1-id68478').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-renegotiate-1-id68478').style.visibility = 'hidden';" id="renegotiate-1">renegotiate(SslSocket) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Initiates a new handshake. A notable return value is <code class="code">{error, renegotiation_rejected}</code> indicating that the peer refused to go through with the renegotiation, but the connection is still active using the previously negotiated session.</p>  
<div><span onmouseover="document.getElementById('ghlink-send-2-id68511').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send-2-id68511').style.visibility = 'hidden';" id="send-2">send(SslSocket, Data) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Writes <code class="code">Data</code> to <code class="code">Socket</code>.</p> <p>A notable return value is <code class="code">{error, closed}</code> indicating that the socket is closed.</p>  
<div><span onmouseover="document.getElementById('ghlink-setopts-2-id68559').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-setopts-2-id68559').style.visibility = 'hidden';" id="setopts-2">setopts(SslSocket, Options) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Sets options according to <code class="code">Options</code> for socket <code class="code">Socket</code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-shutdown-2-id68600').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-shutdown-2-id68600').style.visibility = 'hidden';" id="shutdown-2">shutdown(SslSocket, How) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Immediately closes a socket in one or two directions.</p> <p><code class="code">How == write</code> means closing the socket for writing, reading from it is still possible.</p> <p>To be able to handle that the peer has done a shutdown on the write side, option <code class="code">{exit_on_close, false}</code> is useful.</p>  
<div><span onmouseover="document.getElementById('ghlink-ssl_accept-1-id68651').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-ssl_accept-1-id68651').style.visibility = 'hidden';" id="ssl_accept-1">ssl_accept(SslSocket) -&gt; </span></div>
<div><span onmouseover="document.getElementById('ghlink-ssl_accept-2-id68655').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-ssl_accept-2-id68655').style.visibility = 'hidden';" id="ssl_accept-2">ssl_accept(SslSocket, Timeout) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Deprecated in OTP 21, use <code><a href="#handshake-1">handshake/[1,2]</a></code> instead.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>handshake/[1,2] always returns a new socket.</p>
</div> </div>  
<div><span onmouseover="document.getElementById('ghlink-ssl_accept-2-id68703').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-ssl_accept-2-id68703').style.visibility = 'hidden';" id="ssl_accept-2">ssl_accept(Socket, SslOptions) -&gt; </span></div>
<div><span onmouseover="document.getElementById('ghlink-ssl_accept-3-id68707').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-ssl_accept-3-id68707').style.visibility = 'hidden';" id="ssl_accept-3">ssl_accept(Socket, SslOptions, Timeout) -&gt; {ok, Socket} | ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>      
<p>Deprecated in OTP 21, use <code><a href="#handshake-3">handshake/[2,3]</a></code> instead.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>handshake/[2,3] always returns a new socket.</p>
</div> </div>  
<div><span onmouseover="document.getElementById('ghlink-sockname-1-id73401').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-sockname-1-id73401').style.visibility = 'hidden';" id="sockname-1">sockname(SslSocket) -&gt; {ok, {Address, Port}} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Returns the local address and port number of socket <code class="code">Socket</code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-start-0-id73442').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start-0-id73442').style.visibility = 'hidden';" id="start-0">start() -&gt; </span></div>
<div><span onmouseover="document.getElementById('ghlink-start-1-id73445').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start-1-id73445').style.visibility = 'hidden';" id="start-1">start(Type) -&gt; ok | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Starts the SSL application. Default type is <code class="code">temporary</code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-stop-0-id73478').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-stop-0-id73478').style.visibility = 'hidden';" id="stop-0">stop() -&gt; ok </span></div> 
<p>Stops the SSL application.</p>  
<div><span onmouseover="document.getElementById('ghlink-suite_to_str-1-id73500').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-suite_to_str-1-id73500').style.visibility = 'hidden';" id="suite_to_str-1">suite_to_str(CipherSuite) -&gt; String</span></div>  <h2 class="func-types-title">Types</h2>    
<p>Returns the string representation of a cipher suite.</p>  
<div><span onmouseover="document.getElementById('ghlink-transport_accept-1-id73533').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-transport_accept-1-id73533').style.visibility = 'hidden';" id="transport_accept-1">transport_accept(ListenSocket) -&gt;</span></div>
<div><span onmouseover="document.getElementById('ghlink-transport_accept-2-id73537').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-transport_accept-2-id73537').style.visibility = 'hidden';" id="transport_accept-2">transport_accept(ListenSocket, Timeout) -&gt; {ok, SslSocket} | {error, Reason}</span></div>  <h2 class="func-types-title">Types</h2>     
<p>Accepts an incoming connection request on a listen socket. <code class="code">ListenSocket</code> must be a socket returned from <code><a href="#listen-2">listen/2</a></code>. The socket returned is to be passed to <code><a href="#handshake-2">handshake/[2,3]</a></code> to complete handshaking, that is, establishing the SSL/TLS/DTLS connection.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>The socket returned can only be used with <code><a href="#handshake-2">handshake/[2,3]</a></code>. No traffic can be sent or received before that call.</p> </div> </div> <p>The accepted socket inherits the options set for <code class="code">ListenSocket</code> in <code><a href="#listen-2">listen/2</a></code>.</p> <p>The default value for <code class="code">Timeout</code> is <code class="code">infinity</code>. If <code class="code">Timeout</code> is specified and no connection is accepted within the given time, <code class="code">{error, timeout}</code> is returned.</p>  
<div><span onmouseover="document.getElementById('ghlink-versions-0-id73641').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-versions-0-id73641').style.visibility = 'hidden';" id="versions-0">versions() -&gt; [versions_info()]</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Returns version information relevant for the SSL application.</p> <dl> <dt><strong><code class="code">app_vsn</code></strong></dt> <dd>The application version of the SSL application.</dd> <dt><strong><code class="code">supported</code></strong></dt> <dd>SSL/TLS versions supported by default. Overridden by a version option on <code><a href="#connect-2">connect/[2,3,4]</a></code>, <code><a href="#listen-2">listen/2</a></code>, and <code><a href="#ssl_accept-2">ssl_accept/[1,2,3]</a></code>. For the negotiated SSL/TLS version, see <code><a href="#connection_information-1">connection_information/1</a></code>.</dd> <dt><strong><code class="code">supported_dtls</code></strong></dt> <dd>DTLS versions supported by default. Overridden by a version option on <code><a href="#connect-2">connect/[2,3,4]</a></code>, <code><a href="#listen-2">listen/2</a></code>, and <code><a href="#ssl_accept-2">ssl_accept/[1,2,3]</a></code>. For the negotiated DTLS version, see <code><a href="#connection_information-1">connection_information/1</a></code>.</dd> <dt><strong><code class="code">available</code></strong></dt> <dd>All SSL/TLS versions supported by the SSL application. TLS 1.2 requires sufficient support from the Crypto application.</dd> <dt><strong><code class="code">available_dtls</code></strong></dt> <dd>All DTLS versions supported by the SSL application. DTLS 1.2 requires sufficient support from the Crypto application.</dd> </dl>  </div> <h2>See also</h2>  <p><code>inet(3)</code> and <code>gen_tcp(3)</code> <code>gen_udp(3)</code> </p>
<div class="_attribution">
  <p class="_attribution-p">
     20102017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
