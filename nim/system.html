
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>System - Nim - W3cubDocs</title>
  
  <meta name="description" content="The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use &hellip;">
  <meta name="keywords" content="module, system, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/system.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module system</h1>  <p class="module-desc">The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named <code>system</code>. </p>
<h2 id="module-system">Module system</h2>Expands operating GC stack range to <em>theStackBottom</em>. Does nothing if current stack bottom is already lower than <em>theStackBottom</em>.  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">int {...}{.magic: Int.}</pre></dt> <dd> default integer type; bitwidth depends on architecture, but is always the same as a pointer   </dd>  <dt><pre data-language="nim">int8 {...}{.magic: Int8.}</pre></dt> <dd> signed 8 bit integer type   </dd>  <dt><pre data-language="nim">int16 {...}{.magic: Int16.}</pre></dt> <dd> signed 16 bit integer type   </dd>  <dt><pre data-language="nim">int32 {...}{.magic: Int32.}</pre></dt> <dd> signed 32 bit integer type   </dd>  <dt><pre data-language="nim">int64 {...}{.magic: Int64.}</pre></dt> <dd> signed 64 bit integer type   </dd>  <dt><pre data-language="nim">uint {...}{.magic: UInt.}</pre></dt> <dd> unsigned default integer type   </dd>  <dt><pre data-language="nim">uint8 {...}{.magic: UInt8.}</pre></dt> <dd> unsigned 8 bit integer type   </dd>  <dt><pre data-language="nim">uint16 {...}{.magic: UInt16.}</pre></dt> <dd> unsigned 16 bit integer type   </dd>  <dt><pre data-language="nim">uint32 {...}{.magic: UInt32.}</pre></dt> <dd> unsigned 32 bit integer type   </dd>  <dt><pre data-language="nim">uint64 {...}{.magic: UInt64.}</pre></dt> <dd> unsigned 64 bit integer type   </dd>  <dt><pre data-language="nim">float {...}{.magic: Float.}</pre></dt> <dd> default floating point type   </dd>  <dt><pre data-language="nim">float32 {...}{.magic: Float32.}</pre></dt> <dd> 32 bit floating point type   </dd>  <dt><pre data-language="nim">float64 {...}{.magic: Float.}</pre></dt> <dd> 64 bit floating point type   </dd>  <dt><pre data-language="nim">bool {...}{.magic: Bool.} = enum
  false = 0, true = 1</pre></dt> <dd> built-in boolean type   </dd>  <dt><pre data-language="nim">char {...}{.magic: Char.}</pre></dt> <dd> built-in 8 bit character type (unsigned)   </dd>  <dt><pre data-language="nim">string {...}{.magic: String.}</pre></dt> <dd> built-in string type   </dd>  <dt><pre data-language="nim">cstring {...}{.magic: Cstring.}</pre></dt> <dd> built-in cstring (<em>compatible string</em>) type   </dd>  <dt><pre data-language="nim">pointer {...}{.magic: Pointer.}</pre></dt> <dd> built-in pointer type, use the <code>addr</code> operator to get a pointer to a variable   </dd>  <dt><pre data-language="nim">typedesc {...}{.magic: TypeDesc.}</pre></dt> <dd> meta type to denote a type description   </dd>  <dt><pre data-language="nim">Ordinal {...}{.magic: Ordinal.}[T]</pre></dt> <dd> Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. Note <em>uint</em> and <em>uint64</em> are not ordinal types for implementation reasons   </dd>  <dt><pre data-language="nim">ptr {...}{.magic: Pointer.}[T]</pre></dt> <dd> built-in generic untraced pointer type   </dd>  <dt><pre data-language="nim">ref {...}{.magic: Pointer.}[T]</pre></dt> <dd> built-in generic traced pointer type   </dd>  <dt><pre data-language="nim">void {...}{.magic: "VoidType".}</pre></dt> <dd> meta type to denote the absence of any type   </dd>  <dt><pre data-language="nim">auto {...}{.magic: Expr.}</pre></dt> <dd> meta type for automatic type determination   </dd>  <dt><pre>any = distinct auto</pre></dt> <dd> meta type for any supported type   </dd>  <dt><pre data-language="nim">untyped {...}{.magic: Expr.}</pre></dt> <dd> meta type to denote an expression that is not resolved (for templates)   </dd>  <dt><pre data-language="nim">typed {...}{.magic: Stmt.}</pre></dt> <dd> meta type to denote an expression that is resolved (for templates)   </dd>  <dt><pre data-language="nim">SomeSignedInt = int | int8 | int16 | int32 | int64</pre></dt> <dd> type class matching all signed integer types   </dd>  <dt><pre data-language="nim">SomeUnsignedInt = uint | uint8 | uint16 | uint32 | uint64</pre></dt> <dd> type class matching all unsigned integer types   </dd>  <dt><pre data-language="nim">SomeInteger = SomeSignedInt | SomeUnsignedInt</pre></dt> <dd> type class matching all integer types   </dd>  <dt><pre data-language="nim">SomeOrdinal = int | int8 | int16 | int32 | int64 | bool | enum | uint8 | uint16 | uint32</pre></dt> <dd> type class matching all ordinal types; however this includes enums with holes.   </dd>  <dt><pre data-language="nim">SomeFloat = float | float32 | float64</pre></dt> <dd> type class matching all floating point number types   </dd>  <dt><pre data-language="nim">SomeNumber = SomeInteger | SomeFloat</pre></dt> <dd> type class matching all number types   </dd>  <dt><pre data-language="nim">static {...}{.magic: "Static".}[T]</pre></dt> <dd> <p>meta type representing all values that can be evaluated at compile-time.</p> <p>The type coercion <code>static(x)</code> can be used to force the compile-time evaluation of the given expression <code>x</code>.</p>   </dd>  <dt><pre data-language="nim">type {...}{.magic: "Type".}[T]</pre></dt> <dd> <p>meta type representing the type of all type values.</p> <p>The coercion <code>type(x)</code> can be used to obtain the type of the given expression <code>x</code>.</p>   </dd>  <dt><pre data-language="nim">range {...}{.magic: "Range".}[T]</pre></dt> <dd> Generic type to construct range types.   </dd>  <dt><pre data-language="nim">array {...}{.magic: "Array".}[I; T]</pre></dt> <dd> Generic type to construct fixed-length arrays.   </dd>  <dt><pre data-language="nim">openArray {...}{.magic: "OpenArray".}[T]</pre></dt> <dd> Generic type to construct open arrays. Open arrays are implemented as a pointer to the array data and a length field.   </dd>  <dt><pre data-language="nim">varargs {...}{.magic: "Varargs".}[T]</pre></dt> <dd> Generic type to construct a varargs type.   </dd>  <dt><pre data-language="nim">seq {...}{.magic: "Seq".}[T]</pre></dt> <dd> Generic type to construct sequences.   </dd>  <dt><pre data-language="nim">set {...}{.magic: "Set".}[T]</pre></dt> <dd> Generic type to construct bit sets.   </dd>  <dt><pre data-language="nim">UncheckedArray {...}{.unchecked.}[T] = array[0, T]</pre></dt> <dd> Array with no bounds checking   </dd>  <dt><pre data-language="nim">sink {...}{.magic: "BuiltinType".}[T]</pre></dt>   <dt><pre data-language="nim">lent {...}{.magic: "BuiltinType".}[T]</pre></dt>   <dt><pre data-language="nim">HSlice[T; U] = object
  a*: T                        ## the lower bound (inclusive)
  b*: U                        ## the upper bound (inclusive)</pre></dt> <dd> "heterogenous" slice type   </dd>  <dt><pre data-language="nim">Slice[T] = HSlice[T, T]</pre></dt> <dd> an alias for <code>HSlice[T, T]</code>   </dd>  <dt><pre>byte = uint8</pre></dt> <dd> this is an alias for <code>uint8</code>, that is an unsigned int 8 bits wide.   </dd>  <dt><pre data-language="nim">Natural = range[0 .. high(int)]</pre></dt> <dd> is an int type ranging from zero to the maximum value of an int. This type is often useful for documentation and debugging.   </dd>  <dt><pre data-language="nim">Positive = range[1 .. high(int)]</pre></dt> <dd> is an int type ranging from one to the maximum value of an int. This type is often useful for documentation and debugging.   </dd>  <dt><pre data-language="nim">RootObj {...}{.compilerProc, inheritable.} = object</pre></dt> <dd> the root of Nim's object hierarchy. Objects should inherit from RootObj or one of its descendants. However, objects that have no ancestor are allowed.   </dd>  <dt><pre>RootRef = ref RootObj</pre></dt> <dd> reference to RootObj   </dd>  <dt><pre data-language="nim">RootEffect {...}{.compilerproc.} = object of RootObj</pre></dt> <dd> base effect class; each effect should inherit from <em>RootEffect</em> unless you know what you doing.   </dd>  <dt><pre>TimeEffect = object of RootEffect</pre></dt> <dd> Time effect.   </dd>  <dt><pre>IOEffect = object of RootEffect</pre></dt> <dd> IO effect.   </dd>  <dt><pre>ReadIOEffect = object of IOEffect</pre></dt> <dd> Effect describing a read IO operation.   </dd>  <dt><pre>WriteIOEffect = object of IOEffect</pre></dt> <dd> Effect describing a write IO operation.   </dd>  <dt><pre>ExecIOEffect = object of IOEffect</pre></dt> <dd> Effect describing an executing IO operation.   </dd>  <dt><pre data-language="nim">StackTraceEntry = object
  procname*: cstring           ## name of the proc that is currently executing
  line*: int                   ## line number of the proc that is currently executing
  filename*: cstring           ## filename of the proc that is currently executing</pre></dt> <dd> In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace.   </dd>  <dt><pre data-language="nim">Exception {...}{.compilerproc, magic: "Exception".} = object of RootObj
  parent*: ref Exception        ## parent exception (can be used as a stack)
  name*: cstring               ## The exception's name is its Nim identifier.
               ## This field is filled automatically in the
               ## ``raise`` statement.
  msg* {...}{.exportc: "message".}: string ## the exception's message. Not
                                  ## providing an exception message
                                  ## is bad style.
  when defined(js):
      trace: string

  else:
      trace: seq[StackTraceEntry]

  raise_id: uint
  up: ref Exception</pre></dt> <dd> <p> Base exception class.</p> <p>Each exception has to inherit from <em>Exception</em>. See the full <a href="manual#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd>  <dt><pre>Defect = object of Exception</pre></dt> <dd> Abstract base class for all exceptions that Nim's runtime raises but that are strictly uncatchable as they can also be mapped to a <code>quit</code> / <code>trap</code> / <code>exit</code> operation.   </dd>  <dt><pre>CatchableError = object of Exception</pre></dt> <dd> Abstract class for all exceptions that are catchable.   </dd>  <dt><pre>IOError = object of CatchableError</pre></dt> <dd> Raised if an IO error occurred.   </dd>  <dt><pre>EOFError = object of IOError</pre></dt> <dd> Raised if an IO "end of file" error occurred.   </dd>  <dt><pre data-language="nim">OSError = object of CatchableError
  errorCode*: int32            ## OS-defined error code describing this error.</pre></dt> <dd> Raised if an operating system service failed.   </dd>  <dt><pre>LibraryError = object of OSError</pre></dt> <dd> Raised if a dynamic library could not be loaded.   </dd>  <dt><pre>ResourceExhaustedError = object of CatchableError</pre></dt> <dd> Raised if a resource request could not be fulfilled.   </dd>  <dt><pre>ArithmeticError = object of Defect</pre></dt> <dd> Raised if any kind of arithmetic error occurred.   </dd>  <dt><pre>DivByZeroError = object of ArithmeticError</pre></dt> <dd> Raised for runtime integer divide-by-zero errors.   </dd>  <dt><pre>OverflowError = object of ArithmeticError</pre></dt> <dd> <p> Raised for runtime integer overflows.</p> <p>This happens for calculations whose results are too large to fit in the provided bits.</p>   </dd>  <dt><pre>AccessViolationError = object of Defect</pre></dt> <dd> Raised for invalid memory access errors   </dd>  <dt><pre>AssertionError = object of Defect</pre></dt> <dd> <p> Raised when assertion is proved wrong.</p> <p>Usually the result of using the <a href="#assert">assert() template</a>.</p>   </dd>  <dt><pre>ValueError = object of Defect</pre></dt> <dd> Raised for string and object conversion errors.   </dd>  <dt><pre>KeyError = object of ValueError</pre></dt> <dd> <p> Raised if a key cannot be found in a table.</p> <p>Mostly used by the <a href="tables">tables</a> module, it can also be raised by other collection modules like <a href="sets">sets</a> or <a href="strtabs">strtabs</a>.</p>   </dd>  <dt><pre>OutOfMemError = object of Defect</pre></dt> <dd> Raised for unsuccessful attempts to allocate memory.   </dd>  <dt><pre>IndexError = object of Defect</pre></dt> <dd> Raised if an array index is out of bounds.   </dd>  <dt><pre>FieldError = object of Defect</pre></dt> <dd> Raised if a record field is not accessible because its dicriminant's value does not fit.   </dd>  <dt><pre>RangeError = object of Defect</pre></dt> <dd> Raised if a range check error occurred.   </dd>  <dt><pre>StackOverflowError = object of Defect</pre></dt> <dd> Raised if the hardware stack used for subroutine calls overflowed.   </dd>  <dt><pre>ReraiseError = object of Defect</pre></dt> <dd> Raised if there is no exception to reraise.   </dd>  <dt><pre>ObjectAssignmentError = object of Defect</pre></dt> <dd> Raised if an object gets assigned to its parent's object.   </dd>  <dt><pre>ObjectConversionError = object of Defect</pre></dt> <dd> Raised if an object is converted to an incompatible object type. You can use <code>of</code> operator to check if conversion will succeed.   </dd>  <dt><pre>FloatingPointError = object of Defect</pre></dt> <dd> Base class for floating point exceptions.   </dd>  <dt><pre>FloatInvalidOpError = object of FloatingPointError</pre></dt> <dd> <p> Raised by invalid operations according to IEEE.</p> <p>Raised by <code>0.0/0.0</code>, for example.</p>   </dd>  <dt><pre>FloatDivByZeroError = object of FloatingPointError</pre></dt> <dd> <p> Raised by division by zero.</p> <p>Divisor is zero and dividend is a finite nonzero number.</p>   </dd>  <dt><pre>FloatOverflowError = object of FloatingPointError</pre></dt> <dd> <p> Raised for overflows.</p> <p>The operation produced a result that exceeds the range of the exponent.</p>   </dd>  <dt><pre>FloatUnderflowError = object of FloatingPointError</pre></dt> <dd> <p> Raised for underflows.</p> <p>The operation produced a result that is too small to be represented as a normal number.</p>   </dd>  <dt><pre>FloatInexactError = object of FloatingPointError</pre></dt> <dd> <p> Raised for inexact results.</p> <p>The operation produced a result that cannot be represented with infinite precision -- for example: <code>2.0 / 3.0, log(1.1)</code></p> <p><strong>NOTE</strong>: Nim currently does not detect these!</p>   </dd>  <dt><pre>DeadThreadError = object of Defect</pre></dt> <dd> Raised if it is attempted to send a message to a dead thread.   </dd>  <dt><pre>NilAccessError = object of Defect</pre></dt> <dd> <p> Raised on dereferences of <code>nil</code> pointers.</p> <p>This is only raised if the <code>segfaults.nim</code> module was imported!</p>   </dd>  <dt><pre>MoveError = object of Defect</pre></dt> <dd> Raised on attempts to re-sink an already consumed <code>sink</code> parameter.   </dd>  <dt><pre>JsRoot = ref object of RootObj</pre></dt> <dd> Root type of the JavaScript object hierarchy   </dd>  <dt><pre data-language="nim">Endianness = enum
  littleEndian, bigEndian</pre></dt> <dd> is a type describing the endianness of a processor.   </dd>  <dt><pre>TaintedString = string</pre></dt> <dd> a distinct string type that is <span id="tainted_1">tainted</span>, see <a href="manual#taint-mode">taint mode</a> for details. It is an alias for <code>string</code> if the taint mode is not turned on.   </dd>  <dt><pre>ByteAddress = int</pre></dt> <dd> is the signed integer type that should be used for converting pointers to integer addresses for readability.   </dd>  <dt><pre>BiggestInt = int64</pre></dt> <dd> is an alias for the biggest signed integer type the Nim compiler supports. Currently this is <code>int64</code>, but it is platform-dependant in general.   </dd>  <dt><pre>BiggestFloat = float64</pre></dt> <dd> is an alias for the biggest floating point type the Nim compiler supports. Currently this is <code>float64</code>, but it is platform-dependant in general.   </dd>  <dt><pre>BiggestUInt = uint64</pre></dt> <dd> is an alias for the biggest unsigned integer type the Nim compiler supports. Currently this is <code>uint32</code> for JS and <code>uint64</code> for other targets.   </dd>  <dt><pre data-language="nim">clong {...}{.importc: "long", nodecl.} = int32</pre></dt> <dd> This is the same as the type <code>long</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">culong {...}{.importc: "unsigned long", nodecl.} = uint32</pre></dt> <dd> This is the same as the type <code>unsigned long</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cchar {...}{.importc: "char", nodecl.} = char</pre></dt> <dd> This is the same as the type <code>char</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cschar {...}{.importc: "signed char", nodecl.} = int8</pre></dt> <dd> This is the same as the type <code>signed char</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cshort {...}{.importc: "short", nodecl.} = int16</pre></dt> <dd> This is the same as the type <code>short</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cint {...}{.importc: "int", nodecl.} = int32</pre></dt> <dd> This is the same as the type <code>int</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">csize {...}{.importc: "size_t", nodecl.} = int</pre></dt> <dd> This is the same as the type <code>size_t</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">clonglong {...}{.importc: "long long", nodecl.} = int64</pre></dt> <dd> This is the same as the type <code>long long</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cfloat {...}{.importc: "float", nodecl.} = float32</pre></dt> <dd> This is the same as the type <code>float</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cdouble {...}{.importc: "double", nodecl.} = float64</pre></dt> <dd> This is the same as the type <code>double</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">clongdouble {...}{.importc: "long double", nodecl.} = BiggestFloat</pre></dt> <dd> This is the same as the type <code>long double</code> in <em>C</em>. This C type is not supported by Nim's code generator.   </dd>  <dt><pre data-language="nim">cuchar {...}{.importc: "unsigned char", nodecl.} = char</pre></dt> <dd> This is the same as the type <code>unsigned char</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cushort {...}{.importc: "unsigned short", nodecl.} = uint16</pre></dt> <dd> This is the same as the type <code>unsigned short</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cuint {...}{.importc: "unsigned int", nodecl.} = uint32</pre></dt> <dd> This is the same as the type <code>unsigned int</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">culonglong {...}{.importc: "unsigned long long", nodecl.} = uint64</pre></dt> <dd> This is the same as the type <code>unsigned long long</code> in <em>C</em>.   </dd>  <dt><pre data-language="nim">cstringArray {...}{.importc: "char**", nodecl.} = ptr UncheckedArray[cstring]</pre></dt> <dd> This is binary compatible to the type <code>char**</code> in <em>C</em>. The array's high value is large enough to disable bounds checking in practice. Use <em>cstringArrayToSeq</em> to convert it into a <code>seq[string]</code>.   </dd>  <dt><pre>PFloat32 = ptr float32</pre></dt> <dd> an alias for <code>ptr float32</code>   </dd>  <dt><pre>PFloat64 = ptr float64</pre></dt> <dd> an alias for <code>ptr float64</code>   </dd>  <dt><pre>PInt64 = ptr int64</pre></dt> <dd> an alias for <code>ptr int64</code>   </dd>  <dt><pre>PInt32 = ptr int32</pre></dt> <dd> an alias for <code>ptr int32</code>   </dd>  <dt><pre data-language="nim">GC_Strategy = enum
  gcThroughput,               ## optimize for throughput
  gcResponsiveness,           ## optimize for responsiveness (default)
  gcOptimizeTime,             ## optimize for speed
  gcOptimizeSpace             ## optimize for memory footprint</pre></dt> <dd> the strategy the GC should use for the application   </dd>  <dt><pre>PFrame = ptr TFrame</pre></dt> <dd> represents a runtime frame of the call stack; part of the debugger API.   </dd>  <dt><pre data-language="nim">TFrame {...}{.importc, nodecl, final.} = object
  prev*: PFrame                ## previous frame; used for chaining the call stack
  procname*: cstring           ## name of the proc that is currently executing
  line*: int                   ## line number of the proc that is currently executing
  filename*: cstring           ## filename of the proc that is currently executing
  len*: int16                  ## length of the inspectable slots
  calldepth*: int16            ## used for max call depth checking</pre></dt> <dd> the frame itself   </dd>  <dt><pre data-language="nim">FileSeekPos = enum
  fspSet,                     ## Seek to absolute value
  fspCur,                     ## Seek relative to current position
  fspEnd                      ## Seek relative to end</pre></dt> <dd> Position relative to which seek should happen   </dd>  <dt><pre>File = ptr CFile</pre></dt> <dd> The type representing a file handle.   </dd>  <dt><pre data-language="nim">FileMode = enum
  fmRead,                     ## Open the file for read access only.
  fmWrite,                    ## Open the file for write access only.
          ## If the file does not exist, it will be
          ## created. Existing files will be cleared!
  fmReadWrite,                ## Open the file for read and write access.
              ## If the file does not exist, it will be
              ## created. Existing files will be cleared!
  fmReadWriteExisting,        ## Open the file for read and write access.
                      ## If the file does not exist, it will not be
                      ## created. The existing file will not be cleared.
  fmAppend                    ## Open the file for writing only; append data
          ## at the end.</pre></dt> <dd> The file mode when opening a file.   </dd>  <dt><pre>FileHandle = cint</pre></dt> <dd> type that represents an OS file handle; this is useful for low-level file access   </dd>  <dt><pre>BackwardsIndex = distinct int</pre></dt> <dd> type that is constructed by <code>^</code> for reversed array accesses.   </dd>  <dt><pre data-language="nim">NimNode {...}{.magic: "PNimrodNode".} = ref NimNodeObj</pre></dt> <dd> represents a Nim AST node. Macros operate on this type.   </dd>  <dt><pre data-language="nim">ForLoopStmt {...}{.compilerProc.} = object</pre></dt> <dd> special type that marks a macro as a <span id="forminusloop-macro_1">for-loop macro</span>   </dd> </dl>  <h2 id="8">Vars</h2> <dl>  <dt><pre>programResult: int</pre></dt> <dd> modify this variable to specify the exit code of the program under normal circumstances. When the program is terminated prematurely using <code>quit</code>, this value is ignored.   </dd>  <dt><pre data-language="nim">globalRaiseHook: proc (e: ref Exception): bool {...}{.nimcall, gcsafe, locks: 0.}</pre></dt> <dd> with this hook you can influence exception handling on a global level. If not nil, every 'raise' statement ends up calling this hook. Ordinary application code should never set this hook! You better know what you do when setting this. If <code>globalRaiseHook</code> returns false, the exception is caught and does not propagate further through the call stack.   </dd>  <dt><pre data-language="nim">localRaiseHook: proc (e: ref Exception): bool {...}{.nimcall, gcsafe, locks: 0.}</pre></dt> <dd> with this hook you can influence exception handling on a thread local level. If not nil, every 'raise' statement ends up calling this hook. Ordinary application code should never set this hook! You better know what you do when setting this. If <code>localRaiseHook</code> returns false, the exception is caught and does not propagate further through the call stack.   </dd>  <dt><pre data-language="nim">outOfMemHook: proc () {...}{.nimcall, tags: [], gcsafe, locks: 0.}</pre></dt> <dd> set this variable to provide a procedure that should be called in case of an <span id="out-of-memory_1">out of memory</span> event. The standard handler writes an error message and terminates the program. <em>outOfMemHook</em> can be used to raise an exception in case of OOM like so:<pre class="listing" data-language="nim">var gOutOfMem: ref EOutOfMemory
new(gOutOfMem) # need to be allocated *before* OOM really happened!
gOutOfMem.msg = "out of memory"

proc handleOOM() =
  raise gOutOfMem

system.outOfMemHook = handleOOM</pre>
<p>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</p>   </dd>  <dt><pre>stdin: File</pre></dt> <dd> The standard input stream.   </dd>  <dt><pre>stdout: File</pre></dt> <dd> The standard output stream.   </dd>  <dt><pre>stderr: File</pre></dt> <dd> The standard error stream.   </dd> </dl>  <h2 id="9">Lets</h2> <dl>  <dt><pre>nimvm: bool = false</pre></dt> <dd> may be used only in "when" expression. It is true in Nim VM context and false otherwise   </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre>on = true</pre></dt> <dd> alias for <code>true</code>   </dd>  <dt><pre>off = false</pre></dt> <dd> alias for <code>false</code>   </dd>  <dt><pre data-language="nim">appType: string = ""</pre></dt> <dd> a string that describes the application type. Possible values: "console", "gui", "lib".   </dd>  <dt><pre>NoFakeVars = false</pre></dt> <dd> true if the backend doesn't support "fake variables" like 'var EBADF {.importc.}: cint'.   </dd>  <dt><pre>isMainModule: bool = false</pre></dt> <dd> is true only when accessed in the main module. This works thanks to compiler magic. It is useful to embed testing code in a module.   </dd>  <dt><pre data-language="nim">CompileDate: string = "0000-00-00"</pre></dt> <dd> is the date of compilation as a string of the form <code>YYYY-MM-DD</code>. This works thanks to compiler magic.   </dd>  <dt><pre data-language="nim">CompileTime: string = "00:00:00"</pre></dt> <dd> is the time of compilation as a string of the form <code>HH:MM:SS</code>. This works thanks to compiler magic.   </dd>  <dt><pre>cpuEndian: Endianness = littleEndian</pre></dt> <dd> is the endianness of the target CPU. This is a valuable piece of information for low-level code only. This works thanks to compiler magic.   </dd>  <dt><pre data-language="nim">hostOS: string = ""</pre></dt> <dd> a string that describes the host operating system. Possible values: "windows", "macosx", "linux", "netbsd", "freebsd", "openbsd", "solaris", "aix", "haiku", "standalone".   </dd>  <dt><pre data-language="nim">hostCPU: string = ""</pre></dt> <dd> a string that describes the host CPU. Possible values: "i386", "alpha", "powerpc", "powerpc64", "powerpc64el", "sparc", "amd64", "mips", "mipsel", "arm", "arm64", "mips64", "mips64el", "riscv64".   </dd>  <dt><pre>nimEnableCovariance = false</pre></dt>   <dt><pre>QuitSuccess = 0</pre></dt> <dd> is the value that should be passed to <a href="#quit">quit</a> to indicate success.   </dd>  <dt><pre>QuitFailure = 1</pre></dt> <dd> is the value that should be passed to <a href="#quit">quit</a> to indicate failure.   </dd>  <dt><pre>Inf = inf</pre></dt> <dd> contains the IEEE floating point value of positive infinity.   </dd>  <dt><pre>NegInf = -inf</pre></dt> <dd> contains the IEEE floating point value of negative infinity.   </dd>  <dt><pre>NaN = nan</pre></dt> <dd> contains an IEEE floating point value of <em>Not A Number</em>. Note that you cannot compare a floating point value to this value and expect a reasonable result - use the <em>classify</em> procedure in the module <code>math</code> for checking for NaN.   </dd>  <dt><pre>NimMajor: int = 0</pre></dt> <dd> is the major number of Nim's version.   </dd>  <dt><pre>NimMinor: int = 19</pre></dt> <dd> is the minor number of Nim's version.   </dd>  <dt><pre>NimPatch: int = 0</pre></dt> <dd> is the patch number of Nim's version.   </dd>  <dt><pre data-language="nim">NimVersion: string = "0.19.0"</pre></dt> <dd> is the version of Nim as a string.   </dd>  <dt><pre>nimCoroutines = false</pre></dt>  </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc `or`(a, b: typedesc): typedesc {...}{.magic: "TypeTrait", noSideEffect.}</pre></dt> <dd> Constructs an <em>or</em> meta class   </dd>  <dt><pre data-language="nim">proc `and`(a, b: typedesc): typedesc {...}{.magic: "TypeTrait", noSideEffect.}</pre></dt> <dd> Constructs an <em>and</em> meta class   </dd>  <dt><pre data-language="nim">proc `not`(a: typedesc): typedesc {...}{.magic: "TypeTrait", noSideEffect.}</pre></dt> <dd> Constructs an <em>not</em> meta class   </dd>  <dt><pre data-language="nim">proc defined(x: untyped): bool {...}{.magic: "Defined", noSideEffect, compileTime.}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> is defined. <em>x</em> is an external symbol introduced through the compiler's <a href="nimc#compile-time-symbols">-d:x switch</a> to enable build time conditionals:<pre class="listing" data-language="nim">when not defined(release):
  # Do here programmer friendly expensive sanity checks.
# Put here the normal code</pre>   </dd>  <dt><pre data-language="nim">proc declared(x: untyped): bool {...}{.magic: "Defined", noSideEffect, compileTime.}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> is declared. <em>x</em> has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:<pre class="listing" data-language="nim">when not declared(strutils.toUpper):
  # provide our own toUpper proc here, because strutils is
  # missing it.</pre>   </dd>  <dt><pre data-language="nim">proc declaredInScope(x: untyped): bool {...}{.magic: "DefinedInScope", noSideEffect,
                                     compileTime.}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> is declared in the current scope. <em>x</em> has to be an identifier.   </dd>  <dt><pre data-language="nim">proc `addr`[T](x: var T): ptr T {...}{.magic: "Addr", noSideEffect.}</pre></dt> <dd> Builtin 'addr' operator for taking the address of a memory location. Cannot be overloaded.<pre class="listing" data-language="nim">var
  buf: seq[char] = @['a','b','c']
  p: pointer = buf[1].addr
echo cast[ptr char](p)[]    # b</pre>   </dd>  <dt><pre data-language="nim">proc unsafeAddr[T](x: T): ptr T {...}{.magic: "Addr", noSideEffect.}</pre></dt> <dd> Builtin 'addr' operator for taking the address of a memory location. This works even for <code>let</code> variables or parameters for better interop with C and so it is considered even more unsafe than the ordinary <code>addr</code>. When you use it to write a wrapper for a C library, you should always check that the original library does never write to data behind the pointer that is returned from this procedure. Cannot be overloaded.   </dd>  <dt><pre data-language="nim">proc `not`(x: bool): bool {...}{.magic: "Not", noSideEffect.}</pre></dt> <dd> Boolean not; returns true iff <code>x == false</code>.   </dd>  <dt><pre data-language="nim">proc `and`(x, y: bool): bool {...}{.magic: "And", noSideEffect.}</pre></dt> <dd> Boolean <code>and</code>; returns true iff <code>x == y == true</code>. Evaluation is lazy: if <code>x</code> is false, <code>y</code> will not even be evaluated.   </dd>  <dt><pre data-language="nim">proc `or`(x, y: bool): bool {...}{.magic: "Or", noSideEffect.}</pre></dt> <dd> Boolean <code>or</code>; returns true iff <code>not (not x and not y)</code>. Evaluation is lazy: if <code>x</code> is true, <code>y</code> will not even be evaluated.   </dd>  <dt><pre data-language="nim">proc `xor`(x, y: bool): bool {...}{.magic: "Xor", noSideEffect.}</pre></dt> <dd> Boolean <em>exclusive or</em>; returns true iff <code>x != y</code>.   </dd>  <dt><pre data-language="nim">proc new[T](a: var ref T) {...}{.magic: "New", noSideEffect.}</pre></dt> <dd> creates a new object of type <code>T</code> and returns a safe (traced) reference to it in <code>a</code>.   </dd>  <dt><pre data-language="nim">proc new(T: typedesc): auto</pre></dt> <dd> <p>creates a new object of type <code>T</code> and returns a safe (traced) reference to it as result value.</p> <p>When <code>T</code> is a ref type then the resulting type will be <code>T</code>, otherwise it will be <code>ref T</code>.</p>   </dd>  <dt><pre data-language="nim">proc internalNew[T](a: var ref T) {...}{.magic: "New", noSideEffect.}</pre></dt> <dd> leaked implementation detail. Do not use.   </dd>  <dt><pre data-language="nim">proc new[T](a: var ref T; finalizer: proc (x: ref T) {...}{.nimcall.}) {...}{.magic: "NewFinalize",
    noSideEffect.}</pre></dt> <dd> creates a new object of type <code>T</code> and returns a safe (traced) reference to it in <code>a</code>. When the garbage collector frees the object, <em>finalizer</em> is called. The <em>finalizer</em> may not keep a reference to the object pointed to by <em>x</em>. The <em>finalizer</em> cannot prevent the GC from freeing the object. Note: The <em>finalizer</em> refers to the type <em>T</em>, not to the object! This means that for each object of type <em>T</em> the finalizer will be called!   </dd>  <dt><pre data-language="nim">proc reset[T](obj: var T) {...}{.magic: "Reset", noSideEffect.}</pre></dt> <dd> resets an object <em>obj</em> to its initial (binary zero) value. This needs to be called before any possible <span id="object-branch-transition_1">object branch transition</span>.   </dd>  <dt><pre data-language="nim">proc wasMoved[T](obj: var T) {...}{.magic: "WasMoved", noSideEffect.}</pre></dt> <dd> resets an object <em>obj</em> to its initial (binary zero) value to signify it was "moved" and to signify its destructor should do nothing and ideally be optimized away.   </dd>  <dt><pre data-language="nim">proc move[T](x: var T): T {...}{.magic: "Move", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc high[T: Ordinal](x: T): T {...}{.magic: "High", noSideEffect.}</pre></dt> <dd> returns the highest possible index of an array, a sequence, a string or the highest possible value of an ordinal value <em>x</em>. As a special semantic rule, <em>x</em> may also be a type identifier. <code>high(int)</code> is Nim's way of writing <span id="int-max_1">INT_MAX</span> or <span id="max-int_1">MAX_INT</span>.<pre class="listing" data-language="nim">var arr = [1,2,3,4,5,6,7]
high(arr) #=&gt; 6
high(2) #=&gt; 9223372036854775807
high(int) #=&gt; 9223372036854775807</pre>   </dd>  <dt><pre data-language="nim">proc high[T: Ordinal | enum](x: typedesc[T]): T {...}{.magic: "High", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc high[T](x: openArray[T]): int {...}{.magic: "High", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc high[I, T](x: array[I, T]): I {...}{.magic: "High", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc high[I, T](x: typedesc[array[I, T]]): I {...}{.magic: "High", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc high(x: cstring): int {...}{.magic: "High", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc high(x: string): int {...}{.magic: "High", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc low[T: Ordinal | enum](x: typedesc[T]): T {...}{.magic: "Low", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc low[T](x: openArray[T]): int {...}{.magic: "Low", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc low[I, T](x: array[I, T]): I {...}{.magic: "Low", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc low[T](x: T): T {...}{.magic: "Low", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc low[I, T](x: typedesc[array[I, T]]): I {...}{.magic: "Low", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc low(x: cstring): int {...}{.magic: "Low", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc low(x: string): int {...}{.magic: "Low", noSideEffect.}</pre></dt> <dd> returns the lowest possible index of an array, a sequence, a string or the lowest possible value of an ordinal value <em>x</em>. As a special semantic rule, <em>x</em> may also be a type identifier.<pre class="listing" data-language="nim">var arr = [1,2,3,4,5,6,7]
low(arr) #=&gt; 0
low(2) #=&gt; -9223372036854775808
low(int) #=&gt; -9223372036854775808</pre>   </dd>  <dt><pre data-language="nim">proc shallowCopy[T](x: var T; y: T) {...}{.noSideEffect, magic: "ShallowCopy".}</pre></dt> <dd> use this instead of <em>=</em> for a <span id="shallow-copy_1">shallow copy</span>. The shallow copy only changes the semantics for sequences and strings (and types which contain those). Be careful with the changed semantics though! There is a reason why the default assignment does a deep copy of sequences and strings.   </dd>  <dt><pre data-language="nim">proc `[]`[I: Ordinal; T](a: T; i: I): T {...}{.noSideEffect, magic: "ArrGet".}</pre></dt>   <dt><pre data-language="nim">proc `[]=`[I: Ordinal; T, S](a: T; i: I; x: S) {...}{.noSideEffect, magic: "ArrPut".}</pre></dt>   <dt><pre data-language="nim">proc `=`[T](dest: var T; src: T) {...}{.noSideEffect, magic: "Asgn".}</pre></dt>   <dt><pre data-language="nim">proc `=destroy`[T](x: var T) {...}{.inline, magic: "Asgn".}</pre></dt> <dd> generic <span id="destructor_1">destructor</span> implementation that can be overriden.   </dd>  <dt><pre data-language="nim">proc `=sink`[T](x: var T; y: T) {...}{.inline, magic: "Asgn".}</pre></dt> <dd> generic <span id="sink_1">sink</span> implementation that can be overriden.   </dd>  <dt><pre data-language="nim">proc `..`[T, U](a: T; b: U): HSlice[T, U] {...}{.noSideEffect, inline, magic: "DotDot".}</pre></dt> <dd> binary <span id="slice_1">slice</span> operator that constructs an interval <code>[a, b]</code>, both <em>a</em> and <em>b</em> are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.   </dd>  <dt><pre data-language="nim">proc `..`[T](b: T): HSlice[int, T] {...}{.noSideEffect, inline, magic: "DotDot".}</pre></dt> <dd> unary <span id="slice_2">slice</span> operator that constructs an interval <code>[default(int), b]</code>   </dd>  <dt><pre data-language="nim">proc `==`[Enum: enum](x, y: Enum): bool {...}{.magic: "EqEnum", noSideEffect.}</pre></dt> <dd> Checks whether values within the <em>same enum</em> have the same underlying value<pre class="listing" data-language="nim">type
  Enum1 = enum
    Field1 = 3, Field2
  Enum2 = enum
    Place1, Place2 = 3
var
  e1 = Field1
  e2 = Enum1(Place2)
echo (e1 == e2) # true
echo (e1 == Place2) # raises error</pre>   </dd>  <dt><pre data-language="nim">proc `==`(x, y: pointer): bool {...}{.magic: "EqRef", noSideEffect.}</pre></dt> <dd> <pre class="listing" data-language="nim">var # this is a wildly dangerous example
  a = cast[pointer](0)
  b = cast[pointer](nil)
echo (a == b) # true due to the special meaning of `nil`/0 as a pointer</pre>   </dd>  <dt><pre data-language="nim">proc `==`(x, y: string): bool {...}{.magic: "EqStr", noSideEffect.}</pre></dt> <dd> Checks for equality between two <em>string</em> variables   </dd>  <dt><pre data-language="nim">proc `==`(x, y: char): bool {...}{.magic: "EqCh", noSideEffect.}</pre></dt> <dd> Checks for equality between two <em>char</em> variables   </dd>  <dt><pre data-language="nim">proc `==`(x, y: bool): bool {...}{.magic: "EqB", noSideEffect.}</pre></dt> <dd> Checks for equality between two <em>bool</em> variables   </dd>  <dt><pre data-language="nim">proc `==`[T](x, y: set[T]): bool {...}{.magic: "EqSet", noSideEffect.}</pre></dt> <dd> Checks for equality between two variables of type <em>set</em><pre class="listing" data-language="nim">var a = {1, 2, 2, 3} # duplication in sets is ignored
var b = {1, 2, 3}
echo (a == b) # true</pre>   </dd>  <dt><pre data-language="nim">proc `==`[T](x, y: ref T): bool {...}{.magic: "EqRef", noSideEffect.}</pre></dt> <dd> Checks that two <em>ref</em> variables refer to the same item   </dd>  <dt><pre data-language="nim">proc `==`[T](x, y: ptr T): bool {...}{.magic: "EqRef", noSideEffect.}</pre></dt> <dd> Checks that two <em>ptr</em> variables refer to the same item   </dd>  <dt><pre data-language="nim">proc `==`[T: proc](x, y: T): bool {...}{.magic: "EqProc", noSideEffect.}</pre></dt> <dd> Checks that two <em>proc</em> variables refer to the same procedure   </dd>  <dt><pre data-language="nim">proc `&lt;=`[Enum: enum](x, y: Enum): bool {...}{.magic: "LeEnum", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: string): bool {...}{.magic: "LeStr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: char): bool {...}{.magic: "LeCh", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`[T](x, y: set[T]): bool {...}{.magic: "LeSet", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: bool): bool {...}{.magic: "LeB", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`[T](x, y: ref T): bool {...}{.magic: "LePtr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: pointer): bool {...}{.magic: "LePtr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`[Enum: enum](x, y: Enum): bool {...}{.magic: "LtEnum", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: string): bool {...}{.magic: "LtStr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: char): bool {...}{.magic: "LtCh", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`[T](x, y: set[T]): bool {...}{.magic: "LtSet", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: bool): bool {...}{.magic: "LtB", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`[T](x, y: ref T): bool {...}{.magic: "LtPtr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`[T](x, y: ptr T): bool {...}{.magic: "LtPtr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: pointer): bool {...}{.magic: "LtPtr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc unsafeNew[T](a: var ref T; size: Natural) {...}{.magic: "New", noSideEffect.}</pre></dt> <dd> creates a new object of type <code>T</code> and returns a safe (traced) reference to it in <code>a</code>. This is <strong>unsafe</strong> as it allocates an object of the passed <code>size</code>. This should only be used for optimization purposes when you know what you're doing!   </dd>  <dt><pre data-language="nim">proc sizeof[T](x: T): int {...}{.magic: "SizeOf", noSideEffect.}</pre></dt> <dd> <p>returns the size of <code>x</code> in bytes. Since this is a low-level proc, its usage is discouraged - using <code>new</code> for the most cases suffices that one never needs to know <code>x</code>'s size. As a special semantic rule, <code>x</code> may also be a type identifier (<code>sizeof(int)</code> is valid).</p> <p>Limitations: If used within nim VM context <code>sizeof</code> will only work for simple types.</p> <pre class="listing" data-language="nim">sizeof('A') #=&gt; 1
sizeof(2) #=&gt; 8</pre>   </dd>  <dt><pre data-language="nim">proc sizeof(x: typedesc): int {...}{.magic: "SizeOf", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`[T](x: Ordinal[T]): T {...}{.magic: "UnaryLt", noSideEffect, deprecated.}</pre></dt> <dd> unary <code>&lt;</code> that can be used for nice looking excluding ranges:<pre class="listing" data-language="nim">for i in 0 .. &lt;10: echo i #=&gt; 0 1 2 3 4 5 6 7 8 9</pre>
<p>Semantically this is the same as <code>pred</code>.</p> <p><strong>Deprecated since version 0.18.0</strong>. For the common excluding range write <code>0 ..&lt; 10</code> instead of <code>0 .. &lt; 10</code> (look at the spacing). For <code>&lt;x</code> write <code>pred(x)</code>.</p>   </dd>  <dt><pre data-language="nim">proc succ[T: Ordinal](x: T; y = 1): T {...}{.magic: "Succ", noSideEffect.}</pre></dt> <dd> returns the <code>y</code>-th successor of the value <code>x</code>. <code>T</code> has to be an ordinal type. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs.   </dd>  <dt><pre data-language="nim">proc pred[T: Ordinal](x: T; y = 1): T {...}{.magic: "Pred", noSideEffect.}</pre></dt> <dd> returns the <code>y</code>-th predecessor of the value <code>x</code>. <code>T</code> has to be an ordinal type. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs.   </dd>  <dt><pre data-language="nim">proc inc[T: Ordinal | uint | uint64](x: var T; y = 1) {...}{.magic: "Inc", noSideEffect.}</pre></dt> <dd> increments the ordinal <code>x</code> by <code>y</code>. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs. This is a short notation for: <code>x = succ(x, y)</code>.<pre class="listing" data-language="nim">var i = 2
inc(i) #=&gt; 3
inc(i, 3) #=&gt; 6</pre>   </dd>  <dt><pre data-language="nim">proc dec[T: Ordinal | uint | uint64](x: var T; y = 1) {...}{.magic: "Dec", noSideEffect.}</pre></dt> <dd> decrements the ordinal <code>x</code> by <code>y</code>. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs. This is a short notation for: <code>x = pred(x, y)</code>.<pre class="listing" data-language="nim">var i = 2
dec(i) #=&gt; 1
dec(i, 3) #=&gt; -2</pre>   </dd>  <dt><pre data-language="nim">proc newSeq[T](s: var seq[T]; len: Natural) {...}{.magic: "NewSeq", noSideEffect.}</pre></dt> <dd> <p>creates a new sequence of type <code>seq[T]</code> with length <code>len</code>. This is equivalent to <code>s = @[]; setlen(s, len)</code>, but more efficient since no reallocation is needed.</p> <p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <code>nil</code>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p> <pre class="listing" data-language="nim">var inputStrings : seq[string]
newSeq(inputStrings, 3)
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"</pre>   </dd>  <dt><pre data-language="nim">proc newSeq[T](len = 0.Natural): seq[T]</pre></dt> <dd> <p>creates a new sequence of type <code>seq[T]</code> with length <code>len</code>.</p> <p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <code>nil</code>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p> <pre class="listing" data-language="nim">var inputStrings = newSeq[string](3)
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"</pre>   </dd>  <dt><pre data-language="nim">proc newSeqOfCap[T](cap: Natural): seq[T] {...}{.magic: "NewSeqOfCap", noSideEffect.}</pre></dt> <dd> creates a new sequence of type <code>seq[T]</code> with length 0 and capacity <code>cap</code>.   </dd>  <dt><pre data-language="nim">proc newSeqUninitialized[T: SomeNumber](len: Natural): seq[T]</pre></dt> <dd> <p>creates a new sequence of type <code>seq[T]</code> with length <code>len</code>.</p> <p>Only available for numbers types. Note that the sequence will be uninitialized. After the creation of the sequence you should assign entries to the sequence instead of adding them.</p>   </dd>  <dt><pre data-language="nim">proc len[TOpenArray: openArray | varargs](x: TOpenArray): int {...}{.
    magic: "LengthOpenArray", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc len(x: string): int {...}{.magic: "LengthStr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc len(x: cstring): int {...}{.magic: "LengthStr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc len(x: (type array) | array): int {...}{.magic: "LengthArray", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc len[T](x: seq[T]): int {...}{.magic: "LengthSeq", noSideEffect.}</pre></dt> <dd> returns the length of an array, an openarray, a sequence or a string. This is roughly the same as <code>high(T)-low(T)+1</code>, but its resulting type is always an int.<pre class="listing" data-language="nim">var arr = [1,1,1,1,1]
len(arr) #=&gt; 5
for i in 0..&lt;arr.len:
  echo arr[i] #=&gt; 1,1,1,1,1</pre>   </dd>  <dt><pre data-language="nim">proc incl[T](x: var set[T]; y: T) {...}{.magic: "Incl", noSideEffect.}</pre></dt> <dd> includes element <code>y</code> to the set <code>x</code>. This is the same as <code>x = x + {y}</code>, but it might be more efficient.<pre class="listing" data-language="nim">var a = initSet[int](4)
a.incl(2) #=&gt; {2}
a.incl(3) #=&gt; {2, 3}</pre>   </dd>  <dt><pre data-language="nim">proc excl[T](x: var set[T]; y: T) {...}{.magic: "Excl", noSideEffect.}</pre></dt> <dd> excludes element <code>y</code> to the set <code>x</code>. This is the same as <code>x = x - {y}</code>, but it might be more efficient.<pre class="listing" data-language="nim">var b = {2,3,5,6,12,545}
b.excl(5)  #=&gt; {2,3,6,12,545}</pre>   </dd>  <dt><pre data-language="nim">proc card[T](x: set[T]): int {...}{.magic: "Card", noSideEffect.}</pre></dt> <dd> returns the cardinality of the set <code>x</code>, i.e. the number of elements in the set.<pre class="listing" data-language="nim">var i = {1,2,3,4}
card(i) #=&gt; 4</pre>   </dd>  <dt><pre data-language="nim">proc ord[T: Ordinal | enum](x: T): int {...}{.magic: "Ord", noSideEffect.}</pre></dt> <dd> returns the internal int value of an ordinal value <code>x</code>.<pre class="listing" data-language="nim">ord('A') #=&gt; 65</pre>   </dd>  <dt><pre data-language="nim">proc chr(u: range[0 .. 255]): char {...}{.magic: "Chr", noSideEffect.}</pre></dt> <dd> converts an int in the range 0..255 to a character.<pre class="listing" data-language="nim">chr(65) #=&gt; A</pre>   </dd>  <dt><pre data-language="nim">proc ze(x: int8): int {...}{.magic: "Ze8ToI", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int</code>. This treats <em>x</em> as unsigned.   </dd>  <dt><pre data-language="nim">proc ze(x: int16): int {...}{.magic: "Ze16ToI", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int</code>. This treats <em>x</em> as unsigned.   </dd>  <dt><pre data-language="nim">proc ze64(x: int8): int64 {...}{.magic: "Ze8ToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned.   </dd>  <dt><pre data-language="nim">proc ze64(x: int16): int64 {...}{.magic: "Ze16ToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned.   </dd>  <dt><pre data-language="nim">proc ze64(x: int32): int64 {...}{.magic: "Ze32ToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned.   </dd>  <dt><pre data-language="nim">proc ze64(x: int): int64 {...}{.magic: "ZeIToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned. Does nothing if the size of an <code>int</code> is the same as <code>int64</code>. (This is the case on 64 bit processors.)   </dd>  <dt><pre data-language="nim">proc toU8(x: int): int8 {...}{.magic: "ToU8", noSideEffect.}</pre></dt> <dd> treats <em>x</em> as unsigned and converts it to a byte by taking the last 8 bits from <em>x</em>.   </dd>  <dt><pre data-language="nim">proc toU16(x: int): int16 {...}{.magic: "ToU16", noSideEffect.}</pre></dt> <dd> treats <em>x</em> as unsigned and converts it to an <code>int16</code> by taking the last 16 bits from <em>x</em>.   </dd>  <dt><pre data-language="nim">proc toU32(x: int64): int32 {...}{.magic: "ToU32", noSideEffect.}</pre></dt> <dd> treats <em>x</em> as unsigned and converts it to an <code>int32</code> by taking the last 32 bits from <em>x</em>.   </dd>  <dt><pre data-language="nim">proc `+`(x: int): int {...}{.magic: "UnaryPlusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x: int8): int8 {...}{.magic: "UnaryPlusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x: int16): int16 {...}{.magic: "UnaryPlusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x: int32): int32 {...}{.magic: "UnaryPlusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x: int64): int64 {...}{.magic: "UnaryPlusI", noSideEffect.}</pre></dt> <dd> Unary <em>+</em> operator for an integer. Has no effect.   </dd>  <dt><pre data-language="nim">proc `-`(x: int): int {...}{.magic: "UnaryMinusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x: int8): int8 {...}{.magic: "UnaryMinusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x: int16): int16 {...}{.magic: "UnaryMinusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x: int32): int32 {...}{.magic: "UnaryMinusI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x: int64): int64 {...}{.magic: "UnaryMinusI64", noSideEffect.}</pre></dt> <dd> Unary <em>-</em> operator for an integer. Negates <em>x</em>.   </dd>  <dt><pre data-language="nim">proc `not`(x: int): int {...}{.magic: "BitnotI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `not`(x: int8): int8 {...}{.magic: "BitnotI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `not`(x: int16): int16 {...}{.magic: "BitnotI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `not`(x: int32): int32 {...}{.magic: "BitnotI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise complement</em> of the integer <em>x</em>.   </dd>  <dt><pre data-language="nim">proc `not`(x: int64): int64 {...}{.magic: "BitnotI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x, y: int): int {...}{.magic: "AddI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x, y: int8): int8 {...}{.magic: "AddI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x, y: int16): int16 {...}{.magic: "AddI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x, y: int32): int32 {...}{.magic: "AddI", noSideEffect.}</pre></dt> <dd> Binary <em>+</em> operator for an integer.   </dd>  <dt><pre data-language="nim">proc `+`(x, y: int64): int64 {...}{.magic: "AddI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x, y: int): int {...}{.magic: "SubI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x, y: int8): int8 {...}{.magic: "SubI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x, y: int16): int16 {...}{.magic: "SubI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x, y: int32): int32 {...}{.magic: "SubI", noSideEffect.}</pre></dt> <dd> Binary <em>-</em> operator for an integer.   </dd>  <dt><pre data-language="nim">proc `-`(x, y: int64): int64 {...}{.magic: "SubI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*`(x, y: int): int {...}{.magic: "MulI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*`(x, y: int8): int8 {...}{.magic: "MulI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*`(x, y: int16): int16 {...}{.magic: "MulI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*`(x, y: int32): int32 {...}{.magic: "MulI", noSideEffect.}</pre></dt> <dd> Binary <em>*</em> operator for an integer.   </dd>  <dt><pre data-language="nim">proc `*`(x, y: int64): int64 {...}{.magic: "MulI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `div`(x, y: int): int {...}{.magic: "DivI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `div`(x, y: int8): int8 {...}{.magic: "DivI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `div`(x, y: int16): int16 {...}{.magic: "DivI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `div`(x, y: int32): int32 {...}{.magic: "DivI", noSideEffect.}</pre></dt> <dd> computes the integer division. This is roughly the same as <code>trunc(x/y)</code>.<pre class="listing" data-language="nim">1 div 2 == 0
2 div 2 == 1
3 div 2 == 1
7 div 5 == 1</pre>   </dd>  <dt><pre data-language="nim">proc `div`(x, y: int64): int64 {...}{.magic: "DivI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `mod`(x, y: int): int {...}{.magic: "ModI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `mod`(x, y: int8): int8 {...}{.magic: "ModI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `mod`(x, y: int16): int16 {...}{.magic: "ModI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `mod`(x, y: int32): int32 {...}{.magic: "ModI", noSideEffect.}</pre></dt> <dd> computes the integer modulo operation (remainder). This is the same as <code>x - (x div y) * y</code>.<pre class="listing" data-language="nim">(7 mod 5) == 2</pre>   </dd>  <dt><pre data-language="nim">proc `mod`(x, y: int64): int64 {...}{.magic: "ModI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shr`(x: int; y: SomeInteger): int {...}{.magic: "ShrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shr`(x: int8; y: SomeInteger): int8 {...}{.magic: "ShrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shr`(x: int16; y: SomeInteger): int16 {...}{.magic: "ShrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shr`(x: int32; y: SomeInteger): int32 {...}{.magic: "ShrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shr`(x: int64; y: SomeInteger): int64 {...}{.magic: "ShrI", noSideEffect.}</pre></dt> <dd> computes the <em>shift right</em> operation of <em>x</em> and <em>y</em>, filling vacant bit positions with zeros.<pre class="listing" data-language="nim">0b0001_0000'i8 shr 2 == 0b0000_0100'i8
0b1000_0000'i8 shr 8 == 0b0000_0000'i8
0b0000_0001'i8 shr 1 == 0b0000_0000'i8</pre>   </dd>  <dt><pre data-language="nim">proc `shl`(x: int; y: SomeInteger): int {...}{.magic: "ShlI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shl`(x: int8; y: SomeInteger): int8 {...}{.magic: "ShlI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shl`(x: int16; y: SomeInteger): int16 {...}{.magic: "ShlI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shl`(x: int32; y: SomeInteger): int32 {...}{.magic: "ShlI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `shl`(x: int64; y: SomeInteger): int64 {...}{.magic: "ShlI", noSideEffect.}</pre></dt> <dd> computes the <em>shift left</em> operation of <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">1'i32 shl 4 == 0x0000_0010
1'i64 shl 4 == 0x0000_0000_0000_0010</pre>   </dd>  <dt><pre data-language="nim">proc ashr(x: int; y: SomeInteger): int {...}{.magic: "AshrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc ashr(x: int8; y: SomeInteger): int8 {...}{.magic: "AshrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc ashr(x: int16; y: SomeInteger): int16 {...}{.magic: "AshrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc ashr(x: int32; y: SomeInteger): int32 {...}{.magic: "AshrI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc ashr(x: int64; y: SomeInteger): int64 {...}{.magic: "AshrI", noSideEffect.}</pre></dt> <dd> Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.<pre class="listing" data-language="nim">0b0001_0000'i8 shr 2 == 0b0000_0100'i8
0b1000_0000'i8 shr 8 == 0b1111_1111'i8
0b1000_0000'i8 shr 1 == 0b1100_0000'i8</pre>   </dd>  <dt><pre data-language="nim">proc `and`(x, y: int): int {...}{.magic: "BitandI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `and`(x, y: int8): int8 {...}{.magic: "BitandI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `and`(x, y: int16): int16 {...}{.magic: "BitandI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `and`(x, y: int32): int32 {...}{.magic: "BitandI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `and`(x, y: int64): int64 {...}{.magic: "BitandI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise and</em> of numbers <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">(0xffff'i16 and 0x0010'i16) == 0x0010</pre>   </dd>  <dt><pre data-language="nim">proc `or`(x, y: int): int {...}{.magic: "BitorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `or`(x, y: int8): int8 {...}{.magic: "BitorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `or`(x, y: int16): int16 {...}{.magic: "BitorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `or`(x, y: int32): int32 {...}{.magic: "BitorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `or`(x, y: int64): int64 {...}{.magic: "BitorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise or</em> of numbers <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">(0x0005'i16 or 0x0010'i16) == 0x0015</pre>   </dd>  <dt><pre data-language="nim">proc `xor`(x, y: int): int {...}{.magic: "BitxorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `xor`(x, y: int8): int8 {...}{.magic: "BitxorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `xor`(x, y: int16): int16 {...}{.magic: "BitxorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `xor`(x, y: int32): int32 {...}{.magic: "BitxorI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `xor`(x, y: int64): int64 {...}{.magic: "BitxorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise xor</em> of numbers <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">(0x1011'i16 xor 0x0101'i16) == 0x1110</pre>   </dd>  <dt><pre data-language="nim">proc `==`(x, y: int): bool {...}{.magic: "EqI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `==`(x, y: int8): bool {...}{.magic: "EqI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `==`(x, y: int16): bool {...}{.magic: "EqI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `==`(x, y: int32): bool {...}{.magic: "EqI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `==`(x, y: int64): bool {...}{.magic: "EqI", noSideEffect.}</pre></dt> <dd> Compares two integers for equality.   </dd>  <dt><pre data-language="nim">proc `&lt;=`(x, y: int): bool {...}{.magic: "LeI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: int8): bool {...}{.magic: "LeI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: int16): bool {...}{.magic: "LeI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: int32): bool {...}{.magic: "LeI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: int64): bool {...}{.magic: "LeI", noSideEffect.}</pre></dt> <dd> Returns true iff <em>x</em> is less than or equal to <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `&lt;`(x, y: int): bool {...}{.magic: "LtI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: int8): bool {...}{.magic: "LtI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: int16): bool {...}{.magic: "LtI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: int32): bool {...}{.magic: "LtI", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: int64): bool {...}{.magic: "LtI", noSideEffect.}</pre></dt> <dd> Returns true iff <em>x</em> is less than <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `+%`(x, y: IntMax32): IntMax32 {...}{.magic: "AddU", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+%`(x, y: int64): int64 {...}{.magic: "AddU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and adds them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd>  <dt><pre data-language="nim">proc `-%`(x, y: IntMax32): IntMax32 {...}{.magic: "SubU", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-%`(x, y: int64): int64 {...}{.magic: "SubU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and subtracts them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd>  <dt><pre data-language="nim">proc `*%`(x, y: IntMax32): IntMax32 {...}{.magic: "MulU", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*%`(x, y: int64): int64 {...}{.magic: "MulU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and multiplies them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd>  <dt><pre data-language="nim">proc `/%`(x, y: IntMax32): IntMax32 {...}{.magic: "DivU", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `/%`(x, y: int64): int64 {...}{.magic: "DivU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and divides them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd>  <dt><pre data-language="nim">proc `%%`(x, y: IntMax32): IntMax32 {...}{.magic: "ModU", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `%%`(x, y: int64): int64 {...}{.magic: "ModU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compute the modulo of <em>x</em> and <em>y</em>. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd>  <dt><pre data-language="nim">proc `&lt;=%`(x, y: IntMax32): bool {...}{.magic: "LeU", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=%`(x, y: int64): bool {...}{.magic: "LeU64", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &lt;= unsigned(y)</code>.   </dd>  <dt><pre data-language="nim">proc `&lt;%`(x, y: IntMax32): bool {...}{.magic: "LtU", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;%`(x, y: int64): bool {...}{.magic: "LtU64", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &lt; unsigned(y)</code>.   </dd>  <dt><pre data-language="nim">proc `not`[T: SomeUnsignedInt](x: T): T {...}{.magic: "BitnotI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise complement</em> of the integer <em>x</em>.   </dd>  <dt><pre data-language="nim">proc `shr`[T: SomeUnsignedInt](x: T; y: SomeInteger): T {...}{.magic: "ShrI", noSideEffect.}</pre></dt> <dd> computes the <em>shift right</em> operation of <em>x</em> and <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `shl`[T: SomeUnsignedInt](x: T; y: SomeInteger): T {...}{.magic: "ShlI", noSideEffect.}</pre></dt> <dd> computes the <em>shift left</em> operation of <em>x</em> and <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `and`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "BitandI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise and</em> of numbers <em>x</em> and <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `or`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "BitorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise or</em> of numbers <em>x</em> and <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `xor`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "BitxorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise xor</em> of numbers <em>x</em> and <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `==`[T: SomeUnsignedInt](x, y: T): bool {...}{.magic: "EqI", noSideEffect.}</pre></dt> <dd> Compares two unsigned integers for equality.   </dd>  <dt><pre data-language="nim">proc `+`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "AddU", noSideEffect.}</pre></dt> <dd> Binary <em>+</em> operator for unsigned integers.   </dd>  <dt><pre data-language="nim">proc `-`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "SubU", noSideEffect.}</pre></dt> <dd> Binary <em>-</em> operator for unsigned integers.   </dd>  <dt><pre data-language="nim">proc `*`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "MulU", noSideEffect.}</pre></dt> <dd> Binary <em>*</em> operator for unsigned integers.   </dd>  <dt><pre data-language="nim">proc `div`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "DivU", noSideEffect.}</pre></dt> <dd> computes the integer division. This is roughly the same as <code>trunc(x/y)</code>.<pre class="listing" data-language="nim">(7 div 5) == 1</pre>   </dd>  <dt><pre data-language="nim">proc `mod`[T: SomeUnsignedInt](x, y: T): T {...}{.magic: "ModU", noSideEffect.}</pre></dt> <dd> computes the integer modulo operation (remainder). This is the same as <code>x - (x div y) * y</code>.<pre class="listing" data-language="nim">(7 mod 5) == 2</pre>   </dd>  <dt><pre data-language="nim">proc `&lt;=`[T: SomeUnsignedInt](x, y: T): bool {...}{.magic: "LeU", noSideEffect.}</pre></dt> <dd> Returns true iff <code>x &lt;= y</code>.   </dd>  <dt><pre data-language="nim">proc `&lt;`[T: SomeUnsignedInt](x, y: T): bool {...}{.magic: "LtU", noSideEffect.}</pre></dt> <dd> Returns true iff <code>unsigned(x) &lt; unsigned(y)</code>.   </dd>  <dt><pre data-language="nim">proc `+`(x: float32): float32 {...}{.magic: "UnaryPlusF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x: float32): float32 {...}{.magic: "UnaryMinusF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x, y: float32): float32 {...}{.magic: "AddF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x, y: float32): float32 {...}{.magic: "SubF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*`(x, y: float32): float32 {...}{.magic: "MulF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `/`(x, y: float32): float32 {...}{.magic: "DivF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x: float): float {...}{.magic: "UnaryPlusF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x: float): float {...}{.magic: "UnaryMinusF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `+`(x, y: float): float {...}{.magic: "AddF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `-`(x, y: float): float {...}{.magic: "SubF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*`(x, y: float): float {...}{.magic: "MulF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `/`(x, y: float): float {...}{.magic: "DivF64", noSideEffect.}</pre></dt> <dd> computes the floating point division   </dd>  <dt><pre data-language="nim">proc `==`(x, y: float32): bool {...}{.magic: "EqF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: float32): bool {...}{.magic: "LeF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: float32): bool {...}{.magic: "LtF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `==`(x, y: float): bool {...}{.magic: "EqF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;=`(x, y: float): bool {...}{.magic: "LeF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `&lt;`(x, y: float): bool {...}{.magic: "LtF64", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `*`[T](x, y: set[T]): set[T] {...}{.magic: "MulSet", noSideEffect.}</pre></dt> <dd> This operator computes the intersection of two sets.   </dd>  <dt><pre data-language="nim">proc `+`[T](x, y: set[T]): set[T] {...}{.magic: "PlusSet", noSideEffect.}</pre></dt> <dd> This operator computes the union of two sets.   </dd>  <dt><pre data-language="nim">proc `-`[T](x, y: set[T]): set[T] {...}{.magic: "MinusSet", noSideEffect.}</pre></dt> <dd> This operator computes the difference of two sets.   </dd>  <dt><pre data-language="nim">proc contains[T](x: set[T]; y: T): bool {...}{.magic: "InSet", noSideEffect.}</pre></dt> <dd> One should overload this proc if one wants to overload the <code>in</code> operator. The parameters are in reverse order! <code>a in b</code> is a template for <code>contains(b, a)</code>. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the <code>in</code> operator that would be the wrong direction for this piece of code:<pre class="listing" data-language="nim">var s: set[range['a'..'z']] = {'a'..'c'}
writeLine(stdout, 'b' in s)</pre>
<p>If <code>in</code> had been declared as <code>[T](elem: T, s: set[T])</code> then <code>T</code> would have been bound to <code>char</code>. But <code>s</code> is not compatible to type <code>set[char]</code>! The solution is to bind <code>T</code> to <code>range['a'..'z']</code>. This is achieved by reversing the parameters for <code>contains</code>; <code>in</code> then passes its arguments in reverse order.</p>   </dd>  <dt><pre data-language="nim">proc contains[U, V, W](s: HSlice[U, V]; value: W): bool {...}{.noSideEffect, inline.}</pre></dt> <dd> Checks if <em>value</em> is within the range of <em>s</em>; returns true iff <em>value &gt;= s.a and value &lt;= s.b</em><pre class="listing" data-language="nim">assert((1..3).contains(1) == true)
assert((1..3).contains(2) == true)
assert((1..3).contains(4) == false)</pre>   </dd>  <dt><pre data-language="nim">proc `is`[T, S](x: T; y: S): bool {...}{.magic: "Is", noSideEffect.}</pre></dt> <dd> Checks if T is of the same type as S<pre class="listing" data-language="nim">proc test[T](a: T): int =
  when (T is int):
    return a
  else:
    return 0

assert(test[int](3) == 3)
assert(test[string]("xyz") == 0)</pre>   </dd>  <dt><pre data-language="nim">proc `of`[T, S](x: typedesc[T]; y: typedesc[S]): bool {...}{.magic: "Of", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `of`[T, S](x: T; y: typedesc[S]): bool {...}{.magic: "Of", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc `of`[T, S](x: T; y: S): bool {...}{.magic: "Of", noSideEffect.}</pre></dt> <dd> Checks if <em>x</em> has a type of <em>y</em><pre class="listing" data-language="nim">assert(FloatingPointError of Exception)
assert(DivByZeroError of Exception)</pre>   </dd>  <dt><pre data-language="nim">proc cmp[T](x, y: T): int {...}{.procvar.}</pre></dt> <dd> Generic compare proc. Returns a value &lt; 0 iff x &lt; y, a value &gt; 0 iff x &gt; y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the <em>==</em> and <em>&lt;</em> operators.<pre class="listing" data-language="nim">import algorithm
echo sorted(@[4,2,6,5,8,7], cmp[int])</pre>   </dd>  <dt><pre data-language="nim">proc `@`[IDX, T](a: array[IDX, T]): seq[T] {...}{.magic: "ArrToSeq", nosideeffect.}</pre></dt> <dd> turns an array into a sequence. This most often useful for constructing sequences with the array constructor: <code>@[1, 2, 3]</code> has the type <code>seq[int]</code>, while <code>[1, 2, 3]</code> has the type <code>array[0..2, int]</code>.   </dd>  <dt><pre data-language="nim">proc setLen[T](s: var seq[T]; newlen: Natural) {...}{.magic: "SetLengthSeq", noSideEffect.}</pre></dt> <dd> sets the length of <em>s</em> to <em>newlen</em>. <code>T</code> may be any sequence type. If the current length is greater than the new length, <code>s</code> will be truncated.   </dd>  <dt><pre data-language="nim">proc setLen(s: var string; newlen: Natural) {...}{.magic: "SetLengthStr", noSideEffect.}</pre></dt> <dd> sets the length of <em>s</em> to <em>newlen</em>. If the current length is greater than the new length, <code>s</code> will be truncated.<pre class="listing" data-language="nim">var myS = "Nim is great!!"
myS.setLen(3)
echo myS, " is fantastic!!"</pre>   </dd>  <dt><pre data-language="nim">proc newString(len: Natural): string {...}{.magic: "NewString", importc: "mnewString",
                                   noSideEffect.}</pre></dt> <dd> returns a new string of length <code>len</code> but with uninitialized content. One needs to fill the string character after character with the index operator <code>s[i]</code>. This procedure exists only for optimization purposes; the same effect can be achieved with the <code>&amp;</code> operator or with <code>add</code>.   </dd>  <dt><pre data-language="nim">proc newStringOfCap(cap: Natural): string {...}{.magic: "NewStringOfCap",
                                        importc: "rawNewString", noSideEffect.}</pre></dt> <dd> returns a new string of length <code>0</code> but with capacity <em>cap</em>.This procedure exists only for optimization purposes; the same effect can be achieved with the <code>&amp;</code> operator or with <code>add</code>.   </dd>  <dt><pre data-language="nim">proc `&amp;`(x: string; y: char): string {...}{.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> with <em>y</em><pre class="listing" data-language="nim">assert("ab" &amp; 'c' == "abc")</pre>   </dd>  <dt><pre data-language="nim">proc `&amp;`(x, y: char): string {...}{.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> and <em>y</em> into a string<pre class="listing" data-language="nim">assert('a' &amp; 'b' == "ab")</pre>   </dd>  <dt><pre data-language="nim">proc `&amp;`(x, y: string): string {...}{.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> and <em>y</em><pre class="listing" data-language="nim">assert("ab" &amp; "cd" == "abcd")</pre>   </dd>  <dt><pre data-language="nim">proc `&amp;`(x: char; y: string): string {...}{.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> with <em>y</em><pre class="listing" data-language="nim">assert('a' &amp; "bc" == "abc")</pre>   </dd>  <dt><pre data-language="nim">proc add(x: var string; y: char) {...}{.magic: "AppendStrCh", noSideEffect.}</pre></dt> <dd> Appends <em>y</em> to <em>x</em> in place<pre class="listing" data-language="nim">var tmp = ""
tmp.add('a')
tmp.add('b')
assert(tmp == "ab")</pre>   </dd>  <dt><pre data-language="nim">proc add(x: var string; y: string) {...}{.magic: "AppendStrStr", noSideEffect.}</pre></dt> <dd> Concatenates <em>x</em> and <em>y</em> in place<pre class="listing" data-language="nim">var tmp = ""
tmp.add("ab")
tmp.add("cd")
assert(tmp == "abcd")</pre>   </dd>  <dt><pre data-language="nim">proc compileOption(option: string): bool {...}{.magic: "CompileOption", noSideEffect.}</pre></dt> <dd> can be used to determine an on|off compile-time option. Example:<pre class="listing" data-language="nim">when compileOption("floatchecks"):
  echo "compiled with floating point NaN and Inf checks"</pre>   </dd>  <dt><pre data-language="nim">proc compileOption(option, arg: string): bool {...}{.magic: "CompileOptionArg", noSideEffect.}</pre></dt> <dd> can be used to determine an enum compile-time option. Example:<pre class="listing" data-language="nim">when compileOption("opt", "size") and compileOption("gc", "boehm"):
  echo "compiled with optimization for size and uses Boehm's GC"</pre>   </dd>  <dt><pre data-language="nim">proc quit(errorcode: int = QuitSuccess) {...}{.magic: "Exit", noreturn.}</pre></dt> <dd> <p>Stops the program immediately with an exit code.</p> <p>Before stopping the program the "quit procedures" are called in the opposite order they were added with <a href="#addQuitProc">addQuitProc</a>. <code>quit</code> never returns and ignores any exception that may have been raised by the quit procedures. It does <em>not</em> call the garbage collector to free all the memory, unless a quit procedure calls <a href="#GC_fullCollect">GC_fullCollect</a>.</p> <p>The proc <code>quit(QuitSuccess)</code> is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling <code>quit(QuitFailure)</code>.</p> <p>Note that this is a <em>runtime</em> call and using <code>quit</code> inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the <a href="manual#pragmas-error-pragma">error</a> or <a href="manual#pragmas-fatal-pragma">fatal</a> pragmas.</p>   </dd>  <dt><pre data-language="nim">proc add[T](x: var seq[T]; y: T) {...}{.magic: "AppendSeqElem", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc add[T](x: var seq[T]; y: openArray[T]) {...}{.noSideEffect.}</pre></dt> <dd> Generic proc for adding a data item <em>y</em> to a container <em>x</em>. For containers that have an order, <em>add</em> means <em>append</em>. New generic containers should also call their adding proc <em>add</em> for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.<pre class="listing" data-language="nim">var s: seq[string] = @["test2","test2"]
s.add("test") #=&gt; @[test2, test2, test]</pre>   </dd>  <dt><pre data-language="nim">proc del[T](x: var seq[T]; i: Natural) {...}{.noSideEffect.}</pre></dt> <dd> deletes the item at index <em>i</em> by putting <code>x[high(x)]</code> into position <em>i</em>. This is an O(1) operation.<pre class="listing" data-language="nim">var i = @[1, 2, 3, 4, 5]
i.del(2) #=&gt; @[1, 2, 5, 4]</pre>   </dd>  <dt><pre data-language="nim">proc delete[T](x: var seq[T]; i: Natural) {...}{.noSideEffect.}</pre></dt> <dd> deletes the item at index <em>i</em> by moving <code>x[i+1..]</code> by one position. This is an O(n) operation.<pre class="listing" data-language="nim">var i = @[1, 2, 3, 4, 5]
i.delete(2) #=&gt; @[1, 2, 4, 5]</pre>   </dd>  <dt><pre data-language="nim">proc insert[T](x: var seq[T]; item: T; i = 0.Natural) {...}{.noSideEffect.}</pre></dt> <dd> inserts <em>item</em> into <em>x</em> at position <em>i</em>.<pre class="listing" data-language="nim">var i = @[1, 2, 3, 4, 5]
i.insert(2, 4) #=&gt; @[1, 2, 3, 4, 2, 5]</pre>   </dd>  <dt><pre data-language="nim">proc repr[T](x: T): string {...}{.magic: "Repr", noSideEffect.}</pre></dt> <dd> takes any Nim variable and returns its string representation. It works even for complex data graphs with cycles. This is a great debugging tool.<pre class="listing" data-language="nim">var s: seq[string] = @["test2", "test2"]
var i = @[1, 2, 3, 4, 5]
repr(s) #=&gt; 0x1055eb050[0x1055ec050"test2", 0x1055ec078"test2"]
repr(i) #=&gt; 0x1055ed050[1, 2, 3, 4, 5]</pre>   </dd>  <dt><pre data-language="nim">proc toFloat(i: int): float {...}{.magic: "ToFloat", noSideEffect, importc: "toFloat".}</pre></dt> <dd> converts an integer <em>i</em> into a <code>float</code>. If the conversion fails, <em>EInvalidValue</em> is raised. However, on most platforms the conversion cannot fail.   </dd>  <dt><pre data-language="nim">proc toBiggestFloat(i: BiggestInt): BiggestFloat {...}{.magic: "ToBiggestFloat",
    noSideEffect, importc: "toBiggestFloat".}</pre></dt> <dd> converts an biggestint <em>i</em> into a <code>biggestfloat</code>. If the conversion fails, <em>EInvalidValue</em> is raised. However, on most platforms the conversion cannot fail.   </dd>  <dt><pre data-language="nim">proc toInt(f: float): int {...}{.magic: "ToInt", noSideEffect, importc: "toInt".}</pre></dt> <dd> converts a floating point number <em>f</em> into an <code>int</code>. Conversion rounds <em>f</em> if it does not contain an integer value. If the conversion fails (because <em>f</em> is infinite for example), <em>EInvalidValue</em> is raised.   </dd>  <dt><pre data-language="nim">proc toBiggestInt(f: BiggestFloat): BiggestInt {...}{.magic: "ToBiggestInt", noSideEffect,
    importc: "toBiggestInt".}</pre></dt> <dd> converts a biggestfloat <em>f</em> into a <code>biggestint</code>. Conversion rounds <em>f</em> if it does not contain an integer value. If the conversion fails (because <em>f</em> is infinite for example), <em>EInvalidValue</em> is raised.   </dd>  <dt><pre data-language="nim">proc addQuitProc(QuitProc: proc () {...}{.noconv.}) {...}{.importc: "atexit",
    header: "&lt;stdlib.h&gt;".}</pre></dt> <dd> <p>Adds/registers a quit procedure.</p> <p>Each call to <code>addQuitProc</code> registers another quit procedure. Up to 30 procedures can be registered. They are executed on a last-in, first-out basis (that is, the last function registered is the first to be executed). <code>addQuitProc</code> raises an EOutOfIndex exception if <code>QuitProc</code> cannot be registered.</p>   </dd>  <dt><pre data-language="nim">proc createU(T: typedesc; size = 1.Positive): ptr T:type {...}{.inline, gcsafe, locks: 0.}</pre></dt> <dd> allocates a new memory block with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resize(block, 0)</code> or <code>dealloc(block)</code>. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use <em>createSharedU</em> to allocate from a shared heap.   </dd>  <dt><pre data-language="nim">proc create(T: typedesc; size = 1.Positive): ptr T:type {...}{.inline, gcsafe, locks: 0.}</pre></dt> <dd> allocates a new memory block with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resize(block, 0)</code> or <code>dealloc(block)</code>. The block is initialized with all bytes containing zero, so it is somewhat safer than <code>createU</code>. The allocated memory belongs to its allocating thread! Use <em>createShared</em> to allocate from a shared heap.   </dd>  <dt><pre data-language="nim">proc resize[T](p: ptr T; newSize: Natural): ptr T {...}{.inline, gcsafe, locks: 0.}</pre></dt> <dd> grows or shrinks a given memory block. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <code>T.sizeof * newSize</code> bytes. If <code>newSize == 0</code> and p is not <strong>nil</strong> <code>resize</code> calls <code>dealloc(p)</code>. In other cases the block has to be freed with <code>free</code>. The allocated memory belongs to its allocating thread! Use <em>resizeShared</em> to reallocate from a shared heap.   </dd>  <dt><pre data-language="nim">proc createSharedU(T: typedesc; size = 1.Positive): ptr T:type {...}{.inline, gcsafe, locks: 0.}</pre></dt> <dd> allocates a new memory block on the shared heap with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resizeShared(block, 0)</code> or <code>freeShared(block)</code>. The block is not initialized, so reading from it before writing to it is undefined behaviour!   </dd>  <dt><pre data-language="nim">proc createShared(T: typedesc; size = 1.Positive): ptr T:type {...}{.inline.}</pre></dt> <dd> allocates a new memory block on the shared heap with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resizeShared(block, 0)</code> or <code>freeShared(block)</code>. The block is initialized with all bytes containing zero, so it is somewhat safer than <code>createSharedU</code>.   </dd>  <dt><pre data-language="nim">proc resizeShared[T](p: ptr T; newSize: Natural): ptr T {...}{.inline.}</pre></dt> <dd> grows or shrinks a given memory block on the heap. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <code>T.sizeof * newSize</code> bytes. If <code>newSize == 0</code> and p is not <strong>nil</strong> <code>resizeShared</code> calls <code>freeShared(p)</code>. In other cases the block has to be freed with <code>freeShared</code>.   </dd>  <dt><pre data-language="nim">proc freeShared[T](p: ptr T) {...}{.inline, gcsafe, locks: 0.}</pre></dt> <dd> frees the memory allocated with <code>createShared</code>, <code>createSharedU</code> or <code>resizeShared</code>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.   </dd>  <dt><pre data-language="nim">proc swap[T](a, b: var T) {...}{.magic: "Swap", noSideEffect.}</pre></dt> <dd> swaps the values <em>a</em> and <em>b</em>. This is often more efficient than <code>tmp = a; a = b; b = tmp</code>. Particularly useful for sorting algorithms.   </dd>  <dt><pre data-language="nim">proc `$`(x: int): string {...}{.magic: "IntToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for an integer argument. Returns <em>x</em> converted to a decimal string. <code>$</code> is Nim's general way of spelling <span id="tostring_1">toString</span>.   </dd>  <dt><pre data-language="nim">proc `$`(x: int64): string {...}{.magic: "Int64ToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for an integer argument. Returns <em>x</em> converted to a decimal string.   </dd>  <dt><pre data-language="nim">proc `$`(x: float): string {...}{.magic: "FloatToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a float argument. Returns <em>x</em> converted to a decimal string.   </dd>  <dt><pre data-language="nim">proc `$`(x: bool): string {...}{.magic: "BoolToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a boolean argument. Returns <em>x</em> converted to the string "false" or "true".   </dd>  <dt><pre data-language="nim">proc `$`(x: char): string {...}{.magic: "CharToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a character argument. Returns <em>x</em> converted to a string.   </dd>  <dt><pre data-language="nim">proc `$`(x: cstring): string {...}{.magic: "CStrToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a CString argument. Returns <em>x</em> converted to a string.   </dd>  <dt><pre data-language="nim">proc `$`(x: string): string {...}{.magic: "StrToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a string argument. Returns <em>x</em> as it is. This operator is useful for generic code, so that <code>$expr</code> also works if <code>expr</code> is already a string.   </dd>  <dt><pre data-language="nim">proc `$`[Enum: enum](x: Enum): string {...}{.magic: "EnumToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a <code>$</code> operator for a concrete enumeration is provided, this is used instead. (In other words: <em>Overwriting</em> is possible.)   </dd>  <dt><pre data-language="nim">proc getRefcount[T](x: ref T): int {...}{.importc: "getRefcount", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc getRefcount(x: string): int {...}{.importc: "getRefcount", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc getRefcount[T](x: seq[T]): int {...}{.importc: "getRefcount", noSideEffect.}</pre></dt> <dd> retrieves the reference count of an heap-allocated object. The value is implementation-dependent.   </dd>  <dt><pre data-language="nim">proc min(x, y: int): int {...}{.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc min(x, y: int8): int8 {...}{.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc min(x, y: int16): int16 {...}{.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc min(x, y: int32): int32 {...}{.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc min(x, y: int64): int64 {...}{.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> The minimum value of two integers.   </dd>  <dt><pre data-language="nim">proc min[T](x: openArray[T]): T</pre></dt> <dd> The minimum value of <em>x</em>. <code>T</code> needs to have a <code>&lt;</code> operator.   </dd>  <dt><pre data-language="nim">proc max(x, y: int): int {...}{.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc max(x, y: int8): int8 {...}{.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc max(x, y: int16): int16 {...}{.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc max(x, y: int32): int32 {...}{.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc max(x, y: int64): int64 {...}{.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> The maximum value of two integers.   </dd>  <dt><pre data-language="nim">proc max[T](x: openArray[T]): T</pre></dt> <dd> The maximum value of <em>x</em>. <code>T</code> needs to have a <code>&lt;</code> operator.   </dd>  <dt><pre data-language="nim">proc abs(x: float): float {...}{.magic: "AbsF64", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc min(x, y: float): float {...}{.magic: "MinF64", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc max(x, y: float): float {...}{.magic: "MaxF64", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc min[T](x, y: T): T</pre></dt>   <dt><pre data-language="nim">proc max[T](x, y: T): T</pre></dt>   <dt><pre data-language="nim">proc high(T: typedesc[SomeFloat]): T:type</pre></dt>   <dt><pre data-language="nim">proc low(T: typedesc[SomeFloat]): T:type</pre></dt>   <dt><pre data-language="nim">proc clamp[T](x, a, b: T): T</pre></dt> <dd> limits the value <code>x</code> within the interval [a, b]<pre class="listing" data-language="nim">assert((1.4).clamp(0.0, 1.0) == 1.0)
assert((0.5).clamp(0.0, 1.0) == 0.5)</pre>   </dd>  <dt><pre data-language="nim">proc len[U: Ordinal; V: Ordinal](x: HSlice[U, V]): int {...}{.noSideEffect, inline.}</pre></dt> <dd> length of ordinal slice, when x.b &lt; x.a returns zero length<pre class="listing" data-language="nim">assert((0..5).len == 6)
assert((5..2).len == 0)</pre>   </dd>  <dt><pre data-language="nim">proc isNil[T](x: seq[T]): bool {...}{.noSideEffect, magic: "IsNil", error.}</pre></dt>   <dt><pre data-language="nim">proc isNil[T](x: ref T): bool {...}{.noSideEffect, magic: "IsNil".}</pre></dt>   <dt><pre data-language="nim">proc isNil(x: string): bool {...}{.noSideEffect, magic: "IsNil", error.}</pre></dt>   <dt><pre data-language="nim">proc isNil[T](x: ptr T): bool {...}{.noSideEffect, magic: "IsNil".}</pre></dt>   <dt><pre data-language="nim">proc isNil(x: pointer): bool {...}{.noSideEffect, magic: "IsNil".}</pre></dt>   <dt><pre data-language="nim">proc isNil(x: cstring): bool {...}{.noSideEffect, magic: "IsNil".}</pre></dt>   <dt><pre data-language="nim">proc isNil[T: proc](x: T): bool {...}{.noSideEffect, magic: "IsNil".}</pre></dt> <dd> Fast check whether <em>x</em> is nil. This is sometimes more efficient than <code>== nil</code>.   </dd>  <dt><pre data-language="nim">proc `==`[I, T](x, y: array[I, T]): bool</pre></dt>   <dt><pre data-language="nim">proc `==`[T](x, y: openArray[T]): bool</pre></dt>   <dt><pre data-language="nim">proc `@`[T](a: openArray[T]): seq[T]</pre></dt> <dd> turns an openarray into a sequence. This is not as efficient as turning a fixed length array into a sequence as it always copies every element of <em>a</em>.   </dd>  <dt><pre data-language="nim">proc `&amp;`[T](x, y: seq[T]): seq[T] {...}{.noSideEffect.}</pre></dt> <dd> Concatenates two sequences. Requires copying of the sequences.<pre class="listing" data-language="nim">assert(@[1, 2, 3, 4] &amp; @[5, 6] == @[1, 2, 3, 4, 5, 6])</pre>   </dd>  <dt><pre data-language="nim">proc `&amp;`[T](x: seq[T]; y: T): seq[T] {...}{.noSideEffect.}</pre></dt> <dd> Appends element y to the end of the sequence. Requires copying of the sequence<pre class="listing" data-language="nim">assert(@[1, 2, 3] &amp; 4 == @[1, 2, 3, 4])</pre>   </dd>  <dt><pre data-language="nim">proc `&amp;`[T](x: T; y: seq[T]): seq[T] {...}{.noSideEffect.}</pre></dt> <dd> Prepends the element x to the beginning of the sequence. Requires copying of the sequence<pre class="listing" data-language="nim">assert(1 &amp; @[2, 3, 4] == @[1, 2, 3, 4])</pre>   </dd>  <dt><pre data-language="nim">proc `==`[T](x, y: seq[T]): bool {...}{.noSideEffect.}</pre></dt> <dd> Generic equals operator for sequences: relies on a equals operator for the element type <em>T</em>.   </dd>  <dt><pre data-language="nim">proc find[T, S](a: T; item: S): int {...}{.inline.}</pre></dt> <dd> Returns the first index of <em>item</em> in <em>a</em> or -1 if not found. This requires appropriate <em>items</em> and <em>==</em> operations to work.   </dd>  <dt><pre data-language="nim">proc contains[T](a: openArray[T]; item: T): bool {...}{.inline.}</pre></dt> <dd> Returns true if <em>item</em> is in <em>a</em> or false if not found. This is a shortcut for <code>find(a, item) &gt;= 0</code>.   </dd>  <dt><pre data-language="nim">proc pop[T](s: var seq[T]): T {...}{.inline, noSideEffect.}</pre></dt> <dd> returns the last item of <em>s</em> and decreases <code>s.len</code> by one. This treats <em>s</em> as a stack and implements the common <em>pop</em> operation.   </dd>  <dt><pre data-language="nim">proc `==`[T: tuple |
    object](x, y: T): bool</pre></dt> <dd> generic <code>==</code> operator for tuples that is lifted from the components of <em>x</em> and <em>y</em>.   </dd>  <dt><pre data-language="nim">proc `&lt;=`[T: tuple](x, y: T): bool</pre></dt> <dd> generic <code>&lt;=</code> operator for tuples that is lifted from the components of <em>x</em> and <em>y</em>. This implementation uses <em>cmp</em>.   </dd>  <dt><pre data-language="nim">proc `&lt;`[T: tuple](x, y: T): bool</pre></dt> <dd> generic <code>&lt;</code> operator for tuples that is lifted from the components of <em>x</em> and <em>y</em>. This implementation uses <em>cmp</em>.   </dd>  <dt><pre data-language="nim">proc `$`[T: tuple |
    object](x: T): string</pre></dt> <dd> generic <code>$</code> operator for tuples that is lifted from the components of <em>x</em>. Example:<pre class="listing" data-language="nim">$(23, 45) == "(23, 45)"
$() == "()"</pre>   </dd>  <dt><pre data-language="nim">proc `$`[T](x: set[T]): string</pre></dt> <dd> generic <code>$</code> operator for sets that is lifted from the components of <em>x</em>. Example:<pre class="listing" data-language="nim">${23, 45} == "{23, 45}"</pre>   </dd>  <dt><pre data-language="nim">proc `$`[T](x: seq[T]): string</pre></dt> <dd> generic <code>$</code> operator for seqs that is lifted from the components of <em>x</em>. Example:<pre class="listing" data-language="nim">$(@[23, 45]) == "@[23, 45]"</pre>   </dd>  <dt><pre data-language="nim">proc GC_ref[T](x: ref T) {...}{.magic: "GCref", gcsafe, locks: 0.}</pre></dt>   <dt><pre data-language="nim">proc GC_ref[T](x: seq[T]) {...}{.magic: "GCref", gcsafe, locks: 0.}</pre></dt>   <dt><pre data-language="nim">proc GC_ref(x: string) {...}{.magic: "GCref", gcsafe, locks: 0.}</pre></dt> <dd> marks the object <em>x</em> as referenced, so that it will not be freed until it is unmarked via <em>GC_unref</em>. If called n-times for the same object <em>x</em>, n calls to <em>GC_unref</em> are needed to unmark <em>x</em>.   </dd>  <dt><pre data-language="nim">proc GC_unref[T](x: ref T) {...}{.magic: "GCunref", gcsafe, locks: 0.}</pre></dt>   <dt><pre data-language="nim">proc GC_unref[T](x: seq[T]) {...}{.magic: "GCunref", gcsafe, locks: 0.}</pre></dt>   <dt><pre data-language="nim">proc GC_unref(x: string) {...}{.magic: "GCunref", gcsafe, locks: 0.}</pre></dt> <dd> see the documentation of <em>GC_ref</em>.   </dd>  <dt><pre data-language="nim">proc add(x: var string; y: cstring) {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc echo(x: varargs[typed, `$`]) {...}{.magic: "Echo", tags: [WriteIOEffect], gcsafe,
                                locks: 0, sideEffect.}</pre></dt> <dd> <p>Writes and flushes the parameters to the standard output.</p> <p>Special built-in that takes a variable number of arguments. Each argument is converted to a string via <code>$</code>, so it works for user-defined types that have an overloaded <code>$</code> operator. It is roughly equivalent to <code>writeLine(stdout, x); flushFile(stdout)</code>, but available for the JavaScript target too.</p> <p>Unlike other IO operations this is guaranteed to be thread-safe as <code>echo</code> is very often used for debugging convenience. If you want to use <code>echo</code> inside a <a href="manual#pragmas-nosideeffect-pragma">proc without side effects</a> you can use <a href="#debugEcho">debugEcho</a> instead.</p>   </dd>  <dt><pre data-language="nim">proc debugEcho(x: varargs[typed, `$`]) {...}{.magic: "Echo", noSideEffect, tags: [],
                                     raises: [].}</pre></dt> <dd> Same as <a href="#echo">echo</a>, but as a special semantic rule, <code>debugEcho</code> pretends to be free of side effects, so that it can be used for debugging routines marked as <a href="manual#pragmas-nosideeffect-pragma">noSideEffect</a>.   </dd>  <dt><pre data-language="nim">proc getTypeInfo[T](x: T): pointer {...}{.magic: "GetTypeInfo", gcsafe, locks: 0.}</pre></dt> <dd> get type information for <em>x</em>. Ordinary code should not use this, but the <em>typeinfo</em> module instead.   </dd>  <dt><pre data-language="nim">proc abs(x: int): int {...}{.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc abs(x: int8): int8 {...}{.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc abs(x: int16): int16 {...}{.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc abs(x: int32): int32 {...}{.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc abs(x: int64): int64 {...}{.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> returns the absolute value of <em>x</em>. If <em>x</em> is <code>low(x)</code> (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on).   </dd>  <dt><pre data-language="nim">proc zeroMem(p: pointer; size: Natural) {...}{.inline, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> overwrites the contents of the memory at <code>p</code> with the value 0. Exactly <code>size</code> bytes will be overwritten. Like any procedure dealing with raw memory this is <em>unsafe</em>.   </dd>  <dt><pre data-language="nim">proc copyMem(dest, source: pointer; size: Natural) {...}{.inline, gcsafe, locks: 0, tags: [],
    locks: 0, raises: [].}</pre></dt> <dd> copies the contents from the memory at <code>source</code> to the memory at <code>dest</code>. Exactly <code>size</code> bytes will be copied. The memory regions may not overlap. Like any procedure dealing with raw memory this is <em>unsafe</em>.   </dd>  <dt><pre data-language="nim">proc moveMem(dest, source: pointer; size: Natural) {...}{.inline, gcsafe, locks: 0, tags: [],
    locks: 0, raises: [].}</pre></dt> <dd> copies the contents from the memory at <code>source</code> to the memory at <code>dest</code>. Exactly <code>size</code> bytes will be copied. The memory regions may overlap, <code>moveMem</code> handles this case appropriately and is thus somewhat more safe than <code>copyMem</code>. Like any procedure dealing with raw memory this is still <em>unsafe</em>, though.   </dd>  <dt><pre data-language="nim">proc equalMem(a, b: pointer; size: Natural): bool {...}{.inline, noSideEffect, tags: [],
    locks: 0, raises: [].}</pre></dt> <dd> compares the memory blocks <code>a</code> and <code>b</code>. <code>size</code> bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is <em>unsafe</em>.   </dd>  <dt><pre data-language="nim">proc cmp(x, y: string): int {...}{.noSideEffect, procvar, raises: [], tags: [].}</pre></dt> <dd> Compare proc for strings. More efficient than the generic version. <strong>Note</strong>: The precise result values depend on the used C runtime library and can differ between operating systems!   </dd>  <dt><pre data-language="nim">proc open(f: var File; filename: string; mode: FileMode = fmRead; bufSize: int = -1): bool {...}{.
    tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Returns true iff the file could be opened. This throws no exception if the file could not be opened.</p>   </dd>  <dt><pre data-language="nim">proc open(f: var File; filehandle: FileHandle; mode: FileMode = fmRead): bool {...}{.tags: [],
    gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>Creates a <code>File</code> from a <em>filehandle</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Returns true iff the file could be opened.</p>   </dd>  <dt><pre data-language="nim">proc open(filename: string; mode: FileMode = fmRead; bufSize: int = -1): File {...}{.
    raises: [Exception, IOError], tags: [].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Raises an <code>IO</code> exception if the file could not be opened.</p>   </dd>  <dt><pre data-language="nim">proc reopen(f: File; filename: string; mode: FileMode = fmRead): bool {...}{.tags: [], gcsafe,
    locks: 0, raises: [].}</pre></dt> <dd> <p>reopens the file <em>f</em> with given <em>filename</em> and <em>mode</em>. This is often used to redirect the <em>stdin</em>, <em>stdout</em> or <em>stderr</em> file variables.</p> <p>Default mode is readonly. Returns true iff the file could be reopened.</p>   </dd>  <dt><pre data-language="nim">proc setStdIoUnbuffered() {...}{.tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> Configures <em>stdin</em>, <em>stdout</em> and <em>stderr</em> to be unbuffered.   </dd>  <dt><pre data-language="nim">proc close(f: File) {...}{.tags: [], gcsafe, raises: [].}</pre></dt> <dd> Closes the file.   </dd>  <dt><pre data-language="nim">proc endOfFile(f: File): bool {...}{.tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> Returns true iff <em>f</em> is at the end.   </dd>  <dt><pre data-language="nim">proc readChar(f: File): char {...}{.tags: [ReadIOEffect], raises: [IOError, EOFError].}</pre></dt> <dd> Reads a single character from the stream <em>f</em>. Should not be used in performance sensitive code.   </dd>  <dt><pre data-language="nim">proc flushFile(f: File) {...}{.tags: [WriteIOEffect], raises: [].}</pre></dt> <dd> Flushes <em>f</em>'s buffer.   </dd>  <dt><pre data-language="nim">proc readAll(file: File): TaintedString {...}{.tags: [ReadIOEffect], gcsafe, locks: 0,
                                      raises: [IOError].}</pre></dt> <dd> <p>Reads all data from the stream <em>file</em>.</p> <p>Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.</p>   </dd>  <dt><pre data-language="nim">proc readFile(filename: string): TaintedString {...}{.tags: [ReadIOEffect], gcsafe,
    locks: 0, raises: [IOError].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> for reading.</p> <p>Then calls <a href="#readAll">readAll</a> and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use <a href="#staticRead">staticRead</a>.</p>   </dd>  <dt><pre data-language="nim">proc writeFile(filename, content: string) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0,
                                        raises: [IOError].}</pre></dt> <dd> Opens a file named <em>filename</em> for writing. Then writes the <em>content</em> completely to the file and closes the file afterwards. Raises an IO exception in case of an error.   </dd>  <dt><pre data-language="nim">proc write(f: File; r: float32) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0,
                             raises: [IOError].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; i: int) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; i: BiggestInt) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0,
                                raises: [IOError].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; r: BiggestFloat) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0,
                                  raises: [IOError].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; s: string) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0,
                            raises: [IOError].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; b: bool) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; c: char) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; c: cstring) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0,
                             raises: [IOError].}</pre></dt>   <dt><pre data-language="nim">proc write(f: File; a: varargs[string, `$`]) {...}{.tags: [WriteIOEffect], gcsafe, locks: 0,
    raises: [IOError].}</pre></dt> <dd> Writes a value to the file <em>f</em>. May throw an IO exception.   </dd>  <dt><pre data-language="nim">proc readLine(f: File): TaintedString {...}{.tags: [ReadIOEffect], gcsafe, locks: 0,
                                    raises: [IOError, EOFError].}</pre></dt> <dd> reads a line of text from the file <em>f</em>. May throw an IO exception. A line of text may be delimited by <code>LF</code> or <code>CRLF</code>. The newline character(s) are not part of the returned string.   </dd>  <dt><pre data-language="nim">proc readLine(f: File; line: var TaintedString): bool {...}{.tags: [ReadIOEffect], gcsafe,
    locks: 0, raises: [IOError].}</pre></dt> <dd> reads a line of text from the file <em>f</em> into <em>line</em>. May throw an IO exception. A line of text may be delimited by <code>LF</code> or <code>CRLF</code>. The newline character(s) are not part of the returned string. Returns <code>false</code> if the end of the file has been reached, <code>true</code> otherwise. If <code>false</code> is returned <em>line</em> contains no new data.   </dd>  <dt><pre data-language="nim">proc writeLine[Ty](f: File; x: varargs[Ty, `$`]) {...}{.inline, tags: [WriteIOEffect], gcsafe,
    locks: 0.}</pre></dt> <dd> writes the values <em>x</em> to <em>f</em> and then writes "\n". May throw an IO exception.   </dd>  <dt><pre data-language="nim">proc getFileSize(f: File): int64 {...}{.tags: [ReadIOEffect], gcsafe, locks: 0,
                               raises: [IOError].}</pre></dt> <dd> retrieves the file size (in bytes) of <em>f</em>.   </dd>  <dt><pre data-language="nim">proc readBytes(f: File; a: var openArray[int8 | uint8]; start, len: Natural): int {...}{.
    tags: [ReadIOEffect], gcsafe, locks: 0.}</pre></dt> <dd> reads <em>len</em> bytes into the buffer <em>a</em> starting at <code>a[start]</code>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.   </dd>  <dt><pre data-language="nim">proc readChars(f: File; a: var openArray[char]; start, len: Natural): int {...}{.
    tags: [ReadIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> <p>reads <em>len</em> bytes into the buffer <em>a</em> starting at <code>a[start]</code>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.</p> <p><strong>Warning:</strong> The buffer <em>a</em> must be pre-allocated. This can be done using, for example, <code>newString</code>.</p>   </dd>  <dt><pre data-language="nim">proc readBuffer(f: File; buffer: pointer; len: Natural): int {...}{.tags: [ReadIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> reads <em>len</em> bytes into the buffer pointed to by <em>buffer</em>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.   </dd>  <dt><pre data-language="nim">proc writeBytes(f: File; a: openArray[int8 | uint8]; start, len: Natural): int {...}{.
    tags: [WriteIOEffect], gcsafe, locks: 0.}</pre></dt> <dd> writes the bytes of <code>a[start..start+len-1]</code> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd>  <dt><pre data-language="nim">proc writeChars(f: File; a: openArray[char]; start, len: Natural): int {...}{.
    tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> writes the bytes of <code>a[start..start+len-1]</code> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd>  <dt><pre data-language="nim">proc writeBuffer(f: File; buffer: pointer; len: Natural): int {...}{.tags: [WriteIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> writes the bytes of buffer pointed to by the parameter <em>buffer</em> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd>  <dt><pre data-language="nim">proc setFilePos(f: File; pos: int64; relativeTo: FileSeekPos = fspSet) {...}{.gcsafe, locks: 0,
    raises: [IOError], tags: [].}</pre></dt> <dd> sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero.   </dd>  <dt><pre data-language="nim">proc getFilePos(f: File): int64 {...}{.gcsafe, locks: 0, raises: [IOError], tags: [].}</pre></dt> <dd> retrieves the current position of the file pointer that is used to read from the file <em>f</em>. The file's first byte has the index zero.   </dd>  <dt><pre data-language="nim">proc getFileHandle(f: File): FileHandle {...}{.raises: [], tags: [].}</pre></dt> <dd> returns the OS file handle of the file <code>f</code>. This is only useful for platform specific programming.   </dd>  <dt><pre data-language="nim">proc cstringArrayToSeq(a: cstringArray; len: Natural): seq[string] {...}{.raises: [],
    tags: [].}</pre></dt> <dd> converts a <code>cstringArray</code> to a <code>seq[string]</code>. <em>a</em> is supposed to be of length <code>len</code>.   </dd>  <dt><pre data-language="nim">proc cstringArrayToSeq(a: cstringArray): seq[string] {...}{.raises: [], tags: [].}</pre></dt> <dd> converts a <code>cstringArray</code> to a <code>seq[string]</code>. <em>a</em> is supposed to be terminated by <code>nil</code>.   </dd>  <dt><pre data-language="nim">proc allocCStringArray(a: openArray[string]): cstringArray {...}{.raises: [Exception],
    tags: [].}</pre></dt> <dd> creates a NULL terminated cstringArray from <em>a</em>. The result has to be freed with <em>deallocCStringArray</em> after it's not needed anymore.   </dd>  <dt><pre data-language="nim">proc deallocCStringArray(a: cstringArray) {...}{.raises: [Exception], tags: [].}</pre></dt> <dd> frees a NULL terminated cstringArray.   </dd>  <dt><pre data-language="nim">proc atomicInc(memLoc: var int; x: int = 1): int {...}{.inline, discardable, gcsafe, locks: 0,
    raises: [], tags: [].}</pre></dt> <dd> atomic increment of <em>memLoc</em>. Returns the value after the operation.   </dd>  <dt><pre data-language="nim">proc atomicDec(memLoc: var int; x: int = 1): int {...}{.inline, discardable, gcsafe, locks: 0,
    raises: [], tags: [].}</pre></dt> <dd> atomic decrement of <em>memLoc</em>. Returns the value after the operation.   </dd>  <dt><pre data-language="nim">proc setControlCHook(hook: proc () {...}{.noconv.}) {...}{.raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.   </dd>  <dt><pre data-language="nim">proc writeStackTrace() {...}{.tags: [], gcsafe, raises: [Exception].}</pre></dt> <dd> writes the current stack trace to <code>stderr</code>. This is only works for debug builds. Since it's usually used for debugging, this is proclaimed to have no IO effect!   </dd>  <dt><pre data-language="nim">proc getStackTrace(): string {...}{.gcsafe, raises: [], tags: [].}</pre></dt> <dd> gets the current stack trace. This only works for debug builds.   </dd>  <dt><pre data-language="nim">proc getStackTrace(e: ref Exception): string {...}{.gcsafe, raises: [], tags: [].}</pre></dt> <dd> gets the stack trace associated with <em>e</em>, which is the stack that lead to the <code>raise</code> statement. This only works for debug builds.   </dd>  <dt><pre data-language="nim">proc getCurrentException(): ref Exception {...}{.compilerproc, inline, gcsafe, locks: 0,
                                        raises: [], tags: [].}</pre></dt> <dd> retrieves the current exception; if there is none, nil is returned.   </dd>  <dt><pre data-language="nim">proc getCurrentExceptionMsg(): string {...}{.inline, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> retrieves the error message that was attached to the current exception; if there is none, "" is returned.   </dd>  <dt><pre data-language="nim">proc onRaise(action: proc (e: ref Exception): bool {...}{.closure.}) {...}{.deprecated, raises: [],
    tags: [].}</pre></dt> <dd> <p>can be used in a <code>try</code> statement to setup a Lisp-like <span id="condition-system_1">condition system</span>: This prevents the 'raise' statement to raise an exception but instead calls <code>action</code>. If <code>action</code> returns false, the exception has been handled and does not propagate further through the call stack.</p> <p><em>Deprecated since version 0.18.1</em>: No good usages of this feature are known.</p>   </dd>  <dt><pre data-language="nim">proc setCurrentException(exc: ref Exception) {...}{.inline, gcsafe, locks: 0, raises: [],
    tags: [].}</pre></dt> <dd> <p>sets the current exception.</p> <p><strong>Warning</strong>: Only use this if you know what you are doing.</p>   </dd>  <dt><pre data-language="nim">proc rawProc[T: proc](x: T): pointer {...}{.noSideEffect, inline.}</pre></dt> <dd> retrieves the raw proc pointer of the closure <em>x</em>. This is useful for interfacing closures with C.   </dd>  <dt><pre data-language="nim">proc rawEnv[T: proc](x: T): pointer {...}{.noSideEffect, inline.}</pre></dt> <dd> retrieves the raw environment pointer of the closure <em>x</em>. This is useful for interfacing closures with C.   </dd>  <dt><pre data-language="nim">proc finished[T: proc](x: T): bool {...}{.noSideEffect, inline.}</pre></dt> <dd> can be used to determine if a first class iterator has finished.   </dd>  <dt><pre data-language="nim">proc `$`[T, IDX](x: array[IDX, T]): string</pre></dt> <dd> generic <code>$</code> operator for arrays that is lifted from the components   </dd>  <dt><pre data-language="nim">proc `$`[T](x: openArray[T]): string</pre></dt> <dd> generic <code>$</code> operator for openarrays that is lifted from the components of <em>x</em>. Example:<pre class="listing" data-language="nim">$(@[23, 45].toOpenArray(0, 1)) == "[23, 45]"</pre>   </dd>  <dt><pre data-language="nim">proc quit(errormsg: string; errorcode = QuitFailure) {...}{.noReturn, raises: [], tags: [].}</pre></dt> <dd> a shorthand for <code>echo(errormsg); quit(errorcode)</code>.   </dd>  <dt><pre data-language="nim">proc `/`(x, y: int): float {...}{.inline, noSideEffect, raises: [], tags: [].}</pre></dt> <dd> integer division that results in a float.   </dd>  <dt><pre data-language="nim">proc `[]`[T, U](s: string; x: HSlice[T, U]): string {...}{.inline.}</pre></dt> <dd> slice operation for strings. returns the inclusive range [s[x.a], s[x.b]]:<pre class="listing" data-language="nim">var s = "abcdef"
assert s[1..3] == "bcd"</pre>   </dd>  <dt><pre data-language="nim">proc `[]=`[T, U](s: var string; x: HSlice[T, U]; b: string)</pre></dt> <dd> slice assignment for strings. If <code>b.len</code> is not exactly the number of elements that are referred to by <em>x</em>, a <span id="splice_1">splice</span> is performed:<pre class="listing" data-language="nim">var s = "abcdef"
s[1 .. ^2] = "xyz"
assert s == "axyzf"</pre>   </dd>  <dt><pre data-language="nim">proc `[]`[Idx, T, U, V](a: array[Idx, T]; x: HSlice[U, V]): seq[T]</pre></dt> <dd> slice operation for arrays. returns the inclusive range [a[x.a], a[x.b]]:<pre class="listing" data-language="nim">var a = [1,2,3,4]
assert a[0..2] == @[1,2,3]</pre>   </dd>  <dt><pre data-language="nim">proc `[]=`[Idx, T, U, V](a: var array[Idx, T]; x: HSlice[U, V]; b: openArray[T])</pre></dt> <dd> slice assignment for arrays.   </dd>  <dt><pre data-language="nim">proc `[]`[T, U, V](s: openArray[T]; x: HSlice[U, V]): seq[T]</pre></dt> <dd> slice operation for sequences. returns the inclusive range [s[x.a], s[x.b]]:<pre class="listing" data-language="nim">var s = @[1,2,3,4]
assert s[0..2] == @[1,2,3]</pre>   </dd>  <dt><pre data-language="nim">proc `[]=`[T, U, V](s: var seq[T]; x: HSlice[U, V]; b: openArray[T])</pre></dt> <dd> slice assignment for sequences. If <code>b.len</code> is not exactly the number of elements that are referred to by <em>x</em>, a <span id="splice_2">splice</span> is performed.   </dd>  <dt><pre data-language="nim">proc `[]`[T](s: openArray[T]; i: BackwardsIndex): T {...}{.inline.}</pre></dt>   <dt><pre data-language="nim">proc `[]`[Idx, T](a: array[Idx, T]; i: BackwardsIndex): T {...}{.inline.}</pre></dt>   <dt><pre data-language="nim">proc `[]`(s: string; i: BackwardsIndex): char {...}{.inline, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc `[]`[T](s: var openArray[T]; i: BackwardsIndex): var T {...}{.inline.}</pre></dt>   <dt><pre data-language="nim">proc `[]`[Idx, T](a: var array[Idx, T]; i: BackwardsIndex): var T {...}{.inline.}</pre></dt>   <dt><pre data-language="nim">proc `[]=`[T](s: var openArray[T]; i: BackwardsIndex; x: T) {...}{.inline.}</pre></dt>   <dt><pre data-language="nim">proc `[]=`[Idx, T](a: var array[Idx, T]; i: BackwardsIndex; x: T) {...}{.inline.}</pre></dt>   <dt><pre data-language="nim">proc `[]=`(s: var string; i: BackwardsIndex; x: char) {...}{.inline, raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc slurp(filename: string): string {...}{.magic: "Slurp".}</pre></dt> <dd> This is an alias for <a href="#staticRead">staticRead</a>.   </dd>  <dt><pre data-language="nim">proc staticRead(filename: string): string {...}{.magic: "Slurp".}</pre></dt> <dd> Compile-time <a href="#readFile">readFile</a> proc for easy <span id="resource_1">resource</span> embedding:<pre class="listing" data-language="nim">const myResource = staticRead"mydatafile.bin"</pre>
<p><a href="#slurp">slurp</a> is an alias for <code>staticRead</code>.</p>   </dd>  <dt><pre data-language="nim">proc gorge(command: string; input = ""; cache = ""): string {...}{.magic: "StaticExec",
    raises: [], tags: [].}</pre></dt> <dd> This is an alias for <a href="#staticExec">staticExec</a>.   </dd>  <dt><pre data-language="nim">proc staticExec(command: string; input = ""; cache = ""): string {...}{.magic: "StaticExec",
    raises: [], tags: [].}</pre></dt> <dd> Executes an external process at compile-time. if <em>input</em> is not an empty string, it will be passed as a standard input to the executed program.<pre class="listing" data-language="nim">const buildInfo = "Revision " &amp; staticExec("git rev-parse HEAD") &amp;
                  "\nCompiled on " &amp; staticExec("uname -v")</pre>
<p><a href="#gorge">gorge</a> is an alias for <code>staticExec</code>. Note that you can use this proc inside a pragma like <a href="nimc#passc-pragma">passC</a> or <a href="nimc#passl-pragma">passL</a>.</p> <p>If <code>cache</code> is not empty, the results of <code>staticExec</code> are cached within the <code>nimcache</code> directory. Use <code>--forceBuild</code> to get rid of this caching behaviour then. <code>command &amp; input &amp; cache</code> (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for <code>cache</code>:</p> <pre class="listing" data-language="nim">const stateMachine = staticExec("dfaoptimizer", "input", "0.8.0")</pre>   </dd>  <dt><pre data-language="nim">proc gorgeEx(command: string; input = ""; cache = ""): tuple[output: string, exitCode: int] {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Same as <em>gorge</em> but also returns the precious exit code.   </dd>  <dt><pre data-language="nim">proc `+=`[T: SomeOrdinal | uint | uint64](x: var T; y: T) {...}{.magic: "Inc", noSideEffect.}</pre></dt> <dd> Increments an ordinal   </dd>  <dt><pre data-language="nim">proc `-=`[T: SomeOrdinal | uint | uint64](x: var T; y: T) {...}{.magic: "Dec", noSideEffect.}</pre></dt> <dd> Decrements an ordinal   </dd>  <dt><pre data-language="nim">proc `*=`[T: SomeOrdinal | uint | uint64](x: var T; y: T) {...}{.inline, noSideEffect.}</pre></dt> <dd> Binary <em>*=</em> operator for ordinals   </dd>  <dt><pre data-language="nim">proc `+=`[T: float | float32 | float64](x: var T; y: T) {...}{.inline, noSideEffect.}</pre></dt> <dd> Increments in place a floating point number   </dd>  <dt><pre data-language="nim">proc `-=`[T: float | float32 | float64](x: var T; y: T) {...}{.inline, noSideEffect.}</pre></dt> <dd> Decrements in place a floating point number   </dd>  <dt><pre data-language="nim">proc `*=`[T: float | float32 | float64](x: var T; y: T) {...}{.inline, noSideEffect.}</pre></dt> <dd> Multiplies in place a floating point number   </dd>  <dt><pre data-language="nim">proc `/=`(x: var float64; y: float64) {...}{.inline, noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Divides in place a floating point number   </dd>  <dt><pre data-language="nim">proc `/=`[T: float | float32](x: var T; y: T) {...}{.inline, noSideEffect.}</pre></dt> <dd> Divides in place a floating point number   </dd>  <dt><pre data-language="nim">proc `&amp;=`(x: var string; y: string) {...}{.magic: "AppendStrStr", noSideEffect.}</pre></dt>   <dt><pre data-language="nim">proc astToStr[T](x: T): string {...}{.magic: "AstToStr", noSideEffect.}</pre></dt> <dd> converts the AST of <em>x</em> into a string representation. This is very useful for debugging.   </dd>  <dt><pre data-language="nim">proc instantiationInfo(index = -1; fullPaths = false): tuple[filename: string, line: int,
    column: int] {...}{.magic: "InstantiationInfo", noSideEffect.}</pre></dt> <dd> <p>provides access to the compiler's instantiation stack line information of a template.</p> <p>While similar to the <span id="caller-info_1">caller info</span> of other languages, it is determined at compile time.</p> <p>This proc is mostly useful for meta programming (eg. <code>assert</code> template) to retrieve information about the current filename and line number. Example:</p> <pre class="listing" data-language="nim">import strutils

template testException(exception, code: untyped): typed =
  try:
    let pos = instantiationInfo()
    discard(code)
    echo "Test failure at $1:$2 with '$3'" % [pos.filename,
      $pos.line, astToStr(code)]
    assert false, "A test expecting failure succeeded?"
  except exception:
    discard

proc tester(pos: int): int =
  let
    a = @[1, 2, 3]
  result = a[pos]

when isMainModule:
  testException(IndexError, tester(30))
  testException(IndexError, tester(1))
  # --&gt; Test failure at example.nim:20 with 'tester(1)'</pre>   </dd>  <dt><pre data-language="nim">proc raiseAssert(msg: string) {...}{.noinline, raises: [AssertionError], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc failedAssertImpl(msg: string) {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc shallow[T](s: var seq[T]) {...}{.noSideEffect, inline.}</pre></dt> <dd> marks a sequence <em>s</em> as <span id="shallow_1">shallow</span>. Subsequent assignments will not perform deep copies of <em>s</em>. This is only useful for optimization purposes.   </dd>  <dt><pre data-language="nim">proc shallow(s: var string) {...}{.noSideEffect, inline, raises: [], tags: [].}</pre></dt> <dd> marks a string <em>s</em> as <span id="shallow_2">shallow</span>. Subsequent assignments will not perform deep copies of <em>s</em>. This is only useful for optimization purposes.   </dd>  <dt><pre data-language="nim">proc insert(x: var string; item: string; i = 0.Natural) {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> inserts <em>item</em> into <em>x</em> at position <em>i</em>.   </dd>  <dt><pre data-language="nim">proc compiles(x: untyped): bool {...}{.magic: "Compiles", noSideEffect, compileTime,
                              raises: [], tags: [].}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> can be compiled without any semantic error. This can be used to check whether a type supports some operation:<pre class="listing" data-language="nim">when compiles(3 + 4):
  echo "'+' for integers is available"</pre>   </dd>  <dt><pre data-language="nim">proc addEscapedChar(s: var string; c: char) {...}{.noSideEffect, inline, raises: [], tags: [].}</pre></dt> <dd> Adds a char to string <em>s</em> and applies the following escaping:<ul class="simple">
<li>replaces any <code>\</code> by <code>\\</code>
</li> <li>replaces any <code>'</code> by <code>\'</code>
</li> <li>replaces any <code>"</code> by <code>\"</code>
</li> <li>replaces any <code>\a</code> by <code>\\a</code>
</li> <li>replaces any <code>\b</code> by <code>\\b</code>
</li> <li>replaces any <code>\t</code> by <code>\\t</code>
</li> <li>replaces any <code>\n</code> by <code>\\n</code>
</li> <li>replaces any <code>\v</code> by <code>\\v</code>
</li> <li>replaces any <code>\f</code> by <code>\\f</code>
</li> <li>replaces any <code>\c</code> by <code>\\c</code>
</li> <li>replaces any <code>\e</code> by <code>\\e</code>
</li> <li>replaces any other character not in the set <code>{'\21..'\126'} by ``\xHH</code> where <code>HH</code> is its hexadecimal value.</li> </ul> <p>The procedure has been designed so that its output is usable for many different common syntaxes. <strong>Note</strong>: This is not correct for producing Ansi C code!</p>   </dd>  <dt><pre data-language="nim">proc addQuoted[T](s: var string; x: T)</pre></dt> <dd> <p>Appends <em>x</em> to string <em>s</em> in place, applying quoting and escaping if <em>x</em> is a string or char. See <a href="system#addEscapedChar">addEscapedChar</a> for the escaping scheme. When <em>x</em> is a string, characters in the range <code>{\128..\255}</code> are never escaped so that multibyte UTF-8 characters are untouched (note that this behavior is different from <code>addEscapedChar</code>).</p> <p>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload <em>addQuoted</em> for custom (string-like) types if they want to implement a customized element representation.</p> <pre class="listing" data-language="nim">var tmp = ""
tmp.addQuoted(1)
tmp.add(", ")
tmp.addQuoted("string")
tmp.add(", ")
tmp.addQuoted('c')
assert(tmp == """1, "string", 'c'""")</pre>   </dd>  <dt><pre data-language="nim">proc safeAdd[T](x: var seq[T]; y: T) {...}{.noSideEffect, deprecated.}</pre></dt> <dd> Adds <code>y</code> to <code>x</code> unless <code>x</code> is not yet initialized; in that case, <code>x</code> becomes <code>@[y]</code>   </dd>  <dt><pre data-language="nim">proc safeAdd(x: var string; y: char) {...}{.noSideEffect, deprecated, raises: [], tags: [].}</pre></dt> <dd> Adds <code>y</code> to <code>x</code>. If <code>x</code> is <code>nil</code> it is initialized to <code>""</code>   </dd>  <dt><pre data-language="nim">proc safeAdd(x: var string; y: string) {...}{.noSideEffect, deprecated, raises: [], tags: [].}</pre></dt> <dd> Adds <code>y</code> to <code>x</code> unless <code>x</code> is not yet initalized; in that case, <code>x</code> becomes <code>y</code>   </dd>  <dt><pre data-language="nim">proc locals(): RootObj {...}{.magic: "Plugin", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> generates a tuple constructor expression listing all the local variables in the current scope. This is quite fast as it does not rely on any debug or runtime information. Note that in contrast to what the official signature says, the return type is not <code>RootObj</code> but a tuple of a structure that depends on the current scope. Example:<pre class="listing" data-language="nim">proc testLocals() =
  var
    a = "something"
    b = 4
    c = locals()
    d = "super!"
  
  b = 1
  for name, value in fieldPairs(c):
    echo "name ", name, " with value ", value
  echo "B is ", b
# -&gt; name a with value something
# -&gt; name b with value 4
# -&gt; B is 1</pre>   </dd>  <dt><pre data-language="nim">proc deepCopy[T](x: var T; y: T) {...}{.noSideEffect, magic: "DeepCopy".}</pre></dt> <dd> performs a deep copy of <em>y</em> and copies it into <em>x</em>. This is also used by the code generator for the implementation of <code>spawn</code>.   </dd>  <dt><pre data-language="nim">proc procCall(x: untyped) {...}{.magic: "ProcCall", compileTime, raises: [], tags: [].}</pre></dt> <dd> special magic to prohibit dynamic binding for <span id="method_1">method</span> calls. This is similar to <span id="super_1">super</span> in ordinary OO languages.<pre class="listing" data-language="nim"># 'someMethod' will be resolved fully statically:
procCall someMethod(a, b)</pre>   </dd>  <dt><pre data-language="nim">proc xlen(x: string): int {...}{.magic: "XLenStr", noSideEffect,
                        deprecated: "use len() instead", raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since version 0.18.1</strong>. Use len() instead.   </dd>  <dt><pre data-language="nim">proc xlen[T](x: seq[T]): int {...}{.magic: "XLenSeq", noSideEffect,
                           deprecated: "use len() instead".}</pre></dt> <dd> returns the length of a sequence or a string without testing for 'nil'. This is an optimization that rarely makes sense. <strong>Deprecated since version 0.18.1</strong>. Use len() instead.   </dd>  <dt><pre data-language="nim">proc `==`(x, y: cstring): bool {...}{.magic: "EqCString", noSideEffect, inline, raises: [],
                            tags: [].}</pre></dt> <dd> Checks for equality between two <em>cstring</em> variables.   </dd>  <dt><pre data-language="nim">proc `==`(x: string; y: type(nil)): bool {...}{.error: "\'nil\' is now invalid for \'string\'; compile with --nilseqs:on for a migration period",
                                     raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc `==`(x: type(nil); y: string): bool {...}{.error: "\'nil\' is now invalid for \'string\'; compile with --nilseqs:on for a migration period",
                                     raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc substr(s: string; first, last: int): string {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc substr(s: string; first = 0): string {...}{.raises: [], tags: [].}</pre></dt> <dd> copies a slice of <em>s</em> into a new string and returns this new string. The bounds <em>first</em> and <em>last</em> denote the indices of the first and last characters that shall be copied. If <code>last</code> is omitted, it is treated as <code>high(s)</code>. If <code>last &gt;= s.len</code>, <code>s.len</code> is used instead: This means <code>substr</code> can also be used to <span id="cut_1">cut</span> or <span id="limit_1">limit</span> a string's length.   </dd>  <dt><pre data-language="nim">proc runnableExamples(body: untyped) {...}{.magic: "RunnableExamples".}</pre></dt> <dd> A section you should use to mark <span id="runnable-example_1">runnable example</span> code with.<ul class="simple">
<li>In normal debug and release builds code within a <code>runnableExamples</code> section is ignored.</li> <li>The documentation generator is aware of these examples and considers them part of the <code>##</code> doc comment. As the last step of documentation generation the examples are put into an <code>$file_example.nim</code> file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</li> </ul>   </dd>  <dt><pre data-language="nim">proc toOpenArray[T](x: seq[T]; first, last: int): openArray[T] {...}{.magic: "Slice".}</pre></dt>   <dt><pre data-language="nim">proc toOpenArray[T](x: openArray[T]; first, last: int): openArray[T] {...}{.magic: "Slice".}</pre></dt>   <dt><pre data-language="nim">proc toOpenArray[I, T](x: array[I, T]; first, last: I): openArray[T] {...}{.magic: "Slice".}</pre></dt>   <dt><pre data-language="nim">proc toOpenArray(x: string; first, last: int): openArray[char] {...}{.magic: "Slice".}</pre></dt>   <dt><pre data-language="nim">proc toOpenArrayByte(x: string; first, last: int): openArray[byte] {...}{.magic: "Slice".}</pre></dt>  </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre data-language="nim">iterator countdown[T](a, b: T; step: Positive = 1): T {...}{.inline.}</pre></dt> <dd> Counts from ordinal value <em>a</em> down to <em>b</em> (inclusive) with the given step count. <em>T</em> may be any ordinal type, <em>step</em> may only be positive. <strong>Note</strong>: This fails to count to <code>low(int)</code> if T = int for efficiency reasons.   </dd>  <dt><pre data-language="nim">iterator countup[T](a, b: T; step: Positive = 1): T {...}{.inline.}</pre></dt> <dd> Counts from ordinal value <em>a</em> up to <em>b</em> (inclusive) with the given step count. <em>S</em>, <em>T</em> may be any ordinal type, <em>step</em> may only be positive. <strong>Note</strong>: This fails to count to <code>high(int)</code> if T = int for efficiency reasons.   </dd>  <dt><pre data-language="nim">iterator `..`[T](a, b: T): T {...}{.inline.}</pre></dt> <dd> An alias for <em>countup(a, b, 1)</em>.   </dd>  <dt><pre data-language="nim">iterator `..`(a, b: int64): int64 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> A type specialized version of <code>..</code> for convenience so that mixing integer types work better.   </dd>  <dt><pre data-language="nim">iterator `..`(a, b: int32): int32 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> A type specialized version of <code>..</code> for convenience so that mixing integer types work better.   </dd>  <dt><pre data-language="nim">iterator `..`(a, b: uint64): uint64 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> A type specialized version of <code>..</code> for convenience so that mixing integer types work better.   </dd>  <dt><pre data-language="nim">iterator `..`(a, b: uint32): uint32 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> A type specialized version of <code>..</code> for convenience so that mixing integer types work better.   </dd>  <dt><pre data-language="nim">iterator `||`[S, T](a: S; b: T; annotation = ""): T {...}{.inline, magic: "OmpParFor", sideEffect.}</pre></dt> <dd> parallel loop iterator. Same as <em>..</em> but the loop may run in parallel. <em>annotation</em> is an additional annotation for the code generator to use. Note that the compiler maps that to the <code>#pragma omp parallel for</code> construct of <span id="openmp_1">OpenMP</span> and as such isn't aware of the parallelism in your code! Be careful! Later versions of <code>||</code> will get proper support by Nim's code generator and GC.   </dd>  <dt><pre data-language="nim">iterator items[T](a: openArray[T]): T {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd>  <dt><pre data-language="nim">iterator mitems[T](a: var openArray[T]): var T {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd>  <dt><pre data-language="nim">iterator items[IX, T](a: array[IX, T]): T {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd>  <dt><pre data-language="nim">iterator mitems[IX, T](a: var array[IX, T]): var T {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd>  <dt><pre data-language="nim">iterator items[T](a: set[T]): T {...}{.inline.}</pre></dt> <dd> iterates over each element of <em>a</em>. <em>items</em> iterates only over the elements that are really in the set (and not over the ones the set is able to hold).   </dd>  <dt><pre data-language="nim">iterator items(a: cstring): char {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd>  <dt><pre data-language="nim">iterator mitems(a: var cstring): var char {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd>  <dt><pre data-language="nim">iterator items(E: typedesc[enum]): E:type</pre></dt> <dd> iterates over the values of the enum <code>E</code>.   </dd>  <dt><pre data-language="nim">iterator items[T](s: HSlice[T, T]): T</pre></dt> <dd> iterates over the slice <em>s</em>, yielding each value between <em>s.a</em> and <em>s.b</em> (inclusively).   </dd>  <dt><pre data-language="nim">iterator pairs[T](a: openArray[T]): tuple[key: int, val: T] {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd>  <dt><pre data-language="nim">iterator mpairs[T](a: var openArray[T]): tuple[key: int, val: var T] {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd>  <dt><pre data-language="nim">iterator pairs[IX, T](a: array[IX, T]): tuple[key: IX, val: T] {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd>  <dt><pre data-language="nim">iterator mpairs[IX, T](a: var array[IX, T]): tuple[key: IX, val: var T] {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd>  <dt><pre data-language="nim">iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd>  <dt><pre data-language="nim">iterator mpairs[T](a: var seq[T]): tuple[key: int, val: var T] {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd>  <dt><pre data-language="nim">iterator pairs(a: string): tuple[key: int, val: char] {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd>  <dt><pre data-language="nim">iterator mpairs(a: var string): tuple[key: int, val: var char] {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd>  <dt><pre data-language="nim">iterator pairs(a: cstring): tuple[key: int, val: char] {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd>  <dt><pre data-language="nim">iterator mpairs(a: var cstring): tuple[key: int, val: var char] {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd>  <dt><pre data-language="nim">iterator fields[T: tuple |
    object](x: T): RootObj {...}{.magic: "Fields", noSideEffect.}</pre></dt> <dd> iterates over every field of <em>x</em>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.   </dd>  <dt><pre data-language="nim">iterator fields[S: tuple |
    object; T: tuple |
    object](x: S; y: T): tuple[a, b: untyped] {...}{.magic: "Fields", noSideEffect.}</pre></dt> <dd> iterates over every field of <em>x</em> and <em>y</em>. Warning: This is really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.   </dd>  <dt><pre data-language="nim">iterator fieldPairs[T: tuple |
    object](x: T): RootObj {...}{.magic: "FieldPairs", noSideEffect.}</pre></dt> <dd> <p>Iterates over every field of <em>x</em> returning their name and value.</p> <p>When you iterate over objects with different field types you have to use the compile time <code>when</code> instead of a runtime <code>if</code> to select the code you want to run for each type. To perform the comparison use the <a href="manual#generics-is-operator">is operator</a>. Example:</p> <pre class="listing" data-language="nim">type
  Custom = object
    foo: string
    bar: bool

proc `$`(x: Custom): string =
  result = "Custom:"
  for name, value in x.fieldPairs:
    when value is bool:
      result.add("\n\t" &amp; name &amp; " is " &amp; $value)
    else:
      if value.isNil:
        result.add("\n\t" &amp; name &amp; " (nil)")
      else:
        result.add("\n\t" &amp; name &amp; " '" &amp; value &amp; "'")</pre>
<p>Another way to do the same without <code>when</code> is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the <em>value</em> to.</p> <p>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</p>   </dd>  <dt><pre data-language="nim">iterator fieldPairs[S: tuple |
    object; T: tuple |
    object](x: S; y: T): tuple[a, b: untyped] {...}{.magic: "FieldPairs", noSideEffect.}</pre></dt> <dd> iterates over every field of <em>x</em> and <em>y</em>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.   </dd>  <dt><pre data-language="nim">iterator lines(filename: string): TaintedString {...}{.tags: [ReadIOEffect],
    raises: [Exception, IOError, IOError].}</pre></dt> <dd> <p>Iterates over any line in the file named <em>filename</em>.</p> <p>If the file does not exist <em>EIO</em> is raised. The trailing newline character(s) are removed from the iterated lines. Example:</p> <pre class="listing" data-language="nim">import strutils

proc transformLetters(filename: string) =
  var buffer = ""
  for line in filename.lines:
    buffer.add(line.replace("a", "0") &amp; '\x0A')
  writeFile(filename, buffer)</pre>   </dd>  <dt><pre data-language="nim">iterator lines(f: File): TaintedString {...}{.tags: [ReadIOEffect], raises: [IOError].}</pre></dt> <dd> <p>Iterate over any line in the file <em>f</em>.</p> <p>The trailing newline character(s) are removed from the iterated lines. Example:</p> <pre class="listing" data-language="nim">proc countZeros(filename: File): tuple[lines, zeros: int] =
  for line in filename.lines:
    for letter in line:
      if letter == '0':
        result.zeros += 1
    result.lines += 1</pre>   </dd>  <dt><pre data-language="nim">iterator `..&lt;`[T](a, b: T): T</pre></dt>   <dt><pre data-language="nim">iterator items[T](a: seq[T]): T {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd>  <dt><pre data-language="nim">iterator mitems[T](a: var seq[T]): var T {...}{.inline.}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd>  <dt><pre data-language="nim">iterator items(a: string): char {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd>  <dt><pre data-language="nim">iterator mitems(a: var string): var char {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template `!=`(x, y: untyped): untyped</pre></dt> <dd> unequals operator. This is a shorthand for <code>not (x == y)</code>.   </dd>  <dt><pre data-language="nim">template `&gt;=`(x, y: untyped): untyped</pre></dt> <dd> "is greater or equals" operator. This is the same as <code>y &lt;= x</code>.   </dd>  <dt><pre data-language="nim">template `&gt;`(x, y: untyped): untyped</pre></dt> <dd> "is greater" operator. This is the same as <code>y &lt; x</code>.   </dd>  <dt><pre data-language="nim">template incl[T](s: var set[T]; flags: set[T])</pre></dt> <dd> includes the set of flags to the set <code>x</code>.   </dd>  <dt><pre data-language="nim">template excl[T](s: var set[T]; flags: set[T])</pre></dt> <dd> excludes the set of flags to <code>x</code>.   </dd>  <dt><pre data-language="nim">template `in`(x, y: untyped): untyped {...}{.dirty.}</pre></dt> <dd> Sugar for contains<pre class="listing" data-language="nim">assert(1 in (1..3) == true)
assert(5 in (1..3) == false)</pre>   </dd>  <dt><pre data-language="nim">template `notin`(x, y: untyped): untyped {...}{.dirty.}</pre></dt> <dd> Sugar for not containing<pre class="listing" data-language="nim">assert(1 notin (1..3) == false)
assert(5 notin (1..3) == true)</pre>   </dd>  <dt><pre data-language="nim">template `isnot`(x, y: untyped): untyped</pre></dt> <dd> Negated version of <em>is</em>. Equivalent to <code>not(x is y)</code>.   </dd>  <dt><pre data-language="nim">template `&gt;=%`(x, y: untyped): untyped</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &gt;= unsigned(y)</code>.   </dd>  <dt><pre data-language="nim">template `&gt;%`(x, y: untyped): untyped</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &gt; unsigned(y)</code>.   </dd>  <dt><pre data-language="nim">template accumulateResult(iter: untyped)</pre></dt> <dd> helps to convert an iterator to a proc.   </dd>  <dt><pre data-language="nim">template newException(exceptn: typedesc; message: string;
                     parentException: ref Exception = nil): untyped</pre></dt> <dd> creates an exception object of type <code>exceptn</code> and sets its <code>msg</code> field to <em>message</em>. Returns the new exception object.   </dd>  <dt><pre data-language="nim">template likely(val: bool): bool</pre></dt> <dd> <p>Hints the optimizer that <em>val</em> is likely going to be true.</p> <p>You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</p> <pre class="listing" data-language="nim">for value in inputValues:
  if likely(value &lt;= 100):
    process(value)
  else:
    echo "Value too big!"</pre>
<p>On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.</p>   </dd>  <dt><pre data-language="nim">template unlikely(val: bool): bool</pre></dt> <dd> <p>Hints the optimizer that <em>val</em> is likely going to be false.</p> <p>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</p> <pre class="listing" data-language="nim">for value in inputValues:
  if unlikely(value &gt; 100):
    echo "Value too big!"
  else:
    process(value)</pre>
<p>On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.</p>   </dd>  <dt><pre data-language="nim">template stdmsg(): File</pre></dt> <dd> Template which expands to either stdout or stderr depending on <em>useStdoutAsStdmsg</em> compile-time switch.   </dd>  <dt><pre data-language="nim">template `^`(x: int): BackwardsIndex</pre></dt> <dd> builtin <span id="roof_1">roof</span> operator that can be used for convenient array access. <code>a[^x]</code> is a shortcut for <code>a[a.len-x]</code>.   </dd>  <dt><pre data-language="nim">template `..^`(a, b: untyped): untyped</pre></dt> <dd> a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.   </dd>  <dt><pre data-language="nim">template `..&lt;`(a, b: untyped): untyped</pre></dt> <dd> a shortcut for 'a .. (when b is BackwardsIndex: succ(b) else: pred(b))'.   </dd>  <dt><pre data-language="nim">template `[]`(s: string; i: int): char</pre></dt>   <dt><pre data-language="nim">template `[]=`(s: string; i: int; val: char)</pre></dt>   <dt><pre data-language="nim">template `&amp;=`(x, y: typed)</pre></dt> <dd> generic 'sink' operator for Nim. For files an alias for <code>write</code>. If not specialized further an alias for <code>add</code>.   </dd>  <dt><pre data-language="nim">template `&amp;=`(f: File; x: typed)</pre></dt>   <dt><pre data-language="nim">template currentSourcePath(): string</pre></dt> <dd> returns the full file-system path of the current source   </dd>  <dt><pre data-language="nim">template assert(cond: bool; msg = "")</pre></dt> <dd> <p>Raises <code>AssertionError</code> with <em>msg</em> if <em>cond</em> is false. Note that <code>AssertionError</code> is hidden from the effect system, so it doesn't produce <code>{.raises: [AssertionError].}</code>. This exception is only supposed to be caught by unit testing frameworks.</p> <p>The compiler may not generate any code at all for <code>assert</code> if it is advised to do so through the <code>-d:release</code> or <code>--assertions:off</code> <a href="nimc#command-line-switches">command line switches</a>.</p>   </dd>  <dt><pre data-language="nim">template doAssert(cond: bool; msg = "")</pre></dt> <dd> same as <code>assert</code> but is always turned on regardless of <code>--assertions</code>   </dd>  <dt><pre data-language="nim">template onFailedAssert(msg, code: untyped): untyped {...}{.dirty.}</pre></dt> <dd> Sets an assertion failure handler that will intercept any assert statements following <em>onFailedAssert</em> in the current module scope.<pre class="listing" data-language="nim"># module-wide policy to change the failed assert
# exception type in order to include a lineinfo
onFailedAssert(msg):
  var e = new(TMyError)
  e.msg = msg
  e.lineinfo = instantiationInfo(-2)
  raise e</pre>   </dd>  <dt><pre data-language="nim">template closureScope(body: untyped): untyped</pre></dt> <dd> Useful when creating a closure in a loop to capture local loop variables by their current iteration values. Example:<pre class="listing" data-language="nim">var myClosure : proc()
# without closureScope:
for i in 0 .. 5:
  let j = i
  if j == 3:
    myClosure = proc() = echo j
myClosure() # outputs 5. `j` is changed after closure creation
# with closureScope:
for i in 0 .. 5:
  closureScope: # Everything in this scope is locked after closure creation
    let j = i
    if j == 3:
      myClosure = proc() = echo j
myClosure() # outputs 3</pre>   </dd>  <dt><pre data-language="nim">template once(body: untyped): untyped</pre></dt> <dd> Executes a block of code only once (the first time the block is reached). When hot code reloading is enabled, protects top-level code from being re-executed on each module reload.<pre class="listing" data-language="nim">proc draw(t: Triangle) =
  once:
    graphicsInit()
  line(t.p1, t.p2)
  line(t.p2, t.p3)
  line(t.p3, t.p1)</pre>   </dd>  <dt><pre data-language="nim">template doAssertRaises(exception, code: untyped): typed</pre></dt> <dd> Raises <code>AssertionError</code> if specified <code>code</code> does not raise the specified exception. Example:<pre class="listing" data-language="nim">doAssertRaises(ValueError):
  raise newException(ValueError, "Hello World")</pre>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     20062018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/system.html" class="_attribution-link">https://nim-lang.org/docs/system.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
