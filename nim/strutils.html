
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Strutils - Nim - W3cubDocs</title>
  
  <meta name="description" content="This module contains various string utility routines. See the module re for regular expression support. See the module pegs for PEG support. This &hellip;">
  <meta name="keywords" content="module, strutils, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/strutils.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module strutils</h1>  <p class="module-desc">This module contains various string utility routines. See the module <a href="re">re</a> for regular expression support. See the module <a href="pegs">pegs</a> for PEG support. This module is available for the <a href="backends#the-javascript-target">JavaScript target</a>.</p>  <h2 id="5">Exports</h2> <dl> <a href="unicode#toLower"><span class="Identifier">toLower</span></a>, <a href="unicode#toLower"><span class="Identifier">toLower</span></a>, <a href="unicode#toUpper"><span class="Identifier">toUpper</span></a>, <a href="unicode#toUpper"><span class="Identifier">toUpper</span></a> </dl>  <h2 id="6">Imports</h2> <dl> <a href="parseutils">parseutils</a>, <a href="math">math</a>, <a href="algorithm">algorithm</a>, <a href="unicode">unicode</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">SkipTable = array[char, int]</pre></dt>   <dt><pre data-language="nim">FloatFormatMode = enum
  ffDefault,                  ## use the shorter floating point notation
  ffDecimal,                  ## use decimal floating point notation
  ffScientific                ## use scientific notation (using ``e`` character)</pre></dt> <dd> the different modes of floating point formating   </dd>  <dt><pre data-language="nim">BinaryPrefixMode = enum
  bpIEC, bpColloquial</pre></dt> <dd> the different names for binary prefixes   </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre data-language="nim">Whitespace = {' ', '\t', '\v', '\c', '\n', '\f'}</pre></dt> <dd> All the characters that count as whitespace.   </dd>  <dt><pre data-language="nim">Letters = {'A'..'Z', 'a'..'z'}</pre></dt> <dd> the set of letters   </dd>  <dt><pre data-language="nim">Digits = {'0'..'9'}</pre></dt> <dd> the set of digits   </dd>  <dt><pre data-language="nim">HexDigits = {'0'..'9', 'A'..'F', 'a'..'f'}</pre></dt> <dd> the set of hexadecimal digits   </dd>  <dt><pre data-language="nim">IdentChars = {'a'..'z', 'A'..'Z', '0'..'9', '_'}</pre></dt> <dd> the set of characters an identifier can consist of   </dd>  <dt><pre data-language="nim">IdentStartChars = {'a'..'z', 'A'..'Z', '_'}</pre></dt> <dd> the set of characters an identifier can start with   </dd>  <dt><pre data-language="nim">NewLines = {'\c', '\n'}</pre></dt> <dd> the set of characters a newline terminator can start with   </dd>  <dt><pre data-language="nim">AllChars = {'\x00'..'\xFF'}</pre></dt> <dd> <p>A set with all the possible characters.</p> <p>Not very useful by its own, you can use it to create <em>inverted</em> sets to make the <a href="#find,string,set%5Bchar%5D,int">find() proc</a> find <strong>invalid</strong> characters in strings. Example:</p> <pre class="listing" data-language="nim">let invalid = AllChars - Digits
doAssert "01234".find(invalid) == -1
doAssert "01A34".find(invalid) == 2</pre>   </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc isAlphaAscii(c: char): bool {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsAlphaAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is alphabetical.</p> <p>This checks a-z, A-Z ASCII characters only.</p>   </dd>  <dt><pre data-language="nim">proc isAlphaNumeric(c: char): bool {...}{.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsAlphaNumericChar", raises: [],
                                 tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is alphanumeric.</p> <p>This checks a-z, A-Z, 0-9 ASCII characters only.</p>   </dd>  <dt><pre data-language="nim">proc isDigit(c: char): bool {...}{.noSideEffect, procvar, gcsafe, extern: "nsuIsDigitChar",
                          raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is a number.</p> <p>This checks 0-9 ASCII characters only.</p>   </dd>  <dt><pre data-language="nim">proc isSpaceAscii(c: char): bool {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsSpaceAsciiChar", raises: [], tags: [].}</pre></dt> <dd> Checks whether or not <em>c</em> is a whitespace character.   </dd>  <dt><pre data-language="nim">proc isLowerAscii(c: char): bool {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsLowerAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is a lower case character.</p> <p>This checks ASCII characters only.</p>   </dd>  <dt><pre data-language="nim">proc isUpperAscii(c: char): bool {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsUpperAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is an upper case character.</p> <p>This checks ASCII characters only.</p>   </dd>  <dt><pre data-language="nim">proc isAlphaAscii(s: string): bool {...}{.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsAlphaAsciiStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is alphabetical.</p> <p>This checks a-z, A-Z ASCII characters only. Returns true if all characters in <em>s</em> are alphabetic and there is at least one character in <em>s</em>.</p>   </dd>  <dt><pre data-language="nim">proc isAlphaNumeric(s: string): bool {...}{.noSideEffect, procvar, gcsafe,
                                   extern: "nsuIsAlphaNumericStr", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is alphanumeric.</p> <p>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in <em>s</em> are alpanumeric and there is at least one character in <em>s</em>.</p>   </dd>  <dt><pre data-language="nim">proc isDigit(s: string): bool {...}{.noSideEffect, procvar, gcsafe, extern: "nsuIsDigitStr",
                            raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is a numeric value.</p> <p>This checks 0-9 ASCII characters only. Returns true if all characters in <em>s</em> are numeric and there is at least one character in <em>s</em>.</p>   </dd>  <dt><pre data-language="nim">proc isSpaceAscii(s: string): bool {...}{.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsSpaceAsciiStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is completely whitespace.</p> <p>Returns true if all characters in <em>s</em> are whitespace characters and there is at least one character in <em>s</em>.</p>   </dd>  <dt><pre data-language="nim">proc isLowerAscii(s: string; skipNonAlpha: bool): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether <code>s</code> is lower case.</p> <p>This checks ASCII characters only.</p> <p>If <code>skipNonAlpha</code> is true, returns true if all alphabetical characters in <code>s</code> are lower case. Returns false if none of the characters in <code>s</code> are alphabetical.</p> <p>If <code>skipNonAlpha</code> is false, returns true only if all characters in <code>s</code> are alphabetical and lower case.</p> <p>For either value of <code>skipNonAlpha</code>, returns false if <code>s</code> is an empty string.</p>   </dd>  <dt><pre data-language="nim">proc isUpperAscii(s: string; skipNonAlpha: bool): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether <code>s</code> is upper case.</p> <p>This checks ASCII characters only.</p> <p>If <code>skipNonAlpha</code> is true, returns true if all alphabetical characters in <code>s</code> are upper case. Returns false if none of the characters in <code>s</code> are alphabetical.</p> <p>If <code>skipNonAlpha</code> is false, returns true only if all characters in <code>s</code> are alphabetical and upper case.</p> <p>For either value of <code>skipNonAlpha</code>, returns false if <code>s</code> is an empty string.</p>   </dd>  <dt><pre data-language="nim">proc toLowerAscii(c: char): char {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuToLowerAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>c</em> into lower case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode#toLower">unicode.toLower</a> for a version that works for any Unicode character.</p>   </dd>  <dt><pre data-language="nim">proc toLowerAscii(s: string): string {...}{.noSideEffect, procvar, gcsafe,
                                   extern: "nsuToLowerAsciiStr", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> into lower case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode#toLower">unicode.toLower</a> for a version that works for any Unicode character.</p>   </dd>  <dt><pre data-language="nim">proc toUpperAscii(c: char): char {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuToUpperAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>c</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode#toUpper">unicode.toUpper</a> for a version that works for any Unicode character.</p>   </dd>  <dt><pre data-language="nim">proc toUpperAscii(s: string): string {...}{.noSideEffect, procvar, gcsafe,
                                   extern: "nsuToUpperAsciiStr", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode#toUpper">unicode.toUpper</a> for a version that works for any Unicode character.</p>   </dd>  <dt><pre data-language="nim">proc capitalizeAscii(s: string): string {...}{.noSideEffect, procvar, gcsafe,
                                      extern: "nsuCapitalizeAscii", raises: [],
                                      tags: [].}</pre></dt> <dd> <p>Converts the first character of <em>s</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>.</p>   </dd>  <dt><pre data-language="nim">proc normalize(s: string): string {...}{.noSideEffect, procvar, gcsafe,
                                extern: "nsuNormalize", raises: [], tags: [].}</pre></dt> <dd> <p>Normalizes the string <em>s</em>.</p> <p>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</p>   </dd>  <dt><pre data-language="nim">proc cmpIgnoreCase(a, b: string): int {...}{.noSideEffect, gcsafe,
                                   extern: "nsuCmpIgnoreCase", procvar, raises: [],
                                   tags: [].}</pre></dt> <dd> Compares two strings in a case insensitive manner. Returns:<p>0 iff a == b<br>&lt; 0 iff a &lt; b<br>&gt; 0 iff a &gt; b<br></p>   </dd>  <dt><pre data-language="nim">proc cmpIgnoreStyle(a, b: string): int {...}{.noSideEffect, gcsafe,
                                    extern: "nsuCmpIgnoreStyle", procvar,
                                    raises: [], tags: [].}</pre></dt> <dd> Semantically the same as <code>cmp(normalize(a), normalize(b))</code>. It is just optimized to not allocate temporary strings. This should NOT be used to compare Nim identifier names. use <em>macros.eqIdent</em> for that. Returns:<p>0 iff a == b<br>&lt; 0 iff a &lt; b<br>&gt; 0 iff a &gt; b<br></p>   </dd>  <dt><pre data-language="nim">proc strip(s: string; leading = true; trailing = true; chars: set[char] = Whitespace): string {...}{.
    noSideEffect, gcsafe, extern: "nsuStrip", raises: [], tags: [].}</pre></dt> <dd> <p>Strips leading or trailing <em>chars</em> from <em>s</em> and returns the resulting string.</p> <p>If <em>leading</em> is true, leading <em>chars</em> are stripped. If <em>trailing</em> is true, trailing <em>chars</em> are stripped. If both are false, the string is returned unchanged.</p>   </dd>  <dt><pre data-language="nim">proc toOctal(c: char): string {...}{.noSideEffect, gcsafe, extern: "nsuToOctal", raises: [],
                            tags: [].}</pre></dt> <dd> <p>Converts a character <em>c</em> to its octal representation.</p> <p>The resulting string may not have a leading zero. Its length is always exactly 3.</p>   </dd>  <dt><pre data-language="nim">proc isNilOrEmpty(s: string): bool {...}{.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsNilOrEmpty",
                                 deprecated: "use \'x.len == 0\' instead",
                                 raises: [], tags: [].}</pre></dt> <dd> Checks if <em>s</em> is nil or empty.   </dd>  <dt><pre data-language="nim">proc isNilOrWhitespace(s: string): bool {...}{.noSideEffect, procvar, gcsafe,
                                      extern: "nsuIsNilOrWhitespace", raises: [],
                                      tags: [].}</pre></dt> <dd> Checks if <em>s</em> is nil or consists entirely of whitespace characters.   </dd>  <dt><pre data-language="nim">proc splitWhitespace(s: string; maxsplit: int = -1): seq[string] {...}{.noSideEffect, gcsafe,
    extern: "nsuSplitWhitespace", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#splitWhitespace.i,string,int">splitWhitespace</a> iterator, but is a proc that returns a sequence of substrings.   </dd>  <dt><pre data-language="nim">proc splitLines(s: string; keepEol = false): seq[string] {...}{.noSideEffect, gcsafe,
    extern: "nsuSplitLines", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#splitLines.i,string">splitLines</a> iterator, but is a proc that returns a sequence of substrings.   </dd>  <dt><pre data-language="nim">proc countLines(s: string): int {...}{.noSideEffect, gcsafe, extern: "nsuCountLines",
                              raises: [], tags: [].}</pre></dt> <dd> <p>Returns the number of lines in the string <em>s</em>.</p> <p>This is the same as <code>len(splitLines(s))</code>, but much more efficient because it doesn't modify the string creating temporal objects. Every <a href="manual#character-literals">character literal</a> newline combination (CR, LF, CR-LF) is supported.</p> <p>In this context, a line is any string seperated by a newline combination. A line can be an empty string.</p>   </dd>  <dt><pre data-language="nim">proc split(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): seq[string] {...}{.
    noSideEffect, gcsafe, extern: "nsuSplitCharSet", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#split.i,string,set%5Bchar%5D,int">split iterator</a>, but is a proc that returns a sequence of substrings. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert "a,b;c".split({',', ';'}) == @["a", "b", "c"]
doAssert "".split({' '}) == @[""]</pre>   </dd>  <dt><pre data-language="nim">proc split(s: string; sep: char; maxsplit: int = -1): seq[string] {...}{.noSideEffect, gcsafe,
    extern: "nsuSplitChar", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#split.i,string,char,int">split iterator</a>, but is a proc that returns a sequence of substrings. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert "a,b,c".split(',') == @["a", "b", "c"]
doAssert "".split(' ') == @[""]</pre>   </dd>  <dt><pre data-language="nim">proc split(s: string; sep: string; maxsplit: int = -1): seq[string] {...}{.noSideEffect, gcsafe,
    extern: "nsuSplitString", raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a string separator.</p> <p>Substrings are separated by the string <em>sep</em>. This is a wrapper around the <a href="#split.i,string,string,int">split iterator</a>.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert "a,b,c".split(",") == @["a", "b", "c"]
doAssert "a man a plan a canal panama".split("a ") ==
    @["", "man ", "plan ", "canal panama"]
doAssert "".split("Elon Musk") == @[""]
doAssert "a  largely    spaced sentence".split(" ") ==
    @["a", "", "largely", "", "", "", "spaced", "sentence"]
doAssert "a  largely    spaced sentence".split(" ", maxsplit = 1) ==
    @["a", " largely    spaced sentence"]</pre>   </dd>  <dt><pre data-language="nim">proc rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): seq[string] {...}{.
    noSideEffect, gcsafe, extern: "nsuRSplitCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,set%5Bchar%5D,int">rsplit iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <em>rsplit</em> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <em>#</em> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", {'#'}, maxsplit=1)</pre>
<p>Results in <em>tailSplit</em> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>   </dd>  <dt><pre data-language="nim">proc rsplit(s: string; sep: char; maxsplit: int = -1): seq[string] {...}{.noSideEffect, gcsafe,
    extern: "nsuRSplitChar", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,char,int">rsplit iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <em>rsplit</em> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <em>#</em> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", '#', maxsplit=1)</pre>
<p>Results in <em>tailSplit</em> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>   </dd>  <dt><pre data-language="nim">proc rsplit(s: string; sep: string; maxsplit: int = -1): seq[string] {...}{.noSideEffect,
    gcsafe, extern: "nsuRSplitString", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,string,int">rsplit iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <em>rsplit</em> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <em>#</em> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", "#", maxsplit=1)</pre>
<p>Results in <em>tailSplit</em> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert "a  largely    spaced sentence".rsplit(" ", maxsplit = 1) ==
    @["a  largely    spaced", "sentence"]
doAssert "a,b,c".rsplit(",") == @["a", "b", "c"]
doAssert "a man a plan a canal panama".rsplit("a ") ==
    @["", "man ", "plan ", "canal panama"]
doAssert "".rsplit("Elon Musk") == @[""]
doAssert "a  largely    spaced sentence".rsplit(" ") ==
    @["a", "", "largely", "", "", "", "spaced", "sentence"]</pre>   </dd>  <dt><pre data-language="nim">proc toHex(x: BiggestInt; len: Positive): string {...}{.noSideEffect, gcsafe,
    extern: "nsuToHex", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> to its hexadecimal representation.</p> <p>The resulting string will be exactly <em>len</em> characters long. No prefix like <code>0x</code> is generated. <em>x</em> is treated as an unsigned value.</p>   </dd>  <dt><pre data-language="nim">proc toHex[T: SomeInteger](x: T): string</pre></dt> <dd> Shortcut for <code>toHex(x, T.sizeOf * 2)</code>   </dd>  <dt><pre data-language="nim">proc toHex(s: string): string {...}{.noSideEffect, gcsafe, raises: [], tags: [].}</pre></dt> <dd> <p>Converts a bytes string to its hexadecimal representation.</p> <p>The output is twice the input long. No prefix like <code>0x</code> is generated.</p>   </dd>  <dt><pre data-language="nim">proc intToStr(x: int; minchars: Positive = 1): string {...}{.noSideEffect, gcsafe,
    extern: "nsuIntToStr", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> to its decimal representation.</p> <p>The resulting string will be minimally <em>minchars</em> characters long. This is achieved by adding leading zeros.</p>   </dd>  <dt><pre data-language="nim">proc parseInt(s: string): int {...}{.noSideEffect, procvar, gcsafe, extern: "nsuParseInt",
                            raises: [OverflowError, ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd>  <dt><pre data-language="nim">proc parseBiggestInt(s: string): BiggestInt {...}{.noSideEffect, procvar, gcsafe,
    extern: "nsuParseBiggestInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd>  <dt><pre data-language="nim">proc parseUInt(s: string): uint {...}{.noSideEffect, procvar, gcsafe,
                              extern: "nsuParseUInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal unsigned integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd>  <dt><pre data-language="nim">proc parseBiggestUInt(s: string): BiggestUInt {...}{.noSideEffect, procvar, gcsafe,
    extern: "nsuParseBiggestUInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal unsigned integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd>  <dt><pre data-language="nim">proc parseFloat(s: string): float {...}{.noSideEffect, procvar, gcsafe,
                                extern: "nsuParseFloat", raises: [ValueError],
                                tags: [].}</pre></dt> <dd> Parses a decimal floating point value contained in <em>s</em>. If <em>s</em> is not a valid floating point number, <em>ValueError</em> is raised. <code>NAN</code>, <code>INF</code>, <code>-INF</code> are also supported (case insensitive comparison).   </dd>  <dt><pre data-language="nim">proc parseBinInt(s: string): int {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuParseBinInt", raises: [ValueError],
                               tags: [].}</pre></dt> <dd> <p>Parses a binary integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid binary integer, <em>ValueError</em> is raised. <em>s</em> can have one of the following optional prefixes: <code>0b</code>, <code>0B</code>. Underscores within <em>s</em> are ignored.</p>   </dd>  <dt><pre data-language="nim">proc parseOctInt(s: string): int {...}{.noSideEffect, gcsafe, extern: "nsuParseOctInt",
                               raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses an octal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid oct integer, <em>ValueError</em> is raised. <em>s</em> can have one of the following optional prefixes: <code>0o</code>, <code>0O</code>. Underscores within <em>s</em> are ignored.</p>   </dd>  <dt><pre data-language="nim">proc parseHexInt(s: string): int {...}{.noSideEffect, procvar, gcsafe,
                               extern: "nsuParseHexInt", raises: [ValueError],
                               tags: [].}</pre></dt> <dd> <p>Parses a hexadecimal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid hex integer, <em>ValueError</em> is raised. <em>s</em> can have one of the following optional prefixes: <code>0x</code>, <code>0X</code>, <code>#</code>. Underscores within <em>s</em> are ignored.</p>   </dd>  <dt><pre data-language="nim">proc parseHexStr(s: string): string {...}{.noSideEffect, procvar, gcsafe,
                                  extern: "nsuParseHexStr", raises: [ValueError],
                                  tags: [].}</pre></dt> <dd> Convert hex-encoded string to byte string, e.g.:<pre class="listing" data-language="nim">hexToStr("00ff") == "\0\255"</pre>
<p>Raises <code>ValueError</code> for an invalid hex values. The comparison is case-insensitive.</p>   </dd>  <dt><pre data-language="nim">proc parseBool(s: string): bool {...}{.raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a value into a <em>bool</em>.</p> <p>If <code>s</code> is one of the following values: <code>y, yes, true, 1, on</code>, then returns <em>true</em>. If <code>s</code> is one of the following values: <code>n, no, false, 0, off</code>, then returns <em>false</em>. If <code>s</code> is something else a <code>ValueError</code> exception is raised.</p>   </dd>  <dt><pre data-language="nim">proc parseEnum[T: enum](s: string): T</pre></dt> <dd> <p>Parses an enum <code>T</code>.</p> <p>Raises <code>ValueError</code> for an invalid value in <em>s</em>. The comparison is done in a style insensitive way.</p>   </dd>  <dt><pre data-language="nim">proc parseEnum[T: enum](s: string; default: T): T</pre></dt> <dd> <p>Parses an enum <code>T</code>.</p> <p>Uses <em>default</em> for an invalid value in <em>s</em>. The comparison is done in a style insensitive way.</p>   </dd>  <dt><pre data-language="nim">proc repeat(c: char; count: Natural): string {...}{.noSideEffect, gcsafe,
    extern: "nsuRepeatChar", raises: [], tags: [].}</pre></dt> <dd> Returns a string of length <em>count</em> consisting only of the character <em>c</em>. You can use this proc to left align strings. Example:<pre class="listing" data-language="nim">proc tabexpand(indent: int, text: string, tabsize: int = 4) =
  echo '\t'.repeat(indent div tabsize), ' '.repeat(indent mod tabsize),
      text

tabexpand(4, "At four")
tabexpand(5, "At five")
tabexpand(6, "At six")</pre>   </dd>  <dt><pre data-language="nim">proc repeat(s: string; n: Natural): string {...}{.noSideEffect, gcsafe,
                                       extern: "nsuRepeatStr", raises: [], tags: [].}</pre></dt> <dd> Returns String <em>s</em> concatenated <em>n</em> times. Example:<pre class="listing" data-language="nim">echo "+++ STOP ".repeat(4), "+++"</pre>   </dd>  <dt><pre data-language="nim">proc align(s: string; count: Natural; padding = ' '): string {...}{.noSideEffect, gcsafe,
    extern: "nsuAlignString", raises: [], tags: [].}</pre></dt> <dd> <p>Aligns a string <em>s</em> with <em>padding</em>, so that it is of length <em>count</em>.</p> <p><em>padding</em> characters (by default spaces) are added before <em>s</em> resulting in right alignment. If <code>s.len &gt;= count</code>, no spaces are added and <em>s</em> is returned unchanged. If you need to left align a string use the <a href="#alignLeft">alignLeft proc</a>. Example:</p> <pre class="listing" data-language="nim">assert align("abc", 4) == " abc"
assert align("a", 0) == "a"
assert align("1232", 6) == "  1232"
assert align("1232", 6, '#') == "##1232"</pre>   </dd>  <dt><pre data-language="nim">proc alignLeft(s: string; count: Natural; padding = ' '): string {...}{.noSideEffect,
    raises: [], tags: [].}</pre></dt> <dd> <p>Left-Aligns a string <em>s</em> with <em>padding</em>, so that it is of length <em>count</em>.</p> <p><em>padding</em> characters (by default spaces) are added after <em>s</em> resulting in left alignment. If <code>s.len &gt;= count</code>, no spaces are added and <em>s</em> is returned unchanged. If you need to right align a string use the <a href="#align">align proc</a>. Example:</p> <pre class="listing" data-language="nim">assert alignLeft("abc", 4) == "abc "
assert alignLeft("a", 0) == "a"
assert alignLeft("1232", 6) == "1232  "
assert alignLeft("1232", 6, '#') == "1232##"</pre>   </dd>  <dt><pre data-language="nim">proc wordWrap(s: string; maxLineWidth = 80; splitLongWords = true;
             seps: set[char] = Whitespace; newLine = "\n"): string {...}{.noSideEffect,
    gcsafe, extern: "nsuWordWrap", raises: [], tags: [].}</pre></dt> <dd> Word wraps <em>s</em>.   </dd>  <dt><pre data-language="nim">proc indent(s: string; count: Natural; padding: string = " "): string {...}{.noSideEffect,
    gcsafe, extern: "nsuIndent", raises: [], tags: [].}</pre></dt> <dd> <p>Indents each line in <code>s</code> by <code>count</code> amount of <code>padding</code>.</p> <p><strong>Note:</strong> This does not preserve the new line characters used in <code>s</code>.</p>   </dd>  <dt><pre data-language="nim">proc unindent(s: string; count: Natural; padding: string = " "): string {...}{.noSideEffect,
    gcsafe, extern: "nsuUnindent", raises: [], tags: [].}</pre></dt> <dd> <p>Unindents each line in <code>s</code> by <code>count</code> amount of <code>padding</code>.</p> <p><strong>Note:</strong> This does not preserve the new line characters used in <code>s</code>.</p>   </dd>  <dt><pre data-language="nim">proc unindent(s: string): string {...}{.noSideEffect, gcsafe, extern: "nsuUnindentAll",
                               raises: [], tags: [].}</pre></dt> <dd> <p>Removes all indentation composed of whitespace from each line in <code>s</code>.</p> <p>For example:</p> <pre class="listing" data-language="nim">const x = """
  Hello
  There
""".unindent()

doAssert x == "Hello\nThere\n"</pre>   </dd>  <dt><pre data-language="nim">proc startsWith(s, prefix: string): bool {...}{.noSideEffect, gcsafe,
                                      extern: "nsuStartsWith", raises: [], tags: [].}</pre></dt> <dd> <p>Returns true iff <code>s</code> starts with <code>prefix</code>.</p> <p>If <code>prefix == ""</code> true is returned.</p>   </dd>  <dt><pre data-language="nim">proc startsWith(s: string; prefix: char): bool {...}{.noSideEffect, inline, raises: [],
    tags: [].}</pre></dt> <dd> Returns true iff <code>s</code> starts with <code>prefix</code>.   </dd>  <dt><pre data-language="nim">proc endsWith(s, suffix: string): bool {...}{.noSideEffect, gcsafe, extern: "nsuEndsWith",
                                    raises: [], tags: [].}</pre></dt> <dd> <p>Returns true iff <code>s</code> ends with <code>suffix</code>.</p> <p>If <code>suffix == ""</code> true is returned.</p>   </dd>  <dt><pre data-language="nim">proc endsWith(s: string; suffix: char): bool {...}{.noSideEffect, inline, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>s</code> ends with <code>suffix</code>.   </dd>  <dt><pre data-language="nim">proc continuesWith(s, substr: string; start: Natural): bool {...}{.noSideEffect, gcsafe,
    extern: "nsuContinuesWith", raises: [], tags: [].}</pre></dt> <dd> <p>Returns true iff <code>s</code> continues with <code>substr</code> at position <code>start</code>.</p> <p>If <code>substr == ""</code> true is returned.</p>   </dd>  <dt><pre data-language="nim">proc addSep(dest: var string; sep = ", "; startLen: Natural = 0) {...}{.noSideEffect, inline,
    raises: [], tags: [].}</pre></dt> <dd> <p>Adds a separator to <em>dest</em> only if its length is bigger than <em>startLen</em>.</p> <p>A shorthand for:</p> <pre class="listing" data-language="nim">if dest.len &gt; startLen: add(dest, sep)</pre>
<p>This is often useful for generating some code where the items need to be <em>separated</em> by <em>sep</em>. <em>sep</em> is only added if <em>dest</em> is longer than <em>startLen</em>. The following example creates a string describing an array of integers.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var arr = "["
for x in items([2, 3, 5, 7, 11]):
  addSep(arr, startLen = len("["))
  add(arr, $x)
add(arr, "]")</pre>   </dd>  <dt><pre data-language="nim">proc allCharsInSet(s: string; theSet: set[char]): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns true iff each character of <em>s</em> is in the set <em>theSet</em>.   </dd>  <dt><pre data-language="nim">proc abbrev(s: string; possibilities: openArray[string]): int {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the index of the first item in <em>possibilities</em> if not ambiguous.</p> <p>Returns -1 if no item has been found and -2 if multiple items match.</p>   </dd>  <dt><pre data-language="nim">proc join(a: openArray[string]; sep: string = ""): string {...}{.noSideEffect, gcsafe,
    extern: "nsuJoinSep", raises: [], tags: [].}</pre></dt> <dd> Concatenates all strings in <em>a</em> separating them with <em>sep</em>.   </dd>  <dt><pre data-language="nim">proc join[T: not string](a: openArray[T]; sep: string = ""): string {...}{.noSideEffect, gcsafe.}</pre></dt> <dd> Converts all elements in <em>a</em> to strings using <em>$</em> and concatenates them with <em>sep</em>.   </dd>  <dt><pre data-language="nim">proc initSkipTable(a: var SkipTable; sub: string) {...}{.noSideEffect, gcsafe,
    extern: "nsuInitSkipTable", raises: [], tags: [].}</pre></dt> <dd> Preprocess table <em>a</em> for <em>sub</em>.   </dd>  <dt><pre data-language="nim">proc find(a: SkipTable; s, sub: string; start: Natural = 0; last = 0): int {...}{.noSideEffect,
    gcsafe, extern: "nsuFindStrA", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> inside range <em>start</em>..`last` using preprocessed table <em>a</em>. If <em>last</em> is unspecified, it defaults to <em>s.high</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd>  <dt><pre data-language="nim">proc find(s: string; sub: char; start: Natural = 0; last = 0): int {...}{.noSideEffect, gcsafe,
    extern: "nsuFindChar", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> inside range <em>start</em>..`last`. If <em>last</em> is unspecified, it defaults to <em>s.high</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd>  <dt><pre data-language="nim">proc find(s, sub: string; start: Natural = 0; last = 0): int {...}{.noSideEffect, gcsafe,
    extern: "nsuFindStr", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> inside range <em>start</em>..`last`. If <em>last</em> is unspecified, it defaults to <em>s.high</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd>  <dt><pre data-language="nim">proc find(s: string; chars: set[char]; start: Natural = 0; last = 0): int {...}{.noSideEffect,
    gcsafe, extern: "nsuFindCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>chars</em> in <em>s</em> inside range <em>start</em>..`last`. If <em>last</em> is unspecified, it defaults to <em>s.high</em>.</p> <p>If <em>s</em> contains none of the characters in <em>chars</em>, -1 is returned.</p>   </dd>  <dt><pre data-language="nim">proc rfind(s, sub: string; start: int = -1): int {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> in reverse, starting at <em>start</em> and going backwards to 0.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd>  <dt><pre data-language="nim">proc rfind(s: string; sub: char; start: int = -1): int {...}{.noSideEffect, gcsafe, raises: [],
    tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> in reverse starting at position <em>start</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd>  <dt><pre data-language="nim">proc rfind(s: string; chars: set[char]; start: int = -1): int {...}{.noSideEffect, raises: [],
    tags: [].}</pre></dt> <dd> <p>Searches for <em>chars</em> in <em>s</em> in reverse starting at position <em>start</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd>  <dt><pre data-language="nim">proc center(s: string; width: int; fillChar: char = ' '): string {...}{.noSideEffect, gcsafe,
    extern: "nsuCenterString", raises: [], tags: [].}</pre></dt> <dd> <p>Return the contents of <em>s</em> centered in a string <em>width</em> long using <em>fillChar</em> as padding.</p> <p>The original string is returned if <em>width</em> is less than or equal to <em>s.len</em>.</p>   </dd>  <dt><pre data-language="nim">proc count(s: string; sub: string; overlapping: bool = false): int {...}{.noSideEffect, gcsafe,
    extern: "nsuCountString", raises: [], tags: [].}</pre></dt> <dd> Count the occurrences of a substring <em>sub</em> in the string <em>s</em>. Overlapping occurrences of <em>sub</em> only count when <em>overlapping</em> is set to true.   </dd>  <dt><pre data-language="nim">proc count(s: string; sub: char): int {...}{.noSideEffect, gcsafe, extern: "nsuCountChar",
                                  raises: [], tags: [].}</pre></dt> <dd> Count the occurrences of the character <em>sub</em> in the string <em>s</em>.   </dd>  <dt><pre data-language="nim">proc count(s: string; subs: set[char]): int {...}{.noSideEffect, gcsafe,
                                        extern: "nsuCountCharSet", raises: [],
                                        tags: [].}</pre></dt> <dd> Count the occurrences of the group of character <em>subs</em> in the string <em>s</em>.   </dd>  <dt><pre data-language="nim">proc quoteIfContainsWhite(s: string): string {...}{.deprecated, raises: [], tags: [].}</pre></dt> <dd> <p>Returns <code>'"' &amp; s &amp; '"'</code> if <em>s</em> contains a space and does not start with a quote, else returns <em>s</em>.</p> <p><strong>DEPRECATED</strong> as it was confused for shell quoting function. For this application use <a href="osproc#quoteShell">osproc.quoteShell</a>.</p>   </dd>  <dt><pre data-language="nim">proc contains(s: string; c: char): bool {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Same as <code>find(s, c) &gt;= 0</code>.   </dd>  <dt><pre data-language="nim">proc contains(s, sub: string): bool {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Same as <code>find(s, sub) &gt;= 0</code>.   </dd>  <dt><pre data-language="nim">proc contains(s: string; chars: set[char]): bool {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Same as <code>find(s, chars) &gt;= 0</code>.   </dd>  <dt><pre data-language="nim">proc replace(s, sub: string; by = ""): string {...}{.noSideEffect, gcsafe,
                                        extern: "nsuReplaceStr", raises: [],
                                        tags: [].}</pre></dt> <dd> Replaces <em>sub</em> in <em>s</em> by the string <em>by</em>.   </dd>  <dt><pre data-language="nim">proc replace(s: string; sub, by: char): string {...}{.noSideEffect, gcsafe,
    extern: "nsuReplaceChar", raises: [], tags: [].}</pre></dt> <dd> <p>Replaces <em>sub</em> in <em>s</em> by the character <em>by</em>.</p> <p>Optimized version of <a href="#replace,string,string">replace</a> for characters.</p>   </dd>  <dt><pre data-language="nim">proc replaceWord(s, sub: string; by = ""): string {...}{.noSideEffect, gcsafe,
    extern: "nsuReplaceWord", raises: [], tags: [].}</pre></dt> <dd> <p>Replaces <em>sub</em> in <em>s</em> by the string <em>by</em>.</p> <p>Each occurrence of <em>sub</em> has to be surrounded by word boundaries (comparable to <code>\\w</code> in regular expressions), otherwise it is not replaced.</p>   </dd>  <dt><pre data-language="nim">proc multiReplace(s: string; replacements: varargs[(string, string)]): string {...}{.
    noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Same as replace, but specialized for doing multiple replacements in a single pass through the input string.</p> <p>multiReplace performs all replacements in a single pass, this means it can be used to swap the occurences of "a" and "b", for instance.</p> <p>If the resulting string is not longer than the original input string, only a single memory allocation is required.</p> <p>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</p>   </dd>  <dt><pre data-language="nim">proc delete(s: var string; first, last: int) {...}{.noSideEffect, gcsafe, extern: "nsuDelete",
                                        raises: [], tags: [].}</pre></dt> <dd> <p>Deletes in <em>s</em> the characters at position <em>first</em> .. <em>last</em>.</p> <p>This modifies <em>s</em> itself, it does not return a copy.</p>   </dd>  <dt><pre data-language="nim">proc toOct(x: BiggestInt; len: Positive): string {...}{.noSideEffect, gcsafe,
    extern: "nsuToOct", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> into its octal representation.</p> <p>The resulting string is always <em>len</em> characters long. No leading <code>0o</code> prefix is generated.</p>   </dd>  <dt><pre data-language="nim">proc toBin(x: BiggestInt; len: Positive): string {...}{.noSideEffect, gcsafe,
    extern: "nsuToBin", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> into its binary representation.</p> <p>The resulting string is always <em>len</em> characters long. No leading <code>0b</code> prefix is generated.</p>   </dd>  <dt><pre data-language="nim">proc insertSep(s: string; sep = '_'; digits = 3): string {...}{.noSideEffect, gcsafe,
    extern: "nsuInsertSep", raises: [], tags: [].}</pre></dt> <dd> <p>Inserts the separator <em>sep</em> after <em>digits</em> digits from right to left.</p> <p>Even though the algorithm works with any string <em>s</em>, it is only useful if <em>s</em> contains a number.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert insertSep("1000000") == "1_000_000"</pre>   </dd>  <dt><pre data-language="nim">proc escape(s: string; prefix = "\""; suffix = "\""): string {...}{.noSideEffect, gcsafe,
    extern: "nsuEscape", raises: [], tags: [].}</pre></dt> <dd> <p>Escapes a string <em>s</em>. See <a href="system#addEscapedChar">system.addEscapedChar</a> for the escaping scheme.</p> <p>The resulting string is prefixed with <em>prefix</em> and suffixed with <em>suffix</em>. Both may be empty strings.</p>   </dd>  <dt><pre data-language="nim">proc unescape(s: string; prefix = "\""; suffix = "\""): string {...}{.noSideEffect, gcsafe,
    extern: "nsuUnescape", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Unescapes a string <em>s</em>.</p> <p>This complements <a href="#escape">escape</a> as it performs the opposite operations.</p> <p>If <em>s</em> does not begin with <code>prefix</code> and end with <code>suffix</code> a ValueError exception will be raised.</p>   </dd>  <dt><pre data-language="nim">proc validIdentifier(s: string): bool {...}{.noSideEffect, gcsafe,
                                    extern: "nsuValidIdentifier", raises: [],
                                    tags: [].}</pre></dt> <dd> <p>Returns true if <em>s</em> is a valid identifier.</p> <p>A valid identifier starts with a character of the set <em>IdentStartChars</em> and is followed by any number of characters of the set <em>IdentChars</em>.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert "abc_def08".validIdentifier</pre>   </dd>  <dt><pre data-language="nim">proc editDistance(a, b: string): int {...}{.noSideEffect, gcsafe, extern: "nsuEditDistance",
                                  raises: [], tags: [].}</pre></dt> <dd> <p>Returns the edit distance between <em>a</em> and <em>b</em>.</p> <p>This uses the <span id="levenshtein_1">Levenshtein</span> distance algorithm with only a linear memory overhead.</p>   </dd>  <dt><pre data-language="nim">proc formatBiggestFloat(f: BiggestFloat; format: FloatFormatMode = ffDefault;
                       precision: range[-1 .. 32] = 16; decimalSep = '.'): string {...}{.
    noSideEffect, gcsafe, extern: "nsu$1", raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <em>f</em> to a string.</p> <p>If <code>format == ffDecimal</code> then precision is the number of digits to be printed after the decimal point. If <code>format == ffScientific</code> then precision is the maximum number of significant digits to be printed. <em>precision</em>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <code>biggestFloat</code> type.</p> <p>If <code>precision == -1</code>, it tries to format it nicely.</p>   </dd>  <dt><pre data-language="nim">proc formatFloat(f: float; format: FloatFormatMode = ffDefault;
                precision: range[-1 .. 32] = 16; decimalSep = '.'): string {...}{.noSideEffect,
    gcsafe, extern: "nsu$1", raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <em>f</em> to a string.</p> <p>If <code>format == ffDecimal</code> then precision is the number of digits to be printed after the decimal point. If <code>format == ffScientific</code> then precision is the maximum number of significant digits to be printed. <em>precision</em>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <code>float</code> type.</p> <p>If <code>precision == -1</code>, it tries to format it nicely.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let x = 123.456
doAssert x.formatFloat() == "123.4560000000000"
doAssert x.formatFloat(ffDecimal, 4) == "123.4560"
doAssert x.formatFloat(ffScientific, 2) == "1.23e+02"</pre>   </dd>  <dt><pre data-language="nim">proc trimZeros(x: var string) {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Trim trailing zeros from a formatted floating point value (<em>x</em>). Modifies the passed value.   </dd>  <dt><pre data-language="nim">proc formatSize(bytes: int64; decimalSep = '.'; prefix = bpIEC; includeSpace = false): string {...}{.
    noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Rounds and formats <em>bytes</em>.</p> <p>By default, uses the IEC/ISO standard binary prefixes, so 1024 will be formatted as 1KiB. Set prefix to <em>bpColloquial</em> to use the colloquial names from the SI standard (e.g. k for 1000 being reused as 1024).</p> <p><em>includeSpace</em> can be set to true to include the (SI preferred) space between the number and the unit (e.g. 1 KiB).</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert formatSize((1'i64 shl 31) + (300'i64 shl 20)) == "2.293GiB"
doAssert formatSize((2.234 * 1024 * 1024).int) == "2.234MiB"
doAssert formatSize(4096, includeSpace = true) == "4 KiB"
doAssert formatSize(4096, prefix = bpColloquial, includeSpace = true) == "4 kB"
doAssert formatSize(4096) == "4KiB"
doAssert formatSize(5378934, prefix = bpColloquial, decimalSep = ',') == "5,13MB"</pre>   </dd>  <dt><pre data-language="nim">proc formatEng(f: BiggestFloat; precision: range[0 .. 32] = 10; trim: bool = true;
              siPrefix: bool = false; unit: string = ""; decimalSep = '.';
              useUnitSpace = false): string {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <em>f</em> to a string using engineering notation.</p> <p>Numbers in of the range -1000.0&lt;f&lt;1000.0 will be formatted without an exponent. Numbers outside of this range will be formatted as a significand in the range -1000.0&lt;f&lt;1000.0 and an exponent that will always be an integer multiple of 3, corresponding with the SI prefix scale k, M, G, T etc for numbers with an absolute value greater than 1 and m, , n, p etc for numbers with an absolute value less than 1.</p> <p>The default configuration (<em>trim=true</em> and <em>precision=10</em>) shows the <strong>shortest</strong> form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</p> <p>If <em>trim</em> is set to true, trailing zeros will be removed; if false, the number of digits specified by <em>precision</em> will always be shown.</p> <p><em>precision</em> can be used to set the number of digits to be shown after the decimal point or (if <em>trim</em> is true) the maximum number of digits to be shown.</p> <pre class="listing" data-language="nim">formatEng(0, 2, trim=false) == "0.00"
formatEng(0, 2) == "0"
formatEng(0.053, 0) == "53e-3"
formatEng(52731234, 2) == "52.73e6"
formatEng(-52731234, 2) == "-52.73e6"</pre>
<p>If <em>siPrefix</em> is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as "4.1 k" instead of "4.1e3". Note that <em>u</em> is used for micro- in place of the greek letter mu () as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&lt;f&lt;1000e18 (1a&lt;f&lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether <em>siPrefix</em> is true.</p> <p>If <em>useUnitSpace</em> is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</p> <pre class="listing" data-language="nim">formatEng(4100, siPrefix=true, unit="V") == "4.1 kV"
formatEng(4.1, siPrefix=true, unit="V") == "4.1 V"
formatEng(4.1, siPrefix=true) == "4.1" # Note lack of space
formatEng(4100, siPrefix=true) == "4.1 k"
formatEng(4.1, siPrefix=true, unit="") == "4.1 " # Space with unit=""
formatEng(4100, siPrefix=true, unit="") == "4.1 k"
formatEng(4100) == "4.1e3"
formatEng(4100, unit="V") == "4.1e3 V"
formatEng(4100, unit="", useUnitSpace=true) == "4.1e3 " # Space with useUnitSpace=true</pre>
<p><em>decimalSep</em> is used as the decimal separator.</p>   </dd>  <dt><pre data-language="nim">proc addf(s: var string; formatstr: string; a: varargs[string, `$`]) {...}{.noSideEffect,
    gcsafe, extern: "nsuAddf", raises: [ValueError], tags: [].}</pre></dt> <dd> The same as <code>add(s, formatstr % a)</code>, but more efficient.   </dd>  <dt><pre data-language="nim">proc `%`(formatstr: string; a: openArray[string]): string {...}{.noSideEffect, gcsafe,
    extern: "nsuFormatOpenArray", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Interpolates a format string with the values from <em>a</em>.</p> <p>The <span id="substitution_1">substitution</span> operator performs string substitutions in <em>formatstr</em> and returns a modified <em>formatstr</em>. This is often called <span id="string-interpolation_1">string interpolation</span>.</p> <p>This is best explained by an example:</p> <pre class="listing" data-language="nim">"$1 eats $2." % ["The cat", "fish"]</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"The cat eats fish."</pre>
<p>The substitution variables (the thing after the <code>$</code>) are enumerated from 1 to <code>a.len</code>. To produce a verbatim <code>$</code>, use <code>$$</code>. The notation <code>$#</code> can be used to refer to the next substitution variable:</p> <pre class="listing" data-language="nim">"$# eats $#." % ["The cat", "fish"]</pre>
<p>Substitution variables can also be words (that is <code>[A-Za-z_]+[A-Za-z0-9_]*</code>) in which case the arguments in <em>a</em> with even indices are keys and with odd indices are the corresponding values. An example:</p> <pre class="listing" data-language="nim">"$animal eats $food." % ["animal", "The cat", "food", "fish"]</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"The cat eats fish."</pre>
<p>The variables are compared with <em>cmpIgnoreStyle</em>. <em>ValueError</em> is raised if an ill-formed format string has been passed to the <em>%</em> operator.</p>   </dd>  <dt><pre data-language="nim">proc `%`(formatstr, a: string): string {...}{.noSideEffect, gcsafe,
                                    extern: "nsuFormatSingleElem",
                                    raises: [ValueError], tags: [].}</pre></dt> <dd> This is the same as <code>formatstr % [a]</code>.   </dd>  <dt><pre data-language="nim">proc format(formatstr: string; a: varargs[string, `$`]): string {...}{.noSideEffect, gcsafe,
    extern: "nsuFormatVarargs", raises: [ValueError], tags: [].}</pre></dt> <dd> This is the same as <code>formatstr % a</code> except that it supports auto stringification.   </dd>  <dt><pre data-language="nim">proc removeSuffix(s: var string; chars: set[char] = Newlines) {...}{.gcsafe,
    extern: "nsuRemoveSuffixCharSet", raises: [], tags: [].}</pre></dt> <dd> Removes all characters from <em>chars</em> from the end of the string <em>s</em> (in-place). <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var userInput = "Hello World!*~\c\n"
userInput.removeSuffix
doAssert userInput == "Hello World!*~"
userInput.removeSuffix({'~', '*'})
doAssert userInput == "Hello World!"
var otherInput = "Hello!?!"
otherInput.removeSuffix({'!', '?'})
doAssert otherInput == "Hello"</pre>   </dd>  <dt><pre data-language="nim">proc removeSuffix(s: var string; c: char) {...}{.gcsafe, extern: "nsuRemoveSuffixChar",
                                      raises: [], tags: [].}</pre></dt> <dd> Removes all occurrences of a single character (in-place) from the end of a string. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var table = "users"
table.removeSuffix('s')
doAssert table == "user"
var dots = "Trailing dots......."
dots.removeSuffix('.')
doAssert dots == "Trailing dots"</pre>   </dd>  <dt><pre data-language="nim">proc removeSuffix(s: var string; suffix: string) {...}{.gcsafe,
    extern: "nsuRemoveSuffixString", raises: [], tags: [].}</pre></dt> <dd> Remove the first matching suffix (in-place) from a string. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var answers = "yeses"
answers.removeSuffix("es")
doAssert answers == "yes"</pre>   </dd>  <dt><pre data-language="nim">proc removePrefix(s: var string; chars: set[char] = Newlines) {...}{.gcsafe,
    extern: "nsuRemovePrefixCharSet", raises: [], tags: [].}</pre></dt> <dd> Removes all characters from <em>chars</em> from the start of the string <em>s</em> (in-place). <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var userInput = "\c\n*~Hello World!"
userInput.removePrefix
doAssert userInput == "*~Hello World!"
userInput.removePrefix({'~', '*'})
doAssert userInput == "Hello World!"
var otherInput = "?!?Hello!?!"
otherInput.removePrefix({'!', '?'})
doAssert otherInput == "Hello!?!"</pre>   </dd>  <dt><pre data-language="nim">proc removePrefix(s: var string; c: char) {...}{.gcsafe, extern: "nsuRemovePrefixChar",
                                      raises: [], tags: [].}</pre></dt> <dd> Removes all occurrences of a single character (in-place) from the start of a string. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var ident = "pControl"
ident.removePrefix('p')
doAssert ident == "Control"</pre>   </dd>  <dt><pre data-language="nim">proc removePrefix(s: var string; prefix: string) {...}{.gcsafe,
    extern: "nsuRemovePrefixString", raises: [], tags: [].}</pre></dt> <dd> Remove the first matching prefix (in-place) from a string. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var answers = "yesyes"
answers.removePrefix("yes")
doAssert answers == "yes"</pre>   </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre data-language="nim">iterator split(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a group of separators.</p> <p>Substrings are separated by a substring containing only <em>seps</em>.</p> <pre class="listing" data-language="nim">for word in split("this\lis an\texample"):
  writeLine(stdout, word)</pre>
<p>...generates this output:</p> <pre class="listing" data-language="nim">"this"
"is"
"an"
"example"</pre>
<p>And the following code:</p> <pre class="listing" data-language="nim">for word in split("this:is;an$example", {';', ':', '$'}):
  writeLine(stdout, word)</pre>
<p>...produces the same output as the first example. The code:</p> <pre class="listing" data-language="nim">let date = "2012-11-20T22:08:08.398990"
let separators = {' ', '-', ':', 'T'}
for number in split(date, separators):
  writeLine(stdout, number)</pre>
<p>...results in:</p> <pre class="listing" data-language="nim">"2012"
"11"
"20"
"22"
"08"
"08.398990"</pre>   </dd>  <dt><pre data-language="nim">iterator splitWhitespace(s: string; maxsplit: int = -1): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> at whitespace stripping leading and trailing whitespace if necessary. If <code>maxsplit</code> is specified and is positive, no more than <code>maxsplit</code> splits is made.</p> <p>The following code:</p> <pre class="listing" data-language="nim">let s = "  foo \t bar  baz  "
for ms in [-1, 1, 2, 3]:
  echo "------ maxsplit = ", ms, ":"
  for item in s.splitWhitespace(maxsplit=ms):
    echo '"', item, '"'</pre>
<p>...results in:</p> <pre class="listing" data-language="nim">------ maxsplit = -1:
"foo"
"bar"
"baz"
------ maxsplit = 1:
"foo"
"bar  baz  "
------ maxsplit = 2:
"foo"
"bar"
"baz  "
------ maxsplit = 3:
"foo"
"bar"
"baz"</pre>   </dd>  <dt><pre data-language="nim">iterator split(s: string; sep: char; maxsplit: int = -1): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a single separator.</p> <p>Substrings are separated by the character <em>sep</em>. The code:</p> <pre class="listing" data-language="nim">for word in split(";;this;is;an;;example;;;", ';'):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">""
""
"this"
"is"
"an"
""
"example"
""
""
""</pre>   </dd>  <dt><pre data-language="nim">iterator split(s: string; sep: string; maxsplit: int = -1): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a string separator.</p> <p>Substrings are separated by the string <em>sep</em>. The code:</p> <pre class="listing" data-language="nim">for word in split("thisDATAisDATAcorrupted", "DATA"):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"this"
"is"
"corrupted"</pre>   </dd>  <dt><pre data-language="nim">iterator rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Splits the string <em>s</em> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,char,int">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foo bar".rsplit(WhiteSpace):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the set of chars <em>seps</em></p>   </dd>  <dt><pre data-language="nim">iterator rsplit(s: string; sep: char; maxsplit: int = -1): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Splits the string <em>s</em> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,char,int">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foo:bar".rsplit(':'):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the char <em>sep</em></p>   </dd>  <dt><pre data-language="nim">iterator rsplit(s: string; sep: string; maxsplit: int = -1; keepSeparators: bool = false): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Splits the string <em>s</em> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,string,int">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foothebar".rsplit("the"):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the string <em>sep</em></p>   </dd>  <dt><pre data-language="nim">iterator splitLines(s: string; keepEol = false): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into its containing lines.</p> <p>Every <a href="manual#character-literals">character literal</a> newline combination (CR, LF, CR-LF) is supported. The result strings contain no trailing end of line characters unless parameter <code>keepEol</code> is set to <code>true</code>.</p> <p>Example:</p> <pre class="listing" data-language="nim">for line in splitLines("\nthis\nis\nan\n\nexample\n"):
  writeLine(stdout, line)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">""
"this"
"is"
"an"
""
"example"
""</pre>   </dd>  <dt><pre data-language="nim">iterator tokenize(s: string; seps: set[char] = Whitespace): tuple[token: string,
    isSep: bool] {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Tokenizes the string <em>s</em> into substrings.</p> <p>Substrings are separated by a substring containing only <em>seps</em>. Examples:</p> <pre class="listing" data-language="nim">for word in tokenize("  this is an  example  "):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">("  ", true)
("this", false)
(" ", true)
("is", false)
(" ", true)
("an", false)
("  ", true)
("example", false)
("  ", true)</pre>   </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template spaces(n: Natural): string</pre></dt> <dd> Returns a String with <em>n</em> space characters. You can use this proc to left align strings. Example:<pre class="listing" data-language="nim">let
  width = 15
  text1 = "Hello user!"
  text2 = "This is a very long string"
echo text1 &amp; spaces(max(0, width - text1.len)) &amp; "|"
echo text2 &amp; spaces(max(0, width - text2.len)) &amp; "|"</pre>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     20062018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/strutils.html" class="_attribution-link">https://nim-lang.org/docs/strutils.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
