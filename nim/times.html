
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Times - Nim - W3cubDocs</title>
  
  <meta name="description" content="This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It&#39;s also available for the JavaScript &hellip;">
  <meta name="keywords" content="module, times, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/times.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module times</h1>  
<p>This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It's also available for the <a href="backends#the-javascript-target">JavaScript target</a>.</p> <p>Although the types use nanosecond time resolution, the underlying resolution used by <code>getTime()</code> depends on the platform and backend (JS is limited to millisecond precision).</p> <p>Examples:</p> <pre class="listing" data-language="nim">import times, os
let time = cpuTime()

sleep(100)   # replace this with something to be timed
echo "Time taken: ",cpuTime() - time

echo "My formatted time: ", format(now(), "d MMMM yyyy HH:mm")
echo "Using predefined formats: ", getClockStr(), " ", getDateStr()

echo "cpuTime()  float value: ", cpuTime()
echo "An hour from now      : ", now() + 1.hours
echo "An hour from (UTC) now: ", getTime().utc + initDuration(hours = 1)</pre> <h2 id="parsing-and-formatting-dates">Parsing and Formatting Dates</h2>
<p>The <code>DateTime</code> type can be parsed and formatted using the different <code>parse</code> and <code>format</code> procedures.</p> <pre class="listing" data-language="nim">let dt = parse("2000-01-01", "yyyy-MM-dd")
echo dt.format("yyyy-MM-dd")</pre>
<p>The different format patterns that are supported are documented below.</p> <table>
<tr>
<th>Pattern</th>
<th>Description</th>
<th>Example</th>
</tr> <tr>
<td><code>d</code></td>
<td>Numeric value representing the day of the month, it will be either one or two digits long.</td>
<td><p><code>1/04/2012 -&gt; 1</code><br><code>21/04/2012 -&gt; 21</code><br></p></td>
</tr> <tr>
<td><code>dd</code></td>
<td>Same as above, but is always two digits. </td>
<td><p><code>1/04/2012 -&gt; 01</code><br><code>21/04/2012 -&gt; 21</code><br></p></td>
</tr> <tr>
<td><code>ddd</code></td>
<td>Three letter string which indicates the day of the week. </td>
<td><p><code>Saturday -&gt; Sat</code><br><code>Monday -&gt; Mon</code><br></p></td>
</tr> <tr>
<td><code>dddd</code></td>
<td>Full string for the day of the week. </td>
<td><p><code>Saturday -&gt; Saturday</code><br><code>Monday -&gt; Monday</code><br></p></td>
</tr> <tr>
<td><code>h</code></td>
<td>The hours in one digit if possible. Ranging from 1-12. </td>
<td><p><code>5pm -&gt; 5</code><br><code>2am -&gt; 2</code><br></p></td>
</tr> <tr>
<td><code>hh</code></td>
<td>The hours in two digits always. If the hour is one digit 0 is prepended. </td>
<td><p><code>5pm -&gt; 05</code><br><code>11am -&gt; 11</code><br></p></td>
</tr> <tr>
<td><code>H</code></td>
<td>The hours in one digit if possible, ranging from 0-23. </td>
<td><p><code>5pm -&gt; 17</code><br><code>2am -&gt; 2</code><br></p></td>
</tr> <tr>
<td><code>HH</code></td>
<td>The hours in two digits always. 0 is prepended if the hour is one digit. </td>
<td><p><code>5pm -&gt; 17</code><br><code>2am -&gt; 02</code><br></p></td>
</tr> <tr>
<td><code>m</code></td>
<td>The minutes in 1 digit if possible. </td>
<td><p><code>5:30 -&gt; 30</code><br><code>2:01 -&gt; 1</code><br></p></td>
</tr> <tr>
<td><code>mm</code></td>
<td>Same as above but always 2 digits, 0 is prepended if the minute is one digit. </td>
<td><p><code>5:30 -&gt; 30</code><br><code>2:01 -&gt; 01</code><br></p></td>
</tr> <tr>
<td><code>M</code></td>
<td>The month in one digit if possible. </td>
<td><p><code>September -&gt; 9</code><br><code>December -&gt; 12</code><br></p></td>
</tr> <tr>
<td><code>MM</code></td>
<td>The month in two digits always. 0 is prepended. </td>
<td><p><code>September -&gt; 09</code><br><code>December -&gt; 12</code><br></p></td>
</tr> <tr>
<td><code>MMM</code></td>
<td>Abbreviated three-letter form of the month. </td>
<td><p><code>September -&gt; Sep</code><br><code>December -&gt; Dec</code><br></p></td>
</tr> <tr>
<td><code>MMMM</code></td>
<td>Full month string, properly capitalized.</td>
<td><p><code>September -&gt; September</code><br></p></td>
</tr> <tr>
<td><code>s</code></td>
<td>Seconds as one digit if possible.</td>
<td><p><code>00:00:06 -&gt; 6</code><br></p></td>
</tr> <tr>
<td><code>ss</code></td>
<td>Same as above but always two digits. 0 is prepended.</td>
<td><p><code>00:00:06 -&gt; 06</code><br></p></td>
</tr> <tr>
<td><code>t</code></td>
<td>
<code>A</code> when time is in the AM. <code>P</code> when time is in the PM. </td>
<td><p><code>5pm -&gt; P</code><br><code>2am -&gt; A</code><br></p></td>
</tr> <tr>
<td><code>tt</code></td>
<td>Same as above, but <code>AM</code> and <code>PM</code> instead of <code>A</code> and <code>P</code> respectively. </td>
<td><p><code>5pm -&gt; PM</code><br><code>2am -&gt; AM</code><br></p></td>
</tr> <tr>
<td><code>yy</code></td>
<td>The last two digits of the year. When parsing, the current century is assumed.</td>
<td><p><code>2012 AD -&gt; 12</code><br></p></td>
</tr> <tr>
<td><code>yyyy</code></td>
<td>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended. </td>
<td><p><code>2012 AD -&gt; 2012</code><br><code>24 AD -&gt; 0024</code><br><code>24 BC -&gt; 00024</code><br><code>12345 AD -&gt; +12345</code><br></p></td>
</tr> <tr>
<td><code>YYYY</code></td>
<td>The year without any padding. Is always positive, even when the year is BC.</td>
<td><p><code>2012 AD -&gt; 2012</code><br><code>24 AD -&gt; 24</code><br><code>24 BC -&gt; 24</code><br><code>12345 AD -&gt; 12345</code><br></p></td>
</tr> <tr>
<td><code>uuuu</code></td>
<td>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</td>
<td><p><code>2012 AD -&gt; 2012</code><br><code>24 AD -&gt; 0024</code><br><code>24 BC -&gt; -0023</code><br><code>12345 AD -&gt; +12345</code><br></p></td>
</tr> <tr>
<td><code>UUUU</code></td>
<td>The year without any padding. Will be negative when the year is BC.</td>
<td><p><code>2012 AD -&gt; 2012</code><br><code>24 AD -&gt; 24</code><br><code>24 BC -&gt; -23</code><br><code>12345 AD -&gt; 12345</code><br></p></td>
</tr> <tr>
<td><code>z</code></td>
<td>Displays the timezone offset from UTC. </td>
<td><p><code>GMT+7 -&gt; +7</code><br><code>GMT-5 -&gt; -5</code><br></p></td>
</tr> <tr>
<td><code>zz</code></td>
<td>Same as above but with leading 0. </td>
<td><p><code>GMT+7 -&gt; +07</code><br><code>GMT-5 -&gt; -05</code><br></p></td>
</tr> <tr>
<td><code>zzz</code></td>
<td>Same as above but with <code>:mm</code> where <em>mm</em> represents minutes. </td>
<td><p><code>GMT+7 -&gt; +07:00</code><br><code>GMT-5 -&gt; -05:00</code><br></p></td>
</tr> <tr>
<td><code>zzzz</code></td>
<td>Same as above but with <code>:ss</code> where <em>ss</em> represents seconds. </td>
<td><p><code>GMT+7 -&gt; +07:00:00</code><br><code>GMT-5 -&gt; -05:00:00</code><br></p></td>
</tr> <tr>
<td><code>g</code></td>
<td>Era: AD or BC </td>
<td><p><code>300 AD -&gt; AD</code><br><code>300 BC -&gt; BC</code><br></p></td>
</tr> <tr>
<td><code>fff</code></td>
<td>Milliseconds display</td>
<td><p><code>1000000 nanoseconds -&gt; 1</code><br></p></td>
</tr> <tr>
<td><code>ffffff</code></td>
<td>Microseconds display</td>
<td><p><code>1000000 nanoseconds -&gt; 1000</code><br></p></td>
</tr> <tr>
<td><code>fffffffff</code></td>
<td>Nanoseconds display</td>
<td><p><code>1000000 nanoseconds -&gt; 1000000</code><br></p></td>
</tr> </table>
<p>Other strings can be inserted by putting them in <code>''</code>. For example <code>hh'-&gt;'mm</code> will give <code>01-&gt;56</code>. The following characters can be inserted without quoting them: <code>:</code> <code>-</code> <code>(</code> <code>)</code> <code>/</code> <code>[</code> <code>]</code> <code>,</code>. A literal <code>'</code> can be specified with <code>''</code>.</p> <p>However you don't need to necessarily separate format patterns, a unambiguous format string like <code>yyyyMMddhhmmss</code> is valid too (although only for years in the range 1..9999). </p>  <h2 id="6">Imports</h2> <dl> <a href="strutils">strutils</a>, <a href="parseutils">parseutils</a>, <a href="algorithm">algorithm</a>, <a href="math">math</a>, <a href="options">options</a>, <a href="strformat">strformat</a>, <a href="winlean">winlean</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">Month = enum
  mJan = (1, "January"), mFeb = "February", mMar = "March", mApr = "April", mMay = "May",
  mJun = "June", mJul = "July", mAug = "August", mSep = "September", mOct = "October",
  mNov = "November", mDec = "December"</pre></dt> <dd> Represents a month. Note that the enum starts at <code>1</code>, so <code>ord(month)</code> will give the month number in the range <code>[1..12]</code>.   </dd>  <dt><pre data-language="nim">WeekDay = enum
  dMon = "Monday", dTue = "Tuesday", dWed = "Wednesday", dThu = "Thursday", dFri = "Friday",
  dSat = "Saturday", dSun = "Sunday"</pre></dt> <dd> Represents a weekday.   </dd>  <dt><pre data-language="nim">MonthdayRange = range[1 .. 31]</pre></dt>   <dt><pre data-language="nim">HourRange = range[0 .. 23]</pre></dt>   <dt><pre data-language="nim">MinuteRange = range[0 .. 59]</pre></dt>   <dt><pre data-language="nim">SecondRange = range[0 .. 60]</pre></dt>   <dt><pre data-language="nim">YeardayRange = range[0 .. 365]</pre></dt>   <dt><pre data-language="nim">NanosecondRange = range[0 .. 999999999]</pre></dt>   <dt><pre data-language="nim">Time = object
  seconds: int64
  nanosecond: NanosecondRange</pre></dt> <dd> Represents a point in time.   </dd>  <dt><pre data-language="nim">DateTime = object of RootObj
  nanosecond*: NanosecondRange ## The number of nanoseconds after the second,
                             ## in the range 0 to 999_999_999.
  second*: SecondRange         ## The number of seconds after the minute,
                     ## normally in the range 0 to 59, but can
                     ## be up to 60 to allow for a leap second.
  minute*: MinuteRange         ## The number of minutes after the hour,
                     ## in the range 0 to 59.
  hour*: HourRange             ## The number of hours past midnight,
                 ## in the range 0 to 23.
  monthday*: MonthdayRange     ## The day of the month, in the range 1 to 31.
  month*: Month                ## The current month.
  year*: int ## The current year, using astronomical year numbering
           ## (meaning that before year 1 is year 0, then year -1 and so on).
  weekday*: WeekDay            ## The current day of the week.
  yearday*: YeardayRange       ## The number of days since January 1,
                       ## in the range 0 to 365.
  isDst*: bool                 ## Determines whether DST is in effect.
             ## Always false for the JavaScript backend.
  timezone*: Timezone          ## The timezone represented as an implementation of ``Timezone``.
  utcOffset*: int ## The offset in seconds west of UTC, including any offset due to DST.
                ## Note that the sign of this number is the opposite
                ## of the one in a formatted offset string like ``+01:00``
                ## (which would be parsed into the UTC offset ``-3600``).</pre></dt> <dd> Represents a time in different parts. Although this type can represent leap seconds, they are generally not supported in this module. They are not ignored, but the <code>DateTime</code>'s returned by procedures in this module will never have a leap second.   </dd>  <dt><pre data-language="nim">TimeInterval = object
  nanoseconds*: int            ## The number of nanoseconds
  microseconds*: int           ## The number of microseconds
  milliseconds*: int           ## The number of milliseconds
  seconds*: int                ## The number of seconds
  minutes*: int                ## The number of minutes
  hours*: int                  ## The number of hours
  days*: int                   ## The number of days
  weeks*: int                  ## The number of weeks
  months*: int                 ## The number of months
  years*: int                  ## The number of years</pre></dt> <dd> Represents a non-fixed duration of time. Can be used to add and subtract non-fixed time units from a <code>DateTime</code> or <code>Time</code>. <code>TimeInterval</code> doesn't represent a fixed duration of time, since the duration of some units depend on the context (e.g a year can be either 365 or 366 days long). The non-fixed time units are years, months and days.   </dd>  <dt><pre data-language="nim">Duration = object
  seconds: int64
  nanosecond: NanosecondRange</pre></dt> <dd> Represents a fixed duration of time. Uses the same time resolution as <code>Time</code>. This type should be prefered over <code>TimeInterval</code> unless non-static time units is needed.   </dd>  <dt><pre data-language="nim">TimeUnit = enum
  Nanoseconds, Microseconds, Milliseconds, Seconds, Minutes, Hours, Days, Weeks, Months,
  Years</pre></dt> <dd> Different units of time.   </dd>  <dt><pre data-language="nim">FixedTimeUnit = range[Nanoseconds .. Weeks]</pre></dt> <dd> Subrange of <code>TimeUnit</code> that only includes units of fixed duration. These are the units that can be represented by a <code>Duration</code>.   </dd>  <dt><pre data-language="nim">Timezone = ref object
  zonedTimeFromTimeImpl: proc (x: Time): ZonedTime {...}{.tags: [], raises: [], gcsafe,
      locks: 0.}
  zonedTimeFromAdjTimeImpl: proc (x: Time): ZonedTime {...}{.tags: [], raises: [], gcsafe,
      locks: 0.}
  name: string</pre></dt> <dd> Timezone interface for supporting <code>DateTime</code>'s of arbritary timezones. The <code>times</code> module only supplies implementations for the systems local time and UTC.   </dd>  <dt><pre data-language="nim">ZonedTime = object
  time*: Time                  ## The point in time being represented.
  utcOffset*: int              ## The offset in seconds west of UTC,
                ## including any offset due to DST.
  isDst*: bool                 ## Determines whether DST is in effect.</pre></dt> <dd> Represents a point in time with an associated UTC offset and DST flag. This type is only used for implementing timezones.   </dd>  <dt><pre data-language="nim">DurationParts = array[FixedTimeUnit, int64]</pre></dt>   <dt><pre data-language="nim">TimeIntervalParts = array[TimeUnit, int]</pre></dt>   <dt><pre data-language="nim">TimeFormat = object
  patterns: seq[byte] ## \
                    ## Contains the patterns encoded as bytes.
                    ## Literal values are encoded in a special way.
                    ## They start with ``Lit.byte``, then the length of the literal, then the
                    ## raw char values of the literal. For example, the literal `foo` would
                    ## be encoded as ``@[Lit.byte, 3.byte, 'f'.byte, 'o'.byte, 'o'.byte]``.
  formatStr: string</pre></dt> <dd> Represents a format for parsing and printing time types.   </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre data-language="nim">DurationZero = (seconds: 0, nanosecond: 0)</pre></dt> <dd> Zero value for durations. Useful for comparisons.<pre class="listing" data-language="nim">doAssert initDuration(seconds = 1) &gt; DurationZero
doAssert initDuration(seconds = 0) == DurationZero</pre>   </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc convert[T: SomeInteger](unitFrom, unitTo: FixedTimeUnit; quantity: T): T {...}{.inline.}</pre></dt> <dd> Convert a quantity of some duration unit to another duration unit. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert convert(Days, Hours, 2) == 48
doAssert convert(Days, Weeks, 13) == 1
doAssert convert(Seconds, Milliseconds, -1) == -1000</pre>   </dd>  <dt><pre data-language="nim">proc nanosecond(time: Time): NanosecondRange {...}{.raises: [], tags: [].}</pre></dt> <dd> Get the fractional part of a <code>Time</code> as the number of nanoseconds of the second.   </dd>  <dt><pre data-language="nim">proc weeks(dur: Duration): int64 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole weeks represented by the duration.   </dd>  <dt><pre data-language="nim">proc days(dur: Duration): int64 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole days represented by the duration.   </dd>  <dt><pre data-language="nim">proc minutes(dur: Duration): int64 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole minutes represented by the duration.   </dd>  <dt><pre data-language="nim">proc hours(dur: Duration): int64 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole hours represented by the duration.   </dd>  <dt><pre data-language="nim">proc seconds(dur: Duration): int64 {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole seconds represented by the duration.   </dd>  <dt><pre data-language="nim">proc milliseconds(dur: Duration): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole milliseconds represented by the <strong>fractional</strong> part of the duration. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dur = initDuration(seconds = 1, milliseconds = 1)
doAssert dur.milliseconds == 1</pre>   </dd>  <dt><pre data-language="nim">proc microseconds(dur: Duration): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole microseconds represented by the <strong>fractional</strong> part of the duration. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dur = initDuration(seconds = 1, microseconds = 1)
doAssert dur.microseconds == 1</pre>   </dd>  <dt><pre data-language="nim">proc nanoseconds(dur: Duration): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Number of whole nanoseconds represented by the <strong>fractional</strong> part of the duration. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dur = initDuration(seconds = 1, nanoseconds = 1)
doAssert dur.nanoseconds == 1</pre>   </dd>  <dt><pre data-language="nim">proc fractional(dur: Duration): Duration {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> The fractional part of duration, as a duration. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dur = initDuration(seconds = 1, nanoseconds = 5)
doAssert dur.fractional == initDuration(nanoseconds = 5)</pre>   </dd>  <dt><pre data-language="nim">proc fromUnix(unix: int64): Time {...}{.gcsafe, locks: 0, tags: [], raises: [], noSideEffect.}</pre></dt> <dd> Convert a unix timestamp (seconds since <code>1970-01-01T00:00:00Z</code>) to a <code>Time</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert $fromUnix(0).utc == "1970-01-01T00:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc toUnix(t: Time): int64 {...}{.gcsafe, locks: 0, tags: [], raises: [], noSideEffect.}</pre></dt> <dd> Convert <code>t</code> to a unix timestamp (seconds since <code>1970-01-01T00:00:00Z</code>). <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert fromUnix(0).toUnix() == 0</pre>   </dd>  <dt><pre data-language="nim">proc fromWinTime(win: int64): Time {...}{.raises: [], tags: [].}</pre></dt> <dd> Convert a Windows file time (100-nanosecond intervals since <code>1601-01-01T00:00:00Z</code>) to a <code>Time</code>.   </dd>  <dt><pre data-language="nim">proc toWinTime(t: Time): int64 {...}{.raises: [], tags: [].}</pre></dt> <dd> Convert <code>t</code> to a Windows file time (100-nanosecond intervals since <code>1601-01-01T00:00:00Z</code>).   </dd>  <dt><pre data-language="nim">proc isLeapYear(year: int): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns true if <code>year</code> is a leap year.   </dd>  <dt><pre data-language="nim">proc getDaysInMonth(month: Month; year: int): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Get the number of days in a <code>month</code> of a <code>year</code>.   </dd>  <dt><pre data-language="nim">proc getDaysInYear(year: int): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Get the number of days in a <code>year</code>   </dd>  <dt><pre data-language="nim">proc getDayOfYear(monthday: MonthdayRange; month: Month; year: int): YeardayRange {...}{.
    tags: [], raises: [], gcsafe, locks: 0.}</pre></dt> <dd> Returns the day of the year. Equivalent with <code>initDateTime(monthday, month, year, 0, 0, 0).yearday</code>.   </dd>  <dt><pre data-language="nim">proc getDayOfWeek(monthday: MonthdayRange; month: Month; year: int): WeekDay {...}{.tags: [],
    raises: [], gcsafe, locks: 0.}</pre></dt> <dd> Returns the day of the week enum from day, month and year. Equivalent with <code>initDateTime(monthday, month, year, 0, 0, 0).weekday</code>.   </dd>  <dt><pre data-language="nim">proc initDuration(nanoseconds, microseconds, milliseconds, seconds, minutes, hours,
                 days, weeks: int64 = 0): Duration {...}{.tags: [], raises: [], gcsafe,
    locks: 0, noSideEffect.}</pre></dt> <dd> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dur = initDuration(seconds = 1, milliseconds = 1)
doAssert dur.milliseconds == 1
doAssert dur.seconds == 1</pre>   </dd>  <dt><pre data-language="nim">proc toParts(dur: Duration): DurationParts {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Converts a duration into an array consisting of fixed time units.</p> <p>Each value in the array gives information about a specific unit of time, for example <code>result[Days]</code> gives a count of days.</p> <p>This procedure is useful for converting <code>Duration</code> values to strings.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var dp = toParts(initDuration(weeks = 2, days = 1))
doAssert dp[Days] == 1
doAssert dp[Weeks] == 2
dp = toParts(initDuration(days = -1))
doAssert dp[Days] == -1</pre>   </dd>  <dt><pre data-language="nim">proc `$`(dur: Duration): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Human friendly string representation of <code>Duration</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert $initDuration(seconds = 2) == "2 seconds"
doAssert $initDuration(weeks = 1, days = 2) == "1 week and 2 days"
doAssert $initDuration(hours = 1, minutes = 2, seconds = 3) ==
    "1 hour, 2 minutes, and 3 seconds"
doAssert $initDuration(milliseconds = -1500) == "-1 second and -500 milliseconds"</pre>   </dd>  <dt><pre data-language="nim">proc `+`(a, b: Duration): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> Add two durations together. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert initDuration(seconds = 1) + initDuration(days = 1) ==
    initDuration(seconds = 1, days = 1)</pre>   </dd>  <dt><pre data-language="nim">proc `-`(a, b: Duration): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> Subtract a duration from another. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert initDuration(seconds = 1, days = 1) - initDuration(seconds = 1) ==
    initDuration(days = 1)</pre>   </dd>  <dt><pre data-language="nim">proc `-`(a: Duration): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> Reverse a duration. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert -initDuration(seconds = 1) == initDuration(seconds = -1)</pre>   </dd>  <dt><pre data-language="nim">proc `&lt;`(a, b: Duration): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Note that a duration can be negative, so even if <code>a &lt; b</code> is true <code>a</code> might represent a larger absolute duration. Use <code>abs(a) &lt; abs(b)</code> to compare the absolute duration. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert initDuration(seconds = 1) &lt; initDuration(seconds = 2)
doAssert initDuration(seconds = -2) &lt; initDuration(seconds = 1)</pre>   </dd>  <dt><pre data-language="nim">proc `&lt;=`(a, b: Duration): bool {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc `==`(a, b: Duration): bool {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc `*`(a: int64; b: Duration): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> Multiply a duration by some scalar. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert 5 * initDuration(seconds = 1) == initDuration(seconds = 5)</pre>   </dd>  <dt><pre data-language="nim">proc `*`(a: Duration; b: int64): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> Multiply a duration by some scalar. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert initDuration(seconds = 1) * 5 == initDuration(seconds = 5)</pre>   </dd>  <dt><pre data-language="nim">proc `div`(a: Duration; b: int64): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> Integer division for durations. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert initDuration(seconds = 3) div 2 == initDuration(milliseconds = 1500)
doAssert initDuration(nanoseconds = 3) div 2 == initDuration(nanoseconds = 1)</pre>   </dd>  <dt><pre data-language="nim">proc initTime(unix: int64; nanosecond: NanosecondRange): Time {...}{.tags: [], raises: [],
    gcsafe, locks: 0, noSideEffect.}</pre></dt> <dd> Create a <code>Time</code> from a unix timestamp and a nanosecond part.   </dd>  <dt><pre data-language="nim">proc `-`(a, b: Time): Duration {...}{.extern: "ntDiffTime", raises: [], tags: [].}</pre></dt> <dd> Computes the duration between two points in time.   </dd>  <dt><pre data-language="nim">proc `+`(a: Time; b: Duration): Time {...}{.extern: "ntAddTime", raises: [], tags: [].}</pre></dt> <dd> Add a duration of time to a <code>Time</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert (fromUnix(0) + initDuration(seconds = 1)) == fromUnix(1)</pre>   </dd>  <dt><pre data-language="nim">proc `-`(a: Time; b: Duration): Time {...}{.extern: "ntSubTime", raises: [], tags: [].}</pre></dt> <dd> Subtracts a duration of time from a <code>Time</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert (fromUnix(0) - initDuration(seconds = 1)) == fromUnix(-1)</pre>   </dd>  <dt><pre data-language="nim">proc `&lt;`(a, b: Time): bool {...}{.extern: "ntLtTime", raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>a &lt; b</code>, that is iff a happened before b.   </dd>  <dt><pre data-language="nim">proc `&lt;=`(a, b: Time): bool {...}{.extern: "ntLeTime", raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>a &lt;= b</code>.   </dd>  <dt><pre data-language="nim">proc `==`(a, b: Time): bool {...}{.extern: "ntEqTime", raises: [], tags: [].}</pre></dt> <dd> Returns true if <code>a == b</code>, that is if both times represent the same point in time.   </dd>  <dt><pre data-language="nim">proc high(typ: typedesc[Time]): Time</pre></dt>   <dt><pre data-language="nim">proc low(typ: typedesc[Time]): Time</pre></dt>   <dt><pre data-language="nim">proc high(typ: typedesc[Duration]): Duration</pre></dt> <dd> Get the longest representable duration.   </dd>  <dt><pre data-language="nim">proc low(typ: typedesc[Duration]): Duration</pre></dt> <dd> Get the longest representable duration of negative direction.   </dd>  <dt><pre data-language="nim">proc abs(a: Duration): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert initDuration(milliseconds = -1500).abs ==
    initDuration(milliseconds = 1500)</pre>   </dd>  <dt><pre data-language="nim">proc toTime(dt: DateTime): Time {...}{.tags: [], raises: [], gcsafe, locks: 0.}</pre></dt> <dd> Converts a broken-down time structure to calendar time representation.   </dd>  <dt><pre data-language="nim">proc newTimezone(name: string; zonedTimeFromTimeImpl: proc (time: Time): ZonedTime {...}{.
    tags: [], raises: [], gcsafe, locks: 0.}; zonedTimeFromAdjTimeImpl: proc (
    adjTime: Time): ZonedTime {...}{.tags: [], raises: [], gcsafe, locks: 0.}): Timezone {...}{.
    raises: [], tags: [].}</pre></dt> <dd> <p>Create a new <code>Timezone</code>.</p> <p><code>zonedTimeFromTimeImpl</code> and <code>zonedTimeFromAdjTimeImpl</code> is used as the underlying implementations for <code>zonedTimeFromTime</code> and <code>zonedTimeFromAdjTime</code>.</p> <p>If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">proc utcTzInfo(time: Time): ZonedTime =
  ZonedTime(utcOffset: 0, isDst: false, time: time)

let utc = newTimezone("Etc/UTC", utcTzInfo, utcTzInfo)</pre>   </dd>  <dt><pre data-language="nim">proc name(zone: Timezone): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>The name of the timezone.</p> <p>If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string "LOCAL" is used for the systems local timezone.</p> <p>See also: <a href="https://en.wikipedia.org/wiki/Tz_database">https://en.wikipedia.org/wiki/Tz_database</a></p>   </dd>  <dt><pre data-language="nim">proc zonedTimeFromTime(zone: Timezone; time: Time): ZonedTime {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the <code>ZonedTime</code> for some point in time.   </dd>  <dt><pre data-language="nim">proc zonedTimeFromAdjTime(zone: Timezone; adjTime: Time): ZonedTime {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Returns the <code>ZonedTime</code> for some local time.</p> <p>Note that the <code>Time</code> argument does not represent a point in time, it represent a local time! E.g if <code>adjTime</code> is <code>fromUnix(0)</code>, it should be interpreted as 1970-01-01T00:00:00 in the <code>zone</code> timezone, not in UTC.</p>   </dd>  <dt><pre data-language="nim">proc `$`(zone: Timezone): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the name of the timezone.   </dd>  <dt><pre data-language="nim">proc `==`(zone1, zone2: Timezone): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Two <code>Timezone</code>'s are considered equal if their name is equal. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert local() == local()
doAssert local() != utc()</pre>   </dd>  <dt><pre data-language="nim">proc inZone(time: Time; zone: Timezone): DateTime {...}{.tags: [], raises: [], gcsafe, locks: 0.}</pre></dt> <dd> Convert <code>time</code> into a <code>DateTime</code> using <code>zone</code> as the timezone.   </dd>  <dt><pre data-language="nim">proc inZone(dt: DateTime; zone: Timezone): DateTime {...}{.tags: [], raises: [], gcsafe,
    locks: 0.}</pre></dt> <dd> Returns a <code>DateTime</code> representing the same point in time as <code>dt</code> but using <code>zone</code> as the timezone.   </dd>  <dt><pre data-language="nim">proc utc(): Timezone {...}{.raises: [], tags: [].}</pre></dt> <dd> Get the <code>Timezone</code> implementation for the UTC timezone. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert now().utc.timezone == utc()
doAssert utc().name == "Etc/UTC"</pre>   </dd>  <dt><pre data-language="nim">proc local(): Timezone {...}{.raises: [], tags: [].}</pre></dt> <dd> Get the <code>Timezone</code> implementation for the local timezone. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert now().timezone == local()
doAssert local().name == "LOCAL"</pre>   </dd>  <dt><pre data-language="nim">proc utc(dt: DateTime): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> Shorthand for <code>dt.inZone(utc())</code>.   </dd>  <dt><pre data-language="nim">proc local(dt: DateTime): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> Shorthand for <code>dt.inZone(local())</code>.   </dd>  <dt><pre data-language="nim">proc utc(t: Time): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> Shorthand for <code>t.inZone(utc())</code>.   </dd>  <dt><pre data-language="nim">proc local(t: Time): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> Shorthand for <code>t.inZone(local())</code>.   </dd>  <dt><pre data-language="nim">proc getTime(): Time {...}{.tags: [TimeEffect], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> Gets the current time as a <code>Time</code> with nanosecond resolution.   </dd>  <dt><pre data-language="nim">proc now(): DateTime {...}{.tags: [TimeEffect], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>Get the current time as a <code>DateTime</code> in the local timezone.</p> <p>Shorthand for <code>getTime().local</code>.</p>   </dd>  <dt><pre data-language="nim">proc initTimeInterval(nanoseconds, microseconds, milliseconds, seconds, minutes,
                     hours, days, weeks, months, years: int = 0): TimeInterval {...}{.
    raises: [], tags: [].}</pre></dt> <dd> <p>Creates a new <code>TimeInterval</code>.</p> <p>You can also use the convenience procedures called <code>milliseconds</code>, <code>seconds</code>, <code>minutes</code>, <code>hours</code>, <code>days</code>, <code>months</code>, and <code>years</code>. </p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let day = initTimeInterval(hours = 24)
let dt = initDateTime(1, mJan, 2000, 12, 0, 0, utc())
doAssert $(dt + day) == "2000-01-02T12:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc `+`(ti1, ti2: TimeInterval): TimeInterval {...}{.raises: [], tags: [].}</pre></dt> <dd> Adds two <code>TimeInterval</code> objects together.   </dd>  <dt><pre data-language="nim">proc `-`(ti: TimeInterval): TimeInterval {...}{.raises: [], tags: [].}</pre></dt> <dd> Reverses a time interval <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let day = -initTimeInterval(hours = 24)
doAssert day.hours == -24</pre>   </dd>  <dt><pre data-language="nim">proc `-`(ti1, ti2: TimeInterval): TimeInterval {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Subtracts TimeInterval <code>ti1</code> from <code>ti2</code>.</p> <p>Time components are subtracted one-by-one, see output:</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let ti1 = initTimeInterval(hours = 24)
let ti2 = initTimeInterval(hours = 4)
doAssert (ti1 - ti2) == initTimeInterval(hours = 20)</pre>   </dd>  <dt><pre data-language="nim">proc getDateStr(): string {...}{.gcsafe, extern: "nt$1", tags: [TimeEffect], raises: [].}</pre></dt> <dd> Gets the current date as a string of the format <code>YYYY-MM-DD</code>.   </dd>  <dt><pre data-language="nim">proc getClockStr(): string {...}{.gcsafe, extern: "nt$1", tags: [TimeEffect], raises: [].}</pre></dt> <dd> Gets the current clock time as a string of the format <code>HH:MM:SS</code>.   </dd>  <dt><pre data-language="nim">proc toParts(ti: TimeInterval): TimeIntervalParts {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Converts a <em>TimeInterval</em> into an array consisting of its time units, starting with nanoseconds and ending with years</p> <p>This procedure is useful for converting <code>TimeInterval</code> values to strings. E.g. then you need to implement custom interval printing</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var tp = toParts(initTimeInterval(years = 1, nanoseconds = 123))
doAssert tp[Years] == 1
doAssert tp[Nanoseconds] == 123</pre>   </dd>  <dt><pre data-language="nim">proc `$`(ti: TimeInterval): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Get string representation of <em>TimeInterval</em> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">doAssert $initTimeInterval(years = 1, nanoseconds = 123) ==
    "1 year and 123 nanoseconds"
doAssert $initTimeInterval() == "0 nanoseconds"</pre>   </dd>  <dt><pre data-language="nim">proc nanoseconds(nanos: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> TimeInterval of <code>nanos</code> nanoseconds.   </dd>  <dt><pre data-language="nim">proc microseconds(micros: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> TimeInterval of <code>micros</code> microseconds.   </dd>  <dt><pre data-language="nim">proc milliseconds(ms: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> TimeInterval of <code>ms</code> milliseconds.   </dd>  <dt><pre data-language="nim">proc seconds(s: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>TimeInterval of <code>s</code> seconds.</p> <p><code>echo getTime() + 5.second</code></p>   </dd>  <dt><pre data-language="nim">proc minutes(m: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>TimeInterval of <code>m</code> minutes.</p> <p><code>echo getTime() + 5.minutes</code></p>   </dd>  <dt><pre data-language="nim">proc hours(h: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>TimeInterval of <code>h</code> hours.</p> <p><code>echo getTime() + 2.hours</code></p>   </dd>  <dt><pre data-language="nim">proc days(d: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>TimeInterval of <code>d</code> days.</p> <p><code>echo getTime() + 2.days</code></p>   </dd>  <dt><pre data-language="nim">proc weeks(w: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>TimeInterval of <code>w</code> weeks.</p> <p><code>echo getTime() + 2.weeks</code></p>   </dd>  <dt><pre data-language="nim">proc months(m: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>TimeInterval of <code>m</code> months.</p> <p><code>echo getTime() + 2.months</code></p>   </dd>  <dt><pre data-language="nim">proc years(y: int): TimeInterval {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>TimeInterval of <code>y</code> years.</p> <p><code>echo getTime() + 2.years</code></p>   </dd>  <dt><pre data-language="nim">proc initDateTime(monthday: MonthdayRange; month: Month; year: int; hour: HourRange;
                 minute: MinuteRange; second: SecondRange;
                 nanosecond: NanosecondRange; zone: Timezone = local()): DateTime {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Create a new <code>DateTime</code> in the specified timezone. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt1 = initDateTime(30, mMar, 2017, 0, 0, 0, 0, utc())
doAssert $dt1 == "2017-03-30T00:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc initDateTime(monthday: MonthdayRange; month: Month; year: int; hour: HourRange;
                 minute: MinuteRange; second: SecondRange; zone: Timezone = local()): DateTime {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Create a new <code>DateTime</code> in the specified timezone. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt1 = initDateTime(30, mMar, 2017, 0, 0, 0, utc())
doAssert $dt1 == "2017-03-30T00:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc `+`(dt: DateTime; interval: TimeInterval): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Adds <code>interval</code> to <code>dt</code>. Components from <code>interval</code> are added in the order of their size, i.e first the <code>years</code> component, then the <code>months</code> component and so on. The returned <code>DateTime</code> will have the same timezone as the input.</p> <p>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to <em>31 October</em> will result in <em>31 November</em>, which will overflow and result in <em>1 December</em>. </p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(30, mMar, 2017, 0, 0, 0, utc())
doAssert $(dt + 1.months) == "2017-04-30T00:00:00Z"
doAssert $(dt - 1.months) == "2017-03-02T00:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc `-`(dt: DateTime; interval: TimeInterval): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> Subtract <code>interval</code> from <code>dt</code>. Components from <code>interval</code> are subtracted in the order of their size, i.e first the <code>years</code> component, then the <code>months</code> component and so on. The returned <code>DateTime</code> will have the same timezone as the input. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(30, mMar, 2017, 0, 0, 0, utc())
doAssert $(dt - 5.days) == "2017-03-25T00:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc `+`(dt: DateTime; dur: Duration): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(30, mMar, 2017, 0, 0, 0, utc())
let dur = initDuration(hours = 5)
doAssert $(dt + dur) == "2017-03-30T05:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc `-`(dt: DateTime; dur: Duration): DateTime {...}{.raises: [], tags: [].}</pre></dt> <dd> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(30, mMar, 2017, 0, 0, 0, utc())
let dur = initDuration(days = 5)
doAssert $(dt - dur) == "2017-03-25T00:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc `-`(dt1, dt2: DateTime): Duration {...}{.raises: [], tags: [].}</pre></dt> <dd> Compute the duration between <code>dt1</code> and <code>dt2</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt1 = initDateTime(30, mMar, 2017, 0, 0, 0, utc())
let dt2 = initDateTime(25, mMar, 2017, 0, 0, 0, utc())
doAssert dt1 - dt2 == initDuration(days = 5)</pre>   </dd>  <dt><pre data-language="nim">proc `&lt;`(a, b: DateTime): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>a &lt; b</code>, that is iff a happened before b.   </dd>  <dt><pre data-language="nim">proc `&lt;=`(a, b: DateTime): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>a &lt;= b</code>.   </dd>  <dt><pre data-language="nim">proc `==`(a, b: DateTime): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns true if <code>a == b</code>, that is if both dates represent the same point in time.   </dd>  <dt><pre data-language="nim">proc between(startDt, endDt: DateTime): TimeInterval {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Evaluate difference between two dates in <code>TimeInterval</code> format, so, it will be relative.</p> <p><strong>Warning:</strong> It's not recommended to use <code>between</code> for <code>DateTime's</code> in different <code>TimeZone's</code>. <code>a + between(a, b) == b</code> is only guaranteed when <code>a</code> and <code>b</code> are in UTC.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var a = initDateTime(year = 2018, month = Month(3), monthday = 25, hour = 0, minute = 59,
                  second = 59, nanosecond = 1, zone = utc()).local
var b = initDateTime(year = 2018, month = Month(3), monthday = 25, hour = 1, minute = 1,
                  second = 1, nanosecond = 0, zone = utc()).local
doAssert between(a, b) ==
    initTimeInterval(nanoseconds = 999, milliseconds = 999, microseconds = 999,
                     seconds = 1, minutes = 1)
a = parse("2018-01-09T00:00:00+00:00", "yyyy-MM-dd\'T\'HH:mm:sszzz", utc())
b = parse("2018-01-10T23:00:00-02:00", "yyyy-MM-dd\'T\'HH:mm:sszzz")
doAssert between(a, b) == initTimeInterval(hours = 1, days = 2)
## Though, here correct answer should be 1 day 25 hours (cause this day in
## this tz is actually 26 hours). That's why operating different TZ is
## discouraged</pre>   </dd>  <dt><pre data-language="nim">proc `+`(time: Time; interval: TimeInterval): Time {...}{.raises: [], tags: [].}</pre></dt> <dd> Adds <em>interval</em> to <em>time</em>. If <em>interval</em> contains any years, months, weeks or days the operation is performed in the local timezone. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let tm = fromUnix(0)
doAssert tm + 5.seconds == fromUnix(5)</pre>   </dd>  <dt><pre data-language="nim">proc `-`(time: Time; interval: TimeInterval): Time {...}{.raises: [], tags: [].}</pre></dt> <dd> Subtracts <em>interval</em> from Time <em>time</em>. If <em>interval</em> contains any years, months, weeks or days the operation is performed in the local timezone. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let tm = fromUnix(5)
doAssert tm - 5.seconds == fromUnix(0)</pre>   </dd>  <dt><pre data-language="nim">proc `+=`[T, U: TimesMutableTypes](a: var T; b: U)</pre></dt> <dd> Modify <code>a</code> in place by adding <code>b</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var tm = fromUnix(0)
tm += initDuration(seconds = 1)
doAssert tm == fromUnix(1)</pre>   </dd>  <dt><pre data-language="nim">proc `-=`[T, U: TimesMutableTypes](a: var T; b: U)</pre></dt> <dd> Modify <code>a</code> in place by subtracting <code>b</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var tm = fromUnix(5)
tm -= initDuration(seconds = 5)
doAssert tm == fromUnix(0)</pre>   </dd>  <dt><pre data-language="nim">proc `*=`[T: TimesMutableTypes; U](a: var T; b: U)</pre></dt> <dd> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var dur = initDuration(seconds = 1)
dur *= 5
doAssert dur == initDuration(seconds = 5)</pre>   </dd>  <dt><pre data-language="nim">proc `$`(f: TimeFormat): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the format string that was used to construct <code>f</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let f = initTimeFormat("yyyy-MM-dd")
doAssert $f == "yyyy-MM-dd"</pre>   </dd>  <dt><pre data-language="nim">proc initTimeFormat(format: string): TimeFormat {...}{.raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Construct a new time format for parsing &amp; formatting time types.</p> <p>See <a href="#parsing-and-formatting-dates">Parsing and formatting dates</a> for documentation of the <code>format</code> argument.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let f = initTimeFormat("yyyy-MM-dd")
doAssert "2000-01-01" == "2000-01-01".parse(f).format(f)</pre>   </dd>  <dt><pre data-language="nim">proc format(dt: DateTime; f: TimeFormat): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Format <code>dt</code> using the format specified by <code>f</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let f = initTimeFormat("yyyy-MM-dd")
let dt = initDateTime(1, mJan, 2000, 0, 0, 0, utc())
doAssert "2000-01-01" == dt.format(f)</pre>   </dd>  <dt><pre data-language="nim">proc format(dt: DateTime; f: string): string {...}{.raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Shorthand for constructing a <code>TimeFormat</code> and using it to format <code>dt</code>.</p> <p>See <a href="#parsing-and-formatting-dates">Parsing and formatting dates</a> for documentation of the <code>format</code> argument.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(1, mJan, 2000, 0, 0, 0, utc())
doAssert "2000-01-01" == format(dt, "yyyy-MM-dd")</pre>   </dd>  <dt><pre data-language="nim">proc format(dt: DateTime; f: static[string]): string {...}{.raises: [].}</pre></dt> <dd> Overload that validates <code>format</code> at compile time.   </dd>  <dt><pre data-language="nim">proc format(time: Time; f: string; zone: Timezone = local()): string {...}{.tags: [],
    raises: [ValueError].}</pre></dt> <dd> <p>Shorthand for constructing a <code>TimeFormat</code> and using it to format <code>time</code>. Will use the timezone specified by <code>zone</code>.</p> <p>See <a href="#parsing-and-formatting-dates">Parsing and formatting dates</a> for documentation of the <code>f</code> argument.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var dt = initDateTime(1, mJan, 1970, 0, 0, 0, utc())
var tm = dt.toTime()
doAssert format(tm, "yyyy-MM-dd\'T\'HH:mm:ss", utc()) == "1970-01-01T00:00:00"</pre>   </dd>  <dt><pre data-language="nim">proc format(time: Time; f: static[string]; zone: Timezone = local()): string {...}{.tags: [].}</pre></dt> <dd> Overload that validates <code>f</code> at compile time.   </dd>  <dt><pre data-language="nim">proc parse(input: string; f: TimeFormat; zone: Timezone = local()): DateTime {...}{.
    raises: [ValueError, OverflowError, UnpackError], tags: [TimeEffect].}</pre></dt> <dd> Parses <code>input</code> as a <code>DateTime</code> using the format specified by <code>f</code>. If no UTC offset was parsed, then <code>input</code> is assumed to be specified in the <code>zone</code> timezone. If a UTC offset was parsed, the result will be converted to the <code>zone</code> timezone. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let f = initTimeFormat("yyyy-MM-dd")
let dt = initDateTime(1, mJan, 2000, 0, 0, 0, utc())
doAssert dt == "2000-01-01".parse(f, utc())</pre>   </dd>  <dt><pre data-language="nim">proc parse(input, f: string; tz: Timezone = local()): DateTime {...}{.
    raises: [ValueError, OverflowError, UnpackError], tags: [TimeEffect].}</pre></dt> <dd> <p>Shorthand for constructing a <code>TimeFormat</code> and using it to parse <code>input</code> as a <code>DateTime</code>.</p> <p>See <a href="#parsing-and-formatting-dates">Parsing and formatting dates</a> for documentation of the <code>f</code> argument.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(1, mJan, 2000, 0, 0, 0, utc())
doAssert dt == parse("2000-01-01", "yyyy-MM-dd", utc())</pre>   </dd>  <dt><pre data-language="nim">proc parse(input: string; f: static[string]; zone: Timezone = local()): DateTime</pre></dt> <dd> Overload that validates <code>f</code> at compile time.   </dd>  <dt><pre data-language="nim">proc parseTime(input, f: string; zone: Timezone): Time {...}{.
    raises: [ValueError, OverflowError, UnpackError], tags: [TimeEffect].}</pre></dt> <dd> <p>Shorthand for constructing a <code>TimeFormat</code> and using it to parse <code>input</code> as a <code>DateTime</code>, then converting it a <code>Time</code>.</p> <p>See <a href="#parsing-and-formatting-dates">Parsing and formatting dates</a> for documentation of the <code>format</code> argument.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let tStr = "1970-01-01T00:00:00+00:00"
doAssert parseTime(tStr, "yyyy-MM-dd\'T\'HH:mm:sszzz", utc()) == fromUnix(0)</pre>   </dd>  <dt><pre data-language="nim">proc parseTime(input: string; f: static[string]; zone: Timezone): Time</pre></dt> <dd> Overload that validates <code>format</code> at compile time.   </dd>  <dt><pre data-language="nim">proc `$`(dt: DateTime): string {...}{.tags: [], raises: [], gcsafe, locks: 0.}</pre></dt> <dd> Converts a <em>DateTime</em> object to a string representation. It uses the format <code>yyyy-MM-dd'T'HH-mm-sszzz</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(1, mJan, 2000, 12, 0, 0, utc())
doAssert $dt == "2000-01-01T12:00:00Z"</pre>   </dd>  <dt><pre data-language="nim">proc `$`(time: Time): string {...}{.tags: [], raises: [], gcsafe, locks: 0.}</pre></dt> <dd> converts a <em>Time</em> value to a string representation. It will use the local time zone and use the format <code>yyyy-MM-dd'T'HH-mm-sszzz</code>. <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let dt = initDateTime(1, mJan, 1970, 0, 0, 0, local())
let tm = dt.toTime()
doAssert $tm == "1970-01-01T00:00:00" &amp; format(dt, "zzz")</pre>   </dd>  <dt><pre data-language="nim">proc countLeapYears(yearSpan: int): int {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the number of leap years spanned by a given number of years.</p> <p><strong>Note:</strong> For leap years, start date is assumed to be 1 AD. counts the number of leap years up to January 1st of a given year. Keep in mind that if specified year is a leap year, the leap day has not happened before January 1st of that year.</p>   </dd>  <dt><pre data-language="nim">proc countDays(yearSpan: int): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the number of days spanned by a given number of years.   </dd>  <dt><pre data-language="nim">proc countYears(daySpan: int): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the number of years spanned by a given number of days.   </dd>  <dt><pre data-language="nim">proc countYearsAndDays(daySpan: int): tuple[years: int, days: int] {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the number of years spanned by a given number of days and the remainder as days.   </dd>  <dt><pre data-language="nim">proc toTimeInterval(time: Time): TimeInterval {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Converts a Time to a TimeInterval.</p> <p>To be used when diffing times. Consider using <em>between</em> instead.</p> <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">let a = fromUnix(10)
let b = fromUnix(1500000000)
let ti = b.toTimeInterval() - a.toTimeInterval()
doAssert a + ti == b</pre>   </dd>  <dt><pre data-language="nim">proc cpuTime(): float {...}{.gcsafe, extern: "nt$1", tags: [TimeEffect], raises: [].}</pre></dt> <dd> gets time spent that the CPU spent to run the current process in seconds. This may be more useful for benchmarking than <code>epochTime</code>. However, it may measure the real time instead (depending on the OS). The value of the result has no meaning. To generate useful timing values, take the difference between the results of two <code>cpuTime</code> calls: <p><strong class="examples_text">Examples:</strong></p> <pre class="listing" data-language="nim">var t0 = cpuTime()
var fib = @[0, 1, 1]
for i in 1 .. 10:
  fib.add(fib[^1] + fib[^2])
echo "CPU time [s] ", cpuTime() - t0
echo "Fib is [s] ", fib</pre>   </dd>  <dt><pre data-language="nim">proc epochTime(): float {...}{.gcsafe, extern: "nt$1", tags: [TimeEffect], raises: [].}</pre></dt> <dd> <p>gets time after the UNIX epoch (1970) in seconds. It is a float because sub-second resolution is likely to be supported (depending on the hardware/OS).</p> <p><code>getTime</code> should generally be prefered over this proc.</p>   </dd>  <dt><pre data-language="nim">proc unixTimeToWinTime(time: CTime): int64 {...}{.deprecated: "Use toWinTime instead",
    raises: [], tags: [].}</pre></dt> <dd> <p>Converts a UNIX <em>Time</em> (<code>time_t</code>) to a Windows file time</p> <p><strong>Deprecated:</strong> use <code>toWinTime</code> instead.</p>   </dd>  <dt><pre data-language="nim">proc winTimeToUnixTime(time: int64): CTime {...}{.deprecated: "Use fromWinTime instead",
    raises: [], tags: [].}</pre></dt> <dd> <p>Converts a Windows time to a UNIX <em>Time</em> (<code>time_t</code>)</p> <p><strong>Deprecated:</strong> use <code>fromWinTime</code> instead.</p>   </dd>  <dt><pre data-language="nim">proc initInterval(seconds, minutes, hours, days, months, years: int = 0): TimeInterval {...}{.
    deprecated, raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.18.0:</strong> use <code>initTimeInterval</code> instead.   </dd>  <dt><pre data-language="nim">proc fromSeconds(since1970: float): Time {...}{.tags: [], raises: [], gcsafe, locks: 0,
                                       deprecated.}</pre></dt> <dd> <p>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</p> <p><strong>Deprecated since v0.18.0:</strong> use <code>fromUnix</code> instead</p>   </dd>  <dt><pre data-language="nim">proc fromSeconds(since1970: int64): Time {...}{.tags: [], raises: [], gcsafe, locks: 0,
                                       deprecated.}</pre></dt> <dd> <p>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</p> <p><strong>Deprecated since v0.18.0:</strong> use <code>fromUnix</code> instead</p>   </dd>  <dt><pre data-language="nim">proc toSeconds(time: Time): float {...}{.tags: [], raises: [], gcsafe, locks: 0, deprecated.}</pre></dt> <dd> <p>Returns the time in seconds since the unix epoch.</p> <p><strong>Deprecated since v0.18.0:</strong> use <code>toUnix</code> instead</p>   </dd>  <dt><pre data-language="nim">proc getLocalTime(time: Time): DateTime {...}{.tags: [], raises: [], gcsafe, locks: 0,
                                      deprecated.}</pre></dt> <dd> <p>Converts the calendar time <em>time</em> to broken-time representation, expressed relative to the user's specified time zone.</p> <p><strong>Deprecated since v0.18.0:</strong> use <code>local</code> instead</p>   </dd>  <dt><pre data-language="nim">proc getGMTime(time: Time): DateTime {...}{.tags: [], raises: [], gcsafe, locks: 0, deprecated.}</pre></dt> <dd> <p>Converts the calendar time <em>time</em> to broken-down time representation, expressed in Coordinated Universal Time (UTC).</p> <p><strong>Deprecated since v0.18.0:</strong> use <code>utc</code> instead</p>   </dd>  <dt><pre data-language="nim">proc getTimezone(): int {...}{.tags: [TimeEffect], raises: [], gcsafe, locks: 0, deprecated.}</pre></dt> <dd> <p>Returns the offset of the local (non-DST) timezone in seconds west of UTC.</p> <p><strong>Deprecated since v0.18.0:</strong> use <code>now().utcOffset</code> to get the current utc offset (including DST).</p>   </dd>  <dt><pre data-language="nim">proc timeInfoToTime(dt: DateTime): Time {...}{.tags: [], gcsafe, locks: 0, deprecated,
                                      raises: [].}</pre></dt> <dd> <p>Converts a broken-down time structure to calendar time representation.</p> <p><strong>Deprecated since v0.14.0:</strong> use <code>toTime</code> instead.</p>   </dd>  <dt><pre data-language="nim">proc getStartMilsecs(): int {...}{.deprecated, tags: [TimeEffect], gcsafe, locks: 0,
                           raises: [].}</pre></dt> <dd> <p>get the milliseconds from the start of the program.</p> <p><strong>Deprecated since v0.8.10:</strong> use <code>epochTime</code> or <code>cpuTime</code> instead.</p>   </dd>  <dt><pre data-language="nim">proc timeToTimeInterval(t: Time): TimeInterval {...}{.deprecated, raises: [], tags: [].}</pre></dt> <dd> <p>Converts a Time to a TimeInterval.</p> <p><strong>Deprecated since v0.14.0:</strong> use <code>toTimeInterval</code> instead.</p>   </dd>  <dt><pre data-language="nim">proc getDayOfWeek(day, month, year: int): WeekDay {...}{.tags: [], raises: [], gcsafe, locks: 0,
    deprecated.}</pre></dt> <dd> <strong>Deprecated since v0.18.0:</strong> use <code>getDayOfWeek(monthday: MonthdayRange; month: Month; year: int)</code> instead.   </dd>  <dt><pre data-language="nim">proc getDayOfWeekJulian(day, month, year: int): WeekDay {...}{.deprecated, raises: [],
    tags: [].}</pre></dt> <dd> Returns the day of the week enum from day, month and year, according to the Julian calendar. <strong>Deprecated since v0.18.0</strong>   </dd>  <dt><pre data-language="nim">proc adjTime(zt: ZonedTime): Time {...}{.deprecated: "Use zt.time instead", raises: [],
                                tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.19.0:</strong> use the <code>time</code> field instead.   </dd>  <dt><pre data-language="nim">proc adjTime=(zt: var ZonedTime; adjTime: Time) {...}{.deprecated: "Use zt.time instead",
    raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.19.0:</strong> use the <code>time</code> field instead.   </dd>  <dt><pre data-language="nim">proc zoneInfoFromUtc(zone: Timezone; time: Time): ZonedTime {...}{.
    deprecated: "Use zonedTimeFromTime instead", raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.19.0:</strong> use <code>zonedTimeFromTime</code> instead.   </dd>  <dt><pre data-language="nim">proc zoneInfoFromTz(zone: Timezone; adjTime: Time): ZonedTime {...}{.
    deprecated: "Use zonedTimeFromAdjTime instead", raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.19.0:</strong> use the <code>zonedTimeFromAdjTime</code> instead.   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     20062018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/times.html" class="_attribution-link">https://nim-lang.org/docs/times.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
