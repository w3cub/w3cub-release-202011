
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Recurrent Neural Networks for Drawing Classification - TensorFlow Guide - W3cubDocs</title>
  
  <meta name="description" content=" Quick, Draw! is a game where a player is challenged to draw a number of objects and see if a computer can recognize the drawing. ">
  <meta name="keywords" content="recurrent, neural, networks, for, drawing, classification, tensorflow, guide, tensorflow~guide">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~guide/tutorials/recurrent_quickdraw.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/tensorflow~guide.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~guide/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Guide</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 itemprop="name" class="devsite-page-title"> Recurrent Neural Networks for Drawing Classification </h1>     <p><a href="http://quickdraw.withgoogle.com">Quick, Draw!</a> is a game where a player is challenged to draw a number of objects and see if a computer can recognize the drawing.</p> <p>The recognition in <a href="http://quickdraw.withgoogle.com">Quick, Draw!</a> is performed by a classifier that takes the user input, given as a sequence of strokes of points in x and y, and recognizes the object category that the user tried to draw.</p> <p>In this tutorial we'll show how to build an RNN-based recognizer for this problem. The model will use a combination of convolutional layers, LSTM layers, and a softmax output layer to classify the drawings:</p> 
<center> <img alt="RNN model structure" src="data:image/png;base64,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"> </center> <p>The figure above shows the structure of the model that we will build in this tutorial. The input is a drawing that is encoded as a sequence of strokes of points in x, y, and n, where n indicates whether a the point is the first point in a new stroke.</p> <p>Then, a series of 1-dimensional convolutions is applied. Then LSTM layers are applied and the sum of the outputs of all LSTM steps is fed into a softmax layer to make a classification decision among the classes of drawings that we know.</p> <p>This tutorial uses the data from actual <a href="http://quickdraw.withgoogle.com">Quick, Draw!</a> games <a href="https://quickdraw.withgoogle.com/data">that is publicly available</a>. This dataset contains of 50M drawings in 345 categories.</p> <h2 id="run_the_tutorial_code">Run the tutorial code</h2> <p>To try the code for this tutorial:</p> <ol> <li>
<a href="https://www.tensorflow.org/install/index">Install TensorFlow</a> if you haven't already.</li> <li>Download the <a href="https://github.com/tensorflow/models/tree/master/tutorials/rnn/quickdraw/train_model.py">tutorial code</a> .</li> <li> <p><a href="#download_the_data">Download the data</a> in <code>TFRecord</code> format from <a href="http://download.tensorflow.org/data/quickdraw_tutorial_dataset_v1.tar.gz">here</a> and unzip it. More details about <a href="#optional_download_the_full_quick_draw_data">how to obtain the original Quick, Draw! data</a> and <a href="#optional_converting_the_data">how to convert that to <code>TFRecord</code> files</a> is available below.</p> </li> <li> <p>Execute the tutorial code with the following command to train the RNN-based model described in this tutorial. Make sure to adjust the paths to point to the unzipped data from the download in step 3.</p> </li> </ol> <pre class="prettyprint lang-shell" data-language="cpp">python train_model.py \
  --training_data=rnn_tutorial_data/training.tfrecord-?????-of-????? \
  --eval_data=rnn_tutorial_data/eval.tfrecord-?????-of-????? \
  --classes_file=rnn_tutorial_data/training.tfrecord.classes
</pre> <h2 id="tutorial_details">Tutorial details</h2> <h3 id="download_the_data">Download the data</h3> <p>We make the data that we use in this tutorial available as <code>TFRecord</code> files containing <code>TFExamples</code>. You can download the data from here:</p> <p>http://download.tensorflow.org/data/quickdraw_tutorial_dataset_v1.tar.gz</p> <p>Alternatively you can download the original data in <code>ndjson</code> format from the Google cloud and convert it to the <code>TFRecord</code> files containing <code>TFExamples</code> yourself as described in the next section.</p> <h3 id="optional_download_the_full_quick_draw_data">Optional: Download the full Quick Draw Data</h3> <p>The full <a href="https://quickdraw.withgoogle.com">Quick, Draw!</a> <a href="https://quickdraw.withgoogle.com/data">dataset</a> is available on Google Cloud Storage as <a href="http://ndjson.org/">ndjson</a> files separated by category. You can <a href="https://console.cloud.google.com/storage/quickdraw_dataset">browse the list of files in Cloud Console</a>.</p> <p>To download the data we recommend using <a href="https://cloud.google.com/storage/docs/gsutil_install#install">gsutil</a> to download the entire dataset. Note that the original .ndjson files require downloading ~22GB.</p> <p>Then use the following command to check that your gsutil installation works and that you can access the data bucket:</p> <pre class="prettyprint lang-shell" data-language="cpp">gsutil ls -r "gs://quickdraw_dataset/full/simplified/*"
</pre> <p>which will output a long list of files like the following:</p> <pre class="prettyprint lang-shell" data-language="cpp">gs://quickdraw_dataset/full/simplified/The Eiffel Tower.ndjson
gs://quickdraw_dataset/full/simplified/The Great Wall of China.ndjson
gs://quickdraw_dataset/full/simplified/The Mona Lisa.ndjson
gs://quickdraw_dataset/full/simplified/aircraft carrier.ndjson
...
</pre> <p>Then create a folder and download the dataset there.</p> <pre class="prettyprint lang-shell" data-language="cpp">mkdir rnn_tutorial_data
cd rnn_tutorial_data
gsutil -m cp "gs://quickdraw_dataset/full/simplified/*" .
</pre> <p>This download will take a while and download a bit more than 23GB of data.</p> <h3 id="optional_converting_the_data">Optional: Converting the data</h3> <p>To convert the <code>ndjson</code> files to <a href="https://www.tensorflow.org/api_guides/python/python_io#TFRecords_Format_Details">TFRecord</a> files containing <a href="https://www.tensorflow.org/api_docs/python/tf/train/Example"><code>tf.train.Example</code></a> protos run the following command.</p> <pre class="prettyprint lang-shell" data-language="cpp">python create_dataset.py --ndjson_path rnn_tutorial_data \
   --output_path rnn_tutorial_data
</pre> <p>This will store the data in 10 shards of <a href="https://www.tensorflow.org/api_guides/python/python_io#TFRecords_Format_Details">TFRecord</a> files with 10000 items per class for the training data and 1000 items per class as eval data.</p> <p>This conversion process is described in more detail in the following.</p> <p>The original QuickDraw data is formatted as <code>ndjson</code> files where each line contains a JSON object like the following:</p> <pre class="prettyprint lang-json" data-language="cpp">{"word":"cat",
 "countrycode":"VE",
 "timestamp":"2017-03-02 23:25:10.07453 UTC",
 "recognized":true,
 "key_id":"5201136883597312",
 "drawing":[
   [
     [130,113,99,109,76,64,55,48,48,51,59,86,133,154,170,203,214,217,215,208,186,176,162,157,132],
     [72,40,27,79,82,88,100,120,134,152,165,184,189,186,179,152,131,114,100,89,76,0,31,65,70]
   ],[
     [76,28,7],
     [136,128,128]
   ],[
     [76,23,0],
     [160,164,175]
   ],[
     [87,52,37],
     [175,191,204]
   ],[
     [174,220,246,251],
     [134,132,136,139]
   ],[
     [175,255],
     [147,168]
   ],[
     [171,208,215],
     [164,198,210]
   ],[
     [130,110,108,111,130,139,139,119],
     [129,134,137,144,148,144,136,130]
   ],[
     [107,106],
     [96,113]
   ]
 ]
}
</pre> <p>For our purpose of building a classifier we only care about the fields "<code>word</code>" and "<code>drawing</code>". While parsing the ndjson files, we process them line by line using a function that converts the strokes from the <code>drawing</code> field into a tensor of size <code>[number of points, 3]</code> containing the differences of consecutive points. This function also returns the class name as a string.</p> <pre class="prettyprint lang-python" data-language="python">def parse_line(ndjson_line):
  """Parse an ndjson line and return ink (as np array) and classname."""
  sample = json.loads(ndjson_line)
  class_name = sample["word"]
  inkarray = sample["drawing"]
  stroke_lengths = [len(stroke[0]) for stroke in inkarray]
  total_points = sum(stroke_lengths)
  np_ink = np.zeros((total_points, 3), dtype=np.float32)
  current_t = 0
  for stroke in inkarray:
    for i in [0, 1]:
      np_ink[current_t:(current_t + len(stroke[0])), i] = stroke[i]
    current_t += len(stroke[0])
    np_ink[current_t - 1, 2] = 1  # stroke_end
  # Preprocessing.
  # 1. Size normalization.
  lower = np.min(np_ink[:, 0:2], axis=0)
  upper = np.max(np_ink[:, 0:2], axis=0)
  scale = upper - lower
  scale[scale == 0] = 1
  np_ink[:, 0:2] = (np_ink[:, 0:2] - lower) / scale
  # 2. Compute deltas.
  np_ink = np_ink[1:, 0:2] - np_ink[0:-1, 0:2]
  return np_ink, class_name
</pre> <p>Since we want the data to be shuffled for writing we read from each of the category files in random order and write to a random shard.</p> <p>For the training data we read the first 10000 items for each class and for the eval data we read the next 1000 items for each class.</p> <p>This data is then reformatted into a tensor of shape <code>[num_training_samples, max_length, 3]</code>. Then we determine the bounding box of the original drawing in screen coordinates and normalize the size such that the drawing has unit height.</p> 
<center> <img alt="Size normalization" src="data:image/png;base64,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"> </center> <p>Finally, we compute the differences between consecutive points and store these as a <code>VarLenFeature</code> in a <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/core/example/example.proto">tensorflow.Example</a> under the key <code>ink</code>. In addition we store the <code>class_index</code> as a single entry <code>FixedLengthFeature</code> and the <code>shape</code> of the <code>ink</code> as a <code>FixedLengthFeature</code> of length 2.</p> <h3 id="defining_the_model">Defining the model</h3> <p>To define the model we create a new <code>Estimator</code>. If you want to read more about estimators, we recommend <a href="../get_started/custom_estimators">this tutorial</a>.</p> <p>To build the model, we:</p> <ol> <li> <p>reshape the input back into the original shape - where the mini batch is padded to the maximal length of its contents. In addition to the ink data we also have the lengths for each example and the target class. This happens in the function <a href="#_get_input_tensors"><code>_get_input_tensors</code></a>.</p> </li> <li> <p>pass the input through to a series of convolution layers in <a href="#_add_conv_layers"><code>_add_conv_layers</code></a>.</p> </li> <li> <p>pass the output of the convolutions into a series of bidirectional LSTM layers in <a href="#_add_rnn_layers"><code>_add_rnn_layers</code></a>. At the end of that, the outputs for each time step are summed up to have a compact, fixed length embedding of the input.</p> </li> <li> <p>classify this embedding using a softmax layer in <a href="#_add_fc_layers"><code>_add_fc_layers</code></a>.</p> </li> </ol> <p>In code this looks like:</p> <pre class="prettyprint lang-python" data-language="python">inks, lengths, targets = _get_input_tensors(features, targets)
convolved = _add_conv_layers(inks)
final_state = _add_rnn_layers(convolved, lengths)
logits =_add_fc_layers(final_state)
</pre> <h3 id="_get_input_tensors">_get_input_tensors</h3> <p>To obtain the input features we first obtain the shape from the features dict and then create a 1D tensor of size <code>[batch_size]</code> containing the lengths of the input sequences. The ink is stored as a SparseTensor in the features dict which we convert into a dense tensor and then reshape to be <code>[batch_size, ?, 3]</code>. And finally, if targets were passed in we make sure they are stored as a 1D tensor of size <code>[batch_size]</code></p> <p>In code this looks like this:</p> <pre class="prettyprint lang-python" data-language="python">shapes = features["shape"]
lengths = tf.squeeze(
    tf.slice(shapes, begin=[0, 0], size=[params["batch_size"], 1]))
inks = tf.reshape(
    tf.sparse_tensor_to_dense(features["ink"]),
    [params["batch_size"], -1, 3])
if targets is not None:
  targets = tf.squeeze(targets)
</pre> <h3 id="_add_conv_layers">_add_conv_layers</h3> <p>The desired number of convolution layers and the lengths of the filters is configured through the parameters <code>num_conv</code> and <code>conv_len</code> in the <code>params</code> dict.</p> <p>The input is a sequence where each point has dimensionality 3. We are going to use 1D convolutions where we treat the 3 input features as channels. That means that the input is a <code>[batch_size, length, 3]</code> tensor and the output will be a <code>[batch_size, length, number_of_filters]</code> tensor.</p> <pre class="prettyprint lang-python" data-language="python">convolved = inks
for i in range(len(params.num_conv)):
  convolved_input = convolved
  if params.batch_norm:
    convolved_input = tf.layers.batch_normalization(
        convolved_input,
        training=(mode == tf.estimator.ModeKeys.TRAIN))
  # Add dropout layer if enabled and not first convolution layer.
  if i &gt; 0 and params.dropout:
    convolved_input = tf.layers.dropout(
        convolved_input,
        rate=params.dropout,
        training=(mode == tf.estimator.ModeKeys.TRAIN))
  convolved = tf.layers.conv1d(
      convolved_input,
      filters=params.num_conv[i],
      kernel_size=params.conv_len[i],
      activation=None,
      strides=1,
      padding="same",
      name="conv1d_%d" % i)
return convolved, lengths
</pre> <h3 id="_add_rnn_layers">_add_rnn_layers</h3> <p>We pass the output from the convolutions into bidirectional LSTM layers for which we use a helper function from contrib.</p> <pre class="prettyprint lang-python" data-language="python">outputs, _, _ = contrib_rnn.stack_bidirectional_dynamic_rnn(
    cells_fw=[cell(params.num_nodes) for _ in range(params.num_layers)],
    cells_bw=[cell(params.num_nodes) for _ in range(params.num_layers)],
    inputs=convolved,
    sequence_length=lengths,
    dtype=tf.float32,
    scope="rnn_classification")
</pre> <p>see the code for more details and how to use <code>CUDA</code> accelerated implementations.</p> <p>To create a compact, fixed-length embedding, we sum up the output of the LSTMs. We first zero out the regions of the batch where the sequences have no data.</p> <pre class="prettyprint lang-python" data-language="python">mask = tf.tile(
    tf.expand_dims(tf.sequence_mask(lengths, tf.shape(outputs)[1]), 2),
    [1, 1, tf.shape(outputs)[2]])
zero_outside = tf.where(mask, outputs, tf.zeros_like(outputs))
outputs = tf.reduce_sum(zero_outside, axis=1)
</pre> <h3 id="_add_fc_layers">_add_fc_layers</h3> <p>The embedding of the input is passed into a fully connected layer which we then use as a softmax layer.</p> <pre class="prettyprint lang-python" data-language="python">tf.layers.dense(final_state, params.num_classes)
</pre> <h3 id="loss_predictions_and_optimizer">Loss, predictions, and optimizer</h3> <p>Finally, we need to add a loss, a training op, and predictions to create the <code>ModelFn</code>:</p> <pre class="prettyprint lang-python" data-language="python">cross_entropy = tf.reduce_mean(
    tf.nn.sparse_softmax_cross_entropy_with_logits(
        labels=targets, logits=logits))
# Add the optimizer.
train_op = tf.contrib.layers.optimize_loss(
    loss=cross_entropy,
    global_step=tf.train.get_global_step(),
    learning_rate=params.learning_rate,
    optimizer="Adam",
    # some gradient clipping stabilizes training in the beginning.
    clip_gradients=params.gradient_clipping_norm,
    summaries=["learning_rate", "loss", "gradients", "gradient_norm"])
predictions = tf.argmax(logits, axis=1)
return model_fn_lib.ModelFnOps(
    mode=mode,
    predictions={"logits": logits,
                 "predictions": predictions},
    loss=cross_entropy,
    train_op=train_op,
    eval_metric_ops={"accuracy": tf.metrics.accuracy(targets, predictions)})
</pre> <h3 id="training_and_evaluating_the_model">Training and evaluating the model</h3> <p>To train and evaluate the model we can rely on the functionalities of the <code>Estimator</code> APIs and easily run training and evaluation with the <code>Experiment</code> APIs:</p> <pre class="prettyprint lang-python" data-language="python">estimator = tf.estimator.Estimator(
    model_fn=model_fn,
    model_dir=output_dir,
    config=config,
    params=model_params)
# Train the model.
tf.contrib.learn.Experiment(
    estimator=estimator,
    train_input_fn=get_input_fn(
        mode=tf.contrib.learn.ModeKeys.TRAIN,
        tfrecord_pattern=FLAGS.training_data,
        batch_size=FLAGS.batch_size),
    train_steps=FLAGS.steps,
    eval_input_fn=get_input_fn(
        mode=tf.contrib.learn.ModeKeys.EVAL,
        tfrecord_pattern=FLAGS.eval_data,
        batch_size=FLAGS.batch_size),
    min_eval_frequency=1000)
</pre> <p>Note that this tutorial is just a quick example on a relatively small dataset to get you familiar with the APIs of recurrent neural networks and estimators. Such models can be even more powerful if you try them on a large dataset.</p> <p>When training the model for 1M steps you can expect to get an accuracy of approximately of approximately 70% on the top-1 candidate. Note that this accuracy is sufficient to build the quickdraw game because of the game dynamics the user will be able to adjust their drawing until it is ready. Also, the game does not use the top-1 candidate only but accepts a drawing as correct if the target category shows up with a score better than a fixed threshold.</p>
<div class="_attribution">
  <p class="_attribution-p">
     2018 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/tutorials/recurrent_quickdraw" class="_attribution-link">https://www.tensorflow.org/tutorials/recurrent_quickdraw</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
