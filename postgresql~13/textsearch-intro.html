
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Full Text Search - PostgreSQL 13 - W3cubDocs</title>
  
  <meta name="description" content="Full Text Searching (or just text search) provides the capability to identify natural-language documents that satisfy a query, and optionally to &hellip;">
  <meta name="keywords" content="introduction, full, text, search, postgresql, postgresql~13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/postgresql~13/textsearch-intro.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/postgresql~13.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~13/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 13</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _postgres">
				
				
<h1>12.1. Introduction</h1>    <div class="toc"> <dl class="toc"> <dt><a href="textsearch-intro#TEXTSEARCH-DOCUMENT">12.1.1. What Is a Document?</a></dt> <dt><a href="textsearch-intro#TEXTSEARCH-MATCHING">12.1.2. Basic Text Matching</a></dt> <dt><a href="textsearch-intro#TEXTSEARCH-INTRO-CONFIGURATIONS">12.1.3. Configurations</a></dt> </dl> </div> <p>Full Text Searching (or just <em class="firstterm">text search</em>) provides the capability to identify natural-language <em class="firstterm">documents</em> that satisfy a <em class="firstterm">query</em>, and optionally to sort them by relevance to the query. The most common type of search is to find all documents containing given <em class="firstterm">query terms</em> and return them in order of their <em class="firstterm">similarity</em> to the query. Notions of <code class="varname">query</code> and <code class="varname">similarity</code> are very flexible and depend on the specific application. The simplest search considers <code class="varname">query</code> as a set of words and <code class="varname">similarity</code> as the frequency of query words in the document.</p> <p>Textual search operators have existed in databases for years. PostgreSQL has <code class="literal">~</code>, <code class="literal">~*</code>, <code class="literal">LIKE</code>, and <code class="literal">ILIKE</code> operators for textual data types, but they lack many essential properties required by modern information systems:</p>  <ul> <li> <p>There is no linguistic support, even for English. Regular expressions are not sufficient because they cannot easily handle derived words, e.g., <code class="literal">satisfies</code> and <code class="literal">satisfy</code>. You might miss documents that contain <code class="literal">satisfies</code>, although you probably would like to find them when searching for <code class="literal">satisfy</code>. It is possible to use <code class="literal">OR</code> to search for multiple derived forms, but this is tedious and error-prone (some words can have several thousand derivatives).</p> </li> <li> <p>They provide no ordering (ranking) of search results, which makes them ineffective when thousands of matching documents are found.</p> </li> <li> <p>They tend to be slow because there is no index support, so they must process all documents for every search.</p> </li> </ul>  <p>Full text indexing allows documents to be <span class="emphasis"><em>preprocessed</em></span> and an index saved for later rapid searching. Preprocessing includes:</p>  <ul> <li> <p><span class="emphasis"><em>Parsing documents into <em class="firstterm">tokens</em></em></span>. It is useful to identify various classes of tokens, e.g., numbers, words, complex words, email addresses, so that they can be processed differently. In principle token classes depend on the specific application, but for most purposes it is adequate to use a predefined set of classes. PostgreSQL uses a <em class="firstterm">parser</em> to perform this step. A standard parser is provided, and custom parsers can be created for specific needs.</p> </li> <li> <p><span class="emphasis"><em>Converting tokens into <em class="firstterm">lexemes</em></em></span>. A lexeme is a string, just like a token, but it has been <em class="firstterm">normalized</em> so that different forms of the same word are made alike. For example, normalization almost always includes folding upper-case letters to lower-case, and often involves removal of suffixes (such as <code class="literal">s</code> or <code class="literal">es</code> in English). This allows searches to find variant forms of the same word, without tediously entering all the possible variants. Also, this step typically eliminates <em class="firstterm">stop words</em>, which are words that are so common that they are useless for searching. (In short, then, tokens are raw fragments of the document text, while lexemes are words that are believed useful for indexing and searching.) PostgreSQL uses <em class="firstterm">dictionaries</em> to perform this step. Various standard dictionaries are provided, and custom ones can be created for specific needs.</p> </li> <li> <p><span class="emphasis"><em>Storing preprocessed documents optimized for searching</em></span>. For example, each document can be represented as a sorted array of normalized lexemes. Along with the lexemes it is often desirable to store positional information to use for <em class="firstterm">proximity ranking</em>, so that a document that contains a more <span class="quote">“<span class="quote">dense</span>”</span> region of query words is assigned a higher rank than one with scattered query words.</p> </li> </ul>  <p>Dictionaries allow fine-grained control over how tokens are normalized. With appropriate dictionaries, you can:</p>  <ul> <li> <p>Define stop words that should not be indexed.</p> </li> <li> <p>Map synonyms to a single word using Ispell.</p> </li> <li> <p>Map phrases to a single word using a thesaurus.</p> </li> <li> <p>Map different variations of a word to a canonical form using an Ispell dictionary.</p> </li> <li> <p>Map different variations of a word to a canonical form using Snowball stemmer rules.</p> </li> </ul>  <p>A data type <code class="type">tsvector</code> is provided for storing preprocessed documents, along with a type <code class="type">tsquery</code> for representing processed queries (<a class="xref" href="datatype-textsearch" title="8.11. Text Search Types">Section 8.11</a>). There are many functions and operators available for these data types (<a class="xref" href="functions-textsearch" title="9.13. Text Search Functions and Operators">Section 9.13</a>), the most important of which is the match operator <code class="literal">@@</code>, which we introduce in <a class="xref" href="textsearch-intro#TEXTSEARCH-MATCHING" title="12.1.2. Basic Text Matching">Section 12.1.2</a>. Full text searches can be accelerated using indexes (<a class="xref" href="textsearch-indexes" title="12.9. GIN and GiST Index Types">Section 12.9</a>).</p> <div class="sect2" id="id-1.5.11.4.10.2">    <h2 class="title">12.1.1. What Is a Document?</h2>    <p>A <em class="firstterm">document</em> is the unit of searching in a full text search system; for example, a magazine article or email message. The text search engine must be able to parse documents and store associations of lexemes (key words) with their parent document. Later, these associations are used to search for documents that contain query words.</p> <p>For searches within PostgreSQL, a document is normally a textual field within a row of a database table, or possibly a combination (concatenation) of such fields, perhaps stored in several tables or obtained dynamically. In other words, a document can be constructed from different parts for indexing and it might not be stored anywhere as a whole. For example:</p> <pre data-language="sql">
SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body AS document
FROM messages
WHERE mid = 12;

SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body AS document
FROM messages m, docs d
WHERE m.mid = d.did AND m.mid = 12;
</pre> <blockquote class="note"> <h3 class="title">Note</h3> <p>Actually, in these example queries, <code class="function">coalesce</code> should be used to prevent a single <code class="literal">NULL</code> attribute from causing a <code class="literal">NULL</code> result for the whole document.</p> </blockquote> <p>Another possibility is to store the documents as simple text files in the file system. In this case, the database can be used to store the full text index and to execute searches, and some unique identifier can be used to retrieve the document from the file system. However, retrieving files from outside the database requires superuser permissions or special function support, so this is usually less convenient than keeping all the data inside PostgreSQL. Also, keeping everything inside the database allows easy access to document metadata to assist in indexing and display.</p> <p>For text search purposes, each document must be reduced to the preprocessed <code class="type">tsvector</code> format. Searching and ranking are performed entirely on the <code class="type">tsvector</code> representation of a document — the original text need only be retrieved when the document has been selected for display to a user. We therefore often speak of the <code class="type">tsvector</code> as being the document, but of course it is only a compact representation of the full document.</p> </div> <div class="sect2" id="TEXTSEARCH-MATCHING">    <h2 class="title">12.1.2. Basic Text Matching</h2>    <p>Full text searching in PostgreSQL is based on the match operator <code class="literal">@@</code>, which returns <code class="literal">true</code> if a <code class="type">tsvector</code> (document) matches a <code class="type">tsquery</code> (query). It doesn't matter which data type is written first:</p> <pre data-language="sql">
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat &amp; rat'::tsquery;
 ?column?
----------
 t

SELECT 'fat &amp; cow'::tsquery @@ 'a fat cat sat on a mat and ate a fat rat'::tsvector;
 ?column?
----------
 f
</pre> <p>As the above example suggests, a <code class="type">tsquery</code> is not just raw text, any more than a <code class="type">tsvector</code> is. A <code class="type">tsquery</code> contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For syntax details see <a class="xref" href="datatype-textsearch#DATATYPE-TSQUERY" title="8.11.2. tsquery">Section 8.11.2</a>.) There are functions <code class="function">to_tsquery</code>, <code class="function">plainto_tsquery</code>, and <code class="function">phraseto_tsquery</code> that are helpful in converting user-written text into a proper <code class="type">tsquery</code>, primarily by normalizing words appearing in the text. Similarly, <code class="function">to_tsvector</code> is used to parse and normalize a document string. So in practice a text search match would look more like this:</p> <pre data-language="sql">
SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat &amp; rat');
 ?column? 
----------
 t
</pre> <p>Observe that this match would not succeed if written as</p> <pre data-language="sql">
SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat &amp; rat');
 ?column? 
----------
 f
</pre> <p>since here no normalization of the word <code class="literal">rats</code> will occur. The elements of a <code class="type">tsvector</code> are lexemes, which are assumed already normalized, so <code class="literal">rats</code> does not match <code class="literal">rat</code>.</p> <p>The <code class="literal">@@</code> operator also supports <code class="type">text</code> input, allowing explicit conversion of a text string to <code class="type">tsvector</code> or <code class="type">tsquery</code> to be skipped in simple cases. The variants available are:</p> <pre data-language="sql">
tsvector @@ tsquery
tsquery  @@ tsvector
text @@ tsquery
text @@ text
</pre> <p>The first two of these we saw already. The form <code class="type">text</code> <code class="literal">@@</code> <code class="type">tsquery</code> is equivalent to <code class="literal">to_tsvector(x) @@ y</code>. The form <code class="type">text</code> <code class="literal">@@</code> <code class="type">text</code> is equivalent to <code class="literal">to_tsvector(x) @@ plainto_tsquery(y)</code>.</p> <p>Within a <code class="type">tsquery</code>, the <code class="literal">&amp;</code> (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the <code class="literal">|</code> (OR) operator specifies that at least one of its arguments must appear, while the <code class="literal">!</code> (NOT) operator specifies that its argument must <span class="emphasis"><em>not</em></span> appear in order to have a match. For example, the query <code class="literal">fat &amp; ! rat</code> matches documents that contain <code class="literal">fat</code> but not <code class="literal">rat</code>.</p> <p>Searching for phrases is possible with the help of the <code class="literal">&lt;-&gt;</code> (FOLLOWED BY) <code class="type">tsquery</code> operator, which matches only if its arguments have matches that are adjacent and in the given order. For example:</p> <pre data-language="sql">
SELECT to_tsvector('fatal error') @@ to_tsquery('fatal &lt;-&gt; error');
 ?column? 
----------
 t

SELECT to_tsvector('error is not fatal') @@ to_tsquery('fatal &lt;-&gt; error');
 ?column? 
----------
 f
</pre> <p>There is a more general version of the FOLLOWED BY operator having the form <code class="literal">&lt;N&gt;</code>, where <code>N</code> is an integer standing for the difference between the positions of the matching lexemes. <code class="literal">&lt;1&gt;</code> is the same as <code class="literal">&lt;-&gt;</code>, while <code class="literal">&lt;2&gt;</code> allows exactly one other lexeme to appear between the matches, and so on. The <code class="literal">phraseto_tsquery</code> function makes use of this operator to construct a <code class="literal">tsquery</code> that can match a multi-word phrase when some of the words are stop words. For example:</p> <pre data-language="sql">
SELECT phraseto_tsquery('cats ate rats');
       phraseto_tsquery        
-------------------------------
 'cat' &lt;-&gt; 'ate' &lt;-&gt; 'rat'

SELECT phraseto_tsquery('the cats ate the rats');
       phraseto_tsquery        
-------------------------------
 'cat' &lt;-&gt; 'ate' &lt;2&gt; 'rat'
</pre> <p>A special case that's sometimes useful is that <code class="literal">&lt;0&gt;</code> can be used to require that two patterns match the same word.</p> <p>Parentheses can be used to control nesting of the <code class="type">tsquery</code> operators. Without parentheses, <code class="literal">|</code> binds least tightly, then <code class="literal">&amp;</code>, then <code class="literal">&lt;-&gt;</code>, and <code class="literal">!</code> most tightly.</p> <p>It's worth noticing that the AND/OR/NOT operators mean something subtly different when they are within the arguments of a FOLLOWED BY operator than when they are not, because within FOLLOWED BY the exact position of the match is significant. For example, normally <code class="literal">!x</code> matches only documents that do not contain <code class="literal">x</code> anywhere. But <code class="literal">!x &lt;-&gt; y</code> matches <code class="literal">y</code> if it is not immediately after an <code class="literal">x</code>; an occurrence of <code class="literal">x</code> elsewhere in the document does not prevent a match. Another example is that <code class="literal">x &amp; y</code> normally only requires that <code class="literal">x</code> and <code class="literal">y</code> both appear somewhere in the document, but <code class="literal">(x &amp; y) &lt;-&gt; z</code> requires <code class="literal">x</code> and <code class="literal">y</code> to match at the same place, immediately before a <code class="literal">z</code>. Thus this query behaves differently from <code class="literal">x &lt;-&gt; z &amp; y &lt;-&gt; z</code>, which will match a document containing two separate sequences <code class="literal">x z</code> and <code class="literal">y z</code>. (This specific query is useless as written, since <code class="literal">x</code> and <code class="literal">y</code> could not match at the same place; but with more complex situations such as prefix-match patterns, a query of this form could be useful.)</p> </div> <div class="sect2" id="TEXTSEARCH-INTRO-CONFIGURATIONS">    <h2 class="title">12.1.3. Configurations</h2>    <p>The above are all simple text search examples. As mentioned before, full text search functionality includes the ability to do many more things: skip indexing certain words (stop words), process synonyms, and use sophisticated parsing, e.g., parse based on more than just white space. This functionality is controlled by <em class="firstterm">text search configurations</em>. PostgreSQL comes with predefined configurations for many languages, and you can easily create your own configurations. (psql's <code class="command">\dF</code> command shows all available configurations.)</p> <p>During installation an appropriate configuration is selected and <a class="xref" href="runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG">default_text_search_config</a> is set accordingly in <code class="filename">postgresql.conf</code>. If you are using the same text search configuration for the entire cluster you can use the value in <code class="filename">postgresql.conf</code>. To use different configurations throughout the cluster but the same configuration within any one database, use <code class="command">ALTER DATABASE ... SET</code>. Otherwise, you can set <code class="varname">default_text_search_config</code> in each session.</p> <p>Each text search function that depends on a configuration has an optional <code class="type">regconfig</code> argument, so that the configuration to use can be specified explicitly. <code class="varname">default_text_search_config</code> is used only when this argument is omitted.</p> <p>To make it easier to build custom text search configurations, a configuration is built up from simpler database objects. PostgreSQL's text search facility provides four types of configuration-related database objects:</p>  <ul> <li> <p><em class="firstterm">Text search parsers</em> break documents into tokens and classify each token (for example, as words or numbers).</p> </li> <li> <p><em class="firstterm">Text search dictionaries</em> convert tokens to normalized form and reject stop words.</p> </li> <li> <p><em class="firstterm">Text search templates</em> provide the functions underlying dictionaries. (A dictionary simply specifies a template and a set of parameters for the template.)</p> </li> <li> <p><em class="firstterm">Text search configurations</em> select a parser and a set of dictionaries to use to normalize the tokens produced by the parser.</p> </li> </ul>  <p>Text search parsers and templates are built from low-level C functions; therefore it requires C programming ability to develop new ones, and superuser privileges to install one into a database. (There are examples of add-on parsers and templates in the <code class="filename">contrib/</code> area of the PostgreSQL distribution.) Since dictionaries and configurations just parameterize and connect together some underlying parsers and templates, no special privilege is needed to create a new dictionary or configuration. Examples of creating custom dictionaries and configurations appear later in this chapter.</p> </div>  <div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter">  <table summary="Navigation footer"> <tr> <td width="40%" align="left">
<a accesskey="p" href="https://www.postgresql.org/docs/13/textsearch.html" title="Chapter 12. Full Text Search">Prev</a> </td> <td width="20%" align="center"><a accesskey="u" href="https://www.postgresql.org/docs/13/textsearch.html" title="Chapter 12. Full Text Search">Up</a></td> <td width="40%" align="right"> <a accesskey="n" href="textsearch-tables" title="12.2. Tables and Indexes">Next</a>
</td> </tr> <tr> <td width="40%" align="left">Chapter 12. Full Text Search </td> <td width="20%" align="center"><a accesskey="h" href="https://www.postgresql.org/docs/13/index.html" title="PostgreSQL 13.1 Documentation">Home</a></td> <td width="40%" align="right"> 12.2. Tables and Indexes</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2020 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/13/textsearch-intro.html" class="_attribution-link">https://www.postgresql.org/docs/13/textsearch-intro.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
