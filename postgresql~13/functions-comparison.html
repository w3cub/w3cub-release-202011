
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Comparisons - PostgreSQL 13 - W3cubDocs</title>
  
  <meta name="description" content=" The usual comparison operators are available, as shown in Table 9.1. ">
  <meta name="keywords" content="comparison, functions, and, operators, comparisons, postgresql, postgresql~13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/postgresql~13/functions-comparison.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/postgresql~13.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~13/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 13</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _postgres">
				
				
<h1>9.2. Comparison Functions and Operators</h1>    <p>The usual comparison operators are available, as shown in <a class="xref" href="functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE" title="Table 9.1. Comparison Operators">Table 9.1</a>.</p> <div class="table" id="FUNCTIONS-COMPARISON-OP-TABLE"> <p class="title"><strong>Table 9.1. Comparison Operators</strong></p> <div class="table-contents"> <table class="table" summary="Comparison Operators"> <colgroup> <col> <col> </colgroup> <thead> <tr> <th>Operator</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>
<code>datatype</code> <code class="literal" id="60">&lt;</code> <code>datatype</code> → <code class="returnvalue">boolean</code>
</td> <td>Less than</td> </tr> <tr> <td>
<code>datatype</code> <code class="literal" id="62">&gt;</code> <code>datatype</code> → <code class="returnvalue">boolean</code>
</td> <td>Greater than</td> </tr> <tr> <td>
<code>datatype</code> <code class="literal" id="6061">&lt;=</code> <code>datatype</code> → <code class="returnvalue">boolean</code>
</td> <td>Less than or equal to</td> </tr> <tr> <td>
<code>datatype</code> <code class="literal" id="6261">&gt;=</code> <code>datatype</code> → <code class="returnvalue">boolean</code>
</td> <td>Greater than or equal to</td> </tr> <tr> <td>
<code>datatype</code> <code class="literal" id="61">=</code> <code>datatype</code> → <code class="returnvalue">boolean</code>
</td> <td>Equal</td> </tr> <tr> <td>
<code>datatype</code> <code class="literal" id="6062">&lt;&gt;</code> <code>datatype</code> → <code class="returnvalue">boolean</code>
</td> <td>Not equal</td> </tr> <tr> <td>
<code>datatype</code> <code class="literal" id="3361">!=</code> <code>datatype</code> → <code class="returnvalue">boolean</code>
</td> <td>Not equal</td> </tr> </tbody> </table> </div> </div> <blockquote class="note"> <h3 class="title">Note</h3> <p><code class="literal">&lt;&gt;</code> is the standard SQL notation for <span class="quote">“<span class="quote">not equal</span>”</span>. <code class="literal">!=</code> is an alias, which is converted to <code class="literal">&lt;&gt;</code> at a very early stage of parsing. Hence, it is not possible to implement <code class="literal">!=</code> and <code class="literal">&lt;&gt;</code> operators that do different things.</p> </blockquote> <p>These comparison operators are available for all built-in data types that have a natural ordering, including numeric, string, and date/time types. In addition, arrays, composite types, and ranges can be compared if their component data types are comparable.</p> <p>It is usually possible to compare values of related data types as well; for example <code class="type">integer</code> <code class="literal">&gt;</code> <code class="type">bigint</code> will work. Some cases of this sort are implemented directly by <span class="quote">“<span class="quote">cross-type</span>”</span> comparison operators, but if no such operator is available, the parser will coerce the less-general type to the more-general type and apply the latter's comparison operator.</p> <p>As shown above, all comparison operators are binary operators that return values of type <code class="type">boolean</code>. Thus, expressions like <code class="literal">1 &lt; 2 &lt; 3</code> are not valid (because there is no <code class="literal">&lt;</code> operator to compare a Boolean value with <code class="literal">3</code>). Use the <code class="literal">BETWEEN</code> predicates shown below to perform range tests.</p> <p>There are also some comparison predicates, as shown in <a class="xref" href="functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE" title="Table 9.2. Comparison Predicates">Table 9.2</a>. These behave much like operators, but have special syntax mandated by the SQL standard.</p> <div class="table" id="FUNCTIONS-COMPARISON-PRED-TABLE"> <p class="title"><strong>Table 9.2. Comparison Predicates</strong></p> <div class="table-contents"> <table class="table" summary="Comparison Predicates"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Predicate</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="between">BETWEEN</code> <code>datatype</code> <code class="literal">AND</code> <code>datatype</code> → <code class="returnvalue">boolean</code></p> <p>Between (inclusive of the range endpoints).</p> <p><code class="literal" id="232between32132and323">2 BETWEEN 1 AND 3</code> → <code class="returnvalue">t</code></p> <p><code class="literal" id="232between32332and321">2 BETWEEN 3 AND 1</code> → <code class="returnvalue">f</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="not32between">NOT BETWEEN</code> <code>datatype</code> <code class="literal">AND</code> <code>datatype</code> → <code class="returnvalue">boolean</code></p> <p>Not between (the negation of <code class="literal" id="between">BETWEEN</code>).</p> <p><code class="literal" id="232not32between32132and323">2 NOT BETWEEN 1 AND 3</code> → <code class="returnvalue">f</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="between32symmetric">BETWEEN SYMMETRIC</code> <code>datatype</code> <code class="literal">AND</code> <code>datatype</code> → <code class="returnvalue">boolean</code></p> <p>Between, after sorting the two endpoint values.</p> <p><code class="literal" id="232between32symmetric32332and321">2 BETWEEN SYMMETRIC 3 AND 1</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="not32between32symmetric">NOT BETWEEN SYMMETRIC</code> <code>datatype</code> <code class="literal">AND</code> <code>datatype</code> → <code class="returnvalue">boolean</code></p> <p>Not between, after sorting the two endpoint values.</p> <p><code class="literal" id="232not32between32symmetric32332and321">2 NOT BETWEEN SYMMETRIC 3 AND 1</code> → <code class="returnvalue">f</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="is32distinct32from">IS DISTINCT FROM</code> <code>datatype</code> → <code class="returnvalue">boolean</code></p> <p>Not equal, treating null as a comparable value.</p> <p><code class="literal" id="132is32distinct32from32null">1 IS DISTINCT FROM NULL</code> → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)</p> <p><code class="literal" id="null32is32distinct32from32null">NULL IS DISTINCT FROM NULL</code> → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="is32not32distinct32from">IS NOT DISTINCT FROM</code> <code>datatype</code> → <code class="returnvalue">boolean</code></p> <p>Equal, treating null as a comparable value.</p> <p><code class="literal" id="132is32not32distinct32from32null">1 IS NOT DISTINCT FROM NULL</code> → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)</p> <p><code class="literal" id="null32is32not32distinct32from32null">NULL IS NOT DISTINCT FROM NULL</code> → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="is32null">IS NULL</code> → <code class="returnvalue">boolean</code></p> <p>Test whether value is null.</p> <p><code class="literal" id="146532is32null">1.5 IS NULL</code> → <code class="returnvalue">f</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="is32not32null">IS NOT NULL</code> → <code class="returnvalue">boolean</code></p> <p>Test whether value is not null.</p> <p><code class="literal" id="39null3932is32not32null">'null' IS NOT NULL</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="isnull">ISNULL</code> → <code class="returnvalue">boolean</code></p> <p>Test whether value is null (nonstandard syntax).</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>datatype</code> <code class="literal" id="notnull">NOTNULL</code> → <code class="returnvalue">boolean</code></p> <p>Test whether value is not null (nonstandard syntax).</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">boolean</code> <code class="literal" id="is32true">IS TRUE</code> → <code class="returnvalue">boolean</code></p> <p>Test whether boolean expression yields true.</p> <p><code class="literal" id="true32is32true">true IS TRUE</code> → <code class="returnvalue">t</code></p> <p><code class="literal" id="null5858boolean32is32true">NULL::boolean IS TRUE</code> → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">boolean</code> <code class="literal" id="is32not32true">IS NOT TRUE</code> → <code class="returnvalue">boolean</code></p> <p>Test whether boolean expression yields false or unknown.</p> <p><code class="literal" id="true32is32not32true">true IS NOT TRUE</code> → <code class="returnvalue">f</code></p> <p><code class="literal" id="null5858boolean32is32not32true">NULL::boolean IS NOT TRUE</code> → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">boolean</code> <code class="literal" id="is32false">IS FALSE</code> → <code class="returnvalue">boolean</code></p> <p>Test whether boolean expression yields false.</p> <p><code class="literal" id="true32is32false">true IS FALSE</code> → <code class="returnvalue">f</code></p> <p><code class="literal" id="null5858boolean32is32false">NULL::boolean IS FALSE</code> → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">boolean</code> <code class="literal" id="is32not32false">IS NOT FALSE</code> → <code class="returnvalue">boolean</code></p> <p>Test whether boolean expression yields true or unknown.</p> <p><code class="literal" id="true32is32not32false">true IS NOT FALSE</code> → <code class="returnvalue">t</code></p> <p><code class="literal" id="null5858boolean32is32not32false">NULL::boolean IS NOT FALSE</code> → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">boolean</code> <code class="literal" id="is32unknown">IS UNKNOWN</code> → <code class="returnvalue">boolean</code></p> <p>Test whether boolean expression yields unknown.</p> <p><code class="literal" id="true32is32unknown">true IS UNKNOWN</code> → <code class="returnvalue">f</code></p> <p><code class="literal" id="null5858boolean32is32unknown">NULL::boolean IS UNKNOWN</code> → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">boolean</code> <code class="literal" id="is32not32unknown">IS NOT UNKNOWN</code> → <code class="returnvalue">boolean</code></p> <p>Test whether boolean expression yields true or false.</p> <p><code class="literal" id="true32is32not32unknown">true IS NOT UNKNOWN</code> → <code class="returnvalue">t</code></p> <p><code class="literal" id="null5858boolean32is32not32unknown">NULL::boolean IS NOT UNKNOWN</code> → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)</p> </td> </tr> </tbody> </table> </div> </div> <p id="id-1.5.8.8.11.2">  The <code class="token">BETWEEN</code> predicate simplifies range tests:</p> <pre data-language="sql">
a BETWEEN x AND y
</pre> <p>is equivalent to</p> <pre data-language="sql">
a &gt;= x AND a &lt;= y
</pre> <p>Notice that <code class="token">BETWEEN</code> treats the endpoint values as included in the range. <code class="literal">BETWEEN SYMMETRIC</code> is like <code class="literal">BETWEEN</code> except there is no requirement that the argument to the left of <code class="literal">AND</code> be less than or equal to the argument on the right. If it is not, those two arguments are automatically swapped, so that a nonempty range is always implied.</p> <p>The various variants of <code class="literal">BETWEEN</code> are implemented in terms of the ordinary comparison operators, and therefore will work for any data type(s) that can be compared.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>The use of <code class="literal">AND</code> in the <code class="literal">BETWEEN</code> syntax creates an ambiguity with the use of <code class="literal">AND</code> as a logical operator. To resolve this, only a limited set of expression types are allowed as the second argument of a <code class="literal">BETWEEN</code> clause. If you need to write a more complex sub-expression in <code class="literal">BETWEEN</code>, write parentheses around the sub-expression.</p> </blockquote> <p id="id-1.5.8.8.14.2">  Ordinary comparison operators yield null (signifying <span class="quote">“<span class="quote">unknown</span>”</span>), not true or false, when either input is null. For example, <code class="literal">7 = NULL</code> yields null, as does <code class="literal">7 &lt;&gt; NULL</code>. When this behavior is not suitable, use the <code class="literal">IS [ NOT ] DISTINCT FROM</code> predicates:</p> <pre data-language="sql">
a IS DISTINCT FROM b
a IS NOT DISTINCT FROM b
</pre> <p>For non-null inputs, <code class="literal">IS DISTINCT FROM</code> is the same as the <code class="literal">&lt;&gt;</code> operator. However, if both inputs are null it returns false, and if only one input is null it returns true. Similarly, <code class="literal">IS NOT DISTINCT FROM</code> is identical to <code class="literal">=</code> for non-null inputs, but it returns true when both inputs are null, and false when only one input is null. Thus, these predicates effectively act as though null were a normal data value, rather than <span class="quote">“<span class="quote">unknown</span>”</span>.</p> <p id="id-1.5.8.8.15.4">    To check whether a value is or is not null, use the predicates:</p> <pre data-language="sql">
expression IS NULL
expression IS NOT NULL
</pre> <p>or the equivalent, but nonstandard, predicates:</p> <pre data-language="sql">
expression ISNULL
expression NOTNULL
</pre>  <p>Do <span class="emphasis"><em>not</em></span> write <code class="literal">expression = NULL</code> because <code class="literal">NULL</code> is not <span class="quote">“<span class="quote">equal to</span>”</span> <code class="literal">NULL</code>. (The null value represents an unknown value, and it is not known whether two unknown values are equal.)</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>Some applications might expect that <code class="literal">expression = NULL</code> returns true if <code>expression</code> evaluates to the null value. It is highly recommended that these applications be modified to comply with the SQL standard. However, if that cannot be done the <a class="xref" href="runtime-config-compatible#GUC-TRANSFORM-NULL-EQUALS">transform_null_equals</a> configuration variable is available. If it is enabled, PostgreSQL will convert <code class="literal">x = NULL</code> clauses to <code class="literal">x IS NULL</code>.</p> </blockquote> <p>If the <code>expression</code> is row-valued, then <code class="literal">IS NULL</code> is true when the row expression itself is null or when all the row's fields are null, while <code class="literal">IS NOT NULL</code> is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, <code class="literal">IS NULL</code> and <code class="literal">IS NOT NULL</code> do not always return inverse results for row-valued expressions; in particular, a row-valued expression that contains both null and non-null fields will return false for both tests. In some cases, it may be preferable to write <code>row</code> <code class="literal">IS DISTINCT FROM NULL</code> or <code>row</code> <code class="literal">IS NOT DISTINCT FROM NULL</code>, which will simply check whether the overall row value is null without any additional tests on the row fields.</p> <p id="id-1.5.8.8.19.6">      Boolean values can also be tested using the predicates</p> <pre data-language="sql">
boolean_expression IS TRUE
boolean_expression IS NOT TRUE
boolean_expression IS FALSE
boolean_expression IS NOT FALSE
boolean_expression IS UNKNOWN
boolean_expression IS NOT UNKNOWN
</pre> <p>These will always return true or false, never a null value, even when the operand is null. A null input is treated as the logical value <span class="quote">“<span class="quote">unknown</span>”</span>. Notice that <code class="literal">IS UNKNOWN</code> and <code class="literal">IS NOT UNKNOWN</code> are effectively the same as <code class="literal">IS NULL</code> and <code class="literal">IS NOT NULL</code>, respectively, except that the input expression must be of Boolean type.</p> <p>Some comparison-related functions are also available, as shown in <a class="xref" href="functions-comparison#FUNCTIONS-COMPARISON-FUNC-TABLE" title="Table 9.3. Comparison Functions">Table 9.3</a>.</p> <div class="table" id="FUNCTIONS-COMPARISON-FUNC-TABLE"> <p class="title"><strong>Table 9.3. Comparison Functions</strong></p> <div class="table-contents"> <table class="table" summary="Comparison Functions"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Function</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.8.21.2.2.1.1.1.1"> <code class="function" id="num_nonnulls">num_nonnulls</code> ( <code class="literal" id="variadic">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">integer</code></p> <p>Returns the number of non-null arguments.</p> <p><code class="literal" id="num_nonnulls">num_nonnulls(1, NULL, 2)</code> → <code class="returnvalue">2</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.8.21.2.2.2.1.1.1"> <code class="function" id="num_nulls">num_nulls</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">integer</code></p> <p>Returns the number of null arguments.</p> <p><code class="literal" id="num_nulls">num_nulls(1, NULL, 2)</code> → <code class="returnvalue">1</code></p> </td> </tr> </tbody> </table> </div> </div>  <div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter">  <table summary="Navigation footer"> <tr> <td width="40%" align="left">
<a accesskey="p" href="functions-logical" title="9.1. Logical Operators">Prev</a> </td> <td width="20%" align="center"><a accesskey="u" href="https://www.postgresql.org/docs/13/functions.html" title="Chapter 9. Functions and Operators">Up</a></td> <td width="40%" align="right"> <a accesskey="n" href="functions-math" title="9.3. Mathematical Functions and Operators">Next</a>
</td> </tr> <tr> <td width="40%" align="left">9.1. Logical Operators </td> <td width="20%" align="center"><a accesskey="h" href="https://www.postgresql.org/docs/13/index.html" title="PostgreSQL 13.1 Documentation">Home</a></td> <td width="40%" align="right"> 9.3. Mathematical Functions and Operators</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2020 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/13/functions-comparison.html" class="_attribution-link">https://www.postgresql.org/docs/13/functions-comparison.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
