
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Intersection Observer API - DOM - W3cubDocs</title>
  
  <meta name="description" content="The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or &hellip;">
  <meta name="keywords" content="intersection, observer, api, dom">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/dom/intersection_observer_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/dom.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/dom/" class="_nav-link" title="" style="margin-left:0;">DOM</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _mdn">
				
				
<h1>Intersection Observer API</h1> <p class="summary">The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's <a href="https://developer.mozilla.org/en-US/docs/Glossary/viewport">viewport</a>.</p> <p>Historically, detecting visibility of an element, or the relative visibility of two elements in relation to each other, has been a difficult task for which solutions have been unreliable and prone to causing the browser and the sites the user is accessing to become sluggish. Unfortunately, as the web has matured, the need for this kind of information has grown. Intersection information is needed for many reasons, such as:</p> <ul> <li>Lazy-loading of images or other content as a page is scrolled.</li> <li>Implementing "infinite scrolling" web sites, where more and more content is loaded and rendered as you scroll, so that the user doesn't have to flip through pages.</li> <li>Reporting of visibility of advertisements in order to calculate ad revenues.</li> <li>Deciding whether or not to perform tasks or animation processes based on whether or not the user will see the result.</li> </ul> <p>Implementing intersection detection in the past involved event handlers and loops calling methods like <a href="element/getboundingclientrect"><code>Element.getBoundingClientRect()</code></a> to build up the needed information for every element affected. Since all this code runs on the main thread, even one of these can cause performance problems. When a site is loaded with these tests, things can get downright ugly.</p> <p>Consider a web page that uses infinite scrolling. It uses a vendor-provided library to manage the advertisements placed periodically throughout the page, has animated graphics here and there, and uses a custom library that draws notification boxes and the like. Each of these has its own intersection detection routines, all running on the main thread. The author of the web site may not even realize this is happening, since they're using two libraries that they may know very little about the inner workings of. As the user scrolls the page, these intersection detection routines are firing constantly during the scroll handling code, resulting in an experience that leaves the user frustrated with the browser, the web site, and their computer.</p> <p>The Intersection Observer API lets code register a callback function that is executed whenever an element they wish to monitor enters or exits another element (or the <a href="https://developer.mozilla.org/en-US/docs/Glossary/viewport">viewport</a>), or when the amount by which the two intersect changes by a requested amount. This way, sites no longer need to do anything on the main thread to watch for this kind of element intersection, and the browser is free to optimize the management of intersections as it sees fit.</p> <p>One thing the Intersection Observer API can't tell you: the exact number of pixels that overlap or specifically which ones they are; however, it covers the much more common use case of "If they intersect by somewhere around <em>N</em>%, I need to do something."</p> <h2 id="Intersection_observer_concepts_and_usage">Intersection observer concepts and usage</h2> <p>The Intersection Observer API allows you to configure a callback that is called whenever one element, called the <strong>target</strong>, intersects either the device viewport or a specified element; for the purpose of this API, this is called the <strong>root element</strong> or <strong>root</strong>. Typically, you'll want to watch for intersection changes with regard to the document's viewport (which is done by specifying <code>null</code> as the root element ). Whether you're using the viewport or some other element as the root, the API works the same way, executing a callback function you provide whenever the visibility of the target element changes so that it crosses desired amounts of intersection with the root.</p> <p>The degree of intersection between the target element and its root is the <strong>intersection ratio</strong>. This is a representation of the percentage of the target element which is visible as a value between 0.0 and 1.0.</p> <h3 id="Creating_an_intersection_observer">Creating an intersection observer</h3> <p>Create the intersection observer by calling its constructor and passing it a callback function to be run whenever a threshold is crossed in one direction or the other:</p> <pre data-language="js">var options = {
  root: document.querySelector('#scrollArea'),
  rootMargin: '0px',
  threshold: 1.0
}

var observer = new IntersectionObserver(callback, options);</pre> <p>A threshold of 1.0 means that when 100% of the target is visible within the element specified by the <code>root</code> option, the callback is invoked.</p> <h4 id="Intersection_observer_options">Intersection observer options</h4> <p>The <code>options</code> object passed into the <a href="intersectionobserver/intersectionobserver"><code>IntersectionObserver()</code></a> constructor let you control the circumstances under which the observer's callback is invoked. It has the following fields:</p> <dl> <dt><code>root</code></dt> <dd>The element that is used as the viewport for checking visiblity of the target. Must be the ancestor of the target. Defaults to the browser viewport if not specified or if <code>null</code>.</dd> <dt><code>rootMargin</code></dt> <dd>Margin around the root. Can have values similar to the CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/margin"><code>margin</code></a> property, e.g. "<code>10px 20px 30px 40px"</code> (top, right, bottom, left). The values can be percentages. This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections. Defaults to all zeros.</dd> <dt><code>threshold</code></dt> <dd>Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed. If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5. If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1]. The default is 0 (meaning as soon as even one pixel is visible, the callback will be run). A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.</dd> </dl> <h4 id="Targeting_an_element_to_be_observed">Targeting an element to be observed</h4> <p>Once you have created the observer, you need to give it a target element to watch:</p> <pre data-language="js">var target = document.querySelector('#listItem');
observer.observe(target);
</pre> <p>Whenever the target meets a threshold specified for the <code>IntersectionObserver</code>, the callback is invoked. The callback receives a list of <a href="intersectionobserverentry"><code>IntersectionObserverEntry</code></a> objects and the observer:</p> <pre data-language="js">var callback = function(entries, observer) { 
  entries.forEach(entry =&gt; {
    // Each entry describes an intersection change for one observed
    // target element:
    //   entry.boundingClientRect
    //   entry.intersectionRatio
    //   entry.intersectionRect
    //   entry.isIntersecting
    //   entry.rootBounds
    //   entry.target
    //   entry.time
  });
};
</pre> <p>Be aware that your callback is executed on the main thread. It should operate as quickly as possible; if anything time-consuming needs to be done, use <a href="window/requestidlecallback"><code>Window.requestIdleCallback()</code></a>.</p> <p>Also, note that if you specified the <code>root</code> option, the target must be a descendant of the root element.</p> <h3 id="How_intersection_is_calculated">How intersection is calculated</h3> <p>All areas considered by the Intersection Observer API are rectangles; elements which are irregularly shaped are considered as occupying the smallest rectangle which encloses all of the element's parts. Similarly, if the visible portion of an element is not rectangular, the element's intersection rectangle is construed to be the smallest rectangle that contains all the visible portions of the element.</p> <p>It's useful to understand a bit about how the various properties provided by <a href="intersectionobserverentry"><code>IntersectionObserverEntry</code></a> describe an intersection.</p> <h4 id="The_intersection_root_and_root_margin">The intersection root and root margin</h4> <p>Before we can track the intersection of an element with a container, we need to know what that container is. That container is the <strong>intersection root</strong>, or <strong>root element</strong>. This can be either an element in the document which is an ancestor of the element to be observed, or <code>null</code> to use the document's viewport as the container.</p> <p>The rectangle used as the bounds of the intersection root can be adjusted by setting the <strong>root margin</strong>, <code>rootMargin</code>, when creating the <a href="intersectionobserver"><code>IntersectionObserver</code></a>. The values in <code>rootMargin</code> define offsets added to each side of the intersection root's bounding box to create the final intersection root bounds (which are disclosed in <a href="intersectionobserverentry/rootbounds"><code>IntersectionObserverEntry.rootBounds</code></a> when the callback is executed).</p> <h4 id="Thresholds">Thresholds</h4> <p>Rather than reporting every infinitesimal change in how much a target element is visible, the Intersection Observer API uses <strong>thresholds</strong>. When you create an observer, you can provide one or more numeric values representing percentages of the target element which are visible. Then, the API only reports changes to visibility which cross these thresholds.</p> <p>For example, if you want to be informed every time a target's visibility passes backward or forward through each 25% mark, you would specify the array [0, 0.25, 0.5, 0.75, 1] as the list of thresholds when creating the observer. You can tell which direction the visibility changed in (that is, whether the element became more visible or less visible) by checking the value of the <a href="intersectionobserverentry/isintersecting"><code>isIntersecting</code></a> property on the <a href="intersectionobserverentry"><code>IntersectionObserverEntry</code></a> passed into the callback function at the time of the visibility change. If <code>isIntersecting</code> is <code>true</code>, the target element has become at least as visible as the threshold that was passed. If it's <code>false</code>, the target is no longer as visible as the given threshold.</p> <p>To get a feeling for how thresholds work, try scrolling the box below around. Each colored box within it displays the percentage of itself that's visible in all four of its corners, so you can see these ratios change over time as you scroll the container. Each box has a different set of thresholds:</p> <ul> <li>The first box has a threshold for each percentage point of visibility; that is, the <a href="intersectionobserver/thresholds"><code>IntersectionObserver.thresholds</code></a> array is <code>[0.00, 0.01, 0.02, ..., 0.99, 1.00]</code>.</li> <li>The second box has a single threshold, at the 50% mark.</li> <li>The third box has thresholds every 10% of visibility (0%, 10%, 20%, etc.).</li> <li>The last box has thresholds each 25%.</li> </ul>  <p><iframe src="https://mdn.mozillademos.org/en-US/docs/Web/API/Intersection_Observer_API%24samples/threshold-example?revision=1436018" height="500" class="live-sample-frame sample-code-frame" width="500" frameborder="0" id="frame_threshold-example"></iframe></p> <h3 id="Intersection_change_callbacks">Intersection change callbacks</h3> <p>When the amount of a target element which is visible within the root element crosses one of the visibility thresholds,</p> <h2 id="Interfaces">Interfaces</h2> <dl> <dt><a href="intersectionobserver"><code>IntersectionObserver</code></a></dt> <dd>The primary interface for the Intersection Observer API. Provides methods for creating and managing an observer which can watch any number of target elements for the same intersection configuration. Each observer can asynchronously observe changes in the intersection between one or more target elements and a shared ancestor element or with their top-level <a href="document"><code>Document</code></a>'s <a href="https://developer.mozilla.org/en-US/docs/Glossary/viewport">viewport</a>. The ancestor or viewport is referred to as the <strong>root</strong>.</dd> <dt><a href="intersectionobserverentry"><code>IntersectionObserverEntry</code></a></dt> <dd>Describes the intersection between the target element and its root container at a specific moment of transition. Objects of this type can only be obtained in two ways: as an input to your <code>IntersectionObserver</code> callback, or by calling <a href="intersectionobserver/takerecords"><code>IntersectionObserver.takeRecords()</code></a>.</dd> </dl> <h2 id="A_simple_example">A simple example</h2> <p>This simple example causes a target element to change its color and transparency as it becomes more or less visible. At <a href="intersection_observer_api/timing_element_visibility">Timing element visibility with the Intersection Observer API</a>, you can find a more extensive example showing how to time how long a set of elements (such as ads) are visible to the user and to react to that information by recording statistics or by updating elements..</p> <h3 id="HTML">HTML</h3> <p>The HTML for this example is very short, with a primary element which is the box that we'll be targeting (with the creative ID <code>"box"</code>) and some contents within the box.</p> <pre data-language="html">&lt;div id="box"&gt;
  &lt;div class="vertical"&gt;
    Welcome to &lt;strong&gt;The Box!&lt;/strong&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre> <h3 id="CSS">CSS</h3> <p>The CSS isn't terribly important for the purposes of this example; it lays out the element and establishes that the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-color"><code>background-color</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/border"><code>border</code></a> attributes can participate in <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions">CSS transitions</a>, which we'll use to affect the changes to the element as it becomes more or less obscured.</p> <pre data-language="css">#box {
  background-color: rgba(40, 40, 190, 255);
  border: 4px solid rgb(20, 20, 120);
  transition: background-color 1s, border 1s;
  width: 350px;
  height: 350px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.vertical {
  color: white;
  font: 32px "Arial";
}

.extra {
  width: 350px;
  height: 350px;
  margin-top: 10px;
  border: 4px solid rgb(20, 20, 120);
  text-align: center;
  padding: 20px;
}</pre> <h3 id="JavaScript">JavaScript</h3> <p>Finally, let's take a look at the JavaScript code that uses the Intersection Observer API to make things happen.</p> <h4 id="Setting_up">Setting up</h4> <p>First, we need to prepare some variables and install the observer.</p> <pre data-language="js">var numSteps = 20.0;

var boxElement;
var prevRatio = 0.0;
var increasingColor = "rgba(40, 40, 190, ratio)";
var decreasingColor = "rgba(190, 40, 40, ratio)";

// Set things up.

window.addEventListener("load", function(event) {
  boxElement = document.querySelector("#box");

  createObserver();
}, false);</pre> <p>The constants and variables we set up here are:</p> <dl> <dt><code>numSteps</code></dt> <dd>A constant which indicates how many thresholds we want to have between a visibility ratio of 0.0 and 1.0.</dd> <dt><code>prevRatio</code></dt> <dd>This variable will be used to record what the visibility ratio was the last time a threshold was crossed; this will let us figure out whether the target element is becoming more or less visible.</dd> <dt><code>increasingColor</code></dt> <dd>A string defining a color we'll apply to the target element when the visibility ratio is increasing. The word "ratio" in this string will be replaced with the target's current visibility ratio, so that the element not only changes color but also becomes increasingly opaque as it becomes less obscured.</dd> <dt><code>decreasingColor</code></dt> <dd>Similarly, this is a string defining a color we'll apply when the visibility ratio is decreasing.</dd> </dl> <p>We call <a href="eventtarget/addeventlistener"><code>Window.addEventListener()</code></a> to start listening for the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/load">load</a></code> event; once the page has finished loading, we get a reference to the element with the ID <code>"box"</code> using <a href="document/queryselector"><code>querySelector()</code></a>, then call the <code>createObserver()</code> method we'll create in a moment to handle building and installing the intersection observer.</p> <h4 id="Creating_the_intersection_observer">Creating the intersection observer</h4> <p>The <code>createObserver()</code> method is called once page load is complete to handle actually creating the new <a href="intersectionobserver"><code>IntersectionObserver</code></a> and starting the process of observing the target element.</p> <pre data-language="js">function createObserver() {
  var observer;

  var options = {
    root: null,
    rootMargin: "0px",
    threshold: buildThresholdList()
  };

  observer = new IntersectionObserver(handleIntersect, options);
  observer.observe(boxElement);
}</pre> <p>This begins by setting up an <code>options</code> object containing the settings for the observer. We want to watch for changes in visibility of the target element relative to the document's viewport, so <code>root</code> is <code>null</code>. We need no margin, so the margin offset, <code>rootMargin</code>, is specified as "0px". This causes the observer to watch for changes in the intersection between the target element's bounds and those of the viewport, without any added (or subtracted) space.</p> <p>The list of visibility ratio thresholds, <code>threshold</code>, is constructed by the function <code>buildThresholdList()</code>. The threshold list is built programmatically in this example since there are a number of them and the number is intended to be adjustable.</p> <p>Once <code>options</code> is ready, we create the new observer, calling the <a href="intersectionobserver/intersectionobserver"><code>IntersectionObserver()</code></a> constructor, specifying a function to be called when intersection crosses one of our thresholds, <code>handleIntersect()</code>, and our set of options. We then call <a href="intersectionobserver/observe"><code>observe()</code></a> on the returned observer, passing into it the desired target element.</p> <p>We could opt to monitor multiple elements for visibility intersection changes with respect to the viewport by calling <code>observer.observe()</code> for each of those elements, if we wanted to do so.</p> <h4 id="Building_the_array_of_threshold_ratios">Building the array of threshold ratios</h4> <p>The <code>buildThresholdList()</code> function, which builds the list of thresholds, looks like this:</p> <pre data-language="js">function buildThresholdList() {
  var thresholds = [];
  var numSteps = 20;

  for (var i=1.0; i&lt;=numSteps; i++) {
    var ratio = i/numSteps;
    thresholds.push(ratio);
  }

  thresholds.push(0);
  return thresholds;
}</pre> <p>This builds the array of thresholds—each of which is a ratio between 0.0 and 1.0, by pushing the value <code>i/numSteps</code> onto the <code>thresholds</code> array for each integer <code>i</code> between 1 and <code>numSteps</code>. It also pushes 0 to include that value. The result, given the default value of <code>numSteps</code> (20), is the following list of thresholds:</p> <div class="_table"><table class="standard-table"> <tbody> <tr> <th>#</th> <th>Ratio</th> <th>#</th> <th>Ratio</th> </tr> <tr> <th>1</th> <td>0.05</td> <th>11</th> <td>0.55</td> </tr> <tr> <th>2</th> <td>0.1</td> <th>12</th> <td>0.6</td> </tr> <tr> <th>3</th> <td>0.15</td> <th>13</th> <td>0.65</td> </tr> <tr> <th>4</th> <td>0.2</td> <th>14</th> <td>0.7</td> </tr> <tr> <th>5</th> <td>0.25</td> <th>15</th> <td>0.75</td> </tr> <tr> <th>6</th> <td>0.3</td> <th>16</th> <td>0.8</td> </tr> <tr> <th>7</th> <td>0.35</td> <th>17</th> <td>0.85</td> </tr> <tr> <th>8</th> <td>0.4</td> <th>18</th> <td>0.9</td> </tr> <tr> <th>9</th> <td>0.45</td> <th>19</th> <td>0.95</td> </tr> <tr> <th>10</th> <td>0.5</td> <th>20</th> <td>1.0</td> </tr> </tbody> </table></div> <p>We could, of course, hard-code the array of thresholds into our code, and often that's what you'll end up doing. But this example leaves room for adding configuration controls to adjust the granularity, for example.</p> <h4 id="Handling_intersection_changes">Handling intersection changes</h4> <p>When the browser detects that the target element (in our case, the one with the ID <code>"box"</code>) has been unveiled or obscured such that its visibility ratio crosses one of the thresholds in our list, it calls our handler function, <code>handleIntersect()</code>:</p> <pre data-language="js">function handleIntersect(entries, observer) {
  entries.forEach(function(entry) {
    if (entry.intersectionRatio &gt; prevRatio) {
      entry.target.style.backgroundColor = increasingColor.replace("ratio", entry.intersectionRatio);
    } else {
      entry.target.style.backgroundColor = decreasingColor.replace("ratio", entry.intersectionRatio);
    }

    prevRatio = entry.intersectionRatio;
  });
}</pre> <p>For each <a href="intersectionobserverentry"><code>IntersectionObserverEntry</code></a> in the list <code>entries</code>, we look to see if the entry's <a href="intersectionobserverentry/intersectionratio"><code>intersectionRatio</code></a> is going up; if it is, we set the target's <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-color"><code>background-color</code></a> to the string in <code>increasingColor</code> (remember, it's <code>"rgba(40, 40, 190, ratio)"</code>), replaces the word "ratio" with the entry's <code>intersectionRatio</code>. The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent.</p> <p>Similarly, if the <code>intersectionRatio</code> is going down, we use the string <code>decreasingColor</code> and replace the word "ratio" in that with the <code>intersectionRatio</code> before setting the target element's <code>background-color</code>.</p> <p>Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable <code>prevRatio</code>.</p> <h3 id="Result">Result</h3> <p>Below is the resulting content. Scroll this page up and down and notice how the appearance of the box changes as you do so.</p> <p><iframe src="https://mdn.mozillademos.org/en-US/docs/Web/API/Intersection_Observer_API%24samples/A_simple_example?revision=1436018" height="400" class="live-sample-frame sample-code-frame" width="400" frameborder="0" id="frame_A_simple_example"></iframe></p> <p>There's an even more extensive example at <a href="intersection_observer_api/timing_element_visibility">Timing element visibility with the Intersection Observer API</a>.</p> <h2 id="Specifications">Specifications</h2> <div class="_table"><table class="standard-table"> <thead> <tr> <th scope="col">Specification</th> <th scope="col">Status</th> <th scope="col">Comment</th> </tr> </thead> <tbody> <tr> <td><a href="https://w3c.github.io/IntersectionObserver/" hreflang="en">Intersection Observer</a></td> <td><span class="spec-WD">Working Draft</span></td> <td> </td> </tr> </tbody> </table></div> <h2 id="Browser_compatibility">Browser compatibility<a href="https://github.com/mdn/browser-compat-data" class="bc-github-link">Update compatibility data on GitHub</a>
</h2>  <div class="_table">
<table class="bc-table bc-table-web">
<thead>
<tr class="bc-platforms">
<th></th>
<th colspan="6">Desktop</th>
</tr>
<tr class="bc-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver">Basic support</a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 15</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/IntersectionObserver"><code>IntersectionObserver()</code> constructor</a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 15</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/root"><code>root</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 15</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/rootMargin"><code>rootMargin</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 15</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/thresholds"><code>thresholds</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 15</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/disconnect"><code>disconnect</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes bc-has-history"> 15
<dl>
<dt class="bc-supports-yes bc-supports"> 15
</dt>
<dd> Available since <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/intersectionobserver/">Windows Insider Preview Build 14986</a>
</dd>
</dl>
</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/observe"><code>observe</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 15</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/takeRecords"><code>takeRecords</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes bc-has-history"> 15
<dl>
<dt class="bc-supports-yes bc-supports"> 15
</dt>
<dd> Available since <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/intersectionobserver/">Windows Insider Preview Build 14986</a>
</dd>
</dl>
</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/unobserve"><code>unobserve</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes bc-has-history"> 15
<dl>
<dt class="bc-supports-yes bc-supports"> 15
</dt>
<dd> Available since <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/intersectionobserver/">Windows Insider Preview Build 14986</a>
</dd>
</dl>
</td>
<td class="bc-supports-yes bc-has-history"> 55
<dl>
<dt class="bc-supports-yes bc-supports"> 55
</dt>

<dt class="bc-supports-no bc-supports">53 — 55<div class="bc-icons">Disabled </div>
</dt>
<dd>Disabled From version 53 until version 55 (exclusive): this feature is behind the <code>dom.IntersectionObserver.enabled</code> preference (needs to be set to <code>true</code>). To change preferences in Firefox, visit about:config.</dd>
</dl>
</td>
<td class="bc-supports-no"> No</td>
<td> ? </td>
<td> ? </td>
</tr>
</tbody>
</table>
<table class="bc-table bc-table-web">
<thead>
<tr class="bc-platforms">
<th></th>
<th colspan="7">Mobile</th>
</tr>
<tr class="bc-browsers">
<th></th>
<th>Android webview</th>
<th>Chrome for Android</th>
<th>Edge Mobile</th>
<th>Firefox for Android</th>
<th>Opera for Android</th>
<th>iOS Safari</th>
<th>Samsung Internet</th>
</tr>
</thead>
<tbody>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver">Basic support</a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/IntersectionObserver"><code>IntersectionObserver()</code> constructor</a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/root"><code>root</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/rootMargin"><code>rootMargin</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/thresholds"><code>thresholds</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/disconnect"><code>disconnect</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/observe"><code>observe</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/takeRecords"><code>takeRecords</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
<tr>
<th scope="row">
<a href="https://developer.mozilla.org/docs/Web/API/IntersectionObserver/unobserve"><code>unobserve</code></a> 
</th>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> 51</td>
<td class="bc-supports-yes"> Yes</td>
<td> ? </td>
<td> ? </td>
<td> ? </td>
<td class="bc-supports-yes"> 5.0</td>
</tr>
</tbody>
</table>
</div> <h2 id="See_also">See also</h2> <ul> <li><a href="https://github.com/w3c/IntersectionObserver">Intersection Observer polyfill</a></li> <li><a href="intersection_observer_api/timing_element_visibility">Timing element visibility with the Intersection Observer API</a></li> <li>
<a href="intersectionobserver"><code>IntersectionObserver</code></a> and <a href="intersectionobserverentry"><code>IntersectionObserverEntry</code></a>
</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API%24edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2005–2018 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
