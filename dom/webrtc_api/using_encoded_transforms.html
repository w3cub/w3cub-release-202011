
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>WebRTC API&#58; Using Encoded Transforms - Web APIs - W3cubDocs</title>
  
  <meta name="description" content="WebRTC Encoded Transforms provide a mechanism to inject a high performance Stream API for modifying encoded video and audio frame into the incoming &hellip;">
  <meta name="keywords" content="using, webrtc, encoded, transforms, api, web, apis, dom">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/dom/webrtc_api/using_encoded_transforms.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/dom.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/dom/" class="_nav-link" title="" style="margin-left:0;">Web APIs</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _mdn">
				
				
<header><h1>Using WebRTC Encoded Transforms</h1></header><div class="section-content">
<p> WebRTC Encoded Transforms provide a mechanism to inject a high performance <a href="../streams_api">Stream API</a> for modifying encoded video and audio frame into the incoming and outgoing WebRTC pipelines. This enables use cases such as end-to-end encryption of encoded frames by third-party code. </p> <p> The API defines both main thread and worker side objects. The main-thread interface is a <a href="../rtcrtpscripttransform"><code>RTCRtpScriptTransform</code></a> instance, which on construction specifies the <a href="../worker"><code>Worker</code></a> that is to implement the transformer code. The transform running in the worker is inserted into the incoming or outgoing WebRTC pipeline by adding the <code>RTCRtpScriptTransform</code> to <a href="../rtcrtpreceiver/transform"><code>RTCRtpReceiver.transform</code></a> or <a href="../rtcrtpsender/transform"><code>RTCRtpSender.transform</code></a>, respectively. </p> <p> A counterpart <a href="../rtcrtpscripttransformer"><code>RTCRtpScriptTransformer</code></a> object is created in the worker thread, which has a <a href="../readablestream"><code>ReadableStream</code></a> <code>readable</code> property, a <a href="../writablestream"><code>WritableStream</code></a> <code>writable</code> property, and an <code>options</code> object passed from the associated <a href="../rtcrtpscripttransform"><code>RTCRtpScriptTransform</code></a> constructor. Encoded video frames (<a href="../rtcencodedvideoframe"><code>RTCEncodedVideoFrame</code></a>) or audio frames (<a href="../rtcencodedaudioframe"><code>RTCEncodedAudioFrame</code></a>) from the WebRTC pipeline are enqueued on <code>readable</code> for processing. </p> <p> The <code>RTCRtpScriptTransformer</code> is made available to code as the <code>transformer</code> property of the <a href="../dedicatedworkerglobalscope/rtctransform_event"><code>rtctransform</code></a> event, which is fired at the worker global scope whenever an encoded frame is enqueued for processing (and initially on construction of the corresponding <a href="../rtcrtpscripttransform"><code>RTCRtpScriptTransform</code></a>). The worker code must implement a handler for the event that reads encoded frames from <code>transformer.readable</code>, modifies them as needed, and writes them to <code>transformer.writable</code> in the same order and without any duplication. </p> <p> While the interface doesn't place any other restrictions on the implementation, a natural way to transform the frames is to create a <a href="../streams_api/concepts#pipe_chains">pipe chain</a> that sends frames enqueued on the <code>event.transformer.readable</code> stream through an <a href="../transformstream"><code>TransformStream</code></a> to the <code>event.transformer.writable</code> stream. We can use the <code>event.transformer.options</code> property to configure any transform code that depends on whether the transform is enqueuing incoming frames from the packetizer or outgoing frames from a codec. </p> <p> The <a href="../rtcrtpscripttransformer"><code>RTCRtpScriptTransformer</code></a> interface also provides methods that can be used when sending encoded video to get the codec to generate a "key" frame, and when receiving video to request that a new key frame be sent. These may be useful to allow a recipient to start viewing the video more quickly, if (for example) they join a conference call when delta frames are being sent. </p> <p>The following examples provide more specific examples of how to use the framework using a <a href="../transformstream"><code>TransformStream</code></a> based implementation.</p>
</div>
<h2 id="test_if_encoded_transforms_are_supported">Test if encoded transforms are supported</h2>
<div class="section-content">
<p>Test if <a href="#browser_compatibility">encoded transforms are supported</a> by checking for the existence of <a href="../rtcrtpsender/transform"><code>RTCRtpSender.transform</code></a> (or <a href="../rtcrtpreceiver/transform"><code>RTCRtpReceiver.transform</code></a>):</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="szdUU/vevO97qH0ON1c3Gal/H18/9bkInU9mW56qjJc=" data-language="js"><span class="token keyword">const</span> supportsEncodedTransforms <span class="token operator">=</span>
  window<span class="token punctuation">.</span>RTCRtpSender <span class="token operator">&amp;&amp;</span> <span class="token string">"transform"</span> <span class="token keyword">in</span> <span class="token class-name">RTCRtpSender</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</pre>
</div>
</div>
<h2 id="adding_a_transform_for_outgoing_frames">Adding a transform for outgoing frames</h2>
<div class="section-content">
<p>A transform running in a worker is inserted into the outgoing WebRTC pipeline by assigning its corresponding <code>RTCRtpScriptTransform</code> to the <a href="../rtcrtpsender/transform"><code>RTCRtpSender.transform</code></a> for an outgong track.</p> <p> This example shows how you might stream video from a user's webcam over WebRTC, adding a WebRTC encoded transform to modify the outgoing streams. The code assumes that there is an <a href="../rtcpeerconnection"><code>RTCPeerConnection</code></a> called <code>peerConnection</code> that is already connected to a remote peer. </p> <p>First we get a <a href="../mediastreamtrack"><code>MediaStreamTrack</code></a>, using <a href="../mediadevices/getusermedia"><code>getUserMedia()</code></a> to get a video <a href="../mediastream"><code>MediaStream</code></a> from a media device, and then the <a href="../mediastream/gettracks"><code>MediaStream.getTracks()</code></a> method to get the first <a href="../mediastreamtrack"><code>MediaStreamTrack</code></a> in the stream.</p> <p> The track is added to the peer connection using <a href="../rtcpeerconnection/addtrack"><code>addTrack()</code></a>, which starts streaming it to the remote peer. The <code>addTrack()</code> method returns the <a href="../rtcrtpsender"><code>RTCRtpSender</code></a> that is being used to send the track. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="SoeybAj8YhQ0zIn1X4xjFBb6q9tjp4TaoDQsWgnr3Zw=" data-language="js"><span class="token comment">// Get Video stream and MediaTrack</span>
<span class="token keyword">const</span> stream <span class="token operator">=</span> <span class="token keyword">await</span> navigator<span class="token punctuation">.</span>mediaDevices<span class="token punctuation">.</span><span class="token function">getUserMedia</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">video</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>track<span class="token punctuation">]</span> <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">getTracks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> videoSender <span class="token operator">=</span> peerConnection<span class="token punctuation">.</span><span class="token function">addTrack</span><span class="token punctuation">(</span>track<span class="token punctuation">,</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div> <p> An <code>RTCRtpScriptTransform</code> is then constructed taking a worker script, which defines the transform, and an optional object that can be used to pass arbitrary messages to the worker (in this case we've used a <code>name</code> property with value "senderTransform" to tell the worker that this transform will be added to the outbound stream). We add the transform to the outgoing pipeline by assigning it to the <a href="../rtcrtpsender/transform"><code>RTCRtpSender.transform</code></a> property. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="5LK31P0DW2pALhZDIDeegog1S6jPT6pLTQigcjDqa8U=" data-language="js"><span class="token comment">// Create a worker containing a TransformStream</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">"worker.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
videoSender<span class="token punctuation">.</span>transform <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RTCRtpScriptTransform</span><span class="token punctuation">(</span>worker<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"senderTransform"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div> <p>The <a href="#using_separate_sender_and_receiver_transforms">Using separate sender and receiver transforms</a> section below shows how the <code>name</code> might be used in a worker.</p> <p>Note that you can add the transform at any time, but by adding it immediately after calling <code>addTrack()</code> the transform will get the first encoded frame that is sent.</p>
</div>
<h2 id="adding_a_transform_for_incoming_frames">Adding a transform for incoming frames</h2>
<div class="section-content">
<p>A transform running in a worker is inserted into the incoming WebRTC pipeline by assigning its corresponding <code>RTCRtpScriptTransform</code> to the <a href="../rtcrtpreceiver/transform"><code>RTCRtpReceiver.transform</code></a> for an incoming track.</p> <p> This example shows how you add a transform to modify an incoming stream. The code assumes that there is an <a href="../rtcpeerconnection"><code>RTCPeerConnection</code></a> called <code>peerConnection</code> that is already connected to a remote peer. </p> <p> First we add an <code>RTCPeerConnection</code> <a href="../rtcpeerconnection/track_event"><code>track</code> event</a> handler to catch the event when the peer starts receiving a new track. Within the handler we construct an <code>RTCRtpScriptTransform</code> and add it to <code>event.receiver.transform</code> (<code>event.receiver</code> is a <a href="../rtcrtpreceiver"><code>RTCRtpReceiver</code></a>). As in the previous section, the constructor takes an object with <code>name</code> property, but here we use <code>receiverTransform</code> as the value to tell the worker that frames are incoming. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="pSjpps489gkuUsA4ioqLThGb8CrzK4pOzk2qJ2GOH1c=" data-language="js">peerConnection<span class="token punctuation">.</span><span class="token function-variable function">ontrack</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">"worker.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  event<span class="token punctuation">.</span>receiver<span class="token punctuation">.</span>transform <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RTCRtpScriptTransform</span><span class="token punctuation">(</span>worker<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"receiverTransform"</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  received_video<span class="token punctuation">.</span>srcObject <span class="token operator">=</span> event<span class="token punctuation">.</span>streams<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre>
</div> <p> Note again that you can add the transform stream at any time. However by adding it in the <code>track</code> event handler ensures that the transform stream will get the first encoded frame for the track. </p>
</div>
<h2 id="worker_implementation">Worker implementation</h2>
<div class="section-content">
<p>The worker script must implement a handler for the <a href="../dedicatedworkerglobalscope/rtctransform_event"><code>rtctransform</code></a> event, creating a <a href="../streams_api/concepts#pipe_chains">pipe chain</a> that pipes the <code>event.transformer.readable</code> (<a href="../readablestream"><code>ReadableStream</code></a>) stream through a <a href="../transformstream"><code>TransformStream</code></a> to the <code>event.transformer.writable</code> (<a href="../writablestream"><code>WritableStream</code></a>) stream.</p> <p>A worker might support transforming incoming or outgoing encoded frames, or both, and the transform might be hard coded, or configured at run-time using information passed from the web application.</p>
</div>
<h3 id="basic_webrtc_encoded_transform">Basic WebRTC Encoded Transform</h3>
<div class="section-content">
<p> The example below shows a basic WebRTC Encoded transform, which negates all bits in queued frames. It does not use or need options passed in from the main thread because the same algorithm can be used in the sender pipeline to negate the bits and in the receiver pipeline to restore them. </p> <p> The code implements an event handler for the <code>rtctransform</code> event. This constructs a <a href="../transformstream"><code>TransformStream</code></a>, then pipes through it using <a href="../readablestream/pipethrough"><code>ReadableStream.pipeThrough()</code></a>, and finally pipes to <code>event.transformer.writable</code> using <a href="../readablestream/pipeto"><code>ReadableStream.pipeTo()</code></a>. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="IZ0V3/EkAIgLQfQLWGd3ccl2l7VCdn+GUfWeRHh7X4s=" data-language="js"><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"rtctransform"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> transform <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransformStream</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// Called on startup.</span>
    <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// Called when the stream is about to be closed.</span>
    <span class="token keyword">async</span> <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">encodedFrame<span class="token punctuation">,</span> controller</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Reconstruct the original frame.</span>
      <span class="token keyword">const</span> view <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataView</span><span class="token punctuation">(</span>encodedFrame<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Construct a new buffer</span>
      <span class="token keyword">const</span> newData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span>encodedFrame<span class="token punctuation">.</span>data<span class="token punctuation">.</span>byteLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> newView <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataView</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Negate all bits in the incoming frame</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> encodedFrame<span class="token punctuation">.</span>data<span class="token punctuation">.</span>byteLength<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newView<span class="token punctuation">.</span><span class="token function">setInt8</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">~</span>view<span class="token punctuation">.</span><span class="token function">getInt8</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      encodedFrame<span class="token punctuation">.</span>data <span class="token operator">=</span> newData<span class="token punctuation">;</span>
      controller<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>encodedFrame<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>readable
    <span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>transform<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">pipeTo</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div> <p> The implementation of the WebRTC encoded transform is similar to a "generic" <a href="../transformstream"><code>TransformStream</code></a>, but with some important differences. Like the generic stream, its <a href="../transformstream/transformstream#parameters">constructor</a> takes an object that defines an <em>optional</em> <a href="../transformstream/transformstream#startcontroller"><code>start()</code></a> method, which is called on construction, <a href="../transformstream/transformstream#flushcontroller"><code>flush()</code></a> method, which is called as the stream is about to be closed, and <a href="../transformstream/transformstream#transformchunk_controller"><code>transform()</code></a> method, which is called every time there is a chunk to be processed. Unlike the generic constructor any <code>writableStrategy</code> or <code>readableStrategy</code> properties that are passed in the constructor object are ignored, and the queuing strategy is entirely managed by the user agent. </p> <p> The <code>transform()</code> method also differs in that it is passed either an <a href="../rtcencodedvideoframe"><code>RTCEncodedVideoFrame</code></a> or <a href="../rtcencodedaudioframe"><code>RTCEncodedAudioFrame</code></a> rather than a generic "chunk". The actual code shown here for the method isn't notable other than it demonstrates how to convert the frame to a form where you can modify it and enqueue it afterwards on the stream. </p>
</div>
<h3 id="using_separate_sender_and_receiver_transforms">Using separate sender and receiver transforms</h3>
<div class="section-content">
<p> The previous example works if the transform function is the same when sending and receiving, but in many cases the algorithms will be different. You could use separate worker scripts for the sender and receiver, or handle both cases in one worker as shown below. </p> <p> If the worker is used for both sender and receiver, it needs to know whether the current encoded frame is outgoing from a codec, or incoming from the packetizer. This information can be specified using the second option in the <a href="../rtcrtpscripttransform/rtcrtpscripttransform"><code>RTCRtpScriptTransform</code> constructor</a>. For example, we can define a separate <code>RTCRtpScriptTransform</code> for the sender and receiver, passing the same worker, and an options object with property <code>name</code> that indicates whether the transform is used in the sender or receiver (as shown in previous sections above). The information is then available in the worker in <code>event.transformer.options</code>. </p> <p> In this example we implement the <code>onrtctransform</code> event handler on the global dedicated worker scope object. The value of the <code>name</code> property is used to determine which <code>TransformStream</code> to construct (the actual constructor methods are not shown). </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="rI6XbuYHL+Xvr+tTY7Fdr0bGU1YA63ohpudMeqjnla0=" data-language="js"><span class="token comment">// Code to instantiate transform and attach them to sender/receiver pipelines.</span>
<span class="token function-variable function">onrtctransform</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> transform<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>options<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"senderTransform"</span><span class="token punctuation">)</span>
    transform <span class="token operator">=</span> <span class="token function">createSenderTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns a TransformStream</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>options<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"receiverTransform"</span><span class="token punctuation">)</span>
    transform <span class="token operator">=</span> <span class="token function">createReceiverTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns a TransformStream</span>
  <span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>readable
    <span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>transform<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">pipeTo</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre>
</div> <p>Note that the code to create the pipe chain is the same as in the previous example.</p>
</div>
<h3 id="runtime_communication_with_the_transform">Runtime communication with the transform</h3>
<div class="section-content">
<p> The <a href="../rtcrtpscripttransform/rtcrtpscripttransform"><code>RTCRtpScriptTransform</code> constructor</a> allows you to pass options and transfer objects to the worker. In the previous example we passed static information, but sometimes you might want to modify the transform algorithm in the worker at runtime, or get information back from the worker. For example, a WebRTC conference call that supports encryption might need to add a new key to the algorithm used by the transform. </p> <p>While it is possible to share information between the worker running the tranform code and the main thread using <a href="../worker/postmessage"><code>Worker.postMessage()</code></a>, it is generally easier to share a <a href="../messagechannel"><code>MessageChannel</code></a> as an <a href="../rtcrtpscripttransform/rtcrtpscripttransform"><code>RTCRtpScriptTransform</code> constructor</a> option, because then the channel context is directly available in the <code>event.transformer.options</code> when you are handling a new encoded frame.</p> <p> The code below creates a <a href="../messagechannel"><code>MessageChannel</code></a> and <a href="../web_workers_api/transferable_objects">transfers</a> its second port to the worker. The main thread and transform can subsequently communicate using the first and second ports. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="ajLVlK7zHis/ZuYsv4sr9vE/OksHJTyNe22WpwE8/Oc=" data-language="js"><span class="token comment">// Create a worker containing a TransformStream</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">"worker.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Create a channel</span>
<span class="token comment">// Pass channel.port2 to the transform as a constructor option</span>
<span class="token comment">// and also transfer it to the worker</span>
<span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> transform <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RTCRtpScriptTransform</span><span class="token punctuation">(</span>
  worker<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">purpose</span><span class="token operator">:</span> <span class="token string">"encrypt"</span><span class="token punctuation">,</span> <span class="token literal-property property">port</span><span class="token operator">:</span> channel<span class="token punctuation">.</span>port2 <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>channel<span class="token punctuation">.</span>port2<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Use the port1 to send a string.</span>
<span class="token comment">// (we can send and transfer basic types/objects).</span>
channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">"A message for the worker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div> <p> In the worker the port is available as <code>event.transformer.options.port</code>. The code below shows how you might listen on the port's <code>message</code> event to get messages from the main thread. You can also use the port to send messages back to the main thread. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="Dmn+Iqd7yLRSfmwBHAolXo/gdgOkgb9zbPEOQX0WEq8=" data-language="js">event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>options<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// The message payload is in 'event.data';</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre>
</div>
</div>
<h3 id="triggering_a_key_frame">Triggering a key frame</h3>
<div class="section-content">
<p> Raw video is rarely sent or stored because it consumes a lot of space and bandwidth to represent each frame as a complete image. Instead, codecs periodically generate a "key frame" that contains enough infomation to construct a full image, and between key frames sends "delta frames" that just include the changes since the last delta frame. While this is far more efficient that sending raw video, it means that in order to display the image associated with a particular delta frame, you need the last key frame and all subsequent delta frames. </p> <p> This can cause a delay for new users joining a WebRTC conference application, because they can't display video until they have received their first key frame. Similarly, if an encoded transform was used to encrypt frames, the recipient would not be able to display video until they get the first key frame encrypted with their key. </p> <p>In order to ensure that a new key frame can be sent as early as possible when needed, the <a href="../rtcrtpscripttransformer"><code>RTCRtpScriptTransformer</code></a> object in <code>event.transformer</code> has two methods: <a href="../rtcrtpscripttransformer/generatekeyframe"><code>RTCRtpScriptTransformer.generateKeyFrame()</code></a>, which causes the codec to generate a key frame, and <a href="../rtcrtpscripttransformer/sendkeyframerequest"><code>RTCRtpScriptTransformer.sendKeyFrameRequest()</code></a>, which a receiver can use to request a key frame from the sender.</p> <p> The example below shows how the main thread might pass an encryption key to a sender transform, and trigger the codec to generate a key frame. Note that the main thread doesn't have direct access to the <a href="../rtcrtpscripttransformer"><code>RTCRtpScriptTransformer</code></a> object, so it needs to pass the key and restriction identifier ("rid") to the worker (the "rid" is a stream id, which indicates the encoder that must generat the key frame). Here we do that with a <code>MessageChannel</code>, using the same pattern as in the previous section. The code assumes there is already a peer connection, and that <code>videoSender</code> is an <a href="../rtcrtpsender"><code>RTCRtpSender</code></a>. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="sIeAhk/TW8zIywcFHh/fEtVm5sxhjHc6Z66OBeuhGkY=" data-language="js"><span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">"worker.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

videoSender<span class="token punctuation">.</span>transform <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RTCRtpScriptTransform</span><span class="token punctuation">(</span>
  worker<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"senderTransform"</span><span class="token punctuation">,</span> <span class="token literal-property property">port</span><span class="token operator">:</span> channel<span class="token punctuation">.</span>port2 <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>channel<span class="token punctuation">.</span>port2<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Post rid and new key to the sender</span>
channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">rid</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">"93ae0927a4f8e527f1gce6d10bc6ab6c"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div> <p> The <a href="../dedicatedworkerglobalscope/rtctransform_event"><code>rtctransform</code></a> event handler in the worker gets the port and uses it to listen for <code>message</code> events from the main thread. If an event is received it gets the <code>rid</code> and <code>key</code>, and then calls <code>generateKeyFrame()</code>. </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="keFPFp4+qzcjK4MkFErYS/ZGwUw9tYdNFKwSnPlxdns=" data-language="js">event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>options<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> rid<span class="token punctuation">,</span> key <span class="token punctuation">}</span> <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token comment">// key is used by the transformer to encrypt frames (not shown)</span>

  <span class="token comment">// Get codec to generate a new key frame using the rid</span>
  <span class="token comment">// Here 'rcevent' is the rtctransform event.</span>
  rcevent<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span><span class="token function">generateKeyFrame</span><span class="token punctuation">(</span>rid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre>
</div> <p> The code for a receiver to request a new key frame would be almost identical, except that "rid" isn't specified. Here is the code for just the port message handler: </p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="5LPvz8MWlOR6QdZjkGJeRSEtkjf7IYzQ3ia7D9Lff7Q=" data-language="js">event<span class="token punctuation">.</span>transformer<span class="token punctuation">.</span>options<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> key <span class="token punctuation">}</span> <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token comment">// key is used by the transformer to decrypt frames (not shown)</span>

  <span class="token comment">// Request sender to emit a key frame.</span>
  transformer<span class="token punctuation">.</span><span class="token function">sendKeyFrameRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre>
</div>
</div>
<h2 id="browser_compatibility">Browser compatibility</h2>
<div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="6">Desktop</th>
<th colspan="6">Mobile</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
<th>WebView Android</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
</tr>
</thead>
<tbody><tr>
<th><code>Using_Encoded_Transforms</code></th>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes">117</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes">15.4</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes">117</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes">15.4</td>
<td class="bc-supports-no">No</td>
</tr></tbody>
</table></div>
<h2 id="see_also">See also</h2>
<div class="section-content"><ul> <li><a href="../rtcrtpscripttransform"><code>RTCRtpScriptTransform</code></a></li> <li><a href="../rtcrtpreceiver/transform"><code>RTCRtpReceiver.transform</code></a></li> <li><a href="../rtcrtpsender/transform"><code>RTCRtpSender.transform</code></a></li> <li><a href="../dedicatedworkerglobalscope/rtctransform_event"><code>DedicatedWorkerGlobalScope.rtctransform_event</code></a></li> <li><a href="../rtctransformevent"><code>RTCTransformEvent</code></a></li> <li><a href="../rtcrtpscripttransformer"><code>RTCRtpScriptTransformer</code></a></li> <li><a href="../rtcencodedvideoframe"><code>RTCEncodedVideoFrame</code></a></li> <li><a href="../rtcencodedaudioframe"><code>RTCEncodedAudioFrame</code></a></li> </ul></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2005–2023 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
