
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Extensions - Jinja 2.11 - W3cubDocs</title>
  
  <meta name="description" content="Jinja supports extensions that can add extra filters, tests, globals or even extend the parser. The main motivation of extensions is to move often &hellip;">
  <meta name="keywords" content="extensions, jinja, jinja~2.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/jinja~2.11/extensions/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c7076d7cdaddc6969cb97911f9b488459d4bebca88d6f2525f2a12432f0bec8426c751ccfbc34920dda3867e50ab24698396bc4e548e788fc826f69a158d6856.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/jinja~2.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/jinja~2.11/" class="_nav-link" title="" style="margin-left:0;">Jinja 2.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="jinja-extensions">Extensions</h1> <p>Jinja supports extensions that can add extra filters, tests, globals or even extend the parser. The main motivation of extensions is to move often used code into a reusable class like adding support for internationalization.</p>  <h2 id="adding-extensions">Adding Extensions</h2> <p>Extensions are added to the Jinja environment at creation time. Once the environment is created additional extensions cannot be added. To add an extension pass a list of extension classes or import paths to the <code>extensions</code> parameter of the <a class="reference internal" href="../api/index#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a> constructor. The following example creates a Jinja environment with the i18n extension loaded:</p> <pre data-language="python">jinja_env = Environment(extensions=['jinja2.ext.i18n'])
</pre>   <h2 id="id1">i18n Extension</h2> <p id="i18n-extension"><strong>Import name:</strong> <code>jinja2.ext.i18n</code></p> <p>The i18n extension can be used in combination with <a class="reference external" href="https://docs.python.org/3/library/gettext.html">gettext</a> or <a class="reference external" href="http://babel.pocoo.org/">Babel</a>. When it’s enabled, Jinja provides a <code>trans</code> statement that marks a block as translatable and calls <code>gettext</code>.</p> <p>After enabling, an application has to provide <code>gettext</code> and <code>ngettext</code> functions, either globally or when rendering. A <code>_()</code> function is added as an alias to the <code>gettext</code> function.</p>  <h3 id="environment-methods">Environment Methods</h3> <p>After enabling the extension, the environment provides the following additional methods:</p> <dl class="method"> <dt id="jinja2.Environment.install_gettext_translations">
<code>jinja2.Environment.install_gettext_translations(translations, newstyle=False)</code> </dt> <dd>
<p>Installs a translation globally for the environment. The <code>translations</code> object must implement <code>gettext</code> and <code>ngettext</code> (or <code>ugettext</code> and <code>ungettext</code> for Python 2). <a class="reference external" href="https://docs.python.org/3/library/gettext.html#gettext.NullTranslations" title="(in Python v3.8)"><code>gettext.NullTranslations</code></a>, <a class="reference external" href="https://docs.python.org/3/library/gettext.html#gettext.GNUTranslations" title="(in Python v3.8)"><code>gettext.GNUTranslations</code></a>, and <a class="reference external" href="http://babel.pocoo.org/">Babel</a>s <code>Translations</code> are supported.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span>Added new-style gettext support.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.install_null_translations">
<code>jinja2.Environment.install_null_translations(newstyle=False)</code> </dt> <dd>
<p>Install no-op gettext functions. This is useful if you want to prepare the application for internationalization but don’t want to implement the full system yet.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span>Added new-style gettext support.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.install_gettext_callables">
<code>jinja2.Environment.install_gettext_callables(gettext, ngettext, newstyle=False)</code> </dt> <dd>
<p>Install the given <code>gettext</code> and <code>ngettext</code> callables into the environment. They should behave exactly like <a class="reference external" href="https://docs.python.org/3/library/gettext.html#gettext.gettext" title="(in Python v3.8)"><code>gettext.gettext()</code></a> and <a class="reference external" href="https://docs.python.org/3/library/gettext.html#gettext.ngettext" title="(in Python v3.8)"><code>gettext.ngettext()</code></a> (or <code>ugettext</code> and <code>ungettext</code> for Python 2).</p> <p>If <code>newstyle</code> is activated, the callables are wrapped to work like newstyle callables. See <a class="reference internal" href="#newstyle-gettext"><span class="std std-ref">New Style Gettext</span></a> for more information.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.5: </span>Added new-style gettext support.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.uninstall_gettext_translations">
<code>jinja2.Environment.uninstall_gettext_translations()</code> </dt> <dd>
<p>Uninstall the environment’s globally installed translation.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.extract_translations">
<code>jinja2.Environment.extract_translations(source)</code> </dt> <dd>
<p>Extract localizable strings from the given template node or source.</p> <p>For every string found this function yields a <code>(lineno, function,
message)</code> tuple, where:</p> <ul class="simple"> <li>
<code>lineno</code> is the number of the line on which the string was found.</li> <li>
<code>function</code> is the name of the <code>gettext</code> function used (if the string was extracted from embedded Python code).</li> <li>
<code>message</code> is the string itself (<code>unicode</code> on Python 2), or a tuple of strings for functions with multiple arguments.</li> </ul> <p>If <a class="reference external" href="http://babel.pocoo.org/">Babel</a> is installed, see <a class="reference internal" href="https://jinja.palletsprojects.com/en/2.11.x/integration/#babel-integration"><span class="std std-ref">Babel Integration</span></a> to extract the strings.</p> </dd>
</dl> <p>For a web application that is available in multiple languages but gives all the users the same language (for example, multilingual forum software installed for a French community), the translation may be installed when the environment is created.</p> <pre data-language="python">translations = get_gettext_translations()
env = Environment(extensions=["jinja2.ext.i18n"])
env.install_gettext_translations(translations)
</pre> <p>The <code>get_gettext_translations</code> function would return the translator for the current configuration, for example by using <code>gettext.find</code>.</p> <p>The usage of the <code>i18n</code> extension for template designers is covered in <a class="reference internal" href="../templates/index#i18n-in-templates"><span class="std std-ref">the template documentation</span></a>.</p>   <h3 id="whitespace-trimming">Whitespace Trimming</h3> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.10.</span></p> </div> </details><p>Within <code>{% trans %}</code> blocks, it can be useful to trim line breaks and whitespace so that the block of text looks like a simple string with single spaces in the translation file.</p> <p>Linebreaks and surrounding whitespace can be automatically trimmed by enabling the <code>ext.i18n.trimmed</code> <a class="reference internal" href="../api/index#ext-i18n-trimmed"><span class="std std-ref">policy</span></a>.</p>   <h3 id="newstyle-gettext">New Style Gettext</h3> <details class="changelog" id="new-style-gettext"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> </details><p>New style gettext calls are less to type, less error prone, and support autoescaping better.</p> <p>You can use “new style” gettext calls by setting <code>env.newstyle_gettext = True</code> or passing <code>newstyle=True</code> to <code>env.install_translations</code>. They are fully supported by the Babel extraction tool, but might not work as expected with other extraction tools.</p> <p>With standard <code>gettext</code> calls, string formatting is a separate step done with the <code>|format</code> filter. This requires duplicating work for <code>ngettext</code> calls.</p> <pre data-language="jinja">{{ gettext("Hello, World!") }}
{{ gettext("Hello, %(name)s!")|format(name=name) }}
{{ ngettext(
       "%(num)d apple", "%(num)d apples", apples|count
   )|format(num=apples|count) }}
</pre> <p>New style <code>gettext</code> make formatting part of the call, and behind the scenes enforce more consistency.</p> <pre data-language="jinja">{{ gettext("Hello, World!") }}
{{ gettext("Hello, %(name)s!", name=name) }}
{{ ngettext("%(num)d apple", "%(num)d apples", apples|count) }}
</pre> <p>The advantages of newstyle gettext are:</p> <ul class="simple"> <li>There’s no separate formatting step, you don’t have to remember to use the <code>|format</code> filter.</li> <li>Only named placeholders are allowed. This solves a common problem translators face because positional placeholders can’t switch positions meaningfully. Named placeholders always carry semantic information about what value goes where.</li> <li>String formatting is used even if no placeholders are used, which makes all strings use a consistent format. Remember to escape any raw percent signs as <code>%%</code>, such as <code>100%%</code>.</li> <li>The translated string is marked safe, formatting performs escaping as needed. Mark a parameter as <code>|safe</code> if it has already been escaped.</li> </ul>    <h2 id="expression-statement">Expression Statement</h2> <p><strong>Import name:</strong> <code>jinja2.ext.do</code></p> <p>The “do” aka expression-statement extension adds a simple <code>do</code> tag to the template engine that works like a variable expression but ignores the return value.</p>   <h2 id="loopcontrols-extension">Loop Controls</h2> <p id="loop-controls"><strong>Import name:</strong> <code>jinja2.ext.loopcontrols</code></p> <p>This extension adds support for <code>break</code> and <code>continue</code> in loops. After enabling, Jinja provides those two keywords which work exactly like in Python.</p>   <h2 id="with-extension">With Statement</h2> <p id="with-statement"><strong>Import name:</strong> <code>jinja2.ext.with_</code></p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.9: </span>This extension is now built-in and no longer does anything.</p> </div> </details>  <h2 id="id2">Autoescape Extension</h2> <p id="autoescape-extension"><strong>Import name:</strong> <code>jinja2.ext.autoescape</code></p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.9: </span>This extension was removed and is now built-in. Enabling the extension no longer does anything.</p> </div> </details>  <h2 id="id3">Debug Extension</h2> <p id="debug-extension"><strong>Import name:</strong> <code>jinja2.ext.debug</code></p> <p>Adds a <code>{% debug %}</code> tag to dump the current context as well as the available filters and tests. This is useful to see what’s available to use in the template without setting up a debugger.</p>   <h2 id="writing-extensions">Writing Extensions</h2> <p id="module-jinja2.ext">By writing extensions you can add custom tags to Jinja. This is a non-trivial task and usually not needed as the default tags and expressions cover all common use cases. The i18n extension is a good example of why extensions are useful. Another one would be fragment caching.</p> <p>When writing extensions you have to keep in mind that you are working with the Jinja template compiler which does not validate the node tree you are passing to it. If the AST is malformed you will get all kinds of compiler or runtime errors that are horrible to debug. Always make sure you are using the nodes you create correctly. The API documentation below shows which nodes exist and how to use them.</p>   <h2 id="example-extensions">Example Extensions</h2>  <h3 id="cache">Cache</h3> <p>The following example implements a <code>cache</code> tag for Jinja by using the <a class="reference external" href="https://github.com/pallets/cachelib">cachelib</a> library:</p> <pre data-language="python">from jinja2 import nodes
from jinja2.ext import Extension


class FragmentCacheExtension(Extension):
    # a set of names that trigger the extension.
    tags = {"cache"}

    def __init__(self, environment):
        super(FragmentCacheExtension, self).__init__(environment)

        # add the defaults to the environment
        environment.extend(fragment_cache_prefix="", fragment_cache=None)

    def parse(self, parser):
        # the first token is the token that started the tag.  In our case
        # we only listen to ``'cache'`` so this will be a name token with
        # `cache` as value.  We get the line number so that we can give
        # that line number to the nodes we create by hand.
        lineno = next(parser.stream).lineno

        # now we parse a single expression that is used as cache key.
        args = [parser.parse_expression()]

        # if there is a comma, the user provided a timeout.  If not use
        # None as second parameter.
        if parser.stream.skip_if("comma"):
            args.append(parser.parse_expression())
        else:
            args.append(nodes.Const(None))

        # now we parse the body of the cache block up to `endcache` and
        # drop the needle (which would always be `endcache` in that case)
        body = parser.parse_statements(["name:endcache"], drop_needle=True)

        # now return a `CallBlock` node that calls our _cache_support
        # helper method on this extension.
        return nodes.CallBlock(
            self.call_method("_cache_support", args), [], [], body
        ).set_lineno(lineno)

    def _cache_support(self, name, timeout, caller):
        """Helper callback."""
        key = self.environment.fragment_cache_prefix + name

        # try to load the block from the cache
        # if there is no fragment in the cache, render it and store
        # it in the cache.
        rv = self.environment.fragment_cache.get(key)
        if rv is not None:
            return rv
        rv = caller()
        self.environment.fragment_cache.add(key, rv, timeout)
        return rv
</pre> <p>And here is how you use it in an environment:</p> <pre data-language="python">from jinja2 import Environment
from cachelib import SimpleCache

env = Environment(extensions=[FragmentCacheExtension])
env.fragment_cache = SimpleCache()
</pre> <p>Inside the template it’s then possible to mark blocks as cacheable. The following example caches a sidebar for 300 seconds:</p> <pre data-language="html">{% cache 'sidebar', 300 %}
&lt;div class="sidebar"&gt;
    ...
&lt;/div&gt;
{% endcache %}
</pre>   <h3 id="inline-gettext">Inline <code>gettext</code>
</h3> <p>The following example demonstrates using <a class="reference internal" href="#jinja2.ext.Extension.filter_stream" title="jinja2.ext.Extension.filter_stream"><code>Extension.filter_stream()</code></a> to parse calls to the <code>_()</code> gettext function inline with static data without needing Jinja blocks.</p> <pre data-language="html">&lt;h1&gt;_(Welcome)&lt;/h1&gt;
&lt;p&gt;_(This is a paragraph)&lt;/p&gt;
</pre> <p>It requires the i18n extension to be loaded and configured.</p> <pre data-language="python"># -*- coding: utf-8 -*-
import re

from jinja2.exceptions import TemplateSyntaxError
from jinja2.ext import Extension
from jinja2.lexer import count_newlines
from jinja2.lexer import Token


_outside_re = re.compile(r"\\?(gettext|_)\(")
_inside_re = re.compile(r"\\?[()]")


class InlineGettext(Extension):
    """This extension implements support for inline gettext blocks::

        &lt;h1&gt;_(Welcome)&lt;/h1&gt;
        &lt;p&gt;_(This is a paragraph)&lt;/p&gt;

    Requires the i18n extension to be loaded and configured.
    """

    def filter_stream(self, stream):
        paren_stack = 0

        for token in stream:
            if token.type != "data":
                yield token
                continue

            pos = 0
            lineno = token.lineno

            while 1:
                if not paren_stack:
                    match = _outside_re.search(token.value, pos)
                else:
                    match = _inside_re.search(token.value, pos)
                if match is None:
                    break
                new_pos = match.start()
                if new_pos &gt; pos:
                    preval = token.value[pos:new_pos]
                    yield Token(lineno, "data", preval)
                    lineno += count_newlines(preval)
                gtok = match.group()
                if gtok[0] == "\\":
                    yield Token(lineno, "data", gtok[1:])
                elif not paren_stack:
                    yield Token(lineno, "block_begin", None)
                    yield Token(lineno, "name", "trans")
                    yield Token(lineno, "block_end", None)
                    paren_stack = 1
                else:
                    if gtok == "(" or paren_stack &gt; 1:
                        yield Token(lineno, "data", gtok)
                    paren_stack += gtok == ")" and -1 or 1
                    if not paren_stack:
                        yield Token(lineno, "block_begin", None)
                        yield Token(lineno, "name", "endtrans")
                        yield Token(lineno, "block_end", None)
                pos = match.end()

            if pos &lt; len(token.value):
                yield Token(lineno, "data", token.value[pos:])

        if paren_stack:
            raise TemplateSyntaxError(
                "unclosed gettext expression",
                token.lineno,
                stream.name,
                stream.filename,
            )
</pre>    <h2 id="extension-api">Extension API</h2>  <h3 id="extension">Extension</h3> <p>Extensions always have to extend the <a class="reference internal" href="#jinja2.ext.Extension" title="jinja2.ext.Extension"><code>jinja2.ext.Extension</code></a> class:</p> <dl class="class"> <dt id="jinja2.ext.Extension">
<code>class jinja2.ext.Extension(environment)</code> </dt> <dd>
<p>Extensions can be used to add extra functionality to the Jinja template system at the parser level. Custom extensions are bound to an environment but may not store environment specific data on <code>self</code>. The reason for this is that an extension can be bound to another environment (for overlays) by creating a copy and reassigning the <code>environment</code> attribute.</p> <p>As extensions are created by the environment they cannot accept any arguments for configuration. One may want to work around that by using a factory function, but that is not possible as extensions are identified by their import name. The correct way to configure the extension is storing the configuration values on the environment. Because this way the environment ends up acting as central configuration storage the attributes may clash which is why extensions have to ensure that the names they choose for configuration are not too generic. <code>prefix</code> for example is a terrible name, <code>fragment_cache_prefix</code> on the other hand is a good name as includes the name of the extension (fragment cache).</p> <dl class="attribute"> <dt id="jinja2.ext.Extension.identifier">
<code>identifier</code> </dt> <dd>
<p>The identifier of the extension. This is always the true import name of the extension class and must not be changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.ext.Extension.tags">
<code>tags</code> </dt> <dd>
<p>If the extension implements custom tags this is a set of tag names the extension is listening for.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.ext.Extension.attr">
<code>attr(name, lineno=None)</code> </dt> <dd>
<p>Return an attribute node for the current extension. This is useful to pass constants on extensions to generated template code.</p> <pre data-language="python">self.attr('_my_attribute', lineno=lineno)
</pre> </dd>
</dl> <dl class="method"> <dt id="jinja2.ext.Extension.call_method">
<code>call_method(name, args=None, kwargs=None, dyn_args=None, dyn_kwargs=None, lineno=None)</code> </dt> <dd>
<p>Call a method of the extension. This is a shortcut for <a class="reference internal" href="../templates/index#attr" title="attr"><code>attr()</code></a> + <a class="reference internal" href="#jinja2.nodes.Call" title="jinja2.nodes.Call"><code>jinja2.nodes.Call</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.ext.Extension.filter_stream">
<code>filter_stream(stream)</code> </dt> <dd>
<p>It’s passed a <a class="reference internal" href="#jinja2.lexer.TokenStream" title="jinja2.lexer.TokenStream"><code>TokenStream</code></a> that can be used to filter tokens returned. This method has to return an iterable of <a class="reference internal" href="#jinja2.lexer.Token" title="jinja2.lexer.Token"><code>Token</code></a>s, but it doesn’t have to return a <a class="reference internal" href="#jinja2.lexer.TokenStream" title="jinja2.lexer.TokenStream"><code>TokenStream</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.ext.Extension.parse">
<code>parse(parser)</code> </dt> <dd>
<p>If any of the <a class="reference internal" href="#jinja2.ext.Extension.tags" title="jinja2.ext.Extension.tags"><code>tags</code></a> matched this method is called with the parser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.ext.Extension.preprocess">
<code>preprocess(source, name, filename=None)</code> </dt> <dd>
<p>This method is called before the actual lexing and can be used to preprocess the source. The <code>filename</code> is optional. The return value must be the preprocessed source.</p> </dd>
</dl> </dd>
</dl>   <h3 id="parser">Parser</h3> <p>The parser passed to <a class="reference internal" href="#jinja2.ext.Extension.parse" title="jinja2.ext.Extension.parse"><code>Extension.parse()</code></a> provides ways to parse expressions of different types. The following methods may be used by extensions:</p> <dl class="class"> <dt id="jinja2.parser.Parser">
<code>class jinja2.parser.Parser(environment, source, name=None, filename=None, state=None)</code> </dt> <dd>
<p>This is the central parsing class Jinja uses. It’s passed to extensions and can be used to parse expressions or statements.</p> <dl class="attribute"> <dt id="jinja2.parser.Parser.filename">
<code>filename</code> </dt> <dd>
<p>The filename of the template the parser processes. This is <strong>not</strong> the load name of the template. For the load name see <a class="reference internal" href="#jinja2.parser.Parser.name" title="jinja2.parser.Parser.name"><code>name</code></a>. For templates that were not loaded form the file system this is <code>None</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.parser.Parser.name">
<code>name</code> </dt> <dd>
<p>The load name of the template.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.parser.Parser.stream">
<code>stream</code> </dt> <dd>
<p>The current <a class="reference internal" href="#jinja2.lexer.TokenStream" title="jinja2.lexer.TokenStream"><code>TokenStream</code></a></p> </dd>
</dl> <dl class="method"> <dt id="jinja2.parser.Parser.fail">
<code>fail(msg, lineno=None, exc=&lt;class 'jinja2.exceptions.TemplateSyntaxError'&gt;)</code> </dt> <dd>
<p>Convenience method that raises <code>exc</code> with the message, passed line number or last line number as well as the current name and filename.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.parser.Parser.free_identifier">
<code>free_identifier(lineno=None)</code> </dt> <dd>
<p>Return a new free identifier as <a class="reference internal" href="#jinja2.nodes.InternalName" title="jinja2.nodes.InternalName"><code>InternalName</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.parser.Parser.parse_assign_target">
<code>parse_assign_target(with_tuple=True, name_only=False, extra_end_rules=None, with_namespace=False)</code> </dt> <dd>
<p>Parse an assignment target. As Jinja allows assignments to tuples, this function can parse all allowed assignment targets. Per default assignments to tuples are parsed, that can be disable however by setting <code>with_tuple</code> to <code>False</code>. If only assignments to names are wanted <code>name_only</code> can be set to <code>True</code>. The <code>extra_end_rules</code> parameter is forwarded to the tuple parsing function. If <code>with_namespace</code> is enabled, a namespace assignment may be parsed.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.parser.Parser.parse_expression">
<code>parse_expression(with_condexpr=True)</code> </dt> <dd>
<p>Parse an expression. Per default all expressions are parsed, if the optional <code>with_condexpr</code> parameter is set to <code>False</code> conditional expressions are not parsed.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.parser.Parser.parse_statements">
<code>parse_statements(end_tokens, drop_needle=False)</code> </dt> <dd>
<p>Parse multiple statements into a list until one of the end tokens is reached. This is used to parse the body of statements as it also parses template data if appropriate. The parser checks first if the current token is a colon and skips it if there is one. Then it checks for the block end and parses until if one of the <code>end_tokens</code> is reached. Per default the active token in the stream at the end of the call is the matched end token. If this is not wanted <code>drop_needle</code> can be set to <code>True</code> and the end token is removed.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.parser.Parser.parse_tuple">
<code>parse_tuple(simplified=False, with_condexpr=True, extra_end_rules=None, explicit_parentheses=False)</code> </dt> <dd>
<p>Works like <code>parse_expression</code> but if multiple expressions are delimited by a comma a <a class="reference internal" href="#jinja2.nodes.Tuple" title="jinja2.nodes.Tuple"><code>Tuple</code></a> node is created. This method could also return a regular expression instead of a tuple if no commas where found.</p> <p>The default parsing mode is a full tuple. If <code>simplified</code> is <code>True</code> only names and literals are parsed. The <code>no_condexpr</code> parameter is forwarded to <a class="reference internal" href="#jinja2.parser.Parser.parse_expression" title="jinja2.parser.Parser.parse_expression"><code>parse_expression()</code></a>.</p> <p>Because tuples do not require delimiters and may end in a bogus comma an extra hint is needed that marks the end of a tuple. For example for loops support tuples between <code>for</code> and <code>in</code>. In that case the <code>extra_end_rules</code> is set to <code>['name:in']</code>.</p> <p><code>explicit_parentheses</code> is true if the parsing was triggered by an expression in parentheses. This is used to figure out if an empty tuple is a valid expression or not.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.lexer.TokenStream">
<code>class jinja2.lexer.TokenStream(generator, name, filename)</code> </dt> <dd>
<p>A token stream is an iterable that yields <a class="reference internal" href="#jinja2.lexer.Token" title="jinja2.lexer.Token"><code>Token</code></a>s. The parser however does not iterate over it but calls <code>next()</code> to go one token ahead. The current active token is stored as <a class="reference internal" href="#jinja2.lexer.TokenStream.current" title="jinja2.lexer.TokenStream.current"><code>current</code></a>.</p> <dl class="attribute"> <dt id="jinja2.lexer.TokenStream.current">
<code>current</code> </dt> <dd>
<p>The current <a class="reference internal" href="#jinja2.lexer.Token" title="jinja2.lexer.Token"><code>Token</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.__next__">
<code>__next__()</code> </dt> <dd>
<p>Go one token ahead and return the old one.</p> <p>Use the built-in <a class="reference external" href="https://docs.python.org/3/library/functions.html#next" title="(in Python v3.8)"><code>next()</code></a> instead of calling this directly.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.eos">
<code>property eos</code> </dt> <dd>
<p>Are we at the end of the stream?</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.expect">
<code>expect(expr)</code> </dt> <dd>
<p>Expect a given token type and return it. This accepts the same argument as <a class="reference internal" href="#jinja2.lexer.Token.test" title="jinja2.lexer.Token.test"><code>jinja2.lexer.Token.test()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.look">
<code>look()</code> </dt> <dd>
<p>Look at the next token.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.next_if">
<code>next_if(expr)</code> </dt> <dd>
<p>Perform the token test and return the token if it matched. Otherwise the return value is <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.push">
<code>push(token)</code> </dt> <dd>
<p>Push a token back to the stream.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.skip">
<code>skip(n=1)</code> </dt> <dd>
<p>Got n tokens ahead.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.TokenStream.skip_if">
<code>skip_if(expr)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#jinja2.lexer.TokenStream.next_if" title="jinja2.lexer.TokenStream.next_if"><code>next_if()</code></a> but only returns <code>True</code> or <code>False</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.lexer.Token">
<code>class jinja2.lexer.Token</code> </dt> <dd>
<p>Token class.</p> <dl class="attribute"> <dt id="jinja2.lexer.Token.lineno">
<code>lineno</code> </dt> <dd>
<p>The line number of the token</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.lexer.Token.type">
<code>type</code> </dt> <dd>
<p>The type of the token. This string is interned so you may compare it with arbitrary strings using the <code>is</code> operator.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.lexer.Token.value">
<code>value</code> </dt> <dd>
<p>The value of the token.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.Token.test">
<code>test(expr)</code> </dt> <dd>
<p>Test a token against a token expression. This can either be a token type or <code>'token_type:token_value'</code>. This can only test against string values and types.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.lexer.Token.test_any">
<code>test_any(*iterable)</code> </dt> <dd>
<p>Test against multiple token expressions.</p> </dd>
</dl> </dd>
</dl> <p>There is also a utility function in the lexer module that can count newline characters in strings:</p> <dl class="function"> <dt id="jinja2.lexer.count_newlines">
<code>jinja2.lexer.count_newlines(value)</code> </dt> <dd>
<p>Count the number of newline characters in the string. This is useful for extensions that filter a stream.</p> </dd>
</dl>   <h3 id="ast">AST</h3> <p>The AST (Abstract Syntax Tree) is used to represent a template after parsing. It’s build of nodes that the compiler then converts into executable Python code objects. Extensions that provide custom statements can return nodes to execute custom Python code.</p> <p>The list below describes all nodes that are currently available. The AST may change between Jinja versions but will stay backwards compatible.</p> <p>For more information have a look at the repr of <a class="reference internal" href="../api/index#jinja2.Environment.parse" title="jinja2.Environment.parse"><code>jinja2.Environment.parse()</code></a>.</p> <dl class="class" id="module-jinja2.nodes"> <dt id="jinja2.nodes.Node">
<code>class jinja2.nodes.Node</code> </dt> <dd>
<p>Baseclass for all Jinja nodes. There are a number of nodes available of different types. There are four major types:</p> <ul class="simple"> <li>
<a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a>: statements</li> <li>
<a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a>: expressions</li> <li>
<a class="reference internal" href="#jinja2.nodes.Helper" title="jinja2.nodes.Helper"><code>Helper</code></a>: helper nodes</li> <li>
<a class="reference internal" href="#jinja2.nodes.Template" title="jinja2.nodes.Template"><code>Template</code></a>: the outermost wrapper node</li> </ul> <p>All nodes have fields and attributes. Fields may be other nodes, lists, or arbitrary values. Fields are passed to the constructor as regular positional arguments, attributes as keyword arguments. Each node has two attributes: <code>lineno</code> (the line number of the node) and <code>environment</code>. The <code>environment</code> attribute is set at the end of the parsing process for all nodes automatically.</p> <dl class="method"> <dt id="jinja2.nodes.Node.find">
<code>find(node_type)</code> </dt> <dd>
<p>Find the first node of a given type. If no such node exists the return value is <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.nodes.Node.find_all">
<code>find_all(node_type)</code> </dt> <dd>
<p>Find all the nodes of a given type. If the type is a tuple, the check is performed for any of the tuple items.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.nodes.Node.iter_child_nodes">
<code>iter_child_nodes(exclude=None, only=None)</code> </dt> <dd>
<p>Iterates over all direct child nodes of the node. This iterates over all fields and yields the values of they are nodes. If the value of a field is a list all the nodes in that list are returned.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.nodes.Node.iter_fields">
<code>iter_fields(exclude=None, only=None)</code> </dt> <dd>
<p>This method iterates over all fields that are defined and yields <code>(key, value)</code> tuples. Per default all fields are returned, but it’s possible to limit that to some fields by providing the <code>only</code> parameter or to exclude some using the <code>exclude</code> parameter. Both should be sets or tuples of field names.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.nodes.Node.set_ctx">
<code>set_ctx(ctx)</code> </dt> <dd>
<p>Reset the context of a node and all child nodes. Per default the parser will all generate nodes that have a ‘load’ context as it’s the most common one. This method is used in the parser to set assignment targets and other nodes to a store context.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.nodes.Node.set_environment">
<code>set_environment(environment)</code> </dt> <dd>
<p>Set the environment for all nodes.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.nodes.Node.set_lineno">
<code>set_lineno(lineno, override=False)</code> </dt> <dd>
<p>Set the line numbers of the node and children.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Expr">
<code>class jinja2.nodes.Expr</code> </dt> <dd>
<p>Baseclass for all expressions.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Node" title="jinja2.nodes.Node"><code>Node</code></a></p> </dd> </dl> <dl class="method"> <dt id="jinja2.nodes.Expr.as_const">
<code>as_const(eval_ctx=None)</code> </dt> <dd>
<p>Return the value of the expression as constant or raise <a class="reference internal" href="#jinja2.nodes.Impossible" title="jinja2.nodes.Impossible"><code>Impossible</code></a> if this was not possible.</p> <p>An <a class="reference internal" href="../api/index#jinja2.nodes.EvalContext" title="jinja2.nodes.EvalContext"><code>EvalContext</code></a> can be provided, if none is given a default context is created which requires the nodes to have an attached environment.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span>the <code>eval_ctx</code> parameter was added.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.nodes.Expr.can_assign">
<code>can_assign()</code> </dt> <dd>
<p>Check if it’s possible to assign something to this node.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.BinExpr">
<code>class jinja2.nodes.BinExpr(left, right)</code> </dt> <dd>
<p>Baseclass for all binary expressions.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Add">
<code>class jinja2.nodes.Add(left, right)</code> </dt> <dd>
<p>Add the left to the right node.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.And">
<code>class jinja2.nodes.And(left, right)</code> </dt> <dd>
<p>Short circuited AND.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Div">
<code>class jinja2.nodes.Div(left, right)</code> </dt> <dd>
<p>Divides the left by the right node.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.FloorDiv">
<code>class jinja2.nodes.FloorDiv(left, right)</code> </dt> <dd>
<p>Divides the left by the right node and truncates conver the result into an integer by truncating.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Mod">
<code>class jinja2.nodes.Mod(left, right)</code> </dt> <dd>
<p>Left modulo right.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Mul">
<code>class jinja2.nodes.Mul(left, right)</code> </dt> <dd>
<p>Multiplies the left with the right node.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Or">
<code>class jinja2.nodes.Or(left, right)</code> </dt> <dd>
<p>Short circuited OR.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Pow">
<code>class jinja2.nodes.Pow(left, right)</code> </dt> <dd>
<p>Left to the power of right.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Sub">
<code>class jinja2.nodes.Sub(left, right)</code> </dt> <dd>
<p>Subtract the right from the left node.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.BinExpr" title="jinja2.nodes.BinExpr"><code>BinExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Call">
<code>class jinja2.nodes.Call(node, args, kwargs, dyn_args, dyn_kwargs)</code> </dt> <dd>
<p>Calls an expression. <code>args</code> is a list of arguments, <code>kwargs</code> a list of keyword arguments (list of <a class="reference internal" href="#jinja2.nodes.Keyword" title="jinja2.nodes.Keyword"><code>Keyword</code></a> nodes), and <code>dyn_args</code> and <code>dyn_kwargs</code> has to be either <code>None</code> or a node that is used as node for dynamic positional (<code>*args</code>) or keyword (<code>**kwargs</code>) arguments.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Compare">
<code>class jinja2.nodes.Compare(expr, ops)</code> </dt> <dd>
<p>Compares an expression with some other expressions. <code>ops</code> must be a list of <a class="reference internal" href="#jinja2.nodes.Operand" title="jinja2.nodes.Operand"><code>Operand</code></a>s.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Concat">
<code>class jinja2.nodes.Concat(nodes)</code> </dt> <dd>
<p>Concatenates the list of expressions provided after converting them to unicode.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.CondExpr">
<code>class jinja2.nodes.CondExpr(test, expr1, expr2)</code> </dt> <dd>
<p>A conditional expression (inline if expression). (<code>{{
foo if bar else baz }}</code>)</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.ContextReference">
<code>class jinja2.nodes.ContextReference</code> </dt> <dd>
<p>Returns the current template context. It can be used like a <a class="reference internal" href="#jinja2.nodes.Name" title="jinja2.nodes.Name"><code>Name</code></a> node, with a <code>'load'</code> ctx and will return the current <a class="reference internal" href="../api/index#jinja2.runtime.Context" title="jinja2.runtime.Context"><code>Context</code></a> object.</p> <p>Here an example that assigns the current template name to a variable named <code>foo</code>:</p> <pre data-language="python">Assign(Name('foo', ctx='store'),
       Getattr(ContextReference(), 'name'))
</pre> <p>This is basically equivalent to using the <a class="reference internal" href="../api/index#jinja2.contextfunction" title="jinja2.contextfunction"><code>contextfunction()</code></a> decorator when using the high-level API, which causes a reference to the context to be passed as the first argument to a function.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.DerivedContextReference">
<code>class jinja2.nodes.DerivedContextReference</code> </dt> <dd>
<p>Return the current template context including locals. Behaves exactly like <a class="reference internal" href="#jinja2.nodes.ContextReference" title="jinja2.nodes.ContextReference"><code>ContextReference</code></a>, but includes local variables, such as from a <code>for</code> loop.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.11.</span></p> </div> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.EnvironmentAttribute">
<code>class jinja2.nodes.EnvironmentAttribute(name)</code> </dt> <dd>
<p>Loads an attribute from the environment object. This is useful for extensions that want to call a callback stored on the environment.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.ExtensionAttribute">
<code>class jinja2.nodes.ExtensionAttribute(identifier, name)</code> </dt> <dd>
<p>Returns the attribute of an extension bound to the environment. The identifier is the identifier of the <code>Extension</code>.</p> <p>This node is usually constructed by calling the <a class="reference internal" href="#jinja2.ext.Extension.attr" title="jinja2.ext.Extension.attr"><code>attr()</code></a> method on an extension.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Filter">
<code>class jinja2.nodes.Filter(node, name, args, kwargs, dyn_args, dyn_kwargs)</code> </dt> <dd>
<p>This node applies a filter on an expression. <code>name</code> is the name of the filter, the rest of the fields are the same as for <a class="reference internal" href="#jinja2.nodes.Call" title="jinja2.nodes.Call"><code>Call</code></a>.</p> <p>If the <code>node</code> of a filter is <code>None</code> the contents of the last buffer are filtered. Buffers are created by macros and filter blocks.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Getattr">
<code>class jinja2.nodes.Getattr(node, attr, ctx)</code> </dt> <dd>
<p>Get an attribute or item from an expression that is a ascii-only bytestring and prefer the attribute.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Getitem">
<code>class jinja2.nodes.Getitem(node, arg, ctx)</code> </dt> <dd>
<p>Get an attribute or item from an expression and prefer the item.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.ImportedName">
<code>class jinja2.nodes.ImportedName(importname)</code> </dt> <dd>
<p>If created with an import name the import name is returned on node access. For example <code>ImportedName('cgi.escape')</code> returns the <code>escape</code> function from the cgi module on evaluation. Imports are optimized by the compiler so there is no need to assign them to local variables.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.InternalName">
<code>class jinja2.nodes.InternalName(name)</code> </dt> <dd>
<p>An internal name in the compiler. You cannot create these nodes yourself but the parser provides a <a class="reference internal" href="#jinja2.parser.Parser.free_identifier" title="jinja2.parser.Parser.free_identifier"><code>free_identifier()</code></a> method that creates a new identifier for you. This identifier is not available from the template and is not threated specially by the compiler.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Literal">
<code>class jinja2.nodes.Literal</code> </dt> <dd>
<p>Baseclass for literals.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Const">
<code>class jinja2.nodes.Const(value)</code> </dt> <dd>
<p>All constant values. The parser will return this node for simple constants such as <code>42</code> or <code>"foo"</code> but it can be used to store more complex values such as lists too. Only constants with a safe representation (objects where <code>eval(repr(x)) == x</code> is true).</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Literal" title="jinja2.nodes.Literal"><code>Literal</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Dict">
<code>class jinja2.nodes.Dict(items)</code> </dt> <dd>
<p>Any dict literal such as <code>{1: 2, 3: 4}</code>. The items must be a list of <a class="reference internal" href="#jinja2.nodes.Pair" title="jinja2.nodes.Pair"><code>Pair</code></a> nodes.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Literal" title="jinja2.nodes.Literal"><code>Literal</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.List">
<code>class jinja2.nodes.List(items)</code> </dt> <dd>
<p>Any list literal such as <code>[1, 2, 3]</code></p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Literal" title="jinja2.nodes.Literal"><code>Literal</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.TemplateData">
<code>class jinja2.nodes.TemplateData(data)</code> </dt> <dd>
<p>A constant template string.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Literal" title="jinja2.nodes.Literal"><code>Literal</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Tuple">
<code>class jinja2.nodes.Tuple(items, ctx)</code> </dt> <dd>
<p>For loop unpacking and some other things like multiple arguments for subscripts. Like for <a class="reference internal" href="#jinja2.nodes.Name" title="jinja2.nodes.Name"><code>Name</code></a> <code>ctx</code> specifies if the tuple is used for loading the names or storing.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Literal" title="jinja2.nodes.Literal"><code>Literal</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.MarkSafe">
<code>class jinja2.nodes.MarkSafe(expr)</code> </dt> <dd>
<p>Mark the wrapped expression as safe (wrap it as <code>Markup</code>).</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.MarkSafeIfAutoescape">
<code>class jinja2.nodes.MarkSafeIfAutoescape(expr)</code> </dt> <dd>
<p>Mark the wrapped expression as safe (wrap it as <code>Markup</code>) but only if autoescaping is active.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Name">
<code>class jinja2.nodes.Name(name, ctx)</code> </dt> <dd>
<p>Looks up a name or stores a value in a name. The <code>ctx</code> of the node can be one of the following values:</p> <ul class="simple"> <li>
<code>store</code>: store a value in the name</li> <li>
<code>load</code>: load that name</li> <li>
<code>param</code>: like <code>store</code> but if the name was defined as function parameter.</li> </ul> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.NSRef">
<code>class jinja2.nodes.NSRef(name, attr)</code> </dt> <dd>
<p>Reference to a namespace value assignment</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Slice">
<code>class jinja2.nodes.Slice(start, stop, step)</code> </dt> <dd>
<p>Represents a slice object. This must only be used as argument for <code>Subscript</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Test">
<code>class jinja2.nodes.Test(node, name, args, kwargs, dyn_args, dyn_kwargs)</code> </dt> <dd>
<p>Applies a test on an expression. <code>name</code> is the name of the test, the rest of the fields are the same as for <a class="reference internal" href="#jinja2.nodes.Call" title="jinja2.nodes.Call"><code>Call</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.UnaryExpr">
<code>class jinja2.nodes.UnaryExpr(node)</code> </dt> <dd>
<p>Baseclass for all unary expressions.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Expr" title="jinja2.nodes.Expr"><code>Expr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Neg">
<code>class jinja2.nodes.Neg(node)</code> </dt> <dd>
<p>Make the expression negative.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.UnaryExpr" title="jinja2.nodes.UnaryExpr"><code>UnaryExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Not">
<code>class jinja2.nodes.Not(node)</code> </dt> <dd>
<p>Negate the expression.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.UnaryExpr" title="jinja2.nodes.UnaryExpr"><code>UnaryExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Pos">
<code>class jinja2.nodes.Pos(node)</code> </dt> <dd>
<p>Make the expression positive (noop for most expressions)</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.UnaryExpr" title="jinja2.nodes.UnaryExpr"><code>UnaryExpr</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Helper">
<code>class jinja2.nodes.Helper</code> </dt> <dd>
<p>Nodes that exist in a specific context only.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Node" title="jinja2.nodes.Node"><code>Node</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Keyword">
<code>class jinja2.nodes.Keyword(key, value)</code> </dt> <dd>
<p>A key, value pair for keyword arguments where key is a string.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Helper" title="jinja2.nodes.Helper"><code>Helper</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Operand">
<code>class jinja2.nodes.Operand(op, expr)</code> </dt> <dd>
<p>Holds an operator and an expression. The following operators are available: <code>%</code>, <code>**</code>, <code>*</code>, <code>+</code>, <code>-</code>, <code>//</code>, <code>/</code>, <code>eq</code>, <code>gt</code>, <code>gteq</code>, <code>in</code>, <code>lt</code>, <code>lteq</code>, <code>ne</code>, <code>not</code>, <code>notin</code></p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Helper" title="jinja2.nodes.Helper"><code>Helper</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Pair">
<code>class jinja2.nodes.Pair(key, value)</code> </dt> <dd>
<p>A key, value pair for dicts.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Helper" title="jinja2.nodes.Helper"><code>Helper</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Stmt">
<code>class jinja2.nodes.Stmt</code> </dt> <dd>
<p>Base node for all statements.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Node" title="jinja2.nodes.Node"><code>Node</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Assign">
<code>class jinja2.nodes.Assign(target, node)</code> </dt> <dd>
<p>Assigns an expression to a target.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.AssignBlock">
<code>class jinja2.nodes.AssignBlock(target, filter, body)</code> </dt> <dd>
<p>Assigns a block to a target.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Block">
<code>class jinja2.nodes.Block(name, body, scoped)</code> </dt> <dd>
<p>A node that represents a block.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Break">
<code>class jinja2.nodes.Break</code> </dt> <dd>
<p>Break a loop.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.CallBlock">
<code>class jinja2.nodes.CallBlock(call, args, defaults, body)</code> </dt> <dd>
<p>Like a macro without a name but a call instead. <code>call</code> is called with the unnamed macro as <code>caller</code> argument this node holds.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Continue">
<code>class jinja2.nodes.Continue</code> </dt> <dd>
<p>Continue a loop.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.EvalContextModifier">
<code>class jinja2.nodes.EvalContextModifier(options)</code> </dt> <dd>
<p>Modifies the eval context. For each option that should be modified, a <a class="reference internal" href="#jinja2.nodes.Keyword" title="jinja2.nodes.Keyword"><code>Keyword</code></a> has to be added to the <code>options</code> list.</p> <p>Example to change the <code>autoescape</code> setting:</p> <pre data-language="python">EvalContextModifier(options=[Keyword('autoescape', Const(True))])
</pre> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.ScopedEvalContextModifier">
<code>class jinja2.nodes.ScopedEvalContextModifier(options, body)</code> </dt> <dd>
<p>Modifies the eval context and reverts it later. Works exactly like <a class="reference internal" href="#jinja2.nodes.EvalContextModifier" title="jinja2.nodes.EvalContextModifier"><code>EvalContextModifier</code></a> but will only modify the <a class="reference internal" href="../api/index#jinja2.nodes.EvalContext" title="jinja2.nodes.EvalContext"><code>EvalContext</code></a> for nodes in the <code>body</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.EvalContextModifier" title="jinja2.nodes.EvalContextModifier"><code>EvalContextModifier</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.ExprStmt">
<code>class jinja2.nodes.ExprStmt(node)</code> </dt> <dd>
<p>A statement that evaluates an expression and discards the result.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Extends">
<code>class jinja2.nodes.Extends(template)</code> </dt> <dd>
<p>Represents an extends statement.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.FilterBlock">
<code>class jinja2.nodes.FilterBlock(body, filter)</code> </dt> <dd>
<p>Node for filter sections.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.For">
<code>class jinja2.nodes.For(target, iter, body, else_, test, recursive)</code> </dt> <dd>
<p>The for loop. <code>target</code> is the target for the iteration (usually a <a class="reference internal" href="#jinja2.nodes.Name" title="jinja2.nodes.Name"><code>Name</code></a> or <a class="reference internal" href="#jinja2.nodes.Tuple" title="jinja2.nodes.Tuple"><code>Tuple</code></a>), <code>iter</code> the iterable. <code>body</code> is a list of nodes that are used as loop-body, and <code>else_</code> a list of nodes for the <code>else</code> block. If no else node exists it has to be an empty list.</p> <p>For filtered nodes an expression can be stored as <code>test</code>, otherwise <code>None</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.FromImport">
<code>class jinja2.nodes.FromImport(template, names, with_context)</code> </dt> <dd>
<p>A node that represents the from import tag. It’s important to not pass unsafe names to the name attribute. The compiler translates the attribute lookups directly into getattr calls and does <em>not</em> use the subscript callback of the interface. As exported variables may not start with double underscores (which the parser asserts) this is not a problem for regular Jinja code, but if this node is used in an extension extra care must be taken.</p> <p>The list of names may contain tuples if aliases are wanted.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.If">
<code>class jinja2.nodes.If(test, body, elif_, else_)</code> </dt> <dd>
<p>If <code>test</code> is true, <code>body</code> is rendered, else <code>else_</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Import">
<code>class jinja2.nodes.Import(template, target, with_context)</code> </dt> <dd>
<p>A node that represents the import tag.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Include">
<code>class jinja2.nodes.Include(template, with_context, ignore_missing)</code> </dt> <dd>
<p>A node that represents the include tag.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Macro">
<code>class jinja2.nodes.Macro(name, args, defaults, body)</code> </dt> <dd>
<p>A macro definition. <code>name</code> is the name of the macro, <code>args</code> a list of arguments and <code>defaults</code> a list of defaults if there are any. <code>body</code> is a list of nodes for the macro body.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Output">
<code>class jinja2.nodes.Output(nodes)</code> </dt> <dd>
<p>A node that holds multiple expressions which are then printed out. This is used both for the <code>print</code> statement and the regular template data.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.OverlayScope">
<code>class jinja2.nodes.OverlayScope(context, body)</code> </dt> <dd>
<p>An overlay scope for extensions. This is a largely unoptimized scope that however can be used to introduce completely arbitrary variables into a sub scope from a dictionary or dictionary like object. The <code>context</code> field has to evaluate to a dictionary object.</p> <p>Example usage:</p> <pre data-language="python">OverlayScope(context=self.call_method('get_context'),
             body=[...])
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Scope">
<code>class jinja2.nodes.Scope(body)</code> </dt> <dd>
<p>An artificial scope.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.With">
<code>class jinja2.nodes.With(targets, values, body)</code> </dt> <dd>
<p>Specific node for with statements. In older versions of Jinja the with statement was implemented on the base of the <code>Scope</code> node instead.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.9.3.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Stmt" title="jinja2.nodes.Stmt"><code>Stmt</code></a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.nodes.Template">
<code>class jinja2.nodes.Template(body)</code> </dt> <dd>
<p>Node that represents a template. This must be the outermost node that is passed to the compiler.</p> <dl class="field-list simple"> <dt class="field-odd">Node type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#jinja2.nodes.Node" title="jinja2.nodes.Node"><code>Node</code></a></p> </dd> </dl> </dd>
</dl> <dl class="exception"> <dt id="jinja2.nodes.Impossible">
<code>exception jinja2.nodes.Impossible</code> </dt> <dd>
<p>Raised if the node could not perform a requested action.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2020 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://jinja.palletsprojects.com/en/2.11.x/extensions/" class="_attribution-link">https://jinja.palletsprojects.com/en/2.11.x/extensions/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
