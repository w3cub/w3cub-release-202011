
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>3.19.6. AVR Options - GCC 11 - W3cubDocs</title>
  
  <meta name="description" content=" These options are defined for AVR implementations&#58; ">
  <meta name="keywords" content="avr, options, eind, and, devices, with, more, than, ki, bytes, flash, handling, rampd, rampx, rampy, rampz, special, function, registers, built-in, macros, gcc, gcc~11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/gcc~11/avr-options.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9352e6910fe51dd10a2c4166dc5a7847892ebc84c0bb52d7e40dcdccbf262592790483d09e6dbfd62c689609a706227727ca9acb967a718e944c111f43ca96a0.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/gcc~11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/gcc~11/" class="_nav-link" title="" style="margin-left:0;">GCC 11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="subsection" id="AVR-Options-1">3.19.6 AVR Options</h1>  <p id="index-AVR-Options">These options are defined for AVR implementations: </p> <dl compact> <dt><code>-mmcu=<var>mcu</var></code></dt> <dd> <p id="index-mmcu">Specify Atmel AVR instruction set architectures (ISA) or MCU type. </p> <p>The default for this option is ‘<samp>avr2</samp>’. </p> <p>GCC supports the following AVR devices and ISAs: </p> <dl compact> <dt><code>avr2</code></dt> <dd>
<p>“Classic” devices with up to 8 KiB of program memory. <var>mcu</var> = <code>attiny22</code>, <code>attiny26</code>, <code>at90s2313</code>, <code>at90s2323</code>, <code>at90s2333</code>, <code>at90s2343</code>, <code>at90s4414</code>, <code>at90s4433</code>, <code>at90s4434</code>, <code>at90c8534</code>, <code>at90s8515</code>, <code>at90s8535</code>. </p> </dd> <dt><code>avr25</code></dt> <dd>
<p>“Classic” devices with up to 8 KiB of program memory and with the <code>MOVW</code> instruction. <var>mcu</var> = <code>attiny13</code>, <code>attiny13a</code>, <code>attiny24</code>, <code>attiny24a</code>, <code>attiny25</code>, <code>attiny261</code>, <code>attiny261a</code>, <code>attiny2313</code>, <code>attiny2313a</code>, <code>attiny43u</code>, <code>attiny44</code>, <code>attiny44a</code>, <code>attiny45</code>, <code>attiny48</code>, <code>attiny441</code>, <code>attiny461</code>, <code>attiny461a</code>, <code>attiny4313</code>, <code>attiny84</code>, <code>attiny84a</code>, <code>attiny85</code>, <code>attiny87</code>, <code>attiny88</code>, <code>attiny828</code>, <code>attiny841</code>, <code>attiny861</code>, <code>attiny861a</code>, <code>ata5272</code>, <code>ata6616c</code>, <code>at86rf401</code>. </p> </dd> <dt><code>avr3</code></dt> <dd>
<p>“Classic” devices with 16 KiB up to 64 KiB of program memory. <var>mcu</var> = <code>at76c711</code>, <code>at43usb355</code>. </p> </dd> <dt><code>avr31</code></dt> <dd>
<p>“Classic” devices with 128 KiB of program memory. <var>mcu</var> = <code>atmega103</code>, <code>at43usb320</code>. </p> </dd> <dt><code>avr35</code></dt> <dd>
<p>“Classic” devices with 16 KiB up to 64 KiB of program memory and with the <code>MOVW</code> instruction. <var>mcu</var> = <code>attiny167</code>, <code>attiny1634</code>, <code>atmega8u2</code>, <code>atmega16u2</code>, <code>atmega32u2</code>, <code>ata5505</code>, <code>ata6617c</code>, <code>ata664251</code>, <code>at90usb82</code>, <code>at90usb162</code>. </p> </dd> <dt><code>avr4</code></dt> <dd>
<p>“Enhanced” devices with up to 8 KiB of program memory. <var>mcu</var> = <code>atmega48</code>, <code>atmega48a</code>, <code>atmega48p</code>, <code>atmega48pa</code>, <code>atmega48pb</code>, <code>atmega8</code>, <code>atmega8a</code>, <code>atmega8hva</code>, <code>atmega88</code>, <code>atmega88a</code>, <code>atmega88p</code>, <code>atmega88pa</code>, <code>atmega88pb</code>, <code>atmega8515</code>, <code>atmega8535</code>, <code>ata6285</code>, <code>ata6286</code>, <code>ata6289</code>, <code>ata6612c</code>, <code>at90pwm1</code>, <code>at90pwm2</code>, <code>at90pwm2b</code>, <code>at90pwm3</code>, <code>at90pwm3b</code>, <code>at90pwm81</code>. </p> </dd> <dt><code>avr5</code></dt> <dd>
<p>“Enhanced” devices with 16 KiB up to 64 KiB of program memory. <var>mcu</var> = <code>atmega16</code>, <code>atmega16a</code>, <code>atmega16hva</code>, <code>atmega16hva2</code>, <code>atmega16hvb</code>, <code>atmega16hvbrevb</code>, <code>atmega16m1</code>, <code>atmega16u4</code>, <code>atmega161</code>, <code>atmega162</code>, <code>atmega163</code>, <code>atmega164a</code>, <code>atmega164p</code>, <code>atmega164pa</code>, <code>atmega165</code>, <code>atmega165a</code>, <code>atmega165p</code>, <code>atmega165pa</code>, <code>atmega168</code>, <code>atmega168a</code>, <code>atmega168p</code>, <code>atmega168pa</code>, <code>atmega168pb</code>, <code>atmega169</code>, <code>atmega169a</code>, <code>atmega169p</code>, <code>atmega169pa</code>, <code>atmega32</code>, <code>atmega32a</code>, <code>atmega32c1</code>, <code>atmega32hvb</code>, <code>atmega32hvbrevb</code>, <code>atmega32m1</code>, <code>atmega32u4</code>, <code>atmega32u6</code>, <code>atmega323</code>, <code>atmega324a</code>, <code>atmega324p</code>, <code>atmega324pa</code>, <code>atmega325</code>, <code>atmega325a</code>, <code>atmega325p</code>, <code>atmega325pa</code>, <code>atmega328</code>, <code>atmega328p</code>, <code>atmega328pb</code>, <code>atmega329</code>, <code>atmega329a</code>, <code>atmega329p</code>, <code>atmega329pa</code>, <code>atmega3250</code>, <code>atmega3250a</code>, <code>atmega3250p</code>, <code>atmega3250pa</code>, <code>atmega3290</code>, <code>atmega3290a</code>, <code>atmega3290p</code>, <code>atmega3290pa</code>, <code>atmega406</code>, <code>atmega64</code>, <code>atmega64a</code>, <code>atmega64c1</code>, <code>atmega64hve</code>, <code>atmega64hve2</code>, <code>atmega64m1</code>, <code>atmega64rfr2</code>, <code>atmega640</code>, <code>atmega644</code>, <code>atmega644a</code>, <code>atmega644p</code>, <code>atmega644pa</code>, <code>atmega644rfr2</code>, <code>atmega645</code>, <code>atmega645a</code>, <code>atmega645p</code>, <code>atmega649</code>, <code>atmega649a</code>, <code>atmega649p</code>, <code>atmega6450</code>, <code>atmega6450a</code>, <code>atmega6450p</code>, <code>atmega6490</code>, <code>atmega6490a</code>, <code>atmega6490p</code>, <code>ata5795</code>, <code>ata5790</code>, <code>ata5790n</code>, <code>ata5791</code>, <code>ata6613c</code>, <code>ata6614q</code>, <code>ata5782</code>, <code>ata5831</code>, <code>ata8210</code>, <code>ata8510</code>, <code>ata5702m322</code>, <code>at90pwm161</code>, <code>at90pwm216</code>, <code>at90pwm316</code>, <code>at90can32</code>, <code>at90can64</code>, <code>at90scr100</code>, <code>at90usb646</code>, <code>at90usb647</code>, <code>at94k</code>, <code>m3000</code>. </p> </dd> <dt><code>avr51</code></dt> <dd>
<p>“Enhanced” devices with 128 KiB of program memory. <var>mcu</var> = <code>atmega128</code>, <code>atmega128a</code>, <code>atmega128rfa1</code>, <code>atmega128rfr2</code>, <code>atmega1280</code>, <code>atmega1281</code>, <code>atmega1284</code>, <code>atmega1284p</code>, <code>atmega1284rfr2</code>, <code>at90can128</code>, <code>at90usb1286</code>, <code>at90usb1287</code>. </p> </dd> <dt><code>avr6</code></dt> <dd>
<p>“Enhanced” devices with 3-byte PC, i.e. with more than 128 KiB of program memory. <var>mcu</var> = <code>atmega256rfr2</code>, <code>atmega2560</code>, <code>atmega2561</code>, <code>atmega2564rfr2</code>. </p> </dd> <dt><code>avrxmega2</code></dt> <dd>
<p>“XMEGA” devices with more than 8 KiB and up to 64 KiB of program memory. <var>mcu</var> = <code>atxmega8e5</code>, <code>atxmega16a4</code>, <code>atxmega16a4u</code>, <code>atxmega16c4</code>, <code>atxmega16d4</code>, <code>atxmega16e5</code>, <code>atxmega32a4</code>, <code>atxmega32a4u</code>, <code>atxmega32c3</code>, <code>atxmega32c4</code>, <code>atxmega32d3</code>, <code>atxmega32d4</code>, <code>atxmega32e5</code>. </p> </dd> <dt><code>avrxmega3</code></dt> <dd>
<p>“XMEGA” devices with up to 64 KiB of combined program memory and RAM, and with program memory visible in the RAM address space. <var>mcu</var> = <code>attiny202</code>, <code>attiny204</code>, <code>attiny212</code>, <code>attiny214</code>, <code>attiny402</code>, <code>attiny404</code>, <code>attiny406</code>, <code>attiny412</code>, <code>attiny414</code>, <code>attiny416</code>, <code>attiny417</code>, <code>attiny804</code>, <code>attiny806</code>, <code>attiny807</code>, <code>attiny814</code>, <code>attiny816</code>, <code>attiny817</code>, <code>attiny1604</code>, <code>attiny1606</code>, <code>attiny1607</code>, <code>attiny1614</code>, <code>attiny1616</code>, <code>attiny1617</code>, <code>attiny3214</code>, <code>attiny3216</code>, <code>attiny3217</code>, <code>atmega808</code>, <code>atmega809</code>, <code>atmega1608</code>, <code>atmega1609</code>, <code>atmega3208</code>, <code>atmega3209</code>, <code>atmega4808</code>, <code>atmega4809</code>. </p> </dd> <dt><code>avrxmega4</code></dt> <dd>
<p>“XMEGA” devices with more than 64 KiB and up to 128 KiB of program memory. <var>mcu</var> = <code>atxmega64a3</code>, <code>atxmega64a3u</code>, <code>atxmega64a4u</code>, <code>atxmega64b1</code>, <code>atxmega64b3</code>, <code>atxmega64c3</code>, <code>atxmega64d3</code>, <code>atxmega64d4</code>. </p> </dd> <dt><code>avrxmega5</code></dt> <dd>
<p>“XMEGA” devices with more than 64 KiB and up to 128 KiB of program memory and more than 64 KiB of RAM. <var>mcu</var> = <code>atxmega64a1</code>, <code>atxmega64a1u</code>. </p> </dd> <dt><code>avrxmega6</code></dt> <dd>
<p>“XMEGA” devices with more than 128 KiB of program memory. <var>mcu</var> = <code>atxmega128a3</code>, <code>atxmega128a3u</code>, <code>atxmega128b1</code>, <code>atxmega128b3</code>, <code>atxmega128c3</code>, <code>atxmega128d3</code>, <code>atxmega128d4</code>, <code>atxmega192a3</code>, <code>atxmega192a3u</code>, <code>atxmega192c3</code>, <code>atxmega192d3</code>, <code>atxmega256a3</code>, <code>atxmega256a3b</code>, <code>atxmega256a3bu</code>, <code>atxmega256a3u</code>, <code>atxmega256c3</code>, <code>atxmega256d3</code>, <code>atxmega384c3</code>, <code>atxmega384d3</code>. </p> </dd> <dt><code>avrxmega7</code></dt> <dd>
<p>“XMEGA” devices with more than 128 KiB of program memory and more than 64 KiB of RAM. <var>mcu</var> = <code>atxmega128a1</code>, <code>atxmega128a1u</code>, <code>atxmega128a4u</code>. </p> </dd> <dt><code>avrtiny</code></dt> <dd>
<p>“TINY” Tiny core devices with 512 B up to 4 KiB of program memory. <var>mcu</var> = <code>attiny4</code>, <code>attiny5</code>, <code>attiny9</code>, <code>attiny10</code>, <code>attiny20</code>, <code>attiny40</code>. </p> </dd> <dt><code>avr1</code></dt> <dd>
<p>This ISA is implemented by the minimal AVR core and supported for assembler only. <var>mcu</var> = <code>attiny11</code>, <code>attiny12</code>, <code>attiny15</code>, <code>attiny28</code>, <code>at90s1200</code>. </p> </dd> </dl> </dd> <dt><code>-mabsdata</code></dt> <dd> <p id="index-mabsdata">Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the <code>absdata</code> <a href="variable-attributes#AVR-Variable-Attributes">variable attribute</a>. </p> </dd> <dt><code>-maccumulate-args</code></dt> <dd> <p id="index-maccumulate_002dargs">Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards. </p> <p>Popping the arguments after the function call can be expensive on AVR so that accumulating the stack space might lead to smaller executables because arguments need not be removed from the stack after such a function call. </p> <p>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions. </p> </dd> <dt><code>-mbranch-cost=<var>cost</var></code></dt> <dd> <p id="index-mbranch_002dcost-1">Set the branch costs for conditional branch instructions to <var>cost</var>. Reasonable values for <var>cost</var> are small, non-negative integers. The default branch cost is 0. </p> </dd> <dt><code>-mcall-prologues</code></dt> <dd> <p id="index-mcall_002dprologues">Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller. </p> </dd> <dt><code>-mdouble=<var>bits</var></code></dt> <dt><code>-mlong-double=<var>bits</var></code></dt> <dd>  <p id="index-mlong_002ddouble">Set the size (in bits) of the <code>double</code> or <code>long double</code> type, respectively. Possible values for <var>bits</var> are 32 and 64. Whether or not a specific value for <var>bits</var> is allowed depends on the <code>--with-double=</code> and <code>--with-long-double=</code> <a href="https://gcc.gnu.org/install/configure.html#avr">configure options</a>, and the same applies for the default values of the options. </p> </dd> <dt><code>-mgas-isr-prologues</code></dt> <dd> <p id="index-mgas_002disr_002dprologues">Interrupt service routines (ISRs) may use the <code>__gcc_isr</code> pseudo instruction supported by GNU Binutils. If this option is on, the feature can still be disabled for individual ISRs by means of the <a href="avr-function-attributes#AVR-Function-Attributes"><code>no_gccisr</code></a> function attribute. This feature is activated per default if optimization is on (but not with <samp>-Og</samp>, see <a href="optimize-options#Optimize-Options">Optimize Options</a>), and if GNU Binutils support <a href="https://sourceware.org/PR21683">PR21683</a>. </p> </dd> <dt><code>-mint8</code></dt> <dd> <p id="index-mint8">Assume <code>int</code> to be 8-bit integer. This affects the sizes of all types: a <code>char</code> is 1 byte, an <code>int</code> is 1 byte, a <code>long</code> is 2 bytes, and <code>long long</code> is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size. </p> </dd> <dt><code>-mmain-is-OS_task</code></dt> <dd> <p id="index-mmain_002dis_002dOS_005ftask">Do not save registers in <code>main</code>. The effect is the same like attaching attribute <a href="avr-function-attributes#AVR-Function-Attributes"><code>OS_task</code></a> to <code>main</code>. It is activated per default if optimization is on. </p> </dd> <dt><code>-mn-flash=<var>num</var></code></dt> <dd> <p id="index-mn_002dflash">Assume that the flash memory has a size of <var>num</var> times 64 KiB. </p> </dd> <dt><code>-mno-interrupts</code></dt> <dd> <p id="index-mno_002dinterrupts">Generated code is not compatible with hardware interrupts. Code size is smaller. </p> </dd> <dt><code>-mrelax</code></dt> <dd> <p id="index-mrelax">Try to replace <code>CALL</code> resp. <code>JMP</code> instruction by the shorter <code>RCALL</code> resp. <code>RJMP</code> instruction if applicable. Setting <samp>-mrelax</samp> just adds the <samp>--mlink-relax</samp> option to the assembler’s command line and the <samp>--relax</samp> option to the linker’s command line. </p> <p>Jump relaxing is performed by the linker because jump offsets are not known before code is located. Therefore, the assembler code generated by the compiler is the same, but the instructions in the executable may differ from instructions in the assembler code. </p> <p>Relaxing must be turned on if linker stubs are needed, see the section on <code>EIND</code> and linker stubs below. </p> </dd> <dt><code>-mrmw</code></dt> <dd> <p id="index-mrmw">Assume that the device supports the Read-Modify-Write instructions <code>XCH</code>, <code>LAC</code>, <code>LAS</code> and <code>LAT</code>. </p> </dd> <dt><code>-mshort-calls</code></dt> <dd> <p id="index-mshort_002dcalls">Assume that <code>RJMP</code> and <code>RCALL</code> can target the whole program memory. </p> <p>This option is used internally for multilib selection. It is not an optimization option, and you don’t need to set it by hand. </p> </dd> <dt><code>-msp8</code></dt> <dd> <p id="index-msp8">Treat the stack pointer register as an 8-bit register, i.e. assume the high byte of the stack pointer is zero. In general, you don’t need to set this option by hand. </p> <p>This option is used internally by the compiler to select and build multilibs for architectures <code>avr2</code> and <code>avr25</code>. These architectures mix devices with and without <code>SPH</code>. For any setting other than <samp>-mmcu=avr2</samp> or <samp>-mmcu=avr25</samp> the compiler driver adds or removes this option from the compiler proper’s command line, because the compiler then knows if the device or architecture has an 8-bit stack pointer and thus no <code>SPH</code> register or not. </p> </dd> <dt><code>-mstrict-X</code></dt> <dd> <p id="index-mstrict_002dX">Use address register <code>X</code> in a way proposed by the hardware. This means that <code>X</code> is only used in indirect, post-increment or pre-decrement addressing. </p> <p>Without this option, the <code>X</code> register may be used in the same way as <code>Y</code> or <code>Z</code> which then is emulated by additional instructions. For example, loading a value with <code>X+const</code> addressing with a small non-negative <code>const &lt; 64</code> to a register <var>Rn</var> is performed as </p> <div class="example"> <pre class="example" data-language="cpp">adiw r26, const   ; X += const
ld   <var>Rn</var>, X        ; <var>Rn</var> = *X
sbiw r26, const   ; X -= const</pre>
</div> </dd> <dt><code>-mtiny-stack</code></dt> <dd> <p id="index-mtiny_002dstack">Only change the lower 8 bits of the stack pointer. </p> </dd> <dt><code>-mfract-convert-truncate</code></dt> <dd> <p id="index-mfract_002dconvert_002dtruncate">Allow to use truncation instead of rounding towards zero for fractional fixed-point types. </p> </dd> <dt><code>-nodevicelib</code></dt> <dd> <p id="index-nodevicelib">Don’t link against AVR-LibC’s device specific library <code>lib&lt;mcu&gt;.a</code>. </p> </dd> <dt><code>-nodevicespecs</code></dt> <dd> <p id="index-nodevicespecs">Don’t add <samp>-specs=device-specs/specs-<var>mcu</var></samp> to the compiler driver’s command line. The user takes responsibility for supplying the sub-processes like compiler proper, assembler and linker with appropriate command line options. This means that the user has to supply her private device specs file by means of <samp>-specs=<var>path-to-specs-file</var></samp>. There is no more need for option <samp>-mmcu=<var>mcu</var></samp>. </p> <p>This option can also serve as a replacement for the older way of specifying custom device-specs files that needed <samp>-B <var>some-path</var></samp> to point to a directory which contains a folder named <code>device-specs</code> which contains a specs file named <code>specs-<var>mcu</var></code>, where <var>mcu</var> was specified by <samp>-mmcu=<var>mcu</var></samp>. </p> </dd> <dt><code>-Waddr-space-convert</code></dt> <dd>  <p id="index-Wno_002daddr_002dspace_002dconvert">Warn about conversions between address spaces in the case where the resulting address space is not contained in the incoming address space. </p> </dd> <dt><code>-Wmisspelled-isr</code></dt> <dd>  <p id="index-Wno_002dmisspelled_002disr">Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default. </p>
</dd> </dl>  <h1 class="subsubsection" id="EIND-and-Devices-with-More-Than-128-Ki-Bytes-of-Flash">3.19.6.1 EIND and Devices with More Than 128 Ki Bytes of Flash</h1>  <p id="index-EIND">Pointers in the implementation are 16 bits wide. The address of a function or label is represented as word address so that indirect jumps and calls can target any code address in the range of 64 Ki words. </p> <p>In order to facilitate indirect jump on devices with more than 128 Ki bytes of program memory space, there is a special function register called <code>EIND</code> that serves as most significant part of the target address when <code>EICALL</code> or <code>EIJMP</code> instructions are used. </p> <p>Indirect jumps and calls on these devices are handled as follows by the compiler and are subject to some limitations: </p> <ul> <li> The compiler never sets <code>EIND</code>. </li>
<li> The compiler uses <code>EIND</code> implicitly in <code>EICALL</code>/<code>EIJMP</code> instructions or might read <code>EIND</code> directly in order to emulate an indirect call/jump by means of a <code>RET</code> instruction. </li>
<li> The compiler assumes that <code>EIND</code> never changes during the startup code or during the application. In particular, <code>EIND</code> is not saved/restored in function or interrupt service routine prologue/epilogue. </li>
<li> For indirect calls to functions and computed goto, the linker generates <em>stubs</em>. Stubs are jump pads sometimes also called <em>trampolines</em>. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address. </li>
<li> Linker relaxation must be turned on so that the linker generates the stubs correctly in all situations. See the compiler option <samp>-mrelax</samp> and the linker option <samp>--relax</samp>. There are corner cases where the linker is supposed to generate stubs but aborts without relaxation and without a helpful error message. </li>
<li> The default linker script is arranged for code with <code>EIND = 0</code>. If code is supposed to work for a setup with <code>EIND != 0</code>, a custom linker script has to be used in order to place the sections whose name start with <code>.trampolines</code> into the segment where <code>EIND</code> points to. </li>
<li> The startup code from libgcc never sets <code>EIND</code>. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on <code>EIND</code>, see the <a href="http://nongnu.org/avr-libc/user-manual/"><span class="nolinebreak">AVR-LibC</span> user manual</a>. </li>
<li> It is legitimate for user-specific startup code to set up <code>EIND</code> early, for example by means of initialization code located in section <code>.init3</code>. Such code runs prior to general startup code that initializes RAM and calls constructors, but after the bit of startup code from AVR-LibC that sets <code>EIND</code> to the segment where the vector table is located. <div class="example"> <pre class="example" data-language="cpp">#include &lt;avr/io.h&gt;

static void
__attribute__((section(".init3"),naked,used,no_instrument_function))
init3_set_eind (void)
{
  __asm volatile ("ldi r24,pm_hh8(__trampolines_start)\n\t"
                  "out %i0,r24" :: "n" (&amp;EIND) : "r24","memory");
}</pre>
</div> <p>The <code>__trampolines_start</code> symbol is defined in the linker script. </p> </li>
<li> Stubs are generated automatically by the linker if the following two conditions are met: <ul class="no-bullet"> <li>- The address of a label is taken by means of the <code>gs</code> modifier (short for <em>generate stubs</em>) like so: <div class="example"> <pre class="example" data-language="cpp">LDI r24, lo8(gs(<var>func</var>))
LDI r25, hi8(gs(<var>func</var>))</pre>
</div> </li>
<li>- The final location of that label is in a code segment <em>outside</em> the segment where the stubs are located. </li>
</ul> </li>
<li> The compiler emits such <code>gs</code> modifiers for code labels in the following situations: <ul class="no-bullet"> <li>- Taking address of a function or code label. </li>
<li>- Computed goto. </li>
<li>- If prologue-save function is used, see <samp>-mcall-prologues</samp> command-line option. </li>
<li>- Switch/case dispatch tables. If you do not want such dispatch tables you can specify the <samp>-fno-jump-tables</samp> command-line option. </li>
<li>- C and C++ constructors/destructors called during startup/shutdown. </li>
<li>- If the tools hit a <code>gs()</code> modifier explained above. </li>
</ul> </li>
<li> Jumping to non-symbolic addresses like so is <em>not</em> supported: <div class="example"> <pre class="example" data-language="cpp">int main (void)
{
    /* Call function at word address 0x2 */
    return ((int(*)(void)) 0x2)();
}</pre>
</div> <p>Instead, a stub has to be set up, i.e. the function has to be called through a symbol (<code>func_4</code> in the example): </p> <div class="example"> <pre class="example" data-language="cpp">int main (void)
{
    extern int func_4 (void);

    /* Call function at byte address 0x4 */
    return func_4();
}</pre>
</div> <p>and the application be linked with <samp>-Wl,--defsym,func_4=0x4</samp>. Alternatively, <code>func_4</code> can be defined in the linker script. </p>
</li>
</ul>  <h1 class="subsubsection" id="Handling-of-the-RAMPD_002c-RAMPX_002c-RAMPY-and-RAMPZ-Special-Function-Registers">3.19.6.2 Handling of the RAMPD, RAMPX, RAMPY and RAMPZ Special Function Registers</h1>     <p id="index-RAMPZ">Some AVR devices support memories larger than the 64 KiB range that can be accessed with 16-bit pointers. To access memory locations outside this 64 KiB range, the content of a <code>RAMP</code> register is used as high part of the address: The <code>X</code>, <code>Y</code>, <code>Z</code> address register is concatenated with the <code>RAMPX</code>, <code>RAMPY</code>, <code>RAMPZ</code> special function register, respectively, to get a wide address. Similarly, <code>RAMPD</code> is used together with direct addressing. </p> <ul> <li> The startup code initializes the <code>RAMP</code> special function registers with zero. </li>
<li> If a <a href="named-address-spaces#AVR-Named-Address-Spaces">named address space</a> other than generic or <code>__flash</code> is used, then <code>RAMPZ</code> is set as needed before the operation. </li>
<li> If the device supports RAM larger than 64 KiB and the compiler needs to change <code>RAMPZ</code> to accomplish an operation, <code>RAMPZ</code> is reset to zero after the operation. </li>
<li> If the device comes with a specific <code>RAMP</code> register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it. </li>
<li> RAM larger than 64 KiB is not supported by GCC for AVR targets. If you use inline assembler to read from locations outside the 16-bit address range and change one of the <code>RAMP</code> registers, you must reset it to zero after the access. </li>
</ul>  <h1 class="subsubsection" id="AVR-Built_002din-Macros">3.19.6.3 AVR Built-in Macros</h1> <p>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the <samp>-mmcu=</samp> command-line option. </p> <p>For even more AVR-specific built-in macros see <a href="named-address-spaces#AVR-Named-Address-Spaces">AVR Named Address Spaces</a> and <a href="avr-built_002din-functions#AVR-Built_002din-Functions">AVR Built-in Functions</a>. </p> <dl compact> <dt><code>__AVR_ARCH__</code></dt> <dd>
<p>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the <samp>-mmcu=<var>mcu</var></samp> option. Possible values are: </p> <p><code>2</code>, <code>25</code>, <code>3</code>, <code>31</code>, <code>35</code>, <code>4</code>, <code>5</code>, <code>51</code>, <code>6</code> </p> <p>for <var>mcu</var>=<code>avr2</code>, <code>avr25</code>, <code>avr3</code>, <code>avr31</code>, <code>avr35</code>, <code>avr4</code>, <code>avr5</code>, <code>avr51</code>, <code>avr6</code>, </p> <p>respectively and </p> <p><code>100</code>, <code>102</code>, <code>103</code>, <code>104</code>, <code>105</code>, <code>106</code>, <code>107</code> </p> <p>for <var>mcu</var>=<code>avrtiny</code>, <code>avrxmega2</code>, <code>avrxmega3</code>, <code>avrxmega4</code>, <code>avrxmega5</code>, <code>avrxmega6</code>, <code>avrxmega7</code>, respectively. If <var>mcu</var> specifies a device, this built-in macro is set accordingly. For example, with <samp>-mmcu=atmega8</samp> the macro is defined to <code>4</code>. </p> </dd> <dt><code>__AVR_<var>Device</var>__</code></dt> <dd>
<p>Setting <samp>-mmcu=<var>device</var></samp> defines this built-in macro which reflects the device’s name. For example, <samp>-mmcu=atmega8</samp> defines the built-in macro <code>__AVR_ATmega8__</code>, <samp>-mmcu=attiny261a</samp> defines <code>__AVR_ATtiny261A__</code>, etc. </p> <p>The built-in macros’ names follow the scheme <code>__AVR_<var>Device</var>__</code> where <var>Device</var> is the device name as from the AVR user manual. The difference between <var>Device</var> in the built-in macro and <var>device</var> in <samp>-mmcu=<var>device</var></samp> is that the latter is always lowercase. </p> <p>If <var>device</var> is not a device but only a core architecture like ‘<samp>avr51</samp>’, this macro is not defined. </p> </dd> <dt><code>__AVR_DEVICE_NAME__</code></dt> <dd>
<p>Setting <samp>-mmcu=<var>device</var></samp> defines this built-in macro to the device’s name. For example, with <samp>-mmcu=atmega8</samp> the macro is defined to <code>atmega8</code>. </p> <p>If <var>device</var> is not a device but only a core architecture like ‘<samp>avr51</samp>’, this macro is not defined. </p> </dd> <dt><code>__AVR_XMEGA__</code></dt> <dd>
<p>The device / architecture belongs to the XMEGA family of devices. </p> </dd> <dt><code>__AVR_HAVE_ELPM__</code></dt> <dd>
<p>The device has the <code>ELPM</code> instruction. </p> </dd> <dt><code>__AVR_HAVE_ELPMX__</code></dt> <dd>
<p>The device has the <code>ELPM R<var>n</var>,Z</code> and <code>ELPM
R<var>n</var>,Z+</code> instructions. </p> </dd> <dt><code>__AVR_HAVE_MOVW__</code></dt> <dd>
<p>The device has the <code>MOVW</code> instruction to perform 16-bit register-register moves. </p> </dd> <dt><code>__AVR_HAVE_LPMX__</code></dt> <dd>
<p>The device has the <code>LPM R<var>n</var>,Z</code> and <code>LPM R<var>n</var>,Z+</code> instructions. </p> </dd> <dt><code>__AVR_HAVE_MUL__</code></dt> <dd>
<p>The device has a hardware multiplier. </p> </dd> <dt><code>__AVR_HAVE_JMP_CALL__</code></dt> <dd>
<p>The device has the <code>JMP</code> and <code>CALL</code> instructions. This is the case for devices with more than 8 KiB of program memory. </p> </dd> <dt><code>__AVR_HAVE_EIJMP_EICALL__</code></dt> <dt><code>__AVR_3_BYTE_PC__</code></dt> <dd>
<p>The device has the <code>EIJMP</code> and <code>EICALL</code> instructions. This is the case for devices with more than 128 KiB of program memory. This also means that the program counter (PC) is 3 bytes wide. </p> </dd> <dt><code>__AVR_2_BYTE_PC__</code></dt> <dd>
<p>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory. </p> </dd> <dt><code>__AVR_HAVE_8BIT_SP__</code></dt> <dt><code>__AVR_HAVE_16BIT_SP__</code></dt> <dd>
<p>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by <samp>-mtiny-stack</samp>. </p> </dd> <dt><code>__AVR_HAVE_SPH__</code></dt> <dt><code>__AVR_SP8__</code></dt> <dd>
<p>The device has the SPH (high part of stack pointer) special function register or has an 8-bit stack pointer, respectively. The definition of these macros is affected by <samp>-mmcu=</samp> and in the cases of <samp>-mmcu=avr2</samp> and <samp>-mmcu=avr25</samp> also by <samp>-msp8</samp>. </p> </dd> <dt><code>__AVR_HAVE_RAMPD__</code></dt> <dt><code>__AVR_HAVE_RAMPX__</code></dt> <dt><code>__AVR_HAVE_RAMPY__</code></dt> <dt><code>__AVR_HAVE_RAMPZ__</code></dt> <dd>
<p>The device has the <code>RAMPD</code>, <code>RAMPX</code>, <code>RAMPY</code>, <code>RAMPZ</code> special function register, respectively. </p> </dd> <dt><code>__NO_INTERRUPTS__</code></dt> <dd>
<p>This macro reflects the <samp>-mno-interrupts</samp> command-line option. </p> </dd> <dt><code>__AVR_ERRATA_SKIP__</code></dt> <dt><code>__AVR_ERRATA_SKIP_JMP_CALL__</code></dt> <dd>
<p>Some AVR devices (AT90S8515, ATmega103) must not skip 32-bit instructions because of a hardware erratum. Skip instructions are <code>SBRS</code>, <code>SBRC</code>, <code>SBIS</code>, <code>SBIC</code> and <code>CPSE</code>. The second macro is only defined if <code>__AVR_HAVE_JMP_CALL__</code> is also set. </p> </dd> <dt><code>__AVR_ISA_RMW__</code></dt> <dd>
<p>The device has Read-Modify-Write instructions (XCH, LAC, LAS and LAT). </p> </dd> <dt><code>__AVR_SFR_OFFSET__=<var>offset</var></code></dt> <dd>
<p>Instructions that can address I/O special function registers directly like <code>IN</code>, <code>OUT</code>, <code>SBI</code>, etc. may use a different address as if addressed by an instruction to access RAM like <code>LD</code> or <code>STS</code>. This offset depends on the device architecture and has to be subtracted from the RAM address in order to get the respective I/O address. </p> </dd> <dt><code>__AVR_SHORT_CALLS__</code></dt> <dd>
<p>The <samp>-mshort-calls</samp> command line option is set. </p> </dd> <dt><code>__AVR_PM_BASE_ADDRESS__=<var>addr</var></code></dt> <dd>
<p>Some devices support reading from flash memory by means of <code>LD*</code> instructions. The flash memory is seen in the data address space at an offset of <code>__AVR_PM_BASE_ADDRESS__</code>. If this macro is not defined, this feature is not available. If defined, the address space is linear and there is no need to put <code>.rodata</code> into RAM. This is handled by the default linker description file, and is currently available for <code>avrtiny</code> and <code>avrxmega3</code>. Even more convenient, there is no need to use address spaces like <code>__flash</code> or features like attribute <code>progmem</code> and <code>pgm_read_*</code>. </p> </dd> <dt><code>__WITH_AVRLIBC__</code></dt> <dd>
<p>The compiler is configured to be used together with AVR-Libc. See the <samp>--with-avrlibc</samp> configure option. </p> </dd> <dt><code>__HAVE_DOUBLE_MULTILIB__</code></dt> <dd>
<p>Defined if <samp>-mdouble=</samp> acts as a multilib option. </p> </dd> <dt><code>__HAVE_DOUBLE32__</code></dt> <dt><code>__HAVE_DOUBLE64__</code></dt> <dd>
<p>Defined if the compiler supports 32-bit double resp. 64-bit double. The actual layout is specified by option <samp>-mdouble=</samp>. </p> </dd> <dt><code>__DEFAULT_DOUBLE__</code></dt> <dd>
<p>The size in bits of <code>double</code> if <samp>-mdouble=</samp> is not set. To test the layout of <code>double</code> in a program, use the built-in macro <code>__SIZEOF_DOUBLE__</code>. </p> </dd> <dt><code>__HAVE_LONG_DOUBLE32__</code></dt> <dt><code>__HAVE_LONG_DOUBLE64__</code></dt> <dt><code>__HAVE_LONG_DOUBLE_MULTILIB__</code></dt> <dt><code>__DEFAULT_LONG_DOUBLE__</code></dt> <dd>
<p>Same as above, but for <code>long double</code> instead of <code>double</code>. </p> </dd> <dt><code>__WITH_DOUBLE_COMPARISON__</code></dt> <dd>
<p>Reflects the <code>--with-double-comparison={tristate|bool|libf7}</code> <a href="https://gcc.gnu.org/install/configure.html#avr">configure option</a> and is defined to <code>2</code> or <code>3</code>. </p> </dd> <dt><code>__WITH_LIBF7_LIBGCC__</code></dt> <dt><code>__WITH_LIBF7_MATH__</code></dt> <dt><code>__WITH_LIBF7_MATH_SYMBOLS__</code></dt> <dd>
<p>Reflects the <code>--with-libf7={libgcc|math|math-symbols}</code> <a href="https://gcc.gnu.org/install/configure.html#avr">configure option</a>. </p> </dd> </dl>  <p class="header"> </p>
<p> Next: <a href="blackfin-options#Blackfin-Options" accesskey="n" rel="next">Blackfin Options</a>, Previous: <a href="arm-options#ARM-Options" accesskey="p" rel="prev">ARM Options</a>, Up: <a href="submodel-options#Submodel-Options" accesskey="u" rel="up">Submodel Options</a> [<a href="index#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/Option-Index.html#Option-Index" title="Index" rel="index">Index</a>]</p> <div class="_attribution">
  <p class="_attribution-p">
    © Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/AVR-Options.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/AVR-Options.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
