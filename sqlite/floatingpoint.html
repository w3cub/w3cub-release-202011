
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Floating Pointer Numbers - SQLite - W3cubDocs</title>
  
  <meta name="description" content="SQLite stores integer values in the 64-bit twos-complement format. This gives a storage range of -9223372036854775808 to +9223372036854775807, &hellip;">
  <meta name="keywords" content="floating, pointer, numbers, how, sqlite, stores, extensions, for, dealing, with, point, techniques">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/sqlite/floatingpoint.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/sqlite.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/sqlite/" class="_nav-link" title="" style="margin-left:0;">SQLite</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sqlite">
				
				
<h1 class="fancy_title"> Floating Pointer Numbers </h1> <div class="fancy_toc">  <div id="toc_sub">
<div class="fancy-toc1"><a href="#how_sqlite_stores_numbers">1. How SQLite Stores Numbers</a></div> <div class="fancy-toc2"><a href="#floating_point_accuracy">1.1. Floating-Point Accuracy</a></div> <div class="fancy-toc2"><a href="#floating_point_numbers">1.2. Floating Point Numbers</a></div> <div class="fancy-toc3"><a href="#unrepresentable_numbers">1.2.1. Unrepresentable numbers</a></div> <div class="fancy-toc3"><a href="#is_it_close_enough_">1.2.2. Is it close enough?</a></div> <div class="fancy-toc1"><a href="#extensions_for_dealing_with_floating_point_numbers">2. Extensions For Dealing With Floating Point Numbers</a></div> <div class="fancy-toc2"><a href="#the_ieee754_c_extension">2.1. The ieee754.c Extension</a></div> <div class="fancy-toc3"><a href="#the_ieee754_function">2.1.1. The ieee754() function</a></div> <div class="fancy-toc3"><a href="#the_ieee754_mantissa_and_ieee754_exponent_functions">2.1.2. The ieee754_mantissa() and ieee754_exponent() functions</a></div> <div class="fancy-toc3"><a href="#the_ieee754_from_blob_and_ieee754_to_blob_functions">2.1.3. The ieee754_from_blob() and ieee754_to_blob() functions</a></div> <div class="fancy-toc2"><a href="#the_decimal_c_extension">2.2. The decimal.c Extension</a></div> <div class="fancy-toc1"><a href="#techniques">3. Techniques</a></div> </div> </div>   <h1 id="how_sqlite_stores_numbers">
<span>1. </span>How SQLite Stores Numbers</h1> <p> SQLite stores integer values in the 64-bit <a href="https://en.wikipedia.org/wiki/Two%27s_complement">twos-complement</a> format. This gives a storage range of -9223372036854775808 to +9223372036854775807, inclusive. Integers within this range are exact. </p>
<p> So-called "REAL" or floating point values are stored in the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Binary-64</a> format. This gives a range of positive values between approximately 1.7976931348623157e+308 and 4.9406564584124654e-324 with an equivalent range of negative values. A binary64 can also be 0.0 (and -0.0), positive and negative infinity and "NaN" or "Not-a-Number". Floating point values are approximate. </p>
<p> Pay close attention to the last sentence in the previous paragraph: </p>
<pre data-language="sql"> Floating point values are approximate ← Always remember this! </pre> <p> If you need an exact answer, you should not use binary64 floating-point values, in SQLite or in any other product. This is not an SQLite limitation. It is a mathematical limitation inherent in the design of floating-point numbers. </p>
<h2 id="floating_point_accuracy">
<span>1.1. </span>Floating-Point Accuracy</h2> <p> SQLite promises to preserve the 15 most significant digits of a floating point value. However, it makes no guarantees about the accuracy of computations on floating point values, as no such guarantees are possible. Performing math on floating-point values introduces error. For example, consider what happens if you attempt to subtract two floating-point numbers of similar magnitude: </p>
<blockquote> <table cellpadding="0" cellspacing="0"> <tr><td>1152693165.1106291898</td></tr> <tr><td>-1152693165.1106280772</td></tr> <tr><td> </td></tr>
<tr><td>0.0000011126 </td></tr>
</table> </blockquote> <p>The result shown above (0.0000011126) is the correct answer. But if you do this computation using binary64 floating-point, the answer you get is 0.00000095367431640625 - an error of about 14%. If you do many similar computations as part of your program, the errors add up so that your final result might be completely meaningless. </p>
<p>The error arises because only about the first 15 significant digits of each number are stored accurately, and first the difference between the two numbers being subtracted is in the 16th digit. </p>
<h2 id="floating_point_numbers">
<span>1.2. </span>Floating Point Numbers</h2> <p> The binary64 floating-point format uses 64 bits per number. Hence there are 1.845e+19 different possible floating point values. On the other hand there are infinitely many real numbers in the range of 1.7977e+308 and 4.9407e-324. It follows then that binary64 cannot possibly represent all possible real numbers within that range. Approximations are required. </p>
<p> An IEEE 754 floating-point value is an integer multiplied by a power of two: </p>
<blockquote> <big>M &amp;times 2<sup><small>E</small></sup></big> </blockquote> <p>The M value is the "mantissa" and E is the "exponent". Both M and E are integers. </p>
<p>For Binary64, M is a 53-bit integer and E is an 11-bit integer that offset so that represents a range of values between -1074 and +972, inclusive. </p>
<p><i>(NB: The usual description of IEEE 754 is more complex, and it is important to understand the added complexity if you really want to appreciate the details, merits, and limitations of IEEE 754. However, the integer description shown here, while not exactly right, is easier to understand and is sufficient for the purposes of this article.)</i></p> <h3 id="unrepresentable_numbers">
<span>1.2.1. </span>Unrepresentable numbers</h3> <p>Not ever decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a "price" value of 47.49, that number will be represented in binary64 as: </p>
<blockquote> 6683623321994527 × 2<sup><small>-47</small></sup> </blockquote> <p>Which works out to be: </p>
<blockquote> 47.49000000000000198951966012828052043914794921875 </blockquote> <p>That number is very close to 47.49, but it is not exact. It is a little too big. If we reduce M by one to 6683623321994526 so that we have the next smaller possible binary64 value, we get: </p>
<blockquote> 47.4899999999999948840923025272786617279052734375 </blockquote> <p> This second number is too small. The first number is closer to the desired value of 47.49, so that is the one that gets used. But it is not exact. Most decimal values work this way in IEEE 754. Remember the key point we made above: </p>
<pre data-language="sql"> Floating point values are approximate. </pre> <p>If you remember nothing else about floating-point values, please don't forget this one key idea. </p>
<h3 id="is_it_close_enough_">
<span>1.2.2. </span>Is it close enough?</h3> <p>The precision provided by IEEE 754 Binary64 is sufficient for most computations. For example, if "47.49" represents a price and inflation is running at 2% per year, then the price is going up by about 0.0000000301 dollars per second. The error in the recorded value of 47.49 represents about 66 nanoseconds worth of inflation. So if the 47.49 price is exact when you enter it, then the effects of inflation will cause the true value to exactly equal the value actually stored (47.4900000000000019895196601282805204391479492187) in less than one ten-millionth of a second. Surely that level of precision is sufficient for most purposes? </p>
<h1 id="extensions_for_dealing_with_floating_point_numbers">
<span>2. </span>Extensions For Dealing With Floating Point Numbers</h1>  <h2 id="the_ieee754_c_extension">
<span>2.1. </span>The ieee754.c Extension</h2> <p id="ieee754ext">The ieee754 extension converts a floating point number between its binary64 representation and the M×2<sup><small>E</small></sup> format. In other words in the expression: </p>
<blockquote> <big>F = M &amp;times 2<sup><small>E</small></sup></big> </blockquote> <p>The ieee754 extension converts between F and (M,E) and back again. </p>
<p id="ieee754">The ieee754 extension is not part of the <a href="amalgamation">amalgamation</a>, but it is included by default in the <a href="cli">CLI</a>. If you want to include the ieee754 extension in your application, you will need to compile and load it separately.  </p>
<h3 id="the_ieee754_function">
<span>2.1.1. </span>The ieee754() function</h3> <p>The ieee754(F) SQL function takes a single floating-point argument as its input and returns a string that looks like this: </p>
<blockquote> 'ieee754(M,E)' </blockquote> <p>Except that the M and E are replaced by the mantissa and exponent of the floating point number. For example: </p>
<pre data-language="sql">sqlite&gt; .mode box
sqlite&gt; SELECT ieee754(47.49) AS x;
┌───────────────────────────────┐
│               x               │
├───────────────────────────────┤
│ ieee754(6683623321994527,-47) │
└───────────────────────────────┘
</pre> <p> Going in the other direction, the 2-argument version of ieee754() takes the M and E values and converts them into the corresponding F value: </p>
<pre data-language="sql">sqlite&gt; select ieee754(6683623321994527,-47) as x;
┌───────┐
│   x   │
├───────┤
│ 47.49 │
└───────┘
</pre>  <h3 id="the_ieee754_mantissa_and_ieee754_exponent_functions">
<span>2.1.2. </span>The ieee754_mantissa() and ieee754_exponent() functions</h3> <p id="ieee754m">The text output of the one-argument form of ieee754() is great for human readability, but it awkward to use as part of a larger expression. Hence The ieee754_mantissa() and ieee754_exponent() routines were added to return the M and E values corresponding to their single argument F value. For example: </p>
<pre data-language="sql">sqlite&gt; .mode box
sqlite&gt; SELECT ieee754_mantissa(47.49) AS M, ieee754_exponent(47.49) AS E;
┌──────────────────┬─────┐
│        M         │  E  │
├──────────────────┼─────┤
│ 6683623321994527 │ -47 │
└──────────────────┴─────┘
</pre>  <h3 id="the_ieee754_from_blob_and_ieee754_to_blob_functions">
<span>2.1.3. </span>The ieee754_from_blob() and ieee754_to_blob() functions</h3> <p id="ieee754b">The ieee754_to_blob(F) SQL function converts the floating point number F into an 8-byte BLOB that is the big-endian binary64 encoding of that number. The ieee754_from_blob(B) function goes the other way, converting an 8-byte blob into the floating-point value that the binary64 encoding represents. </p>
<p>So, for example, if you read <a href="#">on Wikipedia</a> that the encoding for the minimum positive binary64 value is 0x0000000000000001, then you can find the corresponding floating point value like this: </p>
<pre data-language="sql">sqlite&gt; .mode box
sqlite&gt; SELECT ieee754_from_blob(x'0000000000000001') AS F;
┌───────────────────────┐
│           F           │
├───────────────────────┤
│ 4.94065645841247e-324 │
└───────────────────────┘
</pre> <p>Or go the other way: </p>
<pre data-language="sql">sqlite&gt; .mode box
sqlite&gt; SELECT quote(ieee754_to_blob(4.94065645841247e-324)) AS binary64;
┌─────────────────────┐
│      binary64       │
├─────────────────────┤
│ X'0000000000000001' │
└─────────────────────┘
</pre>  <h2 id="the_decimal_c_extension">
<span>2.2. </span>The decimal.c Extension</h2> <p id="decext">The decimal extension provides arbitrary-precision decimal arithmetic on numbers stored as text strings. Because the numbers are stored to arbitrary precision and as text, no approximations are needed. Computations can be done exactly. </p>
<p>The decimal extension is not (currently) part of the SQLite <a href="amalgamation">amalgamation</a>. However, it is included in the <a href="cli">CLI</a>. </p>
<p>There are three math functions available: </p>

<ul> <li> decimal_add(A,B) </li>
<li> decimal_sub(A,B) </li>
<li> decimal_mul(A,B) </li>
</ul> <p>These functions respectively add, subtract, and multiply their arguments and return a new text string that is the decimal representation of the result. There is no division operator at this time. </p>
<p>Use the decimal_cmp(A,B) to compare two decimal values. The result will be negative, zero, or positive if A is less than, equal to, or greater than B, respectively. </p>
<p>The decimal_sum(X) function is an aggregate, like the built-in <a href="lang_aggfunc#sumunc">sum() aggregate function</a>, except that decimal_sum() computes its result to arbitrary precision and is therefore precise. </p>
<p>Finally, the decimal extension provides the "decimal" collating sequences that compares decimal text strings in numeric order. </p>
<h1 id="techniques">
<span>3. </span>Techniques</h1> <p> The following SQL illustrates how to use the ieee754 and decimal extensions to compute the exact decimal equivalent for a binary64 floating-point number. </p>
<pre data-language="sql">-- The pow2 table will hold all the necessary powers of two.
CREATE TABLE pow2(x INTEGER PRIMARY KEY, v TEXT);
WITH RECURSIVE c(x,v) AS (
  VALUES(0,'1')
  UNION ALL
  SELECT x+1, decimal_mul(v,'2') FROM c WHERE x+1&lt;=971
) INSERT INTO pow2(x,v) SELECT x, v FROM c;
WITH RECURSIVE c(x,v) AS (
  VALUES(-1,'0.5')
  UNION ALL
  SELECT x-1, decimal_mul(v,'0.5') FROM c WHERE x-1&gt;=-1075
) INSERT INTO pow2(x,v) SELECT x, v FROM c;

-- This query finds the decimal representation of each value in the "c" table.
WITH c(n) AS (VALUES(47.49))
                 ----XXXXX----------- Replace with whatever you want
SELECT decimal_mul(ieee754_mantissa(c.n),pow2.v)
  FROM pow2, c WHERE pow2.x=ieee754_exponent(c.n);
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/floatingpoint.html" class="_attribution-link">https://sqlite.org/floatingpoint.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
