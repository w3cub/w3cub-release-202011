
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.RaggedTensor - TensorFlow 1.15 - W3cubDocs</title>
  
  <meta name="description" content=" ">
  <meta name="keywords" content="tf, raggedtensora, -d, ragged, tensor, with, dimensions, raggedtensor, tensorflow, tensorflow~1.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~1.15/raggedtensor.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/tensorflow~1.15.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~1.15/" class="_nav-link" title="" style="margin-left:0;">TensorFlow 1.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 class="devsite-page-title">tf.RaggedTensor</h1>   <p><devsite-mathjax config="TeX-AMS-MML_SVG"></devsite-mathjax> </p>   <table class="tfo-notebook-buttons tfo-api" align="left">  <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L55-L1868">  View source on GitHub </a> </td> </table> <p>Represents a ragged tensor.</p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases" tabindex="0">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/RaggedTensor"><code translate="no" dir="ltr">tf.compat.v1.RaggedTensor</code></a>, `tf.compat.v2.RaggedTensor`</p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.RaggedTensor(
    values, row_splits, cached_row_lengths=None, cached_value_rowids=None,
    cached_nrows=None, internal=False
)
</pre>  <p>A <code translate="no" dir="ltr">RaggedTensor</code> is a tensor with one or more <em>ragged dimensions</em>, which are dimensions whose slices may have different lengths. For example, the inner (column) dimension of <code translate="no" dir="ltr">rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]</code> is ragged, since the column slices (<code translate="no" dir="ltr">rt[0, :]</code>, ..., <code translate="no" dir="ltr">rt[4, :]</code>) have different lengths. Dimensions whose slices all have the same length are called <em>uniform dimensions</em>. The outermost dimension of a <code translate="no" dir="ltr">RaggedTensor</code> is always uniform, since it consists of a single slice (and so there is no possibility for differing slice lengths).</p> <p>The total number of dimensions in a <code translate="no" dir="ltr">RaggedTensor</code> is called its <em>rank</em>, and the number of ragged dimensions in a <code translate="no" dir="ltr">RaggedTensor</code> is called its <em>ragged-rank</em>. A <code translate="no" dir="ltr">RaggedTensor</code>'s ragged-rank is fixed at graph creation time: it can't depend on the runtime values of <code translate="no" dir="ltr">Tensor</code>s, and can't vary dynamically for different session runs.</p> <h3 id="potentially_ragged_tensors" data-text="Potentially Ragged Tensors" tabindex="0">Potentially Ragged Tensors</h3> <p>Many ops support both <code translate="no" dir="ltr">Tensor</code>s and <code translate="no" dir="ltr">RaggedTensor</code>s. The term "potentially ragged tensor" may be used to refer to a tensor that might be either a <code translate="no" dir="ltr">Tensor</code> or a <code translate="no" dir="ltr">RaggedTensor</code>. The ragged-rank of a <code translate="no" dir="ltr">Tensor</code> is zero.</p> <h3 id="documenting_raggedtensor_shapes" data-text="Documenting RaggedTensor Shapes" tabindex="0">Documenting RaggedTensor Shapes</h3> <p>When documenting the shape of a RaggedTensor, ragged dimensions can be indicated by enclosing them in parentheses. For example, the shape of a 3-D <code translate="no" dir="ltr">RaggedTensor</code> that stores the fixed-size word embedding for each word in a sentence, for each sentence in a batch, could be written as <code translate="no" dir="ltr">[num_sentences, (num_words), embedding_size]</code>. The parentheses around <code translate="no" dir="ltr">(num_words)</code> indicate that dimension is ragged, and that the length of each element list in that dimension may vary for each item.</p> <h3 id="component_tensors" data-text="Component Tensors" tabindex="0">Component Tensors</h3> <p>Internally, a <code translate="no" dir="ltr">RaggedTensor</code> consists of a concatenated list of values that are partitioned into variable-length rows. In particular, each <code translate="no" dir="ltr">RaggedTensor</code> consists of:</p> <ul> <li><p>A <code translate="no" dir="ltr">values</code> tensor, which concatenates the variable-length rows into a flattened list. For example, the <code translate="no" dir="ltr">values</code> tensor for <code translate="no" dir="ltr">[[3, 1, 4, 1], [], [5, 9, 2], [6], []]</code> is <code translate="no" dir="ltr">[3, 1, 4, 1, 5, 9, 2, 6]</code>.</p></li> <li><p>A <code translate="no" dir="ltr">row_splits</code> vector, which indicates how those flattened values are divided into rows. In particular, the values for row <code translate="no" dir="ltr">rt[i]</code> are stored in the slice <code translate="no" dir="ltr">rt.values[rt.row_splits[i]:rt.row_splits[i+1]]</code>.</p></li> </ul> <h4 id="example" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
print(tf.RaggedTensor.from_row_splits(
    values=[3, 1, 4, 1, 5, 9, 2, 6],
    row_splits=[0, 4, 4, 7, 8, 8]))
&lt;tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]&gt;
</pre> <h3 id="alternative_row-partitioning_schemes" data-text="Alternative Row-Partitioning Schemes" tabindex="0">Alternative Row-Partitioning Schemes</h3> <p>In addition to <code translate="no" dir="ltr">row_splits</code>, ragged tensors provide support for four other row-partitioning schemes:</p> <ul> <li><p><code translate="no" dir="ltr">row_lengths</code>: a vector with shape <code translate="no" dir="ltr">[nrows]</code>, which specifies the length of each row.</p></li> <li><p><code translate="no" dir="ltr">value_rowids</code> and <code translate="no" dir="ltr">nrows</code>: <code translate="no" dir="ltr">value_rowids</code> is a vector with shape <code translate="no" dir="ltr">[nvals]</code>, corresponding one-to-one with <code translate="no" dir="ltr">values</code>, which specifies each value's row index. In particular, the row <code translate="no" dir="ltr">rt[row]</code> consists of the values <code translate="no" dir="ltr">rt.values[j]</code> where <code translate="no" dir="ltr">value_rowids[j]==row</code>. <code translate="no" dir="ltr">nrows</code> is an integer scalar that specifies the number of rows in the <code translate="no" dir="ltr">RaggedTensor</code>. (<code translate="no" dir="ltr">nrows</code> is used to indicate trailing empty rows.)</p></li> <li><p><code translate="no" dir="ltr">row_starts</code>: a vector with shape <code translate="no" dir="ltr">[nrows]</code>, which specifies the start offset of each row. Equivalent to <code translate="no" dir="ltr">row_splits[:-1]</code>.</p></li> <li><p><code translate="no" dir="ltr">row_limits</code>: a vector with shape <code translate="no" dir="ltr">[nrows]</code>, which specifies the stop offset of each row. Equivalent to <code translate="no" dir="ltr">row_splits[1:]</code>.</p></li> </ul> <p>Example: The following ragged tensors are equivalent, and all represent the nested list <code translate="no" dir="ltr">[[3, 1, 4, 1], [], [5, 9, 2], [6], []]</code>.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
values = [3, 1, 4, 1, 5, 9, 2, 6]
rt1 = RaggedTensor.from_row_splits(values, row_splits=[0, 4, 4, 7, 8, 8])
rt2 = RaggedTensor.from_row_lengths(values, row_lengths=[4, 0, 3, 1, 0])
rt3 = RaggedTensor.from_value_rowids(
    values, value_rowids=[0, 0, 0, 0, 2, 2, 2, 3], nrows=5)
rt4 = RaggedTensor.from_row_starts(values, row_starts=[0, 4, 4, 7, 8])
rt5 = RaggedTensor.from_row_limits(values, row_limits=[4, 4, 7, 8, 8])
</pre> <h3 id="multiple_ragged_dimensions" data-text="Multiple Ragged Dimensions" tabindex="0">Multiple Ragged Dimensions</h3> <p><code translate="no" dir="ltr">RaggedTensor</code>s with multiple ragged dimensions can be defined by using a nested <code translate="no" dir="ltr">RaggedTensor</code> for the <code translate="no" dir="ltr">values</code> tensor. Each nested <code translate="no" dir="ltr">RaggedTensor</code> adds a single ragged dimension.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
inner_rt = RaggedTensor.from_row_splits(  # =rt1 from above
    values=[3, 1, 4, 1, 5, 9, 2, 6], row_splits=[0, 4, 4, 7, 8, 8])
outer_rt = RaggedTensor.from_row_splits(
    values=inner_rt, row_splits=[0, 3, 3, 5])
print outer_rt.to_list()
[[[3, 1, 4, 1], [], [5, 9, 2]], [], [[6], []]]
print outer_rt.ragged_rank
2
</pre> <p>The factory function <a href="raggedtensor#from_nested_row_splits"><code translate="no" dir="ltr">RaggedTensor.from_nested_row_splits</code></a> may be used to construct a <code translate="no" dir="ltr">RaggedTensor</code> with multiple ragged dimensions directly, by providing a list of <code translate="no" dir="ltr">row_splits</code> tensors:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
RaggedTensor.from_nested_row_splits(
    flat_values=[3, 1, 4, 1, 5, 9, 2, 6],
    nested_row_splits=([0, 3, 3, 5], [0, 4, 4, 7, 8, 8])).to_list()
[[[3, 1, 4, 1], [], [5, 9, 2]], [], [[6], []]]
</pre> <h3 id="uniform_inner_dimensions" data-text="Uniform Inner Dimensions" tabindex="0">Uniform Inner Dimensions</h3> <p><code translate="no" dir="ltr">RaggedTensor</code>s with uniform inner dimensions can be defined by using a multidimensional <code translate="no" dir="ltr">Tensor</code> for <code translate="no" dir="ltr">values</code>.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
rt = RaggedTensor.from_row_splits(values=tf.ones([5, 3]),
..                                    row_splits=[0, 2, 5])
print rt.to_list()
[[[1, 1, 1], [1, 1, 1]],
 [[1, 1, 1], [1, 1, 1], [1, 1, 1]]]
print rt.shape
 (2, ?, 3)
</pre> <h3 id="raggedtensor_shape_restrictions" data-text="RaggedTensor Shape Restrictions" tabindex="0">RaggedTensor Shape Restrictions</h3> <p>The shape of a RaggedTensor is currently restricted to have the following form:</p> <ul> <li>A single uniform dimension</li> <li>Followed by one or more ragged dimensions</li> <li>Followed by zero or more uniform dimensions.</li> </ul> <p>This restriction follows from the fact that each nested <code translate="no" dir="ltr">RaggedTensor</code> replaces the uniform outermost dimension of its <code translate="no" dir="ltr">values</code> with a uniform dimension followed by a ragged dimension.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> A potentially ragged tensor of any dtype and shape <code translate="no" dir="ltr">[nvals, ...]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_splits</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows+1]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">cached_row_lengths</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">cached_value_rowids</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nvals]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">cached_nrows</code> </td> <td> A 1-D integer scalar tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">internal</code> </td> <td> True if the constructor is being called by one of the factory methods. If false, an exception will be raised. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If a row partitioning tensor has an inappropriate dtype. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If exactly one row partitioning argument was not specified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If a row partitioning tensor has an inappropriate shape. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If multiple partitioning arguments are specified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If nrows is specified but value_rowids is not None. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> The <code translate="no" dir="ltr">DType</code> of values in this tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">flat_values</code> </td> <td> The innermost <code translate="no" dir="ltr">values</code> tensor for this ragged tensor. <p>Concretely, if <code translate="no" dir="ltr">rt.values</code> is a <code translate="no" dir="ltr">Tensor</code>, then <code translate="no" dir="ltr">rt.flat_values</code> is <code translate="no" dir="ltr">rt.values</code>; otherwise, <code translate="no" dir="ltr">rt.flat_values</code> is <code translate="no" dir="ltr">rt.values.flat_values</code>.</p> <p>Conceptually, <code translate="no" dir="ltr">flat_values</code> is the tensor formed by flattening the outermost dimension and all of the ragged dimensions into a single dimension.</p> <p><code translate="no" dir="ltr">rt.flat_values.shape = [nvals] + rt.shape[rt.ragged_rank + 1:]</code> (where <code translate="no" dir="ltr">nvals</code> is the number of items in the flattened dimensions).</p> <h4 id="example_2" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
rt = ragged.constant([[[3, 1, 4, 1], [], [5, 9, 2]], [], [[6], []]])
print rt.flat_values()
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
</pre> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">nested_row_splits</code> </td> <td> A tuple containing the row_splits for all ragged dimensions. <p><code translate="no" dir="ltr">rt.nested_row_splits</code> is a tuple containing the <code translate="no" dir="ltr">row_splits</code> tensors for all ragged dimensions in <code translate="no" dir="ltr">rt</code>, ordered from outermost to innermost. In particular, <code translate="no" dir="ltr">rt.nested_row_splits = (rt.row_splits,) + value_splits</code> where:</p> <ul> <li>
<code translate="no" dir="ltr">value_splits = ()</code> if <code translate="no" dir="ltr">rt.values</code> is a <code translate="no" dir="ltr">Tensor</code>.</li> <li>
<code translate="no" dir="ltr">value_splits = rt.values.nested_row_splits</code> otherwise.</li> </ul> <h4 id="example_3" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
rt = ragged.constant([[[[3, 1, 4, 1], [], [5, 9, 2]], [], [[6], []]]])
for i, splits in enumerate(rt.nested_row_splits()):
  print('Splits for dimension %d: %s' % (i+1, splits))
Splits for dimension 1: [0, 1]
Splits for dimension 2: [0, 3, 3, 5]
Splits for dimension 3: [0, 4, 4, 7, 8, 8]
</pre> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">ragged_rank</code> </td> <td> The number of ragged dimensions in this ragged tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_splits</code> </td> <td> The row-split indices for this ragged tensor's <code translate="no" dir="ltr">values</code>. <p><code translate="no" dir="ltr">rt.row_splits</code> specifies where the values for each row begin and end in <code translate="no" dir="ltr">rt.values</code>. In particular, the values for row <code translate="no" dir="ltr">rt[i]</code> are stored in the slice <code translate="no" dir="ltr">rt.values[rt.row_splits[i]:rt.row_splits[i+1]]</code>.</p> <h4 id="example_4" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">&gt;&gt;&gt; rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
&gt;&gt;&gt; print rt.row_splits  # indices of row splits in rt.values
tf.Tensor([0, 4, 4, 7, 8, 8])
</pre> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">shape</code> </td> <td> The statically known shape of this ragged tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> The concatenated rows for this ragged tensor. <p><code translate="no" dir="ltr">rt.values</code> is a potentially ragged tensor formed by flattening the two outermost dimensions of <code translate="no" dir="ltr">rt</code> into a single dimension.</p> <p><code translate="no" dir="ltr">rt.values.shape = [nvals] + rt.shape[2:]</code> (where <code translate="no" dir="ltr">nvals</code> is the number of items in the outer two dimensions of <code translate="no" dir="ltr">rt</code>).</p> <p><code translate="no" dir="ltr">rt.ragged_rank = self.ragged_rank - 1</code></p> <h4 id="example_5" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">&gt;&gt;&gt; rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
&gt;&gt;&gt; print rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
</pre> 
</td> </tr> </table> <h2 id="methods" data-text="Methods" tabindex="0">Methods</h2> <h3 id="bounding_shape" data-text="bounding_shape" tabindex="0"><code translate="no" dir="ltr">bounding_shape</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1169-L1219">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
bounding_shape(
    axis=None, name=None, out_type=None
)
</pre> <p>Returns the tight bounding box shape for this <code translate="no" dir="ltr">RaggedTensor</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">axis</code> </td> <td> An integer scalar or vector indicating which axes to return the bounding box for. If not specified, then the full bounding box is returned. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">out_type</code> </td> <td> <code translate="no" dir="ltr">dtype</code> for the returned tensor. Defaults to <code translate="no" dir="ltr">self.row_splits.dtype</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An integer <code translate="no" dir="ltr">Tensor</code> (<code translate="no" dir="ltr">dtype=self.row_splits.dtype</code>). If <code translate="no" dir="ltr">axis</code> is not specified, then <code translate="no" dir="ltr">output</code> is a vector with <code translate="no" dir="ltr">output.shape=[self.shape.ndims]</code>. If <code translate="no" dir="ltr">axis</code> is a scalar, then the <code translate="no" dir="ltr">output</code> is a scalar. If <code translate="no" dir="ltr">axis</code> is a vector, then <code translate="no" dir="ltr">output</code> is a vector, where <code translate="no" dir="ltr">output[i]</code> is the bounding size for dimension <code translate="no" dir="ltr">axis[i]</code>. </td> </tr> 
</table> <h4 id="example_6" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; rt = ragged.constant([[1, 2, 3, 4], [5], [], [6, 7, 8, 9], [10]])
&gt;&gt;&gt; rt.bounding_shape()
[5, 4]
</pre> <h3 id="consumers" data-text="consumers" tabindex="0"><code translate="no" dir="ltr">consumers</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1867-L1868">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
consumers()
</pre> <h3 id="from_nested_row_lengths" data-text="from_nested_row_lengths" tabindex="0"><code translate="no" dir="ltr">from_nested_row_lengths</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L718-L754">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_nested_row_lengths(
    flat_values, nested_row_lengths, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> from a nested list of <code translate="no" dir="ltr">row_lengths</code> tensors.</p> <h4 id="equivalent_to" data-text="Equivalent to:" tabindex="0">Equivalent to:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">result = flat_values
for row_lengths in reversed(nested_row_lengths):
  result = from_row_lengths(result, row_lengths)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">flat_values</code> </td> <td> A potentially ragged tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nested_row_lengths</code> </td> <td> A list of 1-D integer tensors. The <code translate="no" dir="ltr">i</code>th tensor is used as the <code translate="no" dir="ltr">row_lengths</code> for the <code translate="no" dir="ltr">i</code>th ragged dimension. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code> (or <code translate="no" dir="ltr">flat_values</code> if <code translate="no" dir="ltr">nested_row_lengths</code> is empty). </td> </tr> 
</table> <h3 id="from_nested_row_splits" data-text="from_nested_row_splits" tabindex="0"><code translate="no" dir="ltr">from_nested_row_splits</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L680-L716">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_nested_row_splits(
    flat_values, nested_row_splits, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> from a nested list of <code translate="no" dir="ltr">row_splits</code> tensors.</p> <h4 id="equivalent_to_2" data-text="Equivalent to:" tabindex="0">Equivalent to:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">result = flat_values
for row_splits in reversed(nested_row_splits):
  result = from_row_splits(result, row_splits)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">flat_values</code> </td> <td> A potentially ragged tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nested_row_splits</code> </td> <td> A list of 1-D integer tensors. The <code translate="no" dir="ltr">i</code>th tensor is used as the <code translate="no" dir="ltr">row_splits</code> for the <code translate="no" dir="ltr">i</code>th ragged dimension. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code> (or <code translate="no" dir="ltr">flat_values</code> if <code translate="no" dir="ltr">nested_row_splits</code> is empty). </td> </tr> 
</table> <h3 id="from_nested_value_rowids" data-text="from_nested_value_rowids" tabindex="0"><code translate="no" dir="ltr">from_nested_value_rowids</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L624-L678">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_nested_value_rowids(
    flat_values, nested_value_rowids, nested_nrows=None, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> from a nested list of <code translate="no" dir="ltr">value_rowids</code> tensors.</p> <h4 id="equivalent_to_3" data-text="Equivalent to:" tabindex="0">Equivalent to:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">result = flat_values
for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
  result = from_value_rowids(result, rowids, nrows)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">flat_values</code> </td> <td> A potentially ragged tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nested_value_rowids</code> </td> <td> A list of 1-D integer tensors. The <code translate="no" dir="ltr">i</code>th tensor is used as the <code translate="no" dir="ltr">value_rowids</code> for the <code translate="no" dir="ltr">i</code>th ragged dimension. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nested_nrows</code> </td> <td> A list of integer scalars. The <code translate="no" dir="ltr">i</code>th scalar is used as the <code translate="no" dir="ltr">nrows</code> for the <code translate="no" dir="ltr">i</code>th ragged dimension. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code> (or <code translate="no" dir="ltr">flat_values</code> if <code translate="no" dir="ltr">nested_value_rowids</code> is empty). </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">len(nested_values_rowids) != len(nested_nrows)</code>. </td> </tr> </table> <h3 id="from_row_lengths" data-text="from_row_lengths" tabindex="0"><code translate="no" dir="ltr">from_row_lengths</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L465-L522">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_lengths(
    values, row_lengths, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> with rows partitioned by <code translate="no" dir="ltr">row_lengths</code>.</p> <p>The returned <code translate="no" dir="ltr">RaggedTensor</code> corresponds with the python list defined by:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">result = [[values.pop(0) for i in range(length)]
          for length in row_lengths]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> A potentially ragged tensor with shape <code translate="no" dir="ltr">[nvals, ...]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_lengths</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code>. Must be nonnegative. <code translate="no" dir="ltr">sum(row_lengths)</code> must be <code translate="no" dir="ltr">nvals</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code>. <code translate="no" dir="ltr">result.rank = values.rank + 1</code>. <code translate="no" dir="ltr">result.ragged_rank = values.ragged_rank + 1</code>. </td> </tr> 
</table> <h4 id="example_7" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
&lt;tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])&gt;
</pre> <h3 id="from_row_limits" data-text="from_row_limits" tabindex="0"><code translate="no" dir="ltr">from_row_limits</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L574-L622">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_limits(
    values, row_limits, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> with rows partitioned by <code translate="no" dir="ltr">row_limits</code>.</p> <p>Equivalent to: <code translate="no" dir="ltr">from_row_splits(values, concat([0, row_limits]))</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> A potentially ragged tensor with shape <code translate="no" dir="ltr">[nvals, ...]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_limits</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code>. Must be sorted in ascending order. If <code translate="no" dir="ltr">nrows&gt;0</code>, then <code translate="no" dir="ltr">row_limits[-1]</code> must be <code translate="no" dir="ltr">nvals</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code>. <code translate="no" dir="ltr">result.rank = values.rank + 1</code>. <code translate="no" dir="ltr">result.ragged_rank = values.ragged_rank + 1</code>. </td> </tr> 
</table> <h4 id="example_8" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; print(tf.RaggedTensor.from_row_limits(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_limits=[4, 4, 7, 8, 8]))
&lt;tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]&gt;
</pre> <h3 id="from_row_splits" data-text="from_row_splits" tabindex="0"><code translate="no" dir="ltr">from_row_splits</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L403-L463">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_splits(
    values, row_splits, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> with rows partitioned by <code translate="no" dir="ltr">row_splits</code>.</p> <p>The returned <code translate="no" dir="ltr">RaggedTensor</code> corresponds with the python list defined by:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">result = [values[row_splits[i]:row_splits[i + 1]]
          for i in range(len(row_splits) - 1)]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> A potentially ragged tensor with shape <code translate="no" dir="ltr">[nvals, ...]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_splits</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows+1]</code>. Must not be empty, and must be sorted in ascending order. <code translate="no" dir="ltr">row_splits[0]</code> must be zero and <code translate="no" dir="ltr">row_splits[-1]</code> must be <code translate="no" dir="ltr">nvals</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code>. <code translate="no" dir="ltr">result.rank = values.rank + 1</code>. <code translate="no" dir="ltr">result.ragged_rank = values.ragged_rank + 1</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">row_splits</code> is an empty list. </td> </tr> </table> <h4 id="example_9" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; print(tf.RaggedTensor.from_row_splits(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_splits=[0, 4, 4, 7, 8, 8]))
&lt;tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]&gt;
</pre> <h3 id="from_row_starts" data-text="from_row_starts" tabindex="0"><code translate="no" dir="ltr">from_row_starts</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L524-L572">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_starts(
    values, row_starts, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> with rows partitioned by <code translate="no" dir="ltr">row_starts</code>.</p> <p>Equivalent to: <code translate="no" dir="ltr">from_row_splits(values, concat([row_starts, nvals]))</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> A potentially ragged tensor with shape <code translate="no" dir="ltr">[nvals, ...]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_starts</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code>. Must be nonnegative and sorted in ascending order. If <code translate="no" dir="ltr">nrows&gt;0</code>, then <code translate="no" dir="ltr">row_starts[0]</code> must be zero. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code>. <code translate="no" dir="ltr">result.rank = values.rank + 1</code>. <code translate="no" dir="ltr">result.ragged_rank = values.ragged_rank + 1</code>. </td> </tr> 
</table> <h4 id="example_10" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
&lt;tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]&gt;
</pre> <h3 id="from_sparse" data-text="from_sparse" tabindex="0"><code translate="no" dir="ltr">from_sparse</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1591-L1653">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_sparse(
    st_input, name=None, row_splits_dtype=tf.dtypes.int64
)
</pre> <p>Converts a 2D <a href="sparse/sparsetensor"><code translate="no" dir="ltr">tf.SparseTensor</code></a> to a <code translate="no" dir="ltr">RaggedTensor</code>.</p> <p>Each row of the <code translate="no" dir="ltr">output</code> <code translate="no" dir="ltr">RaggedTensor</code> will contain the explicit values from the same row in <code translate="no" dir="ltr">st_input</code>. <code translate="no" dir="ltr">st_input</code> must be ragged-right. If not it is not ragged-right, then an error will be generated.</p> <h4 id="example_11" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
st = SparseTensor(indices=[[0, 1], [0, 2], [0, 3], [1, 0], [3, 0]],
                  values=[1, 2, 3, 4, 5],
                  dense_shape=[4, 3])
rt.RaggedTensor.from_sparse(st).eval().tolist()
[[1, 2, 3], [4], [], [5]]
</pre> <p>Currently, only two-dimensional <code translate="no" dir="ltr">SparseTensors</code> are supported.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">st_input</code> </td> <td> The sparse tensor to convert. Must have rank 2. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensors (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_splits_dtype</code> </td> <td> <code translate="no" dir="ltr">dtype</code> for the returned <code translate="no" dir="ltr">RaggedTensor</code>'s <code translate="no" dir="ltr">row_splits</code> tensor. One of <a href="../tf#int32"><code translate="no" dir="ltr">tf.int32</code></a> or <a href="../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code> with the same values as <code translate="no" dir="ltr">st_input</code>. <code translate="no" dir="ltr">output.ragged_rank = rank(st_input) - 1</code>. <code translate="no" dir="ltr">output.shape = [st_input.dense_shape[0], None]</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If the number of dimensions in <code translate="no" dir="ltr">st_input</code> is not known statically, or is not two. </td> </tr> </table> <h3 id="from_tensor" data-text="from_tensor" tabindex="0"><code translate="no" dir="ltr">from_tensor</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1320-L1503">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_tensor(
    tensor, lengths=None, padding=None, ragged_rank=1, name=None,
    row_splits_dtype=tf.dtypes.int64
)
</pre> <p>Converts a <a href="tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> into a <code translate="no" dir="ltr">RaggedTensor</code>.</p> <p>The set of absent/default values may be specified using a vector of lengths or a padding value (but not both). If <code translate="no" dir="ltr">lengths</code> is specified, then the output tensor will satisfy <code translate="no" dir="ltr">output[row] = tensor[row][:lengths[row]]</code>. If 'lengths' is a list of lists or tuple of lists, those lists will be used as nested row lengths. If <code translate="no" dir="ltr">padding</code> is specified, then any row <em>suffix</em> consisting entirely of <code translate="no" dir="ltr">padding</code> will be excluded from the returned <code translate="no" dir="ltr">RaggedTensor</code>. If neither <code translate="no" dir="ltr">lengths</code> nor <code translate="no" dir="ltr">padding</code> is specified, then the returned <code translate="no" dir="ltr">RaggedTensor</code> will have no absent/default values.</p> <h4 id="examples" data-text="Examples:" tabindex="0">Examples:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
tf.RaggedTensor.from_tensor(dt)
&lt;tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]&gt;
tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
&lt;tf.RaggedTensor [[5], [], [6, 0, 0]]&gt;

</pre> <blockquote>   <p>tf.RaggedTensor.from_tensor(dt, padding=0) <tf.raggedtensor></tf.raggedtensor></p>   </blockquote> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">
&lt;pre class="devsite-click-to-copy prettyprint lang-py"&gt;
&lt;code class="devsite-terminal" data-terminal-prefix="&amp;gt;&amp;gt;&amp;gt;"&gt;dt = tf.constant([[[5, 0], [7, 0], [0, 0]],&lt;/code&gt;
&lt;code class="no-select nocode"&gt;                      [[0, 0], [3, 0], [0, 0]],&lt;/code&gt;
&lt;code class="no-select nocode"&gt;                      [[6, 0], [0, 0], [0, 0]]])&lt;/code&gt;
&lt;code class="devsite-terminal" data-terminal-prefix="&amp;gt;&amp;gt;&amp;gt;"&gt;tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))&lt;/code&gt;
&lt;code class="no-select nocode"&gt;&amp;lt;tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensor</code> </td> <td> The <code translate="no" dir="ltr">Tensor</code> to convert. Must have rank <code translate="no" dir="ltr">ragged_rank + 1</code> or higher. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">lengths</code> </td> <td> An optional set of row lengths, specified using a 1-D integer <code translate="no" dir="ltr">Tensor</code> whose length is equal to <code translate="no" dir="ltr">tensor.shape[0]</code> (the number of rows in <code translate="no" dir="ltr">tensor</code>). If specified, then <code translate="no" dir="ltr">output[row]</code> will contain <code translate="no" dir="ltr">tensor[row][:lengths[row]]</code>. Negative lengths are treated as zero. You may optionally pass a list or tuple of lengths to this argument, which will be used as nested row lengths to construct a ragged tensor with multiple ragged dimensions. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">padding</code> </td> <td> An optional padding value. If specified, then any row suffix consisting entirely of <code translate="no" dir="ltr">padding</code> will be excluded from the returned RaggedTensor. <code translate="no" dir="ltr">padding</code> is a <code translate="no" dir="ltr">Tensor</code> with the same dtype as <code translate="no" dir="ltr">tensor</code> and with <code translate="no" dir="ltr">shape=tensor.shape[ragged_rank + 1:]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ragged_rank</code> </td> <td> Integer specifying the ragged rank for the returned <code translate="no" dir="ltr">RaggedTensor</code>. Must be greater than zero. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensors (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_splits_dtype</code> </td> <td> <code translate="no" dir="ltr">dtype</code> for the returned <code translate="no" dir="ltr">RaggedTensor</code>'s <code translate="no" dir="ltr">row_splits</code> tensor. One of <a href="../tf#int32"><code translate="no" dir="ltr">tf.int32</code></a> or <a href="../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code> with the specified <code translate="no" dir="ltr">ragged_rank</code>. The shape of the returned ragged tensor is compatible with the shape of <code translate="no" dir="ltr">tensor</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If both <code translate="no" dir="ltr">lengths</code> and <code translate="no" dir="ltr">padding</code> are specified. </td> </tr> </table> <h3 id="from_value_rowids" data-text="from_value_rowids" tabindex="0"><code translate="no" dir="ltr">from_value_rowids</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L285-L401">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_value_rowids(
    values, value_rowids, nrows=None, name=None, validate=True
)
</pre> <p>Creates a <code translate="no" dir="ltr">RaggedTensor</code> with rows partitioned by <code translate="no" dir="ltr">value_rowids</code>.</p> <p>The returned <code translate="no" dir="ltr">RaggedTensor</code> corresponds with the python list defined by:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
          for row in range(nrows)]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> A potentially ragged tensor with shape <code translate="no" dir="ltr">[nvals, ...]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">value_rowids</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nvals]</code>, which corresponds one-to-one with <code translate="no" dir="ltr">values</code>, and specifies each value's row index. Must be nonnegative, and must be sorted in ascending order. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nrows</code> </td> <td> An integer scalar specifying the number of rows. This should be specified if the <code translate="no" dir="ltr">RaggedTensor</code> may containing empty training rows. Must be greater than <code translate="no" dir="ltr">value_rowids[-1]</code> (or zero if <code translate="no" dir="ltr">value_rowids</code> is empty). Defaults to <code translate="no" dir="ltr">value_rowids[-1]</code> (or zero if <code translate="no" dir="ltr">value_rowids</code> is empty). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the RaggedTensor (optional). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code>. <code translate="no" dir="ltr">result.rank = values.rank + 1</code>. <code translate="no" dir="ltr">result.ragged_rank = values.ragged_rank + 1</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">nrows</code> is incompatible with <code translate="no" dir="ltr">value_rowids</code>. </td> </tr> </table> <h4 id="example_12" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; print(tf.RaggedTensor.from_value_rowids(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     value_rowids=[0, 0, 0, 0, 2, 2, 2, 3],
...     nrows=5))
&lt;tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]&gt;
</pre> <h3 id="nested_row_lengths" data-text="nested_row_lengths" tabindex="0"><code translate="no" dir="ltr">nested_row_lengths</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1148-L1167">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
nested_row_lengths(
    name=None
)
</pre> <p>Returns a tuple containing the row_lengths for all ragged dimensions.</p> <p><code translate="no" dir="ltr">rt.nested_row_lengths()</code> is a tuple containing the <code translate="no" dir="ltr">row_lengths</code> tensors for all ragged dimensions in <code translate="no" dir="ltr">rt</code>, ordered from outermost to innermost.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensors (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">tuple</code> of 1-D integer <code translate="no" dir="ltr">Tensors</code>. The length of the tuple is equal to <code translate="no" dir="ltr">self.ragged_rank</code>. </td> </tr> 
</table> <h3 id="nested_value_rowids" data-text="nested_value_rowids" tabindex="0"><code translate="no" dir="ltr">nested_value_rowids</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L987-L1023">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
nested_value_rowids(
    name=None
)
</pre> <p>Returns a tuple containing the value_rowids for all ragged dimensions.</p> <p><code translate="no" dir="ltr">rt.nested_value_rowids</code> is a tuple containing the <code translate="no" dir="ltr">value_rowids</code> tensors for all ragged dimensions in <code translate="no" dir="ltr">rt</code>, ordered from outermost to innermost. In particular, <code translate="no" dir="ltr">rt.nested_value_rowids = (rt.value_rowids(),) + value_ids</code> where:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">* `value_ids = ()` if `rt.values` is a `Tensor`.
* `value_ids = rt.values.nested_value_rowids` otherwise.
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensors (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">tuple</code> of 1-D integer <code translate="no" dir="ltr">Tensor</code>s. </td> </tr> 
</table> <h4 id="example_13" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
rt = ragged.constant([[[[3, 1, 4, 1], [], [5, 9, 2]], [], [[6], []]]])
for i, ids in enumerate(rt.nested_value_rowids()):
  print('row ids for dimension %d: %s' % (i+1, ids))
  row ids for dimension 1: [0]
  row ids for dimension 2: [0, 0, 0, 2, 2]
  row ids for dimension 3: [0, 0, 0, 0, 2, 2, 2, 3]
  
</pre> <h3 id="nrows" data-text="nrows" tabindex="0"><code translate="no" dir="ltr">nrows</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1025-L1052">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
nrows(
    out_type=None, name=None
)
</pre> <p>Returns the number of rows in this ragged tensor.</p> <p>I.e., the size of the outermost dimension of the tensor.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">out_type</code> </td> <td> <code translate="no" dir="ltr">dtype</code> for the returned tensor. Defaults to <code translate="no" dir="ltr">self.row_splits.dtype</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensor (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A scalar <code translate="no" dir="ltr">Tensor</code> with dtype <code translate="no" dir="ltr">out_type</code>. </td> </tr> 
</table> <h4 id="example_14" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
&gt;&gt;&gt; rt.nrows()  # rt has 5 rows.
5
</pre> <h3 id="row_lengths" data-text="row_lengths" tabindex="0"><code translate="no" dir="ltr">row_lengths</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1104-L1146">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
row_lengths(
    axis=1, name=None
)
</pre> <p>Returns the lengths of the rows in this ragged tensor.</p> <p><code translate="no" dir="ltr">rt.row_lengths()[i]</code> indicates the number of values in the <code translate="no" dir="ltr">i</code>th row of <code translate="no" dir="ltr">rt</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">axis</code> </td> <td> An integer constant indicating the axis whose row lengths should be returned. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensor (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A potentially ragged integer Tensor with shape <code translate="no" dir="ltr">self.shape[:axis]</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">axis</code> is out of bounds. </td> </tr> </table> <h4 id="example_15" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; rt = ragged.constant([[[3, 1, 4], [1]], [], [[5, 9], [2]], [[6]], []])
&gt;&gt;&gt; rt.row_lengths(rt)  # lengths of rows in rt
tf.Tensor([2, 0, 2, 1, 0])
&gt;&gt;&gt; rt.row_lengths(axis=2)  # lengths of axis=2 rows.
&lt;tf.RaggedTensor [[3, 1], [], [2, 1], [1], []]&gt;
</pre> <h3 id="row_limits" data-text="row_limits" tabindex="0"><code translate="no" dir="ltr">row_limits</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1079-L1102">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
row_limits(
    name=None
)
</pre> <p>Returns the limit indices for rows in this ragged tensor.</p> <p>These indices specify where the values for each row end in <code translate="no" dir="ltr">self.values</code>. <code translate="no" dir="ltr">rt.row_limits(self)</code> is equal to <code translate="no" dir="ltr">rt.row_splits[:-1]</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensor (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A 1-D integer Tensor with shape <code translate="no" dir="ltr">[nrows]</code>. The returned tensor is nonnegative, and is sorted in ascending order. </td> </tr> 
</table> <h4 id="example_16" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
&gt;&gt;&gt; rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
&gt;&gt;&gt; rt.row_limits()  # indices of row limits in rt.values
tf.Tensor([4, 4, 7, 8, 8])
</pre> <h3 id="row_starts" data-text="row_starts" tabindex="0"><code translate="no" dir="ltr">row_starts</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1054-L1077">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
row_starts(
    name=None
)
</pre> <p>Returns the start indices for rows in this ragged tensor.</p> <p>These indices specify where the values for each row begin in <code translate="no" dir="ltr">self.values</code>. <code translate="no" dir="ltr">rt.row_starts()</code> is equal to <code translate="no" dir="ltr">rt.row_splits[:-1]</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensor (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A 1-D integer Tensor with shape <code translate="no" dir="ltr">[nrows]</code>. The returned tensor is nonnegative, and is sorted in ascending order. </td> </tr> 
</table> <h4 id="example_17" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
&gt;&gt;&gt; rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
&gt;&gt;&gt; rt.row_starts()  # indices of row starts in rt.values
tf.Tensor([0, 4, 4, 7, 8])
</pre> <h3 id="to_list" data-text="to_list" tabindex="0"><code translate="no" dir="ltr">to_list</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1794-L1807">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
to_list()
</pre> <p>Returns a nested Python <code translate="no" dir="ltr">list</code> with the values for this <code translate="no" dir="ltr">RaggedTensor</code>.</p> <p>Requires that <code translate="no" dir="ltr">rt</code> was constructed in eager execution mode.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A nested Python <code translate="no" dir="ltr">list</code>. </td> </tr> 
</table> <h3 id="to_sparse" data-text="to_sparse" tabindex="0"><code translate="no" dir="ltr">to_sparse</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1655-L1679">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
to_sparse(
    name=None
)
</pre> <p>Converts this <code translate="no" dir="ltr">RaggedTensor</code> into a <a href="sparse/sparsetensor"><code translate="no" dir="ltr">tf.SparseTensor</code></a>.</p> <h4 id="example_18" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
rt = ragged.constant([[1, 2, 3], [4], [], [5, 6]])
rt.to_sparse().eval()
SparseTensorValue(indices=[[0, 0], [0, 1], [0, 2], [1, 0], [3, 0], [3, 1]],
                  values=[1, 2, 3, 4, 5, 6],
                  dense_shape=[4, 3])
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensors (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A SparseTensor with the same values as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table> <h3 id="to_tensor" data-text="to_tensor" tabindex="0"><code translate="no" dir="ltr">to_tensor</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1505-L1589">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
to_tensor(
    default_value=None, name=None
)
</pre> <p>Converts this <code translate="no" dir="ltr">RaggedTensor</code> into a <a href="tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>.</p> <h4 id="example_19" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
rt = ragged.constant([[9, 8, 7], [], [6, 5], [4]])
print rt.to_tensor()
[[9 8 7]
 [0 0 0]
 [6 5 0]
 [4 0 0]]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">default_value</code> </td> <td> Value to set for indices not specified in <code translate="no" dir="ltr">self</code>. Defaults to zero. <code translate="no" dir="ltr">default_value</code> must be broadcastable to <code translate="no" dir="ltr">self.shape[self.ragged_rank + 1:]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensors (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">ragged.bounding_shape(self)</code> and the values specified by the non-empty values in <code translate="no" dir="ltr">self</code>. Empty values are assigned <code translate="no" dir="ltr">default_value</code>. </td> </tr> 
</table> <h3 id="value_rowids" data-text="value_rowids" tabindex="0"><code translate="no" dir="ltr">value_rowids</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L957-L985">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
value_rowids(
    name=None
)
</pre> <p>Returns the row indices for the <code translate="no" dir="ltr">values</code> in this ragged tensor.</p> <p><code translate="no" dir="ltr">rt.value_rowids()</code> corresponds one-to-one with the outermost dimension of <code translate="no" dir="ltr">rt.values</code>, and specifies the row containing each value. In particular, the row <code translate="no" dir="ltr">rt[row]</code> consists of the values <code translate="no" dir="ltr">rt.values[j]</code> where <code translate="no" dir="ltr">rt.value_rowids()[j] == row</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name prefix for the returned tensor (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A 1-D integer <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">self.values.shape[:1]</code>. The returned tensor is nonnegative, and is sorted in ascending order. </td> </tr> 
</table> <h4 id="example_20" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
&gt;&gt;&gt; rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
&gt;&gt;&gt; rt.value_rowids()
tf.Tensor([0, 0, 0, 0, 2, 2, 2, 3])  # corresponds 1:1 with rt.values
</pre> <h3 id="with_flat_values" data-text="with_flat_values" tabindex="0"><code translate="no" dir="ltr">with_flat_values</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1258-L1277">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
with_flat_values(
    new_values
)
</pre> <p>Returns a copy of <code translate="no" dir="ltr">self</code> with <code translate="no" dir="ltr">flat_values</code> replaced by <code translate="no" dir="ltr">new_value</code>.</p> <p>Preserves cached row-partitioning tensors such as <code translate="no" dir="ltr">self.cached_nrows</code> and <code translate="no" dir="ltr">self.cached_value_rowids</code> if they have values.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">new_values</code> </td> <td> Potentially ragged tensor that should replace <code translate="no" dir="ltr">self.flat_values</code>. Must have <code translate="no" dir="ltr">rank &gt; 0</code>, and must have the same number of rows as <code translate="no" dir="ltr">self.flat_values</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code>. <code translate="no" dir="ltr">result.rank = self.ragged_rank + new_values.rank</code>. <code translate="no" dir="ltr">result.ragged_rank = self.ragged_rank + new_values.ragged_rank</code>. </td> </tr> 
</table> <h3 id="with_row_splits_dtype" data-text="with_row_splits_dtype" tabindex="0"><code translate="no" dir="ltr">with_row_splits_dtype</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1279-L1314">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
with_row_splits_dtype(
    dtype
)
</pre> <p>Returns a copy of this RaggedTensor with the given <code translate="no" dir="ltr">row_splits</code> dtype.</p> <p>For RaggedTensors with multiple ragged dimensions, the <code translate="no" dir="ltr">row_splits</code> for all nested <code translate="no" dir="ltr">RaggedTensor</code> objects are cast to the given dtype.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> The dtype for <code translate="no" dir="ltr">row_splits</code>. One of <a href="../tf#int32"><code translate="no" dir="ltr">tf.int32</code></a> or <a href="../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A copy of this RaggedTensor, with the <code translate="no" dir="ltr">row_splits</code> cast to the given type. </td> </tr> 
</table> <h3 id="with_values" data-text="with_values" tabindex="0"><code translate="no" dir="ltr">with_values</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_tensor.py#L1225-L1256">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
with_values(
    new_values
)
</pre> <p>Returns a copy of <code translate="no" dir="ltr">self</code> with <code translate="no" dir="ltr">values</code> replaced by <code translate="no" dir="ltr">new_value</code>.</p> <p>Preserves cached row-partitioning tensors such as <code translate="no" dir="ltr">self.cached_nrows</code> and <code translate="no" dir="ltr">self.cached_value_rowids</code> if they have values.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">new_values</code> </td> <td> Potentially ragged tensor to use as the <code translate="no" dir="ltr">values</code> for the returned <code translate="no" dir="ltr">RaggedTensor</code>. Must have <code translate="no" dir="ltr">rank &gt; 0</code>, and must have the same number of rows as <code translate="no" dir="ltr">self.values</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RaggedTensor</code>. <code translate="no" dir="ltr">result.rank = 1 + new_values.rank</code>. <code translate="no" dir="ltr">result.ragged_rank = 1 + new_values.ragged_rank</code> </td> </tr> 
</table> <h3 id="__abs__" data-text="__abs__" tabindex="0"><code translate="no" dir="ltr">__abs__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L245-L278">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__abs__(
    x, name=None
)
</pre> <p>Computes the absolute value of a tensor.</p> <p>Given a tensor of integer or floating-point values, this operation returns a tensor of the same type, where each element contains the absolute value of the corresponding element in the input.</p> <p>Given a tensor <code translate="no" dir="ltr">x</code> of complex numbers, this operation returns a tensor of type <code translate="no" dir="ltr">float32</code> or <code translate="no" dir="ltr">float64</code> that is the absolute value of each element in <code translate="no" dir="ltr">x</code>. All elements in <code translate="no" dir="ltr">x</code> must be complex numbers of the form \(a + bj\). The absolute value is computed as \( \sqrt{a^2 + b^2}\). For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">x = tf.constant([[-2.25 + 4.75j], [-3.25 + 5.75j]])
tf.abs(x)  # [5.25594902, 6.60492229]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> or <code translate="no" dir="ltr">SparseTensor</code> of type <code translate="no" dir="ltr">float16</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code> or <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> or <code translate="no" dir="ltr">SparseTensor</code> the same size, type, and sparsity as <code translate="no" dir="ltr">x</code> with absolute values. Note, for <code translate="no" dir="ltr">complex64</code> or <code translate="no" dir="ltr">complex128</code> input, the returned <code translate="no" dir="ltr">Tensor</code> will be of type <code translate="no" dir="ltr">float32</code> or <code translate="no" dir="ltr">float64</code>, respectively. <p>If <code translate="no" dir="ltr">x</code> is a <code translate="no" dir="ltr">SparseTensor</code>, returns <code translate="no" dir="ltr">SparseTensor(x.indices, tf.math.abs(x.values, ...), x.dense_shape)</code> </p>
</td> </tr> 
</table> <h3 id="__add__" data-text="__add__" tabindex="0"><code translate="no" dir="ltr">__add__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__add__(
    x, y, name=None
)
</pre> <p>Returns x + y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/add"><code translate="no" dir="ltr">math.add</code></a> supports broadcasting. <code translate="no" dir="ltr">AddN</code> does not. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, <code translate="no" dir="ltr">complex128</code>, <code translate="no" dir="ltr">string</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__and__" data-text="__and__" tabindex="0"><code translate="no" dir="ltr">__and__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__and__(
    x, y, name=None
)
</pre> <p>Returns the truth value of x AND y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/logical_and"><code translate="no" dir="ltr">math.logical_and</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__bool__" data-text="__bool__" tabindex="0"><code translate="no" dir="ltr">__bool__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_operators.py#L72-L74">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__bool__(
    _
)
</pre> <p>Dummy method to prevent a RaggedTensor from being used as a Python bool.</p> <h3 id="__div__" data-text="__div__" tabindex="0"><code translate="no" dir="ltr">__div__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1069-L1092">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__div__(
    x, y, name=None
)
</pre> <p>Divides x / y elementwise (using Python 2 division operator semantics). (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Deprecated in favor of operator or tf.math.divide.</span></aside><blockquote class="note">
<strong>Note:</strong><span> Prefer using the Tensor division operator or tf.divide which obey Python 3 division operator semantics.</span>
</blockquote> <p>This function divides <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code>, forcing Python 2 semantics. That is, if <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> are both integers then the result will be an integer. This is in contrast to Python 3, where division with <code translate="no" dir="ltr">/</code> is always a float while division with <code translate="no" dir="ltr">//</code> is always an integer.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> numerator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> denominator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">x / y</code> returns the quotient of x and y. </td> </tr> 
</table> <h3 id="__floordiv__" data-text="__floordiv__" tabindex="0"><code translate="no" dir="ltr">__floordiv__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1152-L1180">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__floordiv__(
    x, y, name=None
)
</pre> <p>Divides <code translate="no" dir="ltr">x / y</code> elementwise, rounding toward the most negative integer.</p> <p>The same as <a href="div"><code translate="no" dir="ltr">tf.compat.v1.div(x,y)</code></a> for integers, but uses <code translate="no" dir="ltr">tf.floor(tf.compat.v1.div(x,y))</code> for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by <code translate="no" dir="ltr">x // y</code> floor division in Python 3 and in Python 2.7 with <code translate="no" dir="ltr">from __future__ import division</code>.</p> <p><code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> must have the same type, and the result will have the same type as well.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> numerator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> denominator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">x / y</code> rounded down. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If the inputs are complex. </td> </tr> </table> <h3 id="__ge__" data-text="__ge__" tabindex="0"><code translate="no" dir="ltr">__ge__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__ge__(
    x, y, name=None
)
</pre> <p>Returns the truth value of (x &gt;= y) element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/greater_equal"><code translate="no" dir="ltr">math.greater_equal</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">uint32</code>, <code translate="no" dir="ltr">uint64</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__getitem__" data-text="__getitem__" tabindex="0"><code translate="no" dir="ltr">__getitem__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_getitem.py#L31-L104">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__getitem__(
    key
)
</pre> <p>Returns the specified piece of this RaggedTensor.</p> <p>Supports multidimensional indexing and slicing, with one restriction: indexing into a ragged inner dimension is not allowed. This case is problematic because the indicated value may exist in some rows but not others. In such cases, it's not obvious whether we should (1) report an IndexError; (2) use a default value; or (3) skip that value and return a tensor with fewer rows than we started with. Following the guiding principles of Python ("In the face of ambiguity, refuse the temptation to guess"), we simply disallow this operation.</p> <p>Any dimensions added by <code translate="no" dir="ltr">array_ops.newaxis</code> will be ragged if the following dimension is ragged.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">self</code> </td> <td> The RaggedTensor to slice. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">key</code> </td> <td> Indicates which piece of the RaggedTensor to return, using standard Python semantics (e.g., negative values index from the end). <code translate="no" dir="ltr">key</code> may have any of the following types: <ul> <li>
<code translate="no" dir="ltr">int</code> constant</li> <li>Scalar integer <code translate="no" dir="ltr">Tensor</code>
</li> <li>
<code translate="no" dir="ltr">slice</code> containing integer constants and/or scalar integer <code translate="no" dir="ltr">Tensor</code>s</li> <li><code translate="no" dir="ltr">Ellipsis</code></li> <li><a href="../tf#newaxis"><code translate="no" dir="ltr">tf.newaxis</code></a></li> <li>
<code translate="no" dir="ltr">tuple</code> containing any of the above (for multidimentional indexing) </li>
</ul>
</td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> or <code translate="no" dir="ltr">RaggedTensor</code> object. Values that include at least one ragged dimension are returned as <code translate="no" dir="ltr">RaggedTensor</code>. Values that include no ragged dimensions are returned as <code translate="no" dir="ltr">Tensor</code>. See above for examples of expressions that return <code translate="no" dir="ltr">Tensor</code>s vs <code translate="no" dir="ltr">RaggedTensor</code>s. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">key</code> is out of bounds. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">key</code> is not supported. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If the indices in <code translate="no" dir="ltr">key</code> have an unsupported type. </td> </tr> </table> <h4 id="examples_2" data-text="Examples:" tabindex="0">Examples:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
# A 2-D ragged tensor with 1 ragged dimension.
rt = ragged.constant([['a', 'b', 'c'], ['d', 'e'], ['f'], ['g']])
rt[0].eval().tolist()       # First row (1-D `Tensor`)
['a', 'b', 'c']
rt[:3].eval().tolist()      # First three rows (2-D RaggedTensor)
[['a', 'b', 'c'], ['d', 'e'], '[f'], [g']]
rt[3, 0].eval().tolist()    # 1st element of 4th row (scalar)
'g'

</pre> <blockquote>   <h1 id="a_3-d_ragged_tensor_with_2_ragged_dimensions" class="page-title" data-text="A 3-D ragged tensor with 2 ragged dimensions." tabindex="0">A 3-D ragged tensor with 2 ragged dimensions.</h1> <p>rt = ragged.constant([[[1, 2, 3], [4]], ... [[5], [], [6]], ... [[7]], ... [[8, 9], [10]]]) rt[1].eval().tolist() # Second row (2-D RaggedTensor) [[5], [], [6]] rt[3, 0].eval().tolist() # First element of fourth row (1-D Tensor) [8, 9] rt[:, 1:3].eval().tolist() # Items 1-3 of each row (3-D RaggedTensor) [[[4]], [[], [6]], [], [[10]]] rt[:, -1:].eval().tolist() # Last item of each row (3-D RaggedTensor) [[[4]], [[6]], [[7]], [[10]]]</p>   </blockquote>  <h3 id="__gt__" data-text="__gt__" tabindex="0"><code translate="no" dir="ltr">__gt__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__gt__(
    x, y, name=None
)
</pre> <p>Returns the truth value of (x &gt; y) element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/greater"><code translate="no" dir="ltr">math.greater</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">uint32</code>, <code translate="no" dir="ltr">uint64</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__invert__" data-text="__invert__" tabindex="0"><code translate="no" dir="ltr">__invert__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__invert__(
    x, name=None
)
</pre> <p>Returns the truth value of NOT x element-wise.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__le__" data-text="__le__" tabindex="0"><code translate="no" dir="ltr">__le__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__le__(
    x, y, name=None
)
</pre> <p>Returns the truth value of (x &lt;= y) element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/less_equal"><code translate="no" dir="ltr">math.less_equal</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">uint32</code>, <code translate="no" dir="ltr">uint64</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__lt__" data-text="__lt__" tabindex="0"><code translate="no" dir="ltr">__lt__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__lt__(
    x, y, name=None
)
</pre> <p>Returns the truth value of (x &lt; y) element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/less"><code translate="no" dir="ltr">math.less</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">uint32</code>, <code translate="no" dir="ltr">uint64</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__mod__" data-text="__mod__" tabindex="0"><code translate="no" dir="ltr">__mod__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__mod__(
    x, y, name=None
)
</pre> <p>Returns element-wise remainder of division. When <code translate="no" dir="ltr">x &lt; 0</code> xor <code translate="no" dir="ltr">y &lt; 0</code> is</p> <p>true, this follows Python semantics in that the result here is consistent with a flooring divide. E.g. <code translate="no" dir="ltr">floor(x / y) * y + mod(x, y) = x</code>.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/floormod"><code translate="no" dir="ltr">math.floormod</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__mul__" data-text="__mul__" tabindex="0"><code translate="no" dir="ltr">__mul__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L328-L331">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__mul__(
    x, y, name=None
)
</pre> <p>Returns x * y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/multiply"><code translate="no" dir="ltr">tf.multiply</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__neg__" data-text="__neg__" tabindex="0"><code translate="no" dir="ltr">__neg__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__neg__(
    x, name=None
)
</pre> <p>Computes numerical negative value element-wise.</p> <p>I.e., \(y = -x\).</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. <p>If <code translate="no" dir="ltr">x</code> is a <code translate="no" dir="ltr">SparseTensor</code>, returns <code translate="no" dir="ltr">SparseTensor(x.indices, tf.math.negative(x.values, ...), x.dense_shape)</code> </p>
</td> </tr> 
</table> <h3 id="__nonzero__" data-text="__nonzero__" tabindex="0"><code translate="no" dir="ltr">__nonzero__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/ragged/ragged_operators.py#L72-L74">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__nonzero__(
    _
)
</pre> <p>Dummy method to prevent a RaggedTensor from being used as a Python bool.</p> <h3 id="__or__" data-text="__or__" tabindex="0"><code translate="no" dir="ltr">__or__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__or__(
    x, y, name=None
)
</pre> <p>Returns the truth value of x OR y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/logical_or"><code translate="no" dir="ltr">math.logical_or</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__pow__" data-text="__pow__" tabindex="0"><code translate="no" dir="ltr">__pow__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L434-L459">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__pow__(
    x, y, name=None
)
</pre> <p>Computes the power of one value to another.</p> <p>Given a tensor <code translate="no" dir="ltr">x</code> and a tensor <code translate="no" dir="ltr">y</code>, this operation computes \(x^y\) for corresponding elements in <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code>. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">x = tf.constant([[2, 2], [3, 3]])
y = tf.constant([[8, 16], [2, 3]])
tf.pow(x, y)  # [[256, 65536], [9, 27]]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">float16</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, or <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">float16</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, or <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. </td> </tr> 
</table> <h3 id="__radd__" data-text="__radd__" tabindex="0"><code translate="no" dir="ltr">__radd__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__radd__(
    x, y, name=None
)
</pre> <p>Returns x + y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/add"><code translate="no" dir="ltr">math.add</code></a> supports broadcasting. <code translate="no" dir="ltr">AddN</code> does not. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, <code translate="no" dir="ltr">complex128</code>, <code translate="no" dir="ltr">string</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__rand__" data-text="__rand__" tabindex="0"><code translate="no" dir="ltr">__rand__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rand__(
    x, y, name=None
)
</pre> <p>Returns the truth value of x AND y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/logical_and"><code translate="no" dir="ltr">math.logical_and</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__rdiv__" data-text="__rdiv__" tabindex="0"><code translate="no" dir="ltr">__rdiv__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1069-L1092">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rdiv__(
    x, y, name=None
)
</pre> <p>Divides x / y elementwise (using Python 2 division operator semantics). (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Deprecated in favor of operator or tf.math.divide.</span></aside><blockquote class="note">
<strong>Note:</strong><span> Prefer using the Tensor division operator or tf.divide which obey Python 3 division operator semantics.</span>
</blockquote> <p>This function divides <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code>, forcing Python 2 semantics. That is, if <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> are both integers then the result will be an integer. This is in contrast to Python 3, where division with <code translate="no" dir="ltr">/</code> is always a float while division with <code translate="no" dir="ltr">//</code> is always an integer.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> numerator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> denominator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">x / y</code> returns the quotient of x and y. </td> </tr> 
</table> <h3 id="__rfloordiv__" data-text="__rfloordiv__" tabindex="0"><code translate="no" dir="ltr">__rfloordiv__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1152-L1180">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rfloordiv__(
    x, y, name=None
)
</pre> <p>Divides <code translate="no" dir="ltr">x / y</code> elementwise, rounding toward the most negative integer.</p> <p>The same as <a href="div"><code translate="no" dir="ltr">tf.compat.v1.div(x,y)</code></a> for integers, but uses <code translate="no" dir="ltr">tf.floor(tf.compat.v1.div(x,y))</code> for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by <code translate="no" dir="ltr">x // y</code> floor division in Python 3 and in Python 2.7 with <code translate="no" dir="ltr">from __future__ import division</code>.</p> <p><code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> must have the same type, and the result will have the same type as well.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> numerator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> denominator of real numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">x / y</code> rounded down. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If the inputs are complex. </td> </tr> </table> <h3 id="__rmod__" data-text="__rmod__" tabindex="0"><code translate="no" dir="ltr">__rmod__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rmod__(
    x, y, name=None
)
</pre> <p>Returns element-wise remainder of division. When <code translate="no" dir="ltr">x &lt; 0</code> xor <code translate="no" dir="ltr">y &lt; 0</code> is</p> <p>true, this follows Python semantics in that the result here is consistent with a flooring divide. E.g. <code translate="no" dir="ltr">floor(x / y) * y + mod(x, y) = x</code>.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/floormod"><code translate="no" dir="ltr">math.floormod</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__rmul__" data-text="__rmul__" tabindex="0"><code translate="no" dir="ltr">__rmul__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L328-L331">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rmul__(
    x, y, name=None
)
</pre> <p>Returns x * y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/multiply"><code translate="no" dir="ltr">tf.multiply</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__ror__" data-text="__ror__" tabindex="0"><code translate="no" dir="ltr">__ror__</code></h3> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__ror__(
    x, y, name=None
)
</pre> <p>Returns the truth value of x OR y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <a href="math/logical_or"><code translate="no" dir="ltr">math.logical_or</code></a> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">bool</code>. </td> </tr> 
</table> <h3 id="__rpow__" data-text="__rpow__" tabindex="0"><code translate="no" dir="ltr">__rpow__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L434-L459">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rpow__(
    x, y, name=None
)
</pre> <p>Computes the power of one value to another.</p> <p>Given a tensor <code translate="no" dir="ltr">x</code> and a tensor <code translate="no" dir="ltr">y</code>, this operation computes \(x^y\) for corresponding elements in <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code>. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">x = tf.constant([[2, 2], [3, 3]])
y = tf.constant([[8, 16], [2, 3]])
tf.pow(x, y)  # [[256, 65536], [9, 27]]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">float16</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, or <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type <code translate="no" dir="ltr">float16</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, or <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. </td> </tr> 
</table> <h3 id="__rsub__" data-text="__rsub__" tabindex="0"><code translate="no" dir="ltr">__rsub__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L349-L352">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rsub__(
    x, y, name=None
)
</pre> <p>Returns x - y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <code translate="no" dir="ltr">Subtract</code> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__rtruediv__" data-text="__rtruediv__" tabindex="0"><code translate="no" dir="ltr">__rtruediv__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1036-L1066">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rtruediv__(
    x, y, name=None
)
</pre> <p>Divides x / y elementwise (using Python 3 division operator semantics).</p> <blockquote class="note">
<strong>Note:</strong><span> Prefer using the Tensor operator or tf.divide which obey Python division operator semantics.</span>
</blockquote> <p>This function forces Python 3 division operator semantics where all integer arguments are cast to floating types first. This op is generated by normal <code translate="no" dir="ltr">x / y</code> division in Python 3 and in Python 2.7 with <code translate="no" dir="ltr">from __future__ import division</code>. If you want integer division that rounds down, use <code translate="no" dir="ltr">x // y</code> or <code translate="no" dir="ltr">tf.math.floordiv</code>.</p> <p><code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> must have the same numeric type. If the inputs are floating point, the output will have the same type. If the inputs are integral, the inputs are cast to <code translate="no" dir="ltr">float32</code> for <code translate="no" dir="ltr">int8</code> and <code translate="no" dir="ltr">int16</code> and <code translate="no" dir="ltr">float64</code> for <code translate="no" dir="ltr">int32</code> and <code translate="no" dir="ltr">int64</code> (matching the behavior of Numpy).</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> numerator of numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> denominator of numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">x / y</code> evaluated in floating point. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> have different dtypes. </td> </tr> </table> <h3 id="__rxor__" data-text="__rxor__" tabindex="0"><code translate="no" dir="ltr">__rxor__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1234-L1265">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__rxor__(
    x, y, name='LogicalXor'
)
</pre> <p>Logical XOR function.</p> <p>x ^ y = (x | y) &amp; ~(x &amp; y)</p> <p>Inputs are tensor and if the tensors contains more than one element, an element-wise logical XOR is computed.</p> <h4 id="usage" data-text="Usage:" tabindex="0">Usage:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">x = tf.constant([False, False, True, True], dtype = tf.bool)
y = tf.constant([False, True, False, True], dtype = tf.bool)
z = tf.logical_xor(x, y, name="LogicalXor")
#  here z = [False  True  True False]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> type bool. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type bool. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type bool with the same size as that of x or y. </td> </tr> 
</table> <h3 id="__sub__" data-text="__sub__" tabindex="0"><code translate="no" dir="ltr">__sub__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L349-L352">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__sub__(
    x, y, name=None
)
</pre> <p>Returns x - y element-wise.</p> <blockquote class="note">
<strong>Note:</strong><span> <code translate="no" dir="ltr">Subtract</code> supports broadcasting. More about broadcasting <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">bfloat16</code>, <code translate="no" dir="ltr">half</code>, <code translate="no" dir="ltr">float32</code>, <code translate="no" dir="ltr">float64</code>, <code translate="no" dir="ltr">uint8</code>, <code translate="no" dir="ltr">int8</code>, <code translate="no" dir="ltr">uint16</code>, <code translate="no" dir="ltr">int16</code>, <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>, <code translate="no" dir="ltr">complex64</code>, <code translate="no" dir="ltr">complex128</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">x</code>. </td> </tr> 
</table> <h3 id="__truediv__" data-text="__truediv__" tabindex="0"><code translate="no" dir="ltr">__truediv__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1036-L1066">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__truediv__(
    x, y, name=None
)
</pre> <p>Divides x / y elementwise (using Python 3 division operator semantics).</p> <blockquote class="note">
<strong>Note:</strong><span> Prefer using the Tensor operator or tf.divide which obey Python division operator semantics.</span>
</blockquote> <p>This function forces Python 3 division operator semantics where all integer arguments are cast to floating types first. This op is generated by normal <code translate="no" dir="ltr">x / y</code> division in Python 3 and in Python 2.7 with <code translate="no" dir="ltr">from __future__ import division</code>. If you want integer division that rounds down, use <code translate="no" dir="ltr">x // y</code> or <code translate="no" dir="ltr">tf.math.floordiv</code>.</p> <p><code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> must have the same numeric type. If the inputs are floating point, the output will have the same type. If the inputs are integral, the inputs are cast to <code translate="no" dir="ltr">float32</code> for <code translate="no" dir="ltr">int8</code> and <code translate="no" dir="ltr">int16</code> and <code translate="no" dir="ltr">float64</code> for <code translate="no" dir="ltr">int32</code> and <code translate="no" dir="ltr">int64</code> (matching the behavior of Numpy).</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> numerator of numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> denominator of numeric type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">x / y</code> evaluated in floating point. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> have different dtypes. </td> </tr> </table> <h3 id="__xor__" data-text="__xor__" tabindex="0"><code translate="no" dir="ltr">__xor__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/ops/math_ops.py#L1234-L1265">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__xor__(
    x, y, name='LogicalXor'
)
</pre> <p>Logical XOR function.</p> <p>x ^ y = (x | y) &amp; ~(x &amp; y)</p> <p>Inputs are tensor and if the tensors contains more than one element, an element-wise logical XOR is computed.</p> <h4 id="usage_2" data-text="Usage:" tabindex="0">Usage:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">x = tf.constant([False, False, True, True], dtype = tf.bool)
y = tf.constant([False, True, False, True], dtype = tf.bool)
z = tf.logical_xor(x, y, name="LogicalXor")
#  here z = [False  True  True False]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> type bool. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">y</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of type bool. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> of type bool with the same size as that of x or y. </td> </tr> 
</table>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
     2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/RaggedTensor" class="_attribution-link">https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/RaggedTensor</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
