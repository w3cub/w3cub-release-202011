
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>CONNECT Data Types - MariaDB - W3cubDocs</title>
  
  <meta name="description" content=" The CONNECT handler was introduced in MariaDB 10.0. ">
  <meta name="keywords" content="connect, data, types, mariadb">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/mariadb/connect-data-types/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/mariadb.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/mariadb/" class="_nav-link" title="" style="margin-left:0;">MariaDB</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _mariadb">
				
				
<h1>CONNECT Data Types</h1> <div> <div class="node creole"> <div class="answer formatted"> <div class="mariadb_from_10_0 mariadb from_10_0 product">
<strong class="product_title">MariaDB starting with <a href="../what-is-mariadb-100/index">10.0</a></strong><p>The CONNECT handler was introduced in <a href="../what-is-mariadb-100/index">MariaDB 10.0</a>.</p> </div>
<p> Many data types make no or little sense when applied to plain files. This why <a href="../connect/index">CONNECT</a> supports only a restricted set of data types. However, ODBC, JDBC or MYSQL source tables may contain data types not supported by CONNECT. In this case, CONNECT makes an automatic conversion to a similar supported type when it is possible.</p> <p>The data types currently supported by CONNECT are:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>Type name</th>
<th>Description</th>
<th>Used for</th>
</tr> <tr>
<td><code>TYPE_STRING</code></td>
<td>Zero ended string</td>
<td>
<a href="../char/index">char</a>, <a href="../varchar/index">varchar</a>, <a href="../text/index">text</a>
</td>
</tr> <tr>
<td><code>TYPE_INT</code></td>
<td>4 bytes integer</td>
<td>
<a href="../int/index">int</a>, <a href="../mediumint/index">mediumint</a>, <a href="../integer/index">integer</a>
</td>
</tr> <tr>
<td><code>TYPE_SHORT</code></td>
<td>2 bytes integer</td>
<td><a href="../smallint/index">smallint</a></td>
</tr> <tr>
<td><code>TYPE_TINY</code></td>
<td>1 byte integer</td>
<td><a href="../tinyint/index">tinyint</a></td>
</tr> <tr>
<td><code>TYPE_BIGINT</code></td>
<td>8 bytes integer</td>
<td>
<a href="../bigint/index">bigint</a>, longlong</td>
</tr> <tr>
<td><code>TYPE_DOUBLE</code></td>
<td>8 bytes floating point</td>
<td>
<a href="../double/index">double</a>, <a href="../float/index">float</a>, real</td>
</tr> <tr>
<td><code>TYPE_DECIM</code></td>
<td>Numeric value</td>
<td>
<a href="../decimal/index">decimal</a>, numeric, number</td>
</tr> <tr>
<td><code>TYPE_DATE</code></td>
<td>4 bytes integer</td>
<td>
<a href="../date/index">date</a>, <a href="../datetime/index">datetime</a>, <a href="../time/index">time</a>, <a href="../timestamp/index">timestamp</a>, <a href="../year/index">year</a>
</td>
</tr> </table> </div>
<h2 class="anchored_heading" id="type_string">TYPE_STRING</h2> <p>This type corresponds to what is generally known as <a href="../char/index">CHAR</a> or <a href="../varchar/index">VARCHAR</a> by database users, or as strings by programmers. Columns containing characters have a maximum length but the character string is of fixed or variable length depending on the file format.</p> <p>The DATA_CHARSET option must be used to specify the character set used in the data source or file. Note that, unlike usually with MariaDB, when a multi-byte character set is used, the column size represents the number of bytes the column value can contain, not the number of characters.</p> <h2 class="anchored_heading" id="type_int">TYPE_INT</h2> <p>The ]<a href="../integer/index">INTEGER</a> type contains signed integer numeric 4-byte values (the <em>int/ of the C language) ranging from <code>–2,147,483,648</code> to <code>2,147,483,647</code> for signed type and <code>0</code> to <code>4,294,967,295</code> for unsigned type.</em></p> <h2 class="anchored_heading" id="type_short">TYPE_SHORT</h2> <p>The SHORT data type contains signed <a href="../smallint/index">integer numeric 2-byte</a> values (the <em>short integer</em> of the C language) ranging from <code>–32,768</code> to <code>32,767</code> for signed type and <code>0</code> to <code>65,535</code> for unsigned type.</p> <h2 class="anchored_heading" id="type_tiny">TYPE_TINY</h2> <p>The TINY data type contains <a href="../tinyint/index">integer numeric 1-byte</a> values (the <em>char</em> of the C language) ranging from <code>–128</code> to <code>127</code> for signed type and <code>0</code> to <code>255</code> for unsigned type. For some table types, TYPE_TINY is used to represent Boolean values (0 is false, anything else is true). </p> <h2 class="anchored_heading" id="type_bigint">TYPE_BIGINT</h2> <p>The <a href="../bigint/index">BIGINT</a> data type contains signed integer 8-byte values (the <em>long long</em> of the C language) ranging from <code>-9,223,372,036,854,775,808</code> to <code>9,223,372,036,854,775,807</code> for signed type and from <code>0</code> to <code>18,446,744,073,709,551,615</code> for unsigned type.</p> <p>Inside tables, the coding of all integer values depends on the table type. In tables represented by text files, the number is written in characters, while in tables represented by binary files (<code>BIN</code> or <code>VEC</code>) the number is directly stored in the binary representation corresponding to the platform.</p> <p>The <em>length</em> (or <em>precision</em>) specification corresponds to the length of the table field in which the value is stored for text files only. It is used to set the output field length for all table types.</p> <h2 class="anchored_heading" id="type_double">TYPE_DOUBLE</h2> <p>The DOUBLE data type corresponds to the C language <a href="../double/index">double</a> type, a floating-point double precision value coded with 8 bytes. Like for integers, the internal coding in tables depends on the table type, characters for text files, and platform binary representation for binary files.</p> <p>The <em>length</em> specification corresponds to the length of the table field in which the value is stored for text files only. The <em>scale</em> (was <em>precision</em>) is the number of decimal digits written into text files. For binary table types (BIN and VEC) this does not apply. The <em>length</em> and <em>scale</em> specifications are used to set the output field length and number of decimals for all types of tables.</p> <h2 class="anchored_heading" id="type_decim">TYPE_DECIM</h2> <p>The DECIMAL data type corresponds to what MariaDB or ODBC data sources call NUMBER, NUMERIC, or <a href="../decimal/index">DECIMAL</a>: a numeric value with a maximum number of digits (the precision) some of them eventually being decimal digits (the scale). The internal coding in CONNECT is a character representation of the number. For instance:</p> <pre class="fixed" data-language="sql">colname decimal(14,6)
</pre>
<p>This defines a column <em>colname</em> as a number having a <em>precision</em> of 14 and a <em>scale</em> of 6. Supposing it is populated by:</p> <pre class="fixed" data-language="sql">insert into xxx values (-2658.74);
</pre>
<p>The internal representation of it will be the character string <code>-2658.740000</code>. The way it is stored in a file table depends on the table type. The <em>length</em> field specification corresponds to the length of the table field in which the value is stored and is calculated by CONNECT from the <em>precision</em> and the <em>scale</em> values. This length is <em>precision</em> plus 1 if <em>scale</em> is not 0 (for the decimal point) plus 1 if this column is not unsigned (for the eventual minus sign). In fix formatted tables the number is right justified in the field of width <em>length</em>, for variable formatted tables, such as CSV, the field is the representing character string.</p> <p>Because this type is mainly used by CONNECT to handle numeric or decimal fields of ODBC, JDBC and MySQL table types, CONNECT does not provide decimal calculations or comparison by itself. This is why decimal columns of CONNECT tables cannot be indexed.</p> <h2 class="anchored_heading" id="date-data-type">DATE Data type</h2> <p>Internally, date/time values are stored by CONNECT as a signed 4-byte integer. The value 0 corresponds to 01 January 1970 12:00:00 am coordinated universal time (<a href="../coordinated-universal-time/index">UTC</a>). All other date/time values are represented by the number of seconds elapsed since or before midnight (00:00:00), 1 January 1970, to that date/time value. Date/time values before midnight 1 January 1970 are represented by a negative number of seconds.</p> <p>CONNECT handles dates from <strong>13 December 1901, 20:45:52</strong> to <strong>18 January 2038, 19:14:07</strong>.</p> <p>Although date and time information can be represented in both CHAR and INTEGER data types, the DATE data type has special associated properties. For each DATE value, CONNECT can store all or only some of the following information: century, year, month, day, hour, minute, and second.</p> <h3 class="anchored_heading" id="date-format-in-text-tables">Date Format in Text Tables</h3> <p>Internally, date/time values are handled as a signed 4-byte integer. But in text tables (type DOS, FIX, CSV, FMT, and DBF) dates are most of the time stored as a formatted character string (although they also can be stored as a numeric string representing their internal value). Because there are infinite ways to format a date, the format to use for decoding dates, as well as the field length in the file, must be associated to date columns (except when they are stored as the internal numeric value).</p> <p>Note that this associated format is used only to describe the way the temporal value is stored internally. This format is used both for output to decode the date in a SELECT statement as well as for input to encode the date in INSERT or UPDATE statements. However, what is kept in this value depends on the data type used in the column definition (all the MariaDB temporal values can be specified). When creating a table, the format is associated to a date column using the DATE_FORMAT option in the column definition, for instance:</p> <pre class="fixed" data-language="sql">create table birthday (
  Name varchar(17),
  Bday date field_length=10 date_format='MM/DD/YYYY',
  Btime time field_length=8 date_format='hh:mm tt')
engine=CONNECT table_type=CSV;

insert into birthday values ('Charlie','2012-11-12','15:30:00');

select * from birthday;
</pre>
<p>The SELECT query returns:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>Name</th>
<th>Bday</th>
<th>Btime</th>
</tr> <tr>
<td>Charlie</td>
<td>2012-11-12</td>
<td>15:30:00</td>
</tr> </table> </div>
<p>The values of the INSERT statement must be specified using the standard MariaDB syntax and these values are displayed as MariaDB temporal values. Sure enough, the column formats apply only to the way these values are represented inside the CSV files. Here, the inserted record will be:</p> <pre class="fixed" data-language="sql">Charlie,11/12/2012,03:30 PM
</pre>
<p><strong>Note:</strong> The field_length option exists because the MariaDB syntax does not allow specifying the field length between parentheses for temporal column types. If not specified, the field length is calculated from the date format (sometimes as a max value) or made equal to the default length value if there is no date format. In the above example it could have been removed as the calculated values are the ones specified. However, if the table type would have been DOS or FIX, these values could be adjusted to fit the actual field length within the file.</p> <p>A CONNECT format string consists of a series of elements that represent a particular piece of information and define its format. The elements will be recognized in the order they appear in the format string. Date and time format elements will be replaced by the actual date and time as they appear in the source string. They are defined by the following groups of characters:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>Element</th>
<th>Description</th>
</tr> <tr>
<td>YY</td>
<td>The last two digits of the year (that is, 1996 would be coded as "96").</td>
</tr> <tr>
<td>YYYY</td>
<td>The full year (that is, 1996 could be entered as "96" but displayed as “1996”).</td>
</tr> <tr>
<td>MM</td>
<td>The one or two-digit month number.</td>
</tr> <tr>
<td>MMM</td>
<td>The three-character month abbreviation.</td>
</tr> <tr>
<td>MMMM</td>
<td>The full month name.</td>
</tr> <tr>
<td>DD</td>
<td>The one or two-digit month day.</td>
</tr> <tr>
<td>DDD</td>
<td>The three-character weekday abbreviation.</td>
</tr> <tr>
<td>DDDD</td>
<td>The full weekday name.</td>
</tr> <tr>
<td>hh</td>
<td>The one or two-digit hour in 12-hour or 24-hour format.</td>
</tr> <tr>
<td>mm</td>
<td>The one or two-digit minute.</td>
</tr> <tr>
<td>ss</td>
<td>The one or two-digit second.</td>
</tr> <tr>
<td>t</td>
<td>The one-letter AM/PM abbreviation (that is, AM is entered as "A").</td>
</tr> <tr>
<td>tt</td>
<td>The two-letter AM/PM abbreviation (that is, AM is entered as "AM").</td>
</tr> </table> </div>
<h3 class="anchored_heading" id="usage-notes">Usage Notes</h3> <ul start="1">
<li>To match the source string, you can add body text to the format string, enclosing it in single quotes or double quotes if it would be ambiguous. Punctuation marks do not need to be quoted. </li>
<li>The hour information is regarded as 12-hour format if a “t” or “tt” element follows the “hh” element in the format or as 24-hour format otherwise. </li>
<li>The "MM", "DD", "hh", "mm", "ss" elements can be specified with one or two letters (e.g. "MM" or "M") making no difference on input, but placing a leading zero to one-digit values on output<sup class="reference" id="_ref-0">[<a href="#_note-0">1</a>]</sup> for two-letter elements. </li>
<li>If the format contains elements DDD or DDDD, the day of week name is skipped on input and ignored to calculate the internal date value. On output, the correct day of week name is generated and displayed. </li>
<li>Temporal values are always stored as numeric in <a href="../connect-table-types-data-files/index#bin-table-type">BIN</a> and <a href="../connect-table-types-data-files/index#vec-table-type-vecto">VEC</a> tables. </li>
</ul> <h3 class="anchored_heading" id="handling-dates-that-are-out-of-the-range-of-supported-connect-dates">Handling dates that are out of the range of supported CONNECT dates</h3> <p>If you want to make a table containing, for instance, historical dates not being convertible into CONNECT dates, make your column CHAR or VARCHAR and store the dates in the MariaDB format. All date functions applied to these strings will convert them to MariaDB dates and will work as if they were real dates. Of course they must be inserted and will be displayed using the MariaDB format.</p> <h2 class="anchored_heading" id="null-handling">NULL handling</h2> <p>CONNECT handles <a href="../null-values-in-mariadb/index">null values</a> for data sources able to produce nulls. Currently this concerns mainly the <a href="../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index">ODBC</a>, <a href="../connect-jdbc-table-type-accessing-tables-from-other-dbms/index">JDBC</a>, MONGO, <a href="../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index">MYSQL</a>, <a href="../connect-table-types-data-files/index#xml-table-type">XML</a>, <a href="../connect-json-table-type/index">JSON</a> and <a href="../connect-table-types-data-files/index#ini-table-type">INI</a> table types. For INI, <a href="../connect-json-table-type/index">JSON</a>, MONGO or XML types, null values are returned when the key is missing in the section (INI) or when the corresponding node does not exist in a row (XML, JSON, MONGO).</p> <p>For other file tables, the issue is to define what a null value is. In a numeric column, 0 can sometimes be a valid value but, in some other cases, it can make no sense. The same for character columns; is a blank field a valid value or not?</p> <p>A special case is DATE columns with a DATE_FORMAT specified. Any value not matching the format can be regarded as NULL.</p> <p>CONNECT leaves the decision to you. When declaring a column in the <a href="../create-table/index">CREATE TABLE</a> statement, if it is declared NOT NULL, blank or zero values will be considered as valid values. Otherwise they will be considered as NULL values. In all cases, nulls are replaced on insert or update by pseudo null values, a zero-length character string for text types or a zero value for numeric types. Once converted to pseudo null values, they will be recognized as NULL only for columns declared as nullable.</p> <p>For instance:</p> <pre class="fixed" data-language="sql">create table t1 (a int, b char(10)) engine=connect;
insert into t1 values (0,'zero'),(1,'one'),(2,'two'),(null,'???');
select * from t1 where a is null;
</pre>
<p>The select query replies:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>a</th>
<th>b</th>
</tr> <tr>
<td>NULL</td>
<td>zero</td>
</tr> <tr>
<td>NULL</td>
<td>???</td>
</tr> </table> </div>
<p>Sure enough, the value 0 entered on the first row is regarded as NULL for a nullable column. However, if we execute the query:</p> <pre class="fixed" data-language="sql">select * from t1 where a = 0;
</pre>
<p>This will return no line because a NULL is not equal to 0 in an SQL where clause.</p> <p>Now let us see what happens with not null columns:</p> <pre class="fixed" data-language="sql">create table t1 (a int not null, b char(10) not null) engine=connect;
insert into t1 values (0,'zero'),(1,'one'),(2,'two'),(null,'???');
</pre>
<p>The insert statement will produce a warning saying:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>Level</th>
<th>Code</th>
<th>Message</th>
</tr> <tr>
<td>Warning</td>
<td>1048</td>
<td>Column 'a' cannot be null</td>
</tr> </table> </div>
<p>It is replaced by a pseudo null <code>0</code> on the fourth row. Let us see the result:</p> <pre class="fixed" data-language="sql">select * from t1 where a is null;
select * from t1 where a = 0;
</pre>
<p>The first query returns no rows, 0 are valid values and not NULL. The second query replies:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>a</th>
<th>b</th>
</tr> <tr>
<td>0</td>
<td>zero</td>
</tr> <tr>
<td>0</td>
<td>???</td>
</tr> </table> </div>
<p>It shows that the NULL inserted value was replaced by a valid 0 value.</p> <h2 class="anchored_heading" id="unsigned-numeric-types">Unsigned numeric types</h2> <p>They are supported by CONNECT since version 1.01.0010 for fixed numeric types (TINY, SHORT, INTEGER, and BITINT).</p> <h2 class="anchored_heading" id="data-type-conversion">Data type conversion</h2> <p>CONNECT is able to convert data from one type to another in most cases. These conversions are done without warning even when this leads to truncation or loss of precision. This is true, in particular, for tables of type ODBC, JDBC, MYSQL and PROXY (via MySQL) because the source table may contain some data types not supported by CONNECT. They are converted when possible to CONNECT types.</p> <p>When converted, MariaDB types are converted as:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>MariaDB Types</th>
<th>CONNECT Type</th>
<th>Remark</th>
</tr> <tr>
<td>
<a href="../integer/index">integer</a>, <a href="../mediumint/index">medium integer</a>
</td>
<td>TYPE_INT</td>
<td>4 byte integer</td>
</tr> <tr>
<td><a href="../smallint/index">small integer</a></td>
<td>TYPE_SHORT</td>
<td>2 byte integer</td>
</tr> <tr>
<td><a href="../tinyint/index">tiny integer</a></td>
<td>TYPE_TINY</td>
<td>1 byte integer</td>
</tr> <tr>
<td>
<a href="../char/index">char</a>, <a href="../varchar/index">varchar</a>
</td>
<td>TYPE_STRING</td>
<td>Same length</td>
</tr> <tr>
<td>
<a href="../double/index">double</a>, <a href="../float/index">float</a>, real</td>
<td>TYPE_DOUBLE</td>
<td>8 byte floating point</td>
</tr> <tr>
<td>
<a href="../decimal/index">decimal</a>, numeric</td>
<td>TYPE_DECIM</td>
<td>Length depends on precision and scale</td>
</tr> <tr>
<td>all <a href="../date/index">date</a> related types</td>
<td>TYPE_DATE</td>
<td>Date format can be set accordingly</td>
</tr> <tr>
<td>
<a href="../bigint/index">bigint</a>, longlong</td>
<td>TYPE_BIGINT</td>
<td>8 byte integer</td>
</tr> <tr>
<td>SQL_GUID</td>
<td>TYPE_STRING</td>
<td>Len = 36</td>
</tr> <tr>
<td>SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY</td>
<td>TYPE_STRING</td>
<td>len = min(abs(len), connect_conv_size) (Only if the value of <a href="../connect-system-variables/index#connect_type_conv">connect_type_conv</a> is <code>FORCE</code>. The column should use the binary charset).</td>
</tr> <tr>
<td>Other types</td>
<td>TYPE_ERROR</td>
<td>Not supported, no conversion provided.</td>
</tr> </table> </div>
<p>In the case of <a href="../text/index">TEXT</a> columns, the handling depends on the values given to the <a href="../connect-system-variables/index#connect_type_conv">connect_type_conv</a> and <a href="../connect-system-variables/index#connect_conv_size">connect_conv_size</a> system variables. By default no conversion is permitted.</p> <p>Note: <a href="../blob/index">BLOB</a> is currently not converted by default until a TYPE_BIN type is added to CONNECT. However, the FORCE option (from Connect 1.06.006) can be specified for blob columns containing text and the SKIP option also applies to ODBC BLOB columns.</p> <p>ODBC SQL types are converted as:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>SQL Types</th>
<th>Connect Type</th>
<th>Remark</th>
</tr> <tr>
<td>SQL_CHAR, SQL_VARCHAR</td>
<td>TYPE_STRING</td>
<td></td>
</tr> <tr>
<td>SQL_LONGVARCHAR</td>
<td>TYPE_STRING</td>
<td>
<code>len = min(abs(len), 255)</code> If the column is generated by discovery (columns not specified) its length is <a href="../connect-system-variables/index#connect_conv_size">connect_conv_size</a>.</td>
</tr> <tr>
<td>SQL_NUMERIC, SQL_DECIMAL</td>
<td>TYPE_DECIM</td>
<td></td>
</tr> <tr>
<td>SQL_INTEGER</td>
<td>TYPE_INT</td>
<td></td>
</tr> <tr>
<td>SQL_SMALLINT</td>
<td>TYPE_SHORT</td>
<td></td>
</tr> <tr>
<td>SQL_TINYINT, SQL_BIT</td>
<td>TYPE_TINY</td>
<td></td>
</tr> <tr>
<td>SQL_FLOAT, SQL_REAL, SQL_DOUBLE</td>
<td>TYPE_DOUBLE</td>
<td></td>
</tr> <tr>
<td>SQL_DATETIME</td>
<td>TYPE_DATE</td>
<td><code>len = 10</code></td>
</tr> <tr>
<td>SQL_INTERVAL</td>
<td>TYPE_STRING</td>
<td><code>len = 8 + ((scale) ? (scale+1) : 0)</code></td>
</tr> <tr>
<td>SQL_TIMESTAMP</td>
<td>TYPE_DATE</td>
<td><code>len = 19 + ((scale) ? (scale +1) : 0)</code></td>
</tr> <tr>
<td>SQL_BIGINT</td>
<td>TYPE_BIGINT</td>
<td></td>
</tr> <tr>
<td>Other types</td>
<td>TYPE_ERROR</td>
<td><em>Not supported.</em></td>
</tr> </table> </div>
<p>JDBC SQL types are converted as:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>JDBC Types</th>
<th>Connect Type</th>
<th>Remark</th>
</tr> <tr>
<td>(N)CHAR, (N)VARCHAR</td>
<td>TYPE_STRING</td>
</tr> <tr>
<td>LONG(N)VARCHAR</td>
<td>TYPE_STRING</td>
<td>
<code>len = min(abs(len), connect_conv_size)</code> If the column is generated by discovery (columns not specified), its length is <a href="../connect-system-variables/index#connect_conv_size">connect_conv_size</a>
</td>
</tr> <tr>
<td>NUMERIC, DECIMAL, VARBINARY</td>
<td>TYPE_DECIM</td>
</tr> <tr>
<td>INTEGER</td>
<td>TYPE_INT</td>
</tr> <tr>
<td>SMALLINT</td>
<td>TYPE_SHORT</td>
</tr> <tr>
<td>TINYINT, BIT</td>
<td>TYPE_TINY</td>
</tr> <tr>
<td>FLOAT, REAL, DOUBLE</td>
<td>TYPE_DOUBLE</td>
</tr> <tr>
<td>DATE</td>
<td>TYPE_DATE</td>
<td><code>len = 10</code></td>
</tr> <tr>
<td>TIME</td>
<td>TYPE_DATE</td>
<td><code>len = 8 + ((scale) ? (scale+1) : 0)</code></td>
</tr> <tr>
<td>TIMESTAMP</td>
<td>TYPE_DATE</td>
<td><code>len = 19 + ((scale) ? (scale +1) : 0)</code></td>
</tr> <tr>
<td>BIGINT</td>
<td>TYPE_BIGINT</td>
</tr> <tr>
<td>Other types</td>
<td>TYPE_ERROR</td>
<td>Not supported.</td>
</tr> </table> </div>
<div class="cstm-style bluebox">
<p>Note: The <a href="../connect-system-variables/index#connect_type_conv">connect_type_conv</a> SKIP option also applies to ODBC and JDBC tables.</p> </div>
<hr> <ol>
<li id="_note-0"> <a href="#_ref-0">↑</a> Here input and output are used to specify respectively decoding the date to get its numeric value from the data file and encoding a date to write it in the table file. Input is performed within <a href="../select/index">SELECT</a> queries; output is performed in <a href="../update/index">UPDATE</a> or <a href="../insert/index">INSERT</a> queries.</li> </ol> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2019 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/connect-data-types/" class="_attribution-link">https://mariadb.com/kb/en/connect-data-types/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
