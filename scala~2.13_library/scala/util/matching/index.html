
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Matching - Scala 2.13 Library - W3cubDocs</title>
  
  <meta name="description" content=" A regular expression is used to determine whether a string matches a pattern and, if it does, to extract or transform the parts that match. ">
  <meta name="keywords" content="package, scala, util, matching, library, scala~2.13_library">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scala~2.13_library/scala/util/matching/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/scala~2.13_library.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scala~2.13_library/" class="_nav-link" title="" style="margin-left:0;">Scala 2.13 Library</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _scala">
				
				
<h1>Package scala.util.matching</h1>
<h2 id="signature">
<span class="modifier_kind"> <span class="kind">package</span></span> <span class="symbol"><span class="name">matching</span></span>
</h2>

<div id="template"><div id="allMembers">
<div id="types" class="types members">
<h2>Type Members</h2>
<h3 id="scala.util.matching.Regex">
<span class="modifier_kind"> <span class="kind">class </span></span><span class="symbol"><a href="regex" title="A regular expression is used to determine whether a string matches a pattern and, if it does, to extract or transform the parts that match."><span class="name">Regex</span></a><span class="result"> extends <a href="../../index#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>A regular expression is used to determine whether a string matches a pattern and, if it does, to extract or transform the parts that match.</p>
<h5> Usage </h5>
<p> This class delegates to the <span name="java.util.regex" class="extype">java.util.regex</span> package of the Java Platform. See the documentation for <span name="java.util.regex.Pattern" class="extype">java.util.regex.Pattern</span> for details about the regular expression syntax for pattern strings.</p>
<p> An instance of <code>Regex</code> represents a compiled regular expression pattern. Since compilation is expensive, frequently used <code>Regex</code>es should be constructed once, outside of loops and perhaps in a companion object.</p>
<p> The canonical way to create a <code>Regex</code> is by using the method <code>r</code>, provided implicitly for strings:</p>
<pre data-language="scala">val date = raw"(\d{4})-(\d{2})-(\d{2})".r</pre>
<p> Since escapes are not processed in multi-line string literals, using triple quotes avoids having to escape the backslash character, so that <code>"\\d"</code> can be written <code>"""\d"""</code>. The same result is achieved with certain interpolators, such as <code>raw"\d".r</code> or a custom interpolator <code>r"\d"</code> that also compiles the <code>Regex</code>.</p>
<h5> Extraction </h5>
<p> To extract the capturing groups when a <code>Regex</code> is matched, use it as an extractor in a pattern match:</p>
<pre data-language="scala">"2004-01-20" match {
  case date(year, month, day) =&gt; s"$year was a good year for PLs."
}</pre>
<p> To check only whether the <code>Regex</code> matches, ignoring any groups, use a sequence wildcard:</p>
<pre data-language="scala">"2004-01-20" match {
  case date(_*) =&gt; "It's a date!"
}</pre>
<p> That works because a <code>Regex</code> extractor produces a sequence of strings. Extracting only the year from a date could also be expressed with a sequence wildcard:</p>
<pre data-language="scala">"2004-01-20" match {
  case date(year, _*) =&gt; s"$year was a good year for PLs."
}</pre>
<p> In a pattern match, <code>Regex</code> normally matches the entire input. However, an unanchored <code>Regex</code> finds the pattern anywhere in the input.</p>
<pre data-language="scala">val embeddedDate = date.unanchored
"Date: 2004-01-20 17:25:18 GMT (10 years, 28 weeks, 5 days, 17 hours and 51 minutes ago)" match {
  case embeddedDate("2004", "01", "20") =&gt; "A Scala is born."
}</pre>
<h5> Find Matches </h5>
<p> To find or replace matches of the pattern, use the various find and replace methods. For each method, there is a version for working with matched strings and another for working with <code>Match</code> objects.</p>
<p> For example, pattern matching with an unanchored <code>Regex</code>, as in the previous example, can also be accomplished using <code>findFirstMatchIn</code>. The <code>findFirst</code> methods return an <code>Option</code> which is non-empty if a match is found, or <code>None</code> for no match:</p>
<pre data-language="scala">val dates = "Important dates in history: 2004-01-20, 1958-09-05, 2010-10-06, 2011-07-15"
val firstDate = date.findFirstIn(dates).getOrElse("No date found.")
val firstYear = for (m &lt;- date.findFirstMatchIn(dates)) yield m.group(1)</pre>
<p> To find all matches:</p>
<pre data-language="scala">val allYears = for (m &lt;- date.findAllMatchIn(dates)) yield m.group(1)</pre>
<p> To check whether input is matched by the regex:</p>
<pre data-language="scala">date.matches("2018-03-01")                     // true
date.matches("Today is 2018-03-01")            // false
date.unanchored.matches("Today is 2018-03-01") // true</pre>
<p> To iterate over the matched strings, use <code>findAllIn</code>, which returns a special iterator that can be queried for the <code>MatchData</code> of the last match:</p>
<pre data-language="scala">val mi = date.findAllIn(dates)
while (mi.hasNext) {
  val d = mi.next
  if (mi.group(1).toInt &lt; 1960) println(s"$d: An oldie but goodie.")
}</pre>
<p> Although the <code>MatchIterator</code> returned by <code>findAllIn</code> is used like any <code>Iterator</code>, with alternating calls to <code>hasNext</code> and <code>next</code>, <code>hasNext</code> has the additional side effect of advancing the underlying matcher to the next unconsumed match. This effect is visible in the <code>MatchData</code> representing the "current match".</p>
<pre data-language="scala">val r = "(ab+c)".r
val s = "xxxabcyyyabbczzz"
r.findAllIn(s).start    // 3
val mi = r.findAllIn(s)
mi.hasNext              // true
mi.start                // 3
mi.next()               // "abc"
mi.start                // 3
mi.hasNext              // true
mi.start                // 9
mi.next()               // "abbc"</pre>
<p> The example shows that methods on <code>MatchData</code> such as <code>start</code> will advance to the first match, if necessary. It also shows that <code>hasNext</code> will advance to the next unconsumed match, if <code>next</code> has already returned the current match.</p>
<p> The current <code>MatchData</code> can be captured using the <code>matchData</code> method. Alternatively, <code>findAllMatchIn</code> returns an <code>Iterator[Match]</code>, where there is no interaction between the iterator and <code>Match</code> objects it has already produced.</p>
<p> Note that <code>findAllIn</code> finds matches that don't overlap. (See <a href="regex#findAllIn(source:CharSequence):scala.util.matching.Regex.MatchIterator" name="scala.util.matching.Regex#findAllIn" id="scala.util.matching.Regex#findAllIn" class="extmbr">findAllIn</a> for more examples.)</p>
<pre data-language="scala">val num = raw"(\d+)".r
val all = num.findAllIn("123").toList  // List("123"), not List("123", "23", "3")</pre>
<h5> Replace Text </h5>
<p> Text replacement can be performed unconditionally or as a function of the current match:</p>
<pre data-language="scala">val redacted    = date.replaceAllIn(dates, "XXXX-XX-XX")
val yearsOnly   = date.replaceAllIn(dates, m =&gt; m.group(1))
val months      = (0 to 11).map { i =&gt; val c = Calendar.getInstance; c.set(2014, i, 1); f"$c%tb" }
val reformatted = date.replaceAllIn(dates, _ match { case date(y,m,d) =&gt; f"${months(m.toInt - 1)} $d, $y" })</pre>
<p> Pattern matching the <code>Match</code> against the <code>Regex</code> that created it does not reapply the <code>Regex</code>. In the expression for <code>reformatted</code>, each <code>date</code> match is computed once. But it is possible to apply a <code>Regex</code> to a <code>Match</code> resulting from a different pattern:</p>
<pre data-language="scala">val docSpree = """2011(?:-\d{2}){2}""".r
val docView  = date.replaceAllIn(dates, _ match {
  case docSpree() =&gt; "Historic doc spree!"
  case _          =&gt; "Something else happened"
})</pre>
</div>
<dl class="attributes block">
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../../serialversionuid" name="scala.SerialVersionUID" id="scala.SerialVersionUID" class="extype">SerialVersionUID</a></span><span class="args">()</span> </dd>
<dt>See also</dt>
<dd><span class="cmt"><p><span name="java.util.regex.Pattern" class="extype">java.util.regex.Pattern</span></p></span></dd>
</dl>
</div>
<h3 id="scala.util.matching.UnanchoredRegex">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="unanchoredregex" title="A Regex that finds the first match when used in a pattern match."><span class="name">UnanchoredRegex</span></a><span class="result"> extends <a href="regex" name="scala.util.matching.Regex" id="scala.util.matching.Regex" class="extype">Regex</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>A <a href="regex" name="scala.util.matching.Regex" id="scala.util.matching.Regex" class="extype">Regex</a> that finds the first match when used in a pattern match. </p></div>
<dl class="attributes block">
<dt>See also</dt>
<dd><span class="cmt"><p><a href="regex#unanchored:scala.util.matching.UnanchoredRegex" name="scala.util.matching.Regex#unanchored" id="scala.util.matching.Regex#unanchored" class="extmbr">Regex#unanchored</a></p></span></dd>
</dl>
</div>
</div>
<div class="values members">
<h2>Value Members</h2>
<h3 id="scala.util.matching.Regex">
<span class="modifier_kind"> <span class="kind">object </span></span><span class="symbol"><a href="regex%24" title="This object defines inner classes that describe regex matches and helper objects."><span class="name">Regex</span></a><span class="result"> extends <span name="java.io.Serializable" class="extype">java.io.Serializable</span></span></span>
</h3>
   </div>
</div></div>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2002-2019 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.scala-lang.org/api/2.13.0/scala/util/matching/index.html" class="_attribution-link">https://www.scala-lang.org/api/2.13.0/scala/util/matching/index.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
