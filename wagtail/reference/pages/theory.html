
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Theory - Wagtail - W3cubDocs</title>
  
  <meta name="description" content=" If you’re unfamiliar with trees as an abstract data type, you might want to review the concepts involved. ">
  <meta name="keywords" content="theory, wagtail">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/wagtail/reference/pages/theory.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9b6ce6139b8492a0447e9396e58206baee4973e9a8a1d9126d4ab69e244811034e5265efcc9da8b9550a8e365367ee3ea1d2c5757f9a5fc1720dc94cd4df775b.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/wagtail.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/wagtail/" class="_nav-link" title="" style="margin-left:0;">Wagtail</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="pages-theory">Theory</h1> <section id="introduction-to-trees"> <h2>Introduction to Trees</h2> <p>If you’re unfamiliar with trees as an abstract data type, you might want to <a class="reference external" href="https://en.wikipedia.org/wiki/Tree_(data_structure)">review the concepts involved</a>.</p> <p>As a web developer, though, you probably already have a good understanding of trees as filesystem directories or paths. Wagtail pages can create the same structure, as each page in the tree has its own URL path, like so:</p> <pre data-language="python">/
    people/
        nien-nunb/
        laura-roslin/
    events/
        captain-picard-day/
        winter-wrap-up/
</pre> <p>The Wagtail admin interface uses the tree to organise content for editing, letting you navigate up and down levels in the tree through its Explorer menu. This method of organisation is a good place to start in thinking about your own Wagtail models.</p> <section id="nodes-and-leaves"> <h3>Nodes and Leaves</h3> <p>It might be handy to think of the <code>Page</code>-derived models you want to create as being one of two node types: parents and leaves. Wagtail isn’t prescriptive in this approach, but it’s a good place to start if you’re not experienced in structuring your own content types.</p> <section id="nodes"> <h4>Nodes</h4> <p>Parent nodes on the Wagtail tree probably want to organise and display a browse-able index of their descendants. A blog, for instance, needs a way to show a list of individual posts.</p> <p>A Parent node could provide its own function returning its descendant objects.</p> <pre data-language="python">class EventPageIndex(Page):
    # ...
    def events(self):
        # Get list of live event pages that are descendants of this page
        events = EventPage.objects.live().descendant_of(self)

        # Filter events list to get ones that are either
        # running now or start in the future
        events = events.filter(date_from__gte=date.today())

        # Order by date
        events = events.order_by('date_from')

        return events
</pre> <p>This example makes sure to limit the returned objects to pieces of content which make sense, specifically ones which have been published through Wagtail’s admin interface (<code>live()</code>) and are children of this node (<code>descendant_of(self)</code>). By setting a <code>subpage_types</code> class property in your model, you can specify which models are allowed to be set as children, and by setting a <code>parent_page_types</code> class property, you can specify which models are allowed to be parents of this page model. Wagtail will allow any <code>Page</code>-derived model by default. Regardless, it’s smart for a parent model to provide an index filtered to make sense.</p> </section> <section id="leaves"> <h4>Leaves</h4> <p>Leaves are the pieces of content itself, a page which is consumable, and might just consist of a bunch of properties. A blog page leaf might have some body text and an image. A person page leaf might have a photo, a name, and an address.</p> <p>It might be helpful for a leaf to provide a way to back up along the tree to a parent, such as in the case of breadcrumbs navigation. The tree might also be deep enough that a leaf’s parent won’t be included in general site navigation.</p> <p>The model for the leaf could provide a function that traverses the tree in the opposite direction and returns an appropriate ancestor:</p> <pre data-language="python">class EventPage(Page):
    # ...
    def event_index(self):
        # Find closest ancestor which is an event index
        return self.get_ancestors().type(EventIndexPage).last()
</pre> <p>If defined, <code>subpage_types</code> and <code>parent_page_types</code> will also limit the parent models allowed to contain a leaf. If not, Wagtail will allow any combination of parents and leafs to be associated in the Wagtail tree. Like with index pages, it’s a good idea to make sure that the index is actually of the expected model to contain the leaf.</p> </section> <section id="other-relationships"> <h4>Other Relationships</h4> <p>Your <code>Page</code>-derived models might have other interrelationships which extend the basic Wagtail tree or depart from it entirely. You could provide functions to navigate between siblings, such as a “Next Post” link on a blog page (<code>post-&gt;post-&gt;post</code>). It might make sense for subtrees to interrelate, such as in a discussion forum (<code>forum-&gt;post-&gt;replies</code>) Skipping across the hierarchy might make sense, too, as all objects of a certain model class might interrelate regardless of their ancestors (<code>events = EventPage.objects.all</code>). It’s largely up to the models to define their interrelations, the possibilities are really endless.</p> </section> </section> </section> <section id="anatomy-of-a-wagtail-request"> <h2 id="id1">Anatomy of a Wagtail Request</h2> <p>For going beyond the basics of model definition and interrelation, it might help to know how Wagtail handles requests and constructs responses. In short, it goes something like:</p> <ol class="arabic simple"> <li>Django gets a request and routes through Wagtail’s URL dispatcher definitions</li> <li>Wagtail checks the hostname of the request to determine which <code>Site</code> record will handle this request.</li> <li>Starting from the root page of that site, Wagtail traverses the page tree, calling the <code>route()</code> method and letting each page model decide whether it will handle the request itself or pass it on to a child page.</li> <li>The page responsible for handling the request returns a <code>RouteResult</code> object from <code>route()</code>, which identifies the page along with any additional <code>args</code>/<code>kwargs</code> to be passed to <code>serve()</code>.</li> <li>Wagtail calls <code>serve()</code>, which constructs a context using <code>get_context()</code>
</li> <li>
<code>serve()</code> finds a template to pass it to using <code>get_template()</code>
</li> <li>A response object is returned by <code>serve()</code> and Django responds to the requester.</li> </ol> <p>You can apply custom behaviour to this process by overriding <code>Page</code> class methods such as <code>route()</code> and <code>serve()</code> in your own models. For examples, see <a class="reference internal" href="model_recipes#page-model-recipes"><span class="std std-ref">Recipes</span></a>.</p> </section> <section id="scheduled-publishing"> <h2 id="id2">Scheduled Publishing</h2> <p>Page publishing can be scheduled through the <em>Set schedule</em> feature in the <em>Status</em> side panel of the <em>Edit</em> page. This allows you to set up initial page publishing or a page update in advance. In order for pages to go live at the scheduled time, you should set up the <a class="reference internal" href="../management_commands#publish-scheduled"><span class="std std-ref">publish_scheduled</span></a> management command.</p> <p>The basic workflow is as follows:</p> <ul class="simple"> <li>Scheduling is done by setting the <em>go-live at</em> field of the page and clicking <em>Publish</em>.</li> <li>Scheduling a revision for a page that is not currently live means that page will go live when the scheduled time comes.</li> <li>Scheduling a revision for a page that is already live means that revision will be published when the time comes.</li> <li>If the page has a scheduled revision and you set another revision to publish immediately (i.e. clicking <em>Publish</em> with the <em>go-live at</em> field unset), the scheduled revision will be unscheduled.</li> <li>If the page has a scheduled revision and you schedule another revision to publish (i.e. clicking <em>Publish</em> with the <em>go-live at</em> field set), the existing scheduled revision will be unscheduled and the new revision will be scheduled instead.</li> </ul> <p>Note that you have to click <em>Publish</em> after setting the <em>go-live at</em> field for the revision to be scheduled. Saving a draft revision with the <em>go-live at</em> field without clicking <em>Publish</em> will not schedule it to be published.</p> <p>The <em>History</em> view for a given page will show which revision is scheduled and when it is scheduled for. A scheduled revision in the list will also provide an <em>Unschedule</em> button to cancel it.</p> <p>In addition to scheduling a page to be published, it is also possible to schedule a page to be unpublished by setting the <em>expire at</em> field. However, unlike with publishing, the unpublishing schedule is applied to the live page instance rather than a specific revision. This means that any change to the <em>expire at</em> field will only be effective once the associated revision is published (i.e. when the changes are applied to the live instance). To illustrate:</p> <ul class="simple"> <li>Scheduling is done by setting the <em>expire at</em> field of the page and clicking <em>Publish</em>. If the <em>go-live at</em> field is also set, then the unpublishing schedule will only be applied after the revision goes live.</li> <li>
<p>Consider a live page that is scheduled to be unpublished on e.g. 14 June. Then sometime before the schedule, consider that a new revision is scheduled to be published on a date that’s <strong>earlier</strong> than the unpublishing schedule, e.g. 9 June. When the new revision goes live on 9 June, the <em>expire at</em> field contained in the new revision will replace the existing unpublishing schedule. This means:</p> <ul> <li>If the new revision contains a different <em>expire at</em> field (e.g. 17 June), the new revision will go live on 9 June and the page will not be unpublished on 14 June but it will be unpublished on 17 June.</li> <li>If the new revision has the <em>expire at</em> field unset, the new revision will go live on 9 June and the unpublishing schedule will be unset, thus the page will not be unpublished.</li> </ul> </li> <li>
<p>Consider another live page that is scheduled to be unpublished on e.g. 14 June. Then sometime before the schedule, consider that a new revision is scheduled to be published on a date that’s <strong>later</strong> than the unpublishing schedule, e.g. 21 June. The new revision will not take effect until it goes live on 21 June, so the page will still be unpublished on 14 June. This means:</p> <ul> <li>If the new revision contains a different <em>expire at</em> field (e.g. 25 June), the page will be unpublished on 14 June, the new revision will go live on 21 June and the page will be unpublished again on 25 June.</li> <li>If the new revision has the <em>expire at</em> field unset, the page will be unpublished on 14 June and the new revision will go live on 21 June.</li> </ul> </li> </ul> <p>The same scheduling mechanism also applies to snippets with <a class="reference internal" href="model_reference#wagtail.models.DraftStateMixin" title="wagtail.models.DraftStateMixin"><code>DraftStateMixin</code></a> applied. For more details, see <a class="reference internal" href="../../topics/snippets#wagtailsnippets-saving-draft-changes-of-snippets"><span class="std std-ref">Saving draft changes of snippets</span></a>.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2014-present Torchbox Ltd and individual contributors.<br>All rights are reserved.<br>Licensed under the BSD License.<br>
    <a href="https://docs.wagtail.org/en/stable/reference/pages/theory.html" class="_attribution-link">https://docs.wagtail.org/en/stable/reference/pages/theory.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
