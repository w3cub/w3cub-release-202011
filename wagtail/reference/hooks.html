
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Hooks - Wagtail - W3cubDocs</title>
  
  <meta name="description" content="On loading, Wagtail will search for any app with the file wagtail_hooks.py and execute the contents. This provides a way to register your own &hellip;">
  <meta name="keywords" content="hooks, wagtail">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/wagtail/reference/hooks.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9b6ce6139b8492a0447e9396e58206baee4973e9a8a1d9126d4ab69e244811034e5265efcc9da8b9550a8e365367ee3ea1d2c5757f9a5fc1720dc94cd4df775b.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/wagtail.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/wagtail/" class="_nav-link" title="" style="margin-left:0;">Wagtail</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="admin-hooks">Hooks</h1> <p>On loading, Wagtail will search for any app with the file <code>wagtail_hooks.py</code> and execute the contents. This provides a way to register your own functions to execute at certain points in Wagtail’s execution, such as when a page is saved or when the main menu is constructed.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Hooks are typically used to customise the view-level behaviour of the Wagtail admin and front-end. For customisations that only deal with model-level behaviour - such as calling an external service when a page or document is added - it is often better to use <a class="reference external" href="https://docs.djangoproject.com/en/stable/topics/signals/" title="(in Django v4.1)"><span class="xref myst">Django’s signal mechanism</span></a> (see also: <a class="reference internal" href="signals"><span class="doc std std-doc">Wagtail signals</span></a>), as these are not dependent on a user taking a particular path through the admin interface.</p> </div> <p>Registering functions with a Wagtail hook is done through the <code>@hooks.register</code> decorator:</p> <pre data-language="python">from wagtail import hooks

@hooks.register('name_of_hook')
def my_hook_function(arg1, arg2...)
    # your code here
</pre> <p>Alternatively, <code>hooks.register</code> can be called as an ordinary function, passing in the name of the hook and a handler function defined elsewhere:</p> <pre data-language="python">hooks.register('name_of_hook', my_hook_function)
</pre> <p>If you need your hooks to run in a particular order, you can pass the <code>order</code> parameter. If order is not specified then the hooks proceed in the order given by <code>INSTALLED_APPS</code>. Wagtail uses hooks internally, too, so you need to be aware of order when overriding built-in Wagtail functionality (such as removing default summary items):</p> <pre data-language="python">@hooks.register('name_of_hook', order=1)  # This will run after every hook in the wagtail core
def my_hook_function(arg1, arg2...)
    # your code here

@hooks.register('name_of_hook', order=-1)  # This will run before every hook in the wagtail core
def my_other_hook_function(arg1, arg2...)
    # your code here

@hooks.register('name_of_hook', order=2)  # This will run after `my_hook_function`
def yet_another_hook_function(arg1, arg2...)
    # your code here
</pre> <section id="unit-testing-hooks"> <h2>Unit testing hooks</h2> <p>Hooks are usually registered on startup and can’t be changed at runtime. But when writing unit tests, you might want to register a hook function just for a single test or block of code and unregister it so that it doesn’t run when other tests are run.</p> <p>You can register hooks temporarily using the <code>hooks.register_temporarily</code> function, this can be used as both a decorator and a context manager. Here’s an example of how to register a hook function for just a single test:</p> <pre data-language="python">def my_hook_function():
    pass

class MyHookTest(TestCase):

    @hooks.register_temporarily('name_of_hook', my_hook_function)
    def test_my_hook_function(self):
        # Test with the hook registered here
        pass
</pre> <p>And here’s an example of registering a hook function for a single block of code:</p> <pre data-language="python">def my_hook_function():
    pass

with hooks.register_temporarily('name_of_hook', my_hook_function):
    # Hook is registered here
    ..

# Hook is unregistered here
</pre> <p>If you need to register multiple hooks in a <code>with</code> block, you can pass the hooks in as a list of tuples:</p> <pre data-language="python">def my_hook(...):
    pass

def my_other_hook(...):
    pass

with hooks.register_temporarily([
    ('hook_name', my_hook),
    ('hook_name', my_other_hook),
]):
    # All hooks are registered here
    ..

# All hooks are unregistered here
</pre> <p>The available hooks are listed below.</p> </section> <section id="admin-modules"> <h2>Admin modules</h2> <p>Hooks for building new areas of the admin interface (alongside pages, images, documents and so on).</p> <section id="construct-homepage-panels"> <h3 id="id1"><code>construct_homepage_panels</code></h3> <p>Add or remove panels from the Wagtail admin homepage. The callable passed into this hook should take a <code>request</code> object and a list of panel objects, and should modify this list in-place as required. Panel objects are <a class="reference internal" href="../extending/template_components#template-components"><span class="std std-ref">Template components</span></a> with an additional <code>order</code> property, an integer that determines the panel’s position in the final ordered list. The default panels use integers between <code>100</code> and <code>300</code>.</p> <pre data-language="python">from django.utils.safestring import mark_safe

from wagtail.admin.ui.components import Component
from wagtail import hooks

class WelcomePanel(Component):
    order = 50

    def render_html(self, parent_context):
        return mark_safe("""
        &lt;section class="panel summary nice-padding"&gt;
          &lt;h3&gt;No, but seriously -- welcome to the admin homepage.&lt;/h3&gt;
        &lt;/section&gt;
        """)

@hooks.register('construct_homepage_panels')
def add_another_welcome_panel(request, panels):
    panels.append(WelcomePanel())
</pre> </section> <section id="construct-homepage-summary-items"> <h3 id="id2"><code>construct_homepage_summary_items</code></h3> <p>Add or remove items from the ‘site summary’ bar on the admin homepage (which shows the number of pages and other object that exist on the site). The callable passed into this hook should take a <code>request</code> object and a list of summary item objects, and should modify this list in-place as required. Summary item objects are instances of <code>wagtail.admin.site_summary.SummaryItem</code>, which extends <a class="reference internal" href="../extending/template_components#creating-template-components"><span class="std std-ref">the Component class</span></a> with the following additional methods and properties:</p>      </section> <section id="construct-main-menu"> <h3 id="id3"><code>construct_main_menu</code></h3> <p>Called just before the Wagtail admin menu is output, to allow the list of menu items to be modified. The callable passed to this hook will receive a <code>request</code> object and a list of <code>menu_items</code>, and should modify <code>menu_items</code> in-place as required. Adding menu items should generally be done through the <code>register_admin_menu_item</code> hook instead - items added through <code>construct_main_menu</code> will not have their <code>is_shown</code> check applied.</p> <pre data-language="python">from wagtail import hooks

@hooks.register('construct_main_menu')
def hide_explorer_menu_item_from_frank(request, menu_items):
  if request.user.username == 'frank':
    menu_items[:] = [item for item in menu_items if item.name != 'explorer']
</pre> </section> <section id="describe-collection-contents"> <h3 id="id4"><code>describe_collection_contents</code></h3> <p>Called when Wagtail needs to find out what objects exist in a collection, if any. Currently this happens on the confirmation before deleting a collection, to ensure that non-empty collections cannot be deleted. The callable passed to this hook will receive a <code>collection</code> object, and should return either <code>None</code> (to indicate no objects in this collection), or a dict containing the following keys:</p> <ul class="simple"> <li>
<code>count</code> - A numeric count of items in this collection</li> <li>
<code>count_text</code> - A human-readable string describing the number of items in this collection, such as “3 documents”. (Sites with multi-language support should return a translatable string here, most likely using the <code>django.utils.translation.ngettext</code> function.)</li> <li>
<code>url</code> (optional) - A URL to an index page that lists the objects being described.</li> </ul> </section> <section id="register-account-settings-panel"> <h3><code>register_account_settings_panel</code></h3> <p>Registers a new settings panel class to add to the “Account” view in the admin.</p> <p>This hook can be added to a sub-class of <code>BaseSettingsPanel</code>. For example:</p> <pre data-language="python">from wagtail.admin.views.account import BaseSettingsPanel
from wagtail import hooks

@hooks.register('register_account_settings_panel')
class CustomSettingsPanel(BaseSettingsPanel):
    name = 'custom'
    title = "My custom settings"
    order = 500
    form_class = CustomSettingsForm
</pre> <p>Alternatively, it can also be added to a function. For example, this function is equivalent to the above:</p> <pre data-language="python">from wagtail.admin.views.account import BaseSettingsPanel
from wagtail import hooks

class CustomSettingsPanel(BaseSettingsPanel):
    name = 'custom'
    title = "My custom settings"
    order = 500
    form_class = CustomSettingsForm

@hooks.register('register_account_settings_panel')
def register_custom_settings_panel(request, user, profile):
    return CustomSettingsPanel(request, user, profile)
</pre> <p>More details about the options that are available can be found at <a class="reference internal" href="../extending/custom_account_settings#custom-account-settings"><span class="std std-ref">Customising the user account settings form</span></a>.</p> </section> <section id="register-account-menu-item"> <h3 id="id5"><code>register_account_menu_item</code></h3> <p>Add an item to the “More actions” tab on the “Account” page within the Wagtail admin. The callable for this hook should return a dict with the keys <code>url</code>, <code>label</code> and <code>help_text</code>. For example:</p> <pre data-language="python">from django.urls import reverse
from wagtail import hooks

@hooks.register('register_account_menu_item')
def register_account_delete_account(request):
    return {
        'url': reverse('delete-account'),
        'label': 'Delete account',
        'help_text': 'This permanently deletes your account.'
    }
</pre> </section> <section id="register-admin-menu-item"> <h3 id="id6"><code>register_admin_menu_item</code></h3> <p>Add an item to the Wagtail admin menu. The callable passed to this hook must return an instance of <code>wagtail.admin.menu.MenuItem</code>. New items can be constructed from the <code>MenuItem</code> class by passing in a <code>label</code> which will be the text in the menu item, and the URL of the admin page you want the menu item to link to (usually by calling <code>reverse()</code> on the admin view you’ve set up). Additionally, the following keyword arguments are accepted:</p> <ul class="simple"> <li>
<code>name</code> - an internal name used to identify the menu item; defaults to the slugified form of the label.</li> <li>
<code>icon_name</code> - icon to display against the menu item; no defaults, optional, but should be set for top-level menu items so they can be identified when collapsed.</li> <li>
<code>classnames</code> - additional classnames applied to the link</li> <li>
<code>order</code> - an integer which determines the item’s position in the menu</li> </ul> <p>For menu items that are only available to superusers, the subclass <code>wagtail.admin.menu.AdminOnlyMenuItem</code> can be used in place of <code>MenuItem</code>.</p> <p><code>MenuItem</code> can be further subclassed to customise its initialisation or conditionally show or hide the item for specific requests (for example, to apply permission checks); see the source code (<code>wagtail/admin/menu.py</code>) for details.</p> <pre data-language="python">from django.urls import reverse

from wagtail import hooks
from wagtail.admin.menu import MenuItem

@hooks.register('register_admin_menu_item')
def register_frank_menu_item():
  return MenuItem('Frank', reverse('frank'), icon_name='folder-inverse', order=10000)
</pre> </section> <section id="register-admin-urls"> <h3 id="id7"><code>register_admin_urls</code></h3> <p>Register additional admin page URLs. The callable fed into this hook should return a list of Django URL patterns which define the structure of the pages and endpoints of your extension to the Wagtail admin. For more about vanilla Django URLconfs and views, see <a class="reference external" href="https://docs.djangoproject.com/en/stable/topics/http/urls/" title="(in Django v4.1)"><span class="xref myst">url dispatcher</span></a>.</p> <pre data-language="python">from django.http import HttpResponse
from django.urls import path

from wagtail import hooks

def admin_view(request):
  return HttpResponse(
    "I have approximate knowledge of many things!",
    content_type="text/plain")

@hooks.register('register_admin_urls')
def urlconf_time():
  return [
    path('how_did_you_almost_know_my_name/', admin_view, name='frank'),
  ]
</pre> </section> <section id="register-group-permission-panel"> <h3 id="id8"><code>register_group_permission_panel</code></h3> <p>Add a new panel to the Groups form in the ‘settings’ area. The callable passed to this hook must return a ModelForm / ModelFormSet-like class, with a constructor that accepts a group object as its <code>instance</code> keyword argument, and which implements the methods <code>save</code>, <code>is_valid</code>, and <code>as_admin_panel</code> (which returns the HTML to be included on the group edit page).</p> </section> <section id="register-settings-menu-item"> <h3 id="id9"><code>register_settings_menu_item</code></h3> <p>As <code>register_admin_menu_item</code>, but registers menu items into the ‘Settings’ sub-menu rather than the top-level menu.</p> </section> <section id="construct-settings-menu"> <h3 id="id10"><code>construct_settings_menu</code></h3> <p>As <code>construct_main_menu</code>, but modifies the ‘Settings’ sub-menu rather than the top-level menu.</p> </section> <section id="register-reports-menu-item"> <h3 id="id11"><code>register_reports_menu_item</code></h3> <p>As <code>register_admin_menu_item</code>, but registers menu items into the ‘Reports’ sub-menu rather than the top-level menu.</p> </section> <section id="construct-reports-menu"> <h3 id="id12"><code>construct_reports_menu</code></h3> <p>As <code>construct_main_menu</code>, but modifies the ‘Reports’ sub-menu rather than the top-level menu.</p> </section> <section id="register-help-menu-item"> <h3 id="id13"><code>register_help_menu_item</code></h3> <p>As <code>register_admin_menu_item</code>, but registers menu items into the ‘Help’ sub-menu rather than the top-level menu.</p> </section> <section id="construct-help-menu"> <h3 id="id14"><code>construct_help_menu</code></h3> <p>As <code>construct_main_menu</code>, but modifies the ‘Help’ sub-menu rather than the top-level menu.</p> </section> <section id="register-admin-search-area"> <h3 id="id15"><code>register_admin_search_area</code></h3> <p>Add an item to the Wagtail admin search “Other Searches”. Behaviour of this hook is similar to <code>register_admin_menu_item</code>. The callable passed to this hook must return an instance of <code>wagtail.admin.search.SearchArea</code>. New items can be constructed from the <code>SearchArea</code> class by passing the following parameters:</p> <ul class="simple"> <li>
<code>label</code> - text displayed in the “Other Searches” option box.</li> <li>
<code>name</code> - an internal name used to identify the search option; defaults to the slugified form of the label.</li> <li>
<code>url</code> - the URL of the target search page.</li> <li>
<code>classnames</code> - arbitrary CSS classnames applied to the link</li> <li>
<code>icon_name</code> - icon to display next to the label.</li> <li>
<code>attrs</code> - additional HTML attributes to apply to the link.</li> <li>
<code>order</code> - an integer which determines the item’s position in the list of options.</li> </ul> <p>Setting the URL can be achieved using reverse() on the target search page. The GET parameter ‘q’ will be appended to the given URL.</p> <p>A template tag, <code>search_other</code> is provided by the <code>wagtailadmin_tags</code> template module. This tag takes a single, optional parameter, <code>current</code>, which allows you to specify the <code>name</code> of the search option currently active. If the parameter is not given, the hook defaults to a reverse lookup of the page’s URL for comparison against the <code>url</code> parameter.</p> <p><code>SearchArea</code> can be subclassed to customise the HTML output, specify JavaScript files required by the option, or conditionally show or hide the item for specific requests (for example, to apply permission checks); see the source code (<code>wagtail/admin/search.py</code>) for details.</p> <pre data-language="python">from django.urls import reverse
from wagtail import hooks
from wagtail.admin.search import SearchArea

@hooks.register('register_admin_search_area')
def register_frank_search_area():
    return SearchArea('Frank', reverse('frank'), icon_name='folder-inverse', order=10000)
</pre> </section> <section id="register-permissions"> <h3 id="id16"><code>register_permissions</code></h3> <p>Return a QuerySet of <code>Permission</code> objects to be shown in the Groups administration area.</p> <pre data-language="python">  from django.contrib.auth.models import Permission
  from wagtail import hooks


  @hooks.register('register_permissions')
  def register_permissions():
      app = 'blog'
      model = 'extramodelset'

      return Permission.objects.filter(content_type__app_label=app, codename__in=[
          f"view_{model}", f"add_{model}", f"change_{model}", f"delete_{model}"
      ])
</pre> </section> <section id="filter-form-submissions-for-user"> <h3 id="id17"><code>filter_form_submissions_for_user</code></h3> <p>Allows access to form submissions to be customised on a per-user, per-form basis.</p> <p>This hook takes two parameters:</p> <ul class="simple"> <li>The user attempting to access form submissions</li> <li>A <code>QuerySet</code> of form pages</li> </ul> <p>The hook must return a <code>QuerySet</code> containing a subset of these form pages which the user is allowed to access the submissions for.</p> <p>For example, to prevent non-superusers from accessing form submissions:</p> <pre data-language="python">from wagtail import hooks


@hooks.register('filter_form_submissions_for_user')
def construct_forms_for_user(user, queryset):
    if not user.is_superuser:
        queryset = queryset.none()

    return queryset
</pre> </section> </section> <section id="editor-interface"> <h2>Editor interface</h2> <p>Hooks for customising the editing interface for pages and snippets.</p> <section id="register-rich-text-features"> <h3 id="id18"><code>register_rich_text_features</code></h3> <p>Rich text fields in Wagtail work with a list of ‘feature’ identifiers that determine which editing controls are available in the editor, and which elements are allowed in the output; for example, a rich text field defined as <code>RichTextField(features=['h2', 'h3', 'bold', 'italic', 'link'])</code> would allow headings, bold / italic formatting and links, but not (for example) bullet lists or images. The <code>register_rich_text_features</code> hook allows new feature identifiers to be defined - see <a class="reference internal" href="../advanced_topics/customisation/page_editing_interface#rich-text-features"><span class="std std-ref">Limiting features in a rich text field</span></a> for details.</p> </section> <section id="insert-editor-css"> <h3 id="id19"><code>insert_editor_css</code></h3> <p>Add additional CSS files or snippets to the page editor.</p> <pre data-language="python">from django.templatetags.static import static
from django.utils.html import format_html

from wagtail import hooks

@hooks.register('insert_editor_css')
def editor_css():
    return format_html(
        '&lt;link rel="stylesheet" href="{}"&gt;',
        static('demo/css/vendor/font-awesome/css/font-awesome.min.css')
    )
</pre> </section> <section id="insert-global-admin-css"> <h3 id="id20"><code>insert_global_admin_css</code></h3> <p>Add additional CSS files or snippets to all admin pages.</p> <pre data-language="python">from django.utils.html import format_html
from django.templatetags.static import static

from wagtail import hooks

@hooks.register('insert_global_admin_css')
def global_admin_css():
    return format_html('&lt;link rel="stylesheet" href="{}"&gt;', static('my/wagtail/theme.css'))
</pre> </section> <section id="insert-editor-js"> <h3 id="id21"><code>insert_editor_js</code></h3> <p>Add additional JavaScript files or code snippets to the page editor.</p> <pre data-language="python">from django.utils.html import format_html_join
from django.utils.safestring import mark_safe
from django.templatetags.static import static

from wagtail import hooks

@hooks.register('insert_editor_js')
def editor_js():
    js_files = [
        'js/fireworks.js', # https://fireworks.js.org
    ]
    js_includes = format_html_join('\n', '&lt;script src="{0}"&gt;&lt;/script&gt;',
        ((static(filename),) for filename in js_files)
    )
    return js_includes + mark_safe(
        """
        &lt;script&gt;
            window.addEventListener('DOMContentLoaded', (event) =&gt; {
                var container = document.createElement('div');
                container.style.cssText = 'position: fixed; width: 100%; height: 100%; z-index: 100; top: 0; left: 0; pointer-events: none;';
                container.id = 'fireworks';
                document.getElementById('main').prepend(container);
                var options = { "acceleration": 1.2, "autoresize": true, "mouse": { "click": true, "max": 3 } };
                var fireworks = new Fireworks(document.getElementById('fireworks'), options);
                fireworks.start();
            });
        &lt;/script&gt;
        """
    )
</pre> </section> <section id="insert-global-admin-js"> <h3 id="id22"><code>insert_global_admin_js</code></h3> <p>Add additional JavaScript files or code snippets to all admin pages.</p> <pre data-language="python">from django.utils.safestring import mark_safe

from wagtail import hooks

@hooks.register('insert_global_admin_js')
def global_admin_js():
    return mark_safe(
        '&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r74/three.js"&gt;&lt;/script&gt;',
    )
</pre> </section> <section id="register-page-header-buttons"> <h3 id="id23"><code>register_page_header_buttons</code></h3> <p>Add buttons to the secondary dropdown menu in the page header. This works similarly to the <code>register_page_listing_buttons</code> hook.</p> <p>This example will add a simple button to the secondary dropdown menu:</p> <pre data-language="python">from wagtail.admin import widgets as wagtailadmin_widgets

@hooks.register('register_page_header_buttons')
def page_header_buttons(page, page_perms, next_url=None):
    yield wagtailadmin_widgets.Button(
        'A dropdown button',
        '/goes/to/a/url/',
        priority=60
    )
</pre> <p>The arguments passed to the hook are as follows:</p> <ul class="simple"> <li>
<code>page</code> - the page object to generate the button for</li> <li>
<code>page_perms</code> - a <code>PagePermissionTester</code> object that can be queried to determine the current user’s permissions on the given page</li> <li>
<code>next_url</code> - the URL that the linked action should redirect back to on completion of the action, if the view supports it</li> </ul> <p>The <code>priority</code> argument controls the order the buttons are displayed in the dropdown. Buttons are ordered from low to high priority, so a button with <code>priority=10</code> will be displayed before a button with <code>priority=60</code>.</p> </section> </section> <section id="editor-workflow"> <h2>Editor workflow</h2> <p>Hooks for customising the way users are directed through the process of creating page content.</p> <section id="after-create-page"> <h3 id="id24"><code>after_create_page</code></h3> <p>Do something with a <code>Page</code> object after it has been saved to the database (as a published page or a revision). The callable passed to this hook should take a <code>request</code> object and a <code>page</code> object. The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object. By default, Wagtail will instead redirect to the Explorer page for the new page’s parent.</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

@hooks.register('after_create_page')
def do_after_page_create(request, page):
    return HttpResponse("Congrats on making content!", content_type="text/plain")
</pre> <p>If you set attributes on a <code>Page</code> object, you should also call <code>save_revision()</code>, since the edit and index view pick up their data from the revisions table rather than the actual saved page record.</p> <pre data-language="python">  @hooks.register('after_create_page')
  def set_attribute_after_page_create(request, page):
      page.title = 'Persistent Title'
      new_revision = page.save_revision()
      if page.live:
          # page has been created and published at the same time,
          # so ensure that the updated title is on the published version too
          new_revision.publish()
</pre> </section> <section id="before-create-page"> <h3 id="id25"><code>before_create_page</code></h3> <p>Called at the beginning of the “create page” view passing in the request, the parent page and page model class.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> <p>Unlike, <code>after_create_page</code>, this is run both for both <code>GET</code> and <code>POST</code> requests.</p> <p>This can be used to completely override the editor on a per-view basis:</p> <pre data-language="python">from wagtail import hooks

from .models import AwesomePage
from .admin_views import edit_awesome_page

@hooks.register('before_create_page')
def before_create_page(request, parent_page, page_class):
    # Use a custom create view for the AwesomePage model
    if page_class == AwesomePage:
        return create_awesome_page(request, parent_page)
</pre> </section> <section id="after-delete-page"> <h3 id="id26"><code>after_delete_page</code></h3> <p>Do something after a <code>Page</code> object is deleted. Uses the same behaviour as <code>after_create_page</code>.</p> </section> <section id="before-delete-page"> <h3 id="id27"><code>before_delete_page</code></h3> <p>Called at the beginning of the “delete page” view passing in the request and the page object.</p> <p>Uses the same behaviour as <code>before_create_page</code>, is is run both for both <code>GET</code> and <code>POST</code> requests.</p> <pre data-language="python">from django.shortcuts import redirect
from django.utils.html import format_html

from wagtail.admin import messages
from wagtail import hooks

from .models import AwesomePage


@hooks.register('before_delete_page')
def before_delete_page(request, page):
    """Block awesome page deletion and show a message."""

    if request.method == 'POST' and page.specific_class in [AwesomePage]:
        messages.warning(request, "Awesome pages cannot be deleted, only unpublished")
        return redirect('wagtailadmin_pages:delete', page.pk)
</pre> </section> <section id="after-edit-page"> <h3 id="id28"><code>after_edit_page</code></h3> <p>Do something with a <code>Page</code> object after it has been updated. Uses the same behaviour as <code>after_create_page</code>.</p> </section> <section id="before-edit-page"> <h3 id="id29"><code>before_edit_page</code></h3> <p>Called at the beginning of the “edit page” view passing in the request and the page object.</p> <p>Uses the same behaviour as <code>before_create_page</code>.</p> </section> <section id="after-publish-page"> <h3 id="id30"><code>after_publish_page</code></h3> <p>Do something with a <code>Page</code> object after it has been published via page create view or page edit view.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> </section> <section id="before-publish-page"> <h3 id="id31"><code>before_publish_page</code></h3> <p>Do something with a <code>Page</code> object before it has been published via page create view or page edit view.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> </section> <section id="after-unpublish-page"> <h3 id="id32"><code>after_unpublish_page</code></h3> <p>Called after unpublish action in “unpublish” view passing in the request and the page object.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> </section> <section id="before-unpublish-page"> <h3 id="id33"><code>before_unpublish_page</code></h3> <p>Called before unpublish action in “unpublish” view passing in the request and the page object.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> </section> <section id="after-copy-page"> <h3 id="id34"><code>after_copy_page</code></h3> <p>Do something with a <code>Page</code> object after it has been copied passing in the request, page object and the new copied page. Uses the same behaviour as <code>after_create_page</code>.</p> </section> <section id="before-copy-page"> <h3 id="id35"><code>before_copy_page</code></h3> <p>Called at the beginning of the “copy page” view passing in the request and the page object.</p> <p>Uses the same behaviour as <code>before_create_page</code>.</p> </section> <section id="after-move-page"> <h3 id="id36"><code>after_move_page</code></h3> <p>Do something with a <code>Page</code> object after it has been moved passing in the request and page object. Uses the same behaviour as <code>after_create_page</code>.</p> </section> <section id="before-move-page"> <h3 id="id37"><code>before_move_page</code></h3> <p>Called at the beginning of the “move page” view passing in the request, the page object and the destination page object.</p> <p>Uses the same behaviour as <code>before_create_page</code>.</p> </section> <section id="before-convert-alias-page"> <h3 id="id38"><code>before_convert_alias_page</code></h3> <p>Called at the beginning of the <code>convert_alias</code> view, which is responsible for converting alias pages into normal Wagtail pages.</p> <p>The request and the page being converted are passed in as arguments to the hook.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> </section> <section id="after-convert-alias-page"> <h3 id="id39"><code>after_convert_alias_page</code></h3> <p>Do something with a <code>Page</code> object after it has been converted from an alias.</p> <p>The request and the page that was just converted are passed in as arguments to the hook.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> </section> <section id="construct-translated-pages-to-cascade-actions"> <h3 id="id40"><code>construct_translated_pages_to_cascade_actions</code></h3> <p>Return additional pages to process in a synced tree setup.</p> <p>This hook is only triggered on unpublishing a page when <code>WAGTAIL_I18N_ENABLED = True</code>.</p> <p>The list of pages and the action are passed in as arguments to the hook.</p> <p>The function should return a dictionary with the page from the pages list as key, and a list of additional pages to perform the action on. We recommend they are non-aliased, direct translations of the pages from the function argument.</p> </section> <section id="register-page-action-menu-item"> <h3 id="id41"><code>register_page_action_menu_item</code></h3> <p>Add an item to the popup menu of actions on the page creation and edit views. The callable passed to this hook must return an instance of <code>wagtail.admin.action_menu.ActionMenuItem</code>. <code>ActionMenuItem</code> is a subclass of <a class="reference internal" href="../extending/template_components#creating-template-components"><span class="std std-ref">Component</span></a> and so the rendering of the menu item can be customised through <code>template_name</code>, <code>get_context_data</code>, <code>render_html</code> and <code>Media</code>. In addition, the following attributes and methods are available to be overridden:</p> <ul class="simple"> <li>
<code>order</code> - an integer (default 100) which determines the item’s position in the menu. Can also be passed as a keyword argument to the object constructor. The lowest-numbered item in this sequence will be selected as the default menu item; as standard, this is “Save draft” (which has an <code>order</code> of 0).</li> <li>
<code>label</code> - the displayed text of the menu item</li> <li>
<code>get_url</code> - a method which returns a URL for the menu item to link to; by default, returns <code>None</code> which causes the menu item to behave as a form submit button instead</li> <li>
<code>name</code> - value of the <code>name</code> attribute of the submit button, if no URL is specified</li> <li>
<code>icon_name</code> - icon to display against the menu item</li> <li>
<code>classname</code> - a <code>class</code> attribute value to add to the button element</li> <li>
<code>is_shown</code> - a method which returns a boolean indicating whether the menu item should be shown; by default, true except when editing a locked page</li> </ul> <p>The <code>get_url</code>, <code>is_shown</code>, <code>get_context_data</code> and <code>render_html</code> methods all accept a context dictionary containing the following fields:</p> <ul class="simple"> <li>
<code>view</code> - name of the current view: <code>'create'</code>, <code>'edit'</code> or <code>'revisions_revert'</code>
</li> <li>
<code>page</code> - for <code>view</code> = <code>'edit'</code> or <code>'revisions_revert'</code>, the page being edited</li> <li>
<code>parent_page</code> - for <code>view</code> = <code>'create'</code>, the parent page of the page being created</li> <li>
<code>request</code> - the current request object</li> <li>
<code>user_page_permissions</code> - a <code>UserPagePermissionsProxy</code> object for the current user, to test permissions against</li> </ul> <pre data-language="python">from wagtail import hooks
from wagtail.admin.action_menu import ActionMenuItem

class GuacamoleMenuItem(ActionMenuItem):
    name = 'action-guacamole'
    label = "Guacamole"

    def get_url(self, context):
        return "https://www.youtube.com/watch?v=dNJdJIwCF_Y"


@hooks.register('register_page_action_menu_item')
def register_guacamole_menu_item():
    return GuacamoleMenuItem(order=10)
</pre> </section> <section id="construct-page-action-menu"> <h3 id="id42"><code>construct_page_action_menu</code></h3> <p>Modify the final list of action menu items on the page creation and edit views. The callable passed to this hook receives a list of <code>ActionMenuItem</code> objects, a request object and a context dictionary as per <code>register_page_action_menu_item</code>, and should modify the list of menu items in-place.</p> <pre data-language="python">@hooks.register('construct_page_action_menu')
def remove_submit_to_moderator_option(menu_items, request, context):
    menu_items[:] = [item for item in menu_items if item.name != 'action-submit']
</pre> <p>The <code>construct_page_action_menu</code> hook is called after the menu items have been sorted by their order attributes, and so setting a menu item’s order will have no effect at this point. Instead, items can be reordered by changing their position in the list, with the first item being selected as the default action. For example, to change the default action to Publish:</p> <pre data-language="python">@hooks.register('construct_page_action_menu')
def make_publish_default_action(menu_items, request, context):
    for (index, item) in enumerate(menu_items):
        if item.name == 'action-publish':
            # move to top of list
            menu_items.pop(index)
            menu_items.insert(0, item)
            break
</pre> </section> <section id="construct-page-listing-buttons"> <h3 id="id43"><code>construct_page_listing_buttons</code></h3> <p>Modify the final list of page listing buttons in the page explorer. The callable passed to this hook receives a list of <code>PageListingButton</code> objects, a page, a page perms object, and a context dictionary as per <code>register_page_listing_buttons</code>, and should modify the list of listing items in-place.</p> <pre data-language="python">@hooks.register('construct_page_listing_buttons')
def remove_page_listing_button_item(buttons, page, page_perms, context=None):
    if page.is_root:
        buttons.pop() # removes the last 'more' dropdown button on the root page listing buttons
</pre> </section> <section id="construct-wagtail-userbar"> <h3 id="id44"><code>construct_wagtail_userbar</code></h3> <p>Add or remove items from the wagtail userbar. Add, edit, and moderation tools are provided by default. The callable passed into the hook must take the <code>request</code> object and a list of menu objects, <code>items</code>. The menu item objects must have a <code>render</code> method which can take a <code>request</code> object and return the HTML string representing the menu item. See the userbar templates and menu item classes for more information.</p> <pre data-language="python">from wagtail import hooks

class UserbarPuppyLinkItem:
    def render(self, request):
        return '&lt;li&gt;&lt;a href="http://cuteoverload.com/tag/puppehs/" ' \
            + 'target="_parent" role="menuitem" class="action icon icon-wagtail"&gt;Puppies!&lt;/a&gt;&lt;/li&gt;'

@hooks.register('construct_wagtail_userbar')
def add_puppy_link_item(request, items):
    return items.append( UserbarPuppyLinkItem() )
</pre> </section> </section> <section id="admin-workflow"> <h2>Admin workflow</h2> <p>Hooks for customising the way admins are directed through the process of editing users.</p> <section id="after-create-user"> <h3 id="id45"><code>after_create_user</code></h3> <p>Do something with a <code>User</code> object after it has been saved to the database. The callable passed to this hook should take a <code>request</code> object and a <code>user</code> object. The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object. By default, Wagtail will instead redirect to the User index page.</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

@hooks.register('after_create_user')
def do_after_create_user(request, user):
    return HttpResponse("Congrats on creating a new user!", content_type="text/plain")
</pre> </section> <section id="before-create-user"> <h3 id="id46"><code>before_create_user</code></h3> <p>Called at the beginning of the “create user” view passing in the request.</p> <p>The function does not have to return anything, but if an object with a <code>status_code</code> property is returned, Wagtail will use it as a response object and skip the rest of the view.</p> <p>Unlike, <code>after_create_user</code>, this is run both for both <code>GET</code> and <code>POST</code> requests.</p> <p>This can be used to completely override the user editor on a per-view basis:</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

from .models import AwesomePage
from .admin_views import edit_awesome_page

@hooks.register('before_create_user')
def do_before_create_user(request):
    return HttpResponse("A user creation form", content_type="text/plain")
</pre> </section> <section id="after-delete-user"> <h3 id="id47"><code>after_delete_user</code></h3> <p>Do something after a <code>User</code> object is deleted. Uses the same behaviour as <code>after_create_user</code>.</p> </section> <section id="before-delete-user"> <h3 id="id48"><code>before_delete_user</code></h3> <p>Called at the beginning of the “delete user” view passing in the request and the user object.</p> <p>Uses the same behaviour as <code>before_create_user</code>.</p> </section> <section id="after-edit-user"> <h3 id="id49"><code>after_edit_user</code></h3> <p>Do something with a <code>User</code> object after it has been updated. Uses the same behaviour as <code>after_create_user</code>.</p> </section> <section id="before-edit-user"> <h3 id="id50"><code>before_edit_user</code></h3> <p>Called at the beginning of the “edit user” view passing in the request and the user object.</p> <p>Uses the same behaviour as <code>before_create_user</code>.</p> </section> </section> <section id="choosers"> <h2>Choosers</h2> <section id="construct-page-chooser-queryset"> <h3 id="id51"><code>construct_page_chooser_queryset</code></h3> <p>Called when rendering the page chooser view, to allow the page listing QuerySet to be customised. The callable passed into the hook will receive the current page QuerySet and the request object, and must return a Page QuerySet (either the original one, or a new one).</p> <pre data-language="python">from wagtail import hooks

@hooks.register('construct_page_chooser_queryset')
def show_my_pages_only(pages, request):
    # Only show own pages
    pages = pages.filter(owner=request.user)

    return pages
</pre> </section> <section id="construct-document-chooser-queryset"> <h3 id="id52"><code>construct_document_chooser_queryset</code></h3> <p>Called when rendering the document chooser view, to allow the document listing QuerySet to be customised. The callable passed into the hook will receive the current document QuerySet and the request object, and must return a Document QuerySet (either the original one, or a new one).</p> <pre data-language="python">from wagtail import hooks

@hooks.register('construct_document_chooser_queryset')
def show_my_uploaded_documents_only(documents, request):
    # Only show uploaded documents
    documents = documents.filter(uploaded_by_user=request.user)

    return documents
</pre> </section> <section id="construct-image-chooser-queryset"> <h3 id="id53"><code>construct_image_chooser_queryset</code></h3> <p>Called when rendering the image chooser view, to allow the image listing QuerySet to be customised. The callable passed into the hook will receive the current image QuerySet and the request object, and must return an Image QuerySet (either the original one, or a new one).</p> <pre data-language="python">from wagtail import hooks

@hooks.register('construct_image_chooser_queryset')
def show_my_uploaded_images_only(images, request):
    # Only show uploaded images
    images = images.filter(uploaded_by_user=request.user)

    return images
</pre> </section> </section> <section id="page-explorer"> <h2>Page explorer</h2> <section id="construct-explorer-page-queryset"> <h3 id="id54"><code>construct_explorer_page_queryset</code></h3> <p>Called when rendering the page explorer view, to allow the page listing QuerySet to be customised. The callable passed into the hook will receive the parent page object, the current page QuerySet, and the request object, and must return a Page QuerySet (either the original one, or a new one).</p> <pre data-language="python">from wagtail import hooks

@hooks.register('construct_explorer_page_queryset')
def show_my_profile_only(parent_page, pages, request):
    # If we're in the 'user-profiles' section, only show the user's own profile
    if parent_page.slug == 'user-profiles':
        pages = pages.filter(owner=request.user)

    return pages
</pre> </section> <section id="register-page-listing-buttons"> <h3 id="id55"><code>register_page_listing_buttons</code></h3> <p>Add buttons to the actions list for a page in the page explorer. This is useful when adding custom actions to the listing, such as translations or a complex workflow.</p> <p>This example will add a simple button to the listing:</p> <pre data-language="python">from wagtail.admin import widgets as wagtailadmin_widgets

@hooks.register('register_page_listing_buttons')
def page_listing_buttons(page, page_perms, next_url=None):
    yield wagtailadmin_widgets.PageListingButton(
        'A page listing button',
        '/goes/to/a/url/',
        priority=10
    )
</pre> <p>The arguments passed to the hook are as follows:</p> <ul class="simple"> <li>
<code>page</code> - the page object to generate the button for</li> <li>
<code>page_perms</code> - a <code>PagePermissionTester</code> object that can be queried to determine the current user’s permissions on the given page</li> <li>
<code>next_url</code> - the URL that the linked action should redirect back to on completion of the action, if the view supports it</li> </ul> <p>The <code>priority</code> argument controls the order the buttons are displayed in. Buttons are ordered from low to high priority, so a button with <code>priority=10</code> will be displayed before a button with <code>priority=20</code>.</p> </section> <section id="register-page-listing-more-buttons"> <h3 id="id56"><code>register_page_listing_more_buttons</code></h3> <p>Add buttons to the “More” dropdown menu for a page in the page explorer. This works similarly to the <code>register_page_listing_buttons</code> hook but is useful for lesser-used custom actions that are better suited for the dropdown.</p> <p>This example will add a simple button to the dropdown menu:</p> <pre data-language="python">from wagtail.admin import widgets as wagtailadmin_widgets

@hooks.register('register_page_listing_more_buttons')
def page_listing_more_buttons(page, page_perms, next_url=None):
    yield wagtailadmin_widgets.Button(
        'A dropdown button',
        '/goes/to/a/url/',
        priority=60
    )
</pre> <p>The arguments passed to the hook are as follows:</p> <ul class="simple"> <li>
<code>page</code> - the page object to generate the button for</li> <li>
<code>page_perms</code> - a <code>PagePermissionTester</code> object that can be queried to determine the current user’s permissions on the given page</li> <li>
<code>next_url</code> - the URL that the linked action should redirect back to on completion of the action, if the view supports it</li> </ul> <p>The <code>priority</code> argument controls the order the buttons are displayed in the dropdown. Buttons are ordered from low to high priority, so a button with <code>priority=10</code> will be displayed before a button with <code>priority=60</code>.</p> <section id="buttons-with-dropdown-lists"> <h4>Buttons with dropdown lists</h4> <p>The admin widgets also provide <code>ButtonWithDropdownFromHook</code>, which allows you to define a custom hook for generating a dropdown menu that gets attached to your button.</p> <p>Creating a button with a dropdown menu involves two steps. Firstly, you add your button to the <code>register_page_listing_buttons</code> hook, just like the example above. Secondly, you register a new hook that yields the contents of the dropdown menu.</p> <p>This example shows how Wagtail’s default admin dropdown is implemented. You can also see how to register buttons conditionally, in this case by evaluating the <code>page_perms</code>:</p> <pre data-language="python">from wagtail.admin import widgets as wagtailadmin_widgets

@hooks.register('register_page_listing_buttons')
def page_custom_listing_buttons(page, page_perms, next_url=None):
    yield wagtailadmin_widgets.ButtonWithDropdownFromHook(
        'More actions',
        hook_name='my_button_dropdown_hook',
        page=page,
        page_perms=page_perms,
        next_url=next_url,
        priority=50
    )

@hooks.register('my_button_dropdown_hook')
def page_custom_listing_more_buttons(page, page_perms, next_url=None):
    if page_perms.can_move():
        yield wagtailadmin_widgets.Button('Move', reverse('wagtailadmin_pages:move', args=[page.id]), priority=10)
    if page_perms.can_delete():
        yield wagtailadmin_widgets.Button('Delete', reverse('wagtailadmin_pages:delete', args=[page.id]), priority=30)
    if page_perms.can_unpublish():
        yield wagtailadmin_widgets.Button('Unpublish', reverse('wagtailadmin_pages:unpublish', args=[page.id]), priority=40)
</pre> <p>The template for the dropdown button can be customised by overriding <code>wagtailadmin/pages/listing/_button_with_dropdown.html</code>. The JavaScript that runs the dropdowns makes use of custom data attributes, so you should leave <code>data-dropdown</code> and <code>data-dropdown-toggle</code> in the markup if you customise it.</p> </section> </section> </section> <section id="page-serving"> <h2>Page serving</h2> <section id="before-serve-page"> <h3 id="id57"><code>before_serve_page</code></h3> <p>Called when Wagtail is about to serve a page. The callable passed into the hook will receive the page object, the request object, and the <code>args</code> and <code>kwargs</code> that will be passed to the page’s <code>serve()</code> method. If the callable returns an <code>HttpResponse</code>, that response will be returned immediately to the user, and Wagtail will not proceed to call <code>serve()</code> on the page.</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

@hooks.register('before_serve_page')
def block_googlebot(page, request, serve_args, serve_kwargs):
    if request.META.get('HTTP_USER_AGENT') == 'GoogleBot':
        return HttpResponse("&lt;h1&gt;bad googlebot no cookie&lt;/h1&gt;")
</pre> </section> </section> <section id="document-serving"> <h2>Document serving</h2> <section id="before-serve-document"> <h3 id="id58"><code>before_serve_document</code></h3> <p>Called when Wagtail is about to serve a document. The callable passed into the hook will receive the document object and the request object. If the callable returns an <code>HttpResponse</code>, that response will be returned immediately to the user, instead of serving the document. Note that this hook will be skipped if the <a class="reference internal" href="settings#wagtaildocs-serve-method"><span class="std std-ref"><code>WAGTAILDOCS_SERVE_METHOD</code></span></a> setting is set to <code>direct</code>.</p> </section> </section> <section id="snippets"> <h2>Snippets</h2> <p>Hooks for working with registered Snippets.</p> <section id="after-edit-snippet"> <h3 id="id59"><code>after_edit_snippet</code></h3> <p>Called when a Snippet is edited. The callable passed into the hook will receive the model instance, the request object. If the callable returns an <code>HttpResponse</code>, that response will be returned immediately to the user, and Wagtail will not proceed to call <code>redirect()</code> to the listing view.</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

@hooks.register('after_edit_snippet')
def after_snippet_update(request, instance):
    return HttpResponse(f"Congrats on editing a snippet with id {instance.pk}", content_type="text/plain")
</pre> </section> <section id="before-edit-snippet"> <h3 id="id60"><code>before_edit_snippet</code></h3> <p>Called at the beginning of the edit snippet view. The callable passed into the hook will receive the model instance, the request object. If the callable returns an <code>HttpResponse</code>, that response will be returned immediately to the user, and Wagtail will not proceed to call <code>redirect()</code> to the listing view.</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

@hooks.register('before_edit_snippet')
def block_snippet_edit(request, instance):
    if isinstance(instance, RestrictedSnippet) and instance.prevent_edit:
        return HttpResponse("Sorry, you can't edit this snippet", content_type="text/plain")
</pre> </section> <section id="after-create-snippet"> <h3 id="id61"><code>after_create_snippet</code></h3> <p>Called when a Snippet is created. <code>after_create_snippet</code> and <code>after_edit_snippet</code> work in identical ways. The only difference is where the hook is called.</p> </section> <section id="before-create-snippet"> <h3 id="id62"><code>before_create_snippet</code></h3> <p>Called at the beginning of the create snippet view. Works in a similar way to <code>before_edit_snippet</code> except the model is passed as an argument instead of an instance.</p> </section> <section id="after-delete-snippet"> <h3 id="id63"><code>after_delete_snippet</code></h3> <p>Called when a Snippet is deleted. The callable passed into the hook will receive the model instance(s) as a queryset along with the request object. If the callable returns an <code>HttpResponse</code>, that response will be returned immediately to the user, and Wagtail will not proceed to call <code>redirect()</code> to the listing view.</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

@hooks.register('after_delete_snippet')
def after_snippet_delete(request, instances):
    # "instances" is a QuerySet
    total = len(instances)
    return HttpResponse(f"{total} snippets have been deleted", content_type="text/plain")
</pre> </section> <section id="before-delete-snippet"> <h3 id="id64"><code>before_delete_snippet</code></h3> <p>Called at the beginning of the delete snippet view. The callable passed into the hook will receive the model instance(s) as a queryset along with the request object. If the callable returns an <code>HttpResponse</code>, that response will be returned immediately to the user, and Wagtail will not proceed to call <code>redirect()</code> to the listing view.</p> <pre data-language="python">from django.http import HttpResponse

from wagtail import hooks

@hooks.register('before_delete_snippet')
def before_snippet_delete(request, instances):
    # "instances" is a QuerySet
    total = len(instances)

    if request.method == 'POST':
      # Override the deletion behaviour
      instances.delete()

      return HttpResponse(f"{total} snippets have been deleted", content_type="text/plain")
</pre> </section> <section id="register-snippet-action-menu-item"> <h3 id="id65"><code>register_snippet_action_menu_item</code></h3> <p>Add an item to the popup menu of actions on the snippet creation and edit views. The callable passed to this hook must return an instance of <code>wagtail.snippets.action_menu.ActionMenuItem</code>. <code>ActionMenuItem</code> is a subclass of <a class="reference internal" href="../extending/template_components#creating-template-components"><span class="std std-ref">Component</span></a> and so the rendering of the menu item can be customised through <code>template_name</code>, <code>get_context_data</code>, <code>render_html</code> and <code>Media</code>. In addition, the following attributes and methods are available to be overridden:</p> <ul class="simple"> <li>
<code>order</code>- an integer (default 100) which determines the item’s position in the menu. Can also be passed as a keyword argument to the object constructor. The lowest-numbered item in this sequence will be selected as the default menu item; as standard, this is “Save draft” (which has an<code>order</code> of 0).</li> <li>
<code>label</code> - the displayed text of the menu item</li> <li>
<code>get_url</code> - a method which returns a URL for the menu item to link to; by default, returns <code>None</code> which causes the menu item to behave as a form submit button instead</li> <li>
<code>name</code> - value of the <code>name</code> attribute of the submit button if no URL is specified</li> <li>
<code>icon_name</code> - icon to display against the menu item</li> <li>
<code>classname</code> - a <code>class</code> attribute value to add to the button element</li> <li>
<code>is_shown</code> - a method which returns a boolean indicating whether the menu item should be shown; by default, true except when editing a locked page</li> </ul> <p>The <code>get_url</code>, <code>is_shown</code>, <code>get_context_data</code> and <code>render_html</code> methods all accept a context dictionary containing the following fields:</p> <ul class="simple"> <li>
<code>view</code> - name of the current view: <code>'create'</code> or <code>'edit'</code>
</li> <li>
<code>model</code> - the snippet’s model class</li> <li>
<code>instance</code> - for <code>view</code> = <code>'edit'</code>, the instance being edited</li> <li>
<code>request</code> - the current request object</li> </ul> <pre data-language="python">from wagtail import hooks
from wagtail.snippets.action_menu import ActionMenuItem

class GuacamoleMenuItem(ActionMenuItem):
    name = 'action-guacamole'
    label = "Guacamole"

    def get_url(self, context):
        return "https://www.youtube.com/watch?v=dNJdJIwCF_Y"


@hooks.register('register_snippet_action_menu_item')
def register_guacamole_menu_item():
    return GuacamoleMenuItem(order=10)
</pre> </section> <section id="construct-snippet-action-menu"> <h3 id="id66"><code>construct_snippet_action_menu</code></h3> <p>Modify the final list of action menu items on the snippet creation and edit views. The callable passed to this hook receives a list of <code>ActionMenuItem</code> objects, a request object and a context dictionary as per <code>register_snippet_action_menu_item</code>, and should modify the list of menu items in-place.</p> <pre data-language="python">@hooks.register('construct_snippet_action_menu')
def remove_delete_option(menu_items, request, context):
    menu_items[:] = [item for item in menu_items if item.name != 'delete']
</pre> <p>The <code>construct_snippet_action_menu</code> hook is called after the menu items have been sorted by their order attributes, and so setting a menu item’s order will have no effect at this point. Instead, items can be reordered by changing their position in the list, with the first item being selected as the default action. For example, to change the default action to Delete:</p> <pre data-language="python">@hooks.register('construct_snippet_action_menu')
def make_delete_default_action(menu_items, request, context):
    for (index, item) in enumerate(menu_items):
        if item.name == 'delete':
            # move to top of list
            menu_items.pop(index)
            menu_items.insert(0, item)
            break
</pre> </section> <section id="register-snippet-listing-buttons"> <h3 id="id67"><code>register_snippet_listing_buttons</code></h3> <p>Add buttons to the actions list for a snippet in the snippets listing. This is useful when adding custom actions to the listing, such as translations or a complex workflow.</p> <p>This example will add a simple button to the listing:</p> <pre data-language="python">from wagtail.snippets import widgets as wagtailsnippets_widgets

@hooks.register('register_snippet_listing_buttons')
def snippet_listing_buttons(snippet, user, next_url=None):
    yield wagtailsnippets_widgets.SnippetListingButton(
        'A page listing button',
        '/goes/to/a/url/',
        priority=10
    )
</pre> <p>The arguments passed to the hook are as follows:</p> <ul class="simple"> <li>
<code>snippet</code> - the snippet object to generate the button for</li> <li>
<code>user</code> - the user who is viewing the snippets listing</li> <li>
<code>next_url</code> - the URL that the linked action should redirect back to on completion of the action, if the view supports it</li> </ul> <p>The <code>priority</code> argument controls the order the buttons are displayed in. Buttons are ordered from low to high priority, so a button with <code>priority=10</code> will be displayed before a button with <code>priority=20</code>.</p> </section> <section id="construct-snippet-listing-buttons"> <h3 id="id68"><code>construct_snippet_listing_buttons</code></h3> <p>Modify the final list of snippet listing buttons. The callable passed to this hook receives a list of <code>SnippetListingButton</code> objects, a user, and a context dictionary as per <code>register_snippet_listing_buttons</code>, and should modify the list of menu items in-place.</p> <pre data-language="python">@hooks.register('construct_snippet_listing_buttons')
def remove_snippet_listing_button_item(buttons, snippet, user, context=None):
    buttons.pop()  # Removes the 'delete' button
</pre> </section> </section> <section id="bulk-actions"> <h2>Bulk actions</h2> <p>Hooks for registering and customising bulk actions. See <a class="reference internal" href="../extending/custom_bulk_actions#custom-bulk-actions"><span class="std std-ref">Adding custom bulk actions</span></a> on how to write custom bulk actions.</p> <section id="register-bulk-action"> <h3 id="id69"><code>register_bulk_action</code></h3> <p>Registers a new bulk action to add to the list of bulk actions in the explorer</p> <p>This hook must be registered with a sub-class of <code>BulkAction</code> . For example:</p> <pre data-language="python">from wagtail.admin.views.bulk_action import BulkAction
from wagtail import hooks


@hooks.register("register_bulk_action")
class CustomBulkAction(BulkAction):
    display_name = _("Custom Action")
    action_type = "action"
    aria_label = _("Do custom action")
    template_name = "/path/to/template"
    models = [...]  # list of models the action should execute upon


    @classmethod
    def execute_action(cls, objects, **kwargs):
        for object in objects:
            do_something(object)
        return num_parent_objects, num_child_objects  # return the count of updated objects
</pre> </section> <section id="before-bulk-action"> <h3 id="id70"><code>before_bulk_action</code></h3> <p>Do something right before a bulk action is executed (before the <code>execute_action</code> method is called)</p> <p>This hook can be used to return an HTTP response. For example:</p> <pre data-language="python">from wagtail import hooks

@hooks.register("before_bulk_action")
def hook_func(request, action_type, objects, action_class_instance):
  if action_type == 'delete':
    return HttpResponse(f"{len(objects)} objects would be deleted", content_type="text/plain")
</pre> </section> <section id="after-bulk-action"> <h3 id="id71"><code>after_bulk_action</code></h3> <p>Do something right after a bulk action is executed (after the <code>execute_action</code> method is called)</p> <p>This hook can be used to return an HTTP response. For example:</p> <pre data-language="python">from wagtail import hooks

@hooks.register("after_bulk_action")
def hook_func(request, action_type, objects, action_class_instance):
  if action_type == 'delete':
    return HttpResponse(f"{len(objects)} objects have been deleted", content_type="text/plain")
</pre> </section> </section> <section id="audit-log"> <h2>Audit log</h2> <section id="register-log-actions"> <h3 id="id72"><code>register_log_actions</code></h3> <p>See <a class="reference internal" href="../extending/audit_log#audit-log"><span class="std std-ref">Audit log</span></a></p> <p>To add new actions to the registry, call the <code>register_action</code> method with the action type, its label and the message to be displayed in administrative listings.</p> <pre data-language="python">from django.utils.translation import gettext_lazy as _

from wagtail import hooks

@hooks.register('register_log_actions')
def additional_log_actions(actions):
    actions.register_action('wagtail_package.echo', _('Echo'), _('Sent an echo'))
</pre> <p>Alternatively, for a log message that varies according to the log entry’s data, create a subclass of <code>wagtail.log_actions.LogFormatter</code> that overrides the <code>format_message</code> method, and use <code>register_action</code> as a decorator on that class:</p> <pre data-language="python">from django.utils.translation import gettext_lazy as _

from wagtail import hooks
from wagtail.log_actions import LogFormatter

@hooks.register('register_log_actions')
def additional_log_actions(actions):
    @actions.register_action('wagtail_package.greet_audience')
    class GreetingActionFormatter(LogFormatter):
        label = _('Greet audience')

        def format_message(self, log_entry):
            return _('Hello %(audience)s') % {
                'audience': log_entry.data['audience'],
            }
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.15: </span>The <code>LogFormatter</code> class was introduced. Previously, dynamic messages were achieved by passing a callable as the <code>message</code> argument to <code>register_action</code>.</p> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2014-present Torchbox Ltd and individual contributors.<br>All rights are reserved.<br>Licensed under the BSD License.<br>
    <a href="https://docs.wagtail.org/en/stable/reference/hooks.html" class="_attribution-link">https://docs.wagtail.org/en/stable/reference/hooks.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
