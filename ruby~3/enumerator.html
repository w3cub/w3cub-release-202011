
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Enumerator - Ruby 3 - W3cubDocs</title>
  
  <meta name="description" content=" A class which allows both internal and external iteration. ">
  <meta name="keywords" content="class, enumerator, ruby, ruby~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~3/enumerator.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/ruby~3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~3/" class="_nav-link" title="" style="margin-left:0;">Ruby 3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Enumerator" class="class"> class Enumerator </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable">Enumerable</a></dd>
</dl> <section class="description"> <p>A class which allows both internal and external iteration.</p> <p>An <a href="enumerator"><code>Enumerator</code></a> can be created by the following methods.</p> <ul>
<li> <p><a href="object#method-i-to_enum"><code>Object#to_enum</code></a></p> </li>
<li> <p><a href="object#method-i-enum_for"><code>Object#enum_for</code></a></p> </li>
<li> <p><a href="enumerator#method-c-new"><code>Enumerator.new</code></a></p> </li>
</ul> <p>Most methods have two forms: a block form where the contents are evaluated for each item in the enumeration, and a non-block form which returns a new <a href="enumerator"><code>Enumerator</code></a> wrapping the iteration.</p> <pre class="ruby" data-language="ruby">enumerator = %w(one two three).each
puts enumerator.class # =&gt; Enumerator

enumerator.each_with_object("foo") do |item, obj|
  puts "#{obj}: #{item}"
end

# foo: one
# foo: two
# foo: three

enum_with_obj = enumerator.each_with_object("foo")
puts enum_with_obj.class # =&gt; Enumerator

enum_with_obj.each do |item, obj|
  puts "#{obj}: #{item}"
end

# foo: one
# foo: two
# foo: three
</pre> <p>This allows you to chain Enumerators together. For example, you can map a list's elements to strings containing the index and the element as a string via:</p> <pre class="ruby" data-language="ruby">puts %w[foo bar baz].map.with_index { |w, i| "#{i}:#{w}" }
# =&gt; ["0:foo", "1:bar", "2:baz"]
</pre> <p>An <a href="enumerator"><code>Enumerator</code></a> can also be used as an external iterator. For example, <a href="enumerator#method-i-next"><code>Enumerator#next</code></a> returns the next value of the iterator or raises <a href="stopiteration"><code>StopIteration</code></a> if the <a href="enumerator"><code>Enumerator</code></a> is at the end.</p> <pre class="ruby" data-language="ruby">e = [1,2,3].each   # returns an enumerator object.
puts e.next   # =&gt; 1
puts e.next   # =&gt; 2
puts e.next   # =&gt; 3
puts e.next   # raises StopIteration
</pre> <p>Note that enumeration sequence by <code>next</code>, <code>next_values</code>, <code>peek</code> and <code>peek_values</code> do not affect other non-external enumeration methods, unless the underlying iteration method itself has side-effect, e.g. <a href="io#method-i-each_line"><code>IO#each_line</code></a>.</p> <p>Moreover, implementation typically uses fibers so performance could be slower and exception stacktraces different than expected.</p> <p>You can use this to implement an internal iterator as follows:</p> <pre class="ruby" data-language="ruby">def ext_each(e)
  while true
    begin
      vs = e.next_values
    rescue StopIteration
      return $!.result
    end
    y = yield(*vs)
    e.feed y
  end
end

o = Object.new

def o.each
  puts yield
  puts yield(1)
  puts yield(1, 2)
  3
end

# use o.each as an internal iterator directly.
puts o.each {|*x| puts x; [:b, *x] }
# =&gt; [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3

# convert o.each to an external iterator for
# implementing an internal iterator.
puts ext_each(o.to_enum) {|*x| puts x; [:b, *x] }
# =&gt; [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(size = nil) { |yielder| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
enumerator_initialize(int argc, VALUE *argv, VALUE obj)
{
    VALUE iter = rb_block_proc();
    VALUE recv = generator_init(generator_allocate(rb_cGenerator), iter);
    VALUE arg0 = rb_check_arity(argc, 0, 1) ? argv[0] : Qnil;
    VALUE size = convert_to_feasible_size_value(arg0);

    return enumerator_init(obj, recv, sym_each, 0, 0, 0, size, false);
}</pre> </div> <p>Creates a new <a href="enumerator"><code>Enumerator</code></a> object, which can be used as an <a href="enumerable"><code>Enumerable</code></a>.</p> <p>Iteration is defined by the given block, in which a “yielder” object, given as block parameter, can be used to yield a value by calling the <code>yield</code> method (aliased as <code>&lt;&lt;</code>):</p> <pre class="ruby" data-language="ruby">fib = Enumerator.new do |y|
  a = b = 1
  loop do
    y &lt;&lt; a
    a, b = b, a + b
  end
end

fib.take(10) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</pre> <p>The optional parameter can be used to specify how to calculate the size in a lazy fashion (see <a href="enumerator#method-i-size"><code>Enumerator#size</code></a>). It can either be a value or a callable object.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-produce"> <span class="method-callseq"> produce(initial = nil) { |prev| block } → enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="produce-source"> <pre class="c" data-language="c">static VALUE
enumerator_s_produce(int argc, VALUE *argv, VALUE klass)
{
    VALUE init, producer;

    if (!rb_block_given_p()) rb_raise(rb_eArgError, "no block given");

    if (rb_scan_args(argc, argv, "01", &amp;init) == 0) {
        init = Qundef;
    }

    producer = producer_init(producer_allocate(rb_cEnumProducer), init, rb_block_proc());

    return rb_enumeratorize_with_size_kw(producer, sym_each, 0, 0, producer_size, RB_NO_KEYWORDS);
}</pre> </div> <p>Creates an infinite enumerator from any block, just called over and over. The result of the previous iteration is passed to the next one. If <code>initial</code> is provided, it is passed to the first iteration, and becomes the first element of the enumerator; if it is not provided, the first iteration receives <code>nil</code>, and its result becomes the first element of the iterator.</p> <p>Raising <a href="stopiteration"><code>StopIteration</code></a> from the block stops an iteration.</p> <pre class="ruby" data-language="ruby">Enumerator.produce(1, &amp;:succ)   # =&gt; enumerator of 1, 2, 3, 4, ....

Enumerator.produce { rand(10) } # =&gt; infinite random number sequence

ancestors = Enumerator.produce(node) { |prev| node = prev.parent or raise StopIteration }
enclosing_section = ancestors.find { |n| n.type == :section }
</pre> <p>Using <a href="enumerator#method-c-produce"><code>::produce</code></a> together with <a href="enumerable"><code>Enumerable</code></a> methods like <a href="enumerable#method-i-detect"><code>Enumerable#detect</code></a>, <a href="enumerable#method-i-slice_after"><code>Enumerable#slice_after</code></a>, <a href="enumerable#method-i-take_while"><code>Enumerable#take_while</code></a> can provide Enumerator-based alternatives for <code>while</code> and <code>until</code> cycles:</p> <pre class="ruby" data-language="ruby"># Find next Tuesday
require "date"
Enumerator.produce(Date.today, &amp;:succ).detect(&amp;:tuesday?)

# Simple lexer:
require "strscan"
scanner = StringScanner.new("7+38/6")
PATTERN = %r{\d+|[-/+*]}
Enumerator.produce { scanner.scan(PATTERN) }.slice_after { scanner.eos? }.first
# =&gt; ["7", "+", "38", "/", "6"]
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-2B"> <span class="method-callseq"> e + enum → enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">static VALUE
enumerator_plus(VALUE obj, VALUE eobj)
{
    VALUE enums = rb_ary_new_from_args(2, obj, eobj);

    return enum_chain_initialize(enum_chain_allocate(rb_cEnumChain), enums);
}</pre> </div> <p>Returns an enumerator object generated from this enumerator and a given enumerable.</p> <pre class="ruby" data-language="ruby">e = (1..3).each + [4, 5]
e.to_a #=&gt; [1, 2, 3, 4, 5]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each { |elm| block } → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each → enum </span> </div> <div class="method-heading"> <span class="method-callseq"> each(*appending_args) { |elm| block } → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> each(*appending_args) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
enumerator_each(int argc, VALUE *argv, VALUE obj)
{
    if (argc &gt; 0) {
        struct enumerator *e = enumerator_ptr(obj = rb_obj_dup(obj));
        VALUE args = e-&gt;args;
        if (args) {
#if SIZEOF_INT &lt; SIZEOF_LONG
            /* check int range overflow */
            rb_long2int(RARRAY_LEN(args) + argc);
#endif
            args = rb_ary_dup(args);
            rb_ary_cat(args, argv, argc);
        }
        else {
            args = rb_ary_new4(argc, argv);
        }
        e-&gt;args = args;
        e-&gt;size = Qnil;
        e-&gt;size_fn = 0;
    }
    if (!rb_block_given_p()) return obj;
    return enumerator_block_call(obj, 0, obj);
}</pre> </div> <p>Iterates over the block according to how this <a href="enumerator"><code>Enumerator</code></a> was constructed. If no block and no arguments are given, returns self.</p> <h3 id="method-i-each-label-Examples">Examples</h3> <pre class="ruby" data-language="ruby">"Hello, world!".scan(/\w+/)                     #=&gt; ["Hello", "world"]
"Hello, world!".to_enum(:scan, /\w+/).to_a      #=&gt; ["Hello", "world"]
"Hello, world!".to_enum(:scan).each(/\w+/).to_a #=&gt; ["Hello", "world"]

obj = Object.new

def obj.each_arg(a, b=:b, *rest)
  yield a
  yield b
  yield rest
  :method_returned
end

enum = obj.to_enum :each_arg, :a, :x

enum.each.to_a                  #=&gt; [:a, :x, []]
enum.each.equal?(enum)          #=&gt; true
enum.each { |elm| elm }         #=&gt; :method_returned

enum.each(:y, :z).to_a          #=&gt; [:a, :x, [:y, :z]]
enum.each(:y, :z).equal?(enum)  #=&gt; false
enum.each(:y, :z) { |elm| elm } #=&gt; :method_returned
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_with_index"> <span class="method-callseq"> each_with_index {|(*args), idx| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_with_index </span> </div> <div class="method-description">
<div class="method-source-code" id="each_with_index-source"> <pre class="c" data-language="c">static VALUE
enumerator_each_with_index(VALUE obj)
{
    return enumerator_with_index(0, NULL, obj);
}</pre> </div> <p>Same as <a href="enumerator#method-i-with_index"><code>Enumerator#with_index(0)</code></a>, i.e. there is no starting offset.</p> <p>If no block is given, a new <a href="enumerator"><code>Enumerator</code></a> is returned that includes the index.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_with_object"> <span class="method-callseq"> each_with_object(obj) {|(*args), obj| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_with_object(obj) </span> </div> <div class="method-description">
<div class="method-source-code" id="each_with_object-source"> <pre class="c" data-language="c">static VALUE
enumerator_with_object(VALUE obj, VALUE memo)
{
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;memo, enumerator_enum_size);
    enumerator_block_call(obj, enumerator_with_object_i, memo);

    return memo;
}</pre> </div> <p>Iterates the given block for each element with an arbitrary object, <code>obj</code>, and returns <code>obj</code></p> <p>If no block is given, returns a new <a href="enumerator"><code>Enumerator</code></a>.</p> <h3 id="method-i-each_with_object-label-Example">Example</h3> <pre class="ruby" data-language="ruby">to_three = Enumerator.new do |y|
  3.times do |x|
    y &lt;&lt; x
  end
end

to_three_with_string = to_three.with_object("foo")
to_three_with_string.each do |x,string|
  puts "#{string}: #{x}"
end

# =&gt; foo: 0
# =&gt; foo: 1
# =&gt; foo: 2
</pre>  </div> <div class="aliases"> Also aliased as: <a href="enumerator#method-i-with_object">with_object</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-feed"> <span class="method-callseq"> feed obj → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="feed-source"> <pre class="c" data-language="c">static VALUE
enumerator_feed(VALUE obj, VALUE v)
{
    struct enumerator *e = enumerator_ptr(obj);

    if (e-&gt;feedvalue != Qundef) {
        rb_raise(rb_eTypeError, "feed value already set");
    }
    e-&gt;feedvalue = v;

    return Qnil;
}</pre> </div> <p>Sets the value to be returned by the next yield inside <code>e</code>.</p> <p>If the value is not set, the yield returns nil.</p> <p>This value is cleared after being yielded.</p> <pre class="ruby" data-language="ruby"># Array#map passes the array's elements to "yield" and collects the
# results of "yield" as an array.
# Following example shows that "next" returns the passed elements and
# values passed to "feed" are collected as an array which can be
# obtained by StopIteration#result.
e = [1,2,3].map
p e.next           #=&gt; 1
e.feed "a"
p e.next           #=&gt; 2
e.feed "b"
p e.next           #=&gt; 3
e.feed "c"
begin
  e.next
rescue StopIteration
  p $!.result      #=&gt; ["a", "b", "c"]
end

o = Object.new
def o.each
  x = yield         # (2) blocks
  p x               # (5) =&gt; "foo"
  x = yield         # (6) blocks
  p x               # (8) =&gt; nil
  x = yield         # (9) blocks
  p x               # not reached w/o another e.next
end

e = o.to_enum
e.next              # (1)
e.feed "foo"        # (3)
e.next              # (4)
e.next              # (7)
                    # (10)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
enumerator_inspect(VALUE obj)
{
    return rb_exec_recursive(inspect_enumerator, obj, 0);
}</pre> </div> <p>Creates a printable version of <em>e</em>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next"> <span class="method-callseq"> next → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="next-source"> <pre class="c" data-language="c">static VALUE
enumerator_next(VALUE obj)
{
    VALUE vs = enumerator_next_values(obj);
    return ary2sv(vs, 0);
}</pre> </div> <p>Returns the next object in the enumerator, and move the internal position forward. When the position reached at the end, <a href="stopiteration"><code>StopIteration</code></a> is raised.</p> <h3 id="method-i-next-label-Example">Example</h3> <pre class="ruby" data-language="ruby">a = [1,2,3]
e = a.to_enum
p e.next   #=&gt; 1
p e.next   #=&gt; 2
p e.next   #=&gt; 3
p e.next   #raises StopIteration
</pre> <p>See class-level notes about external iterators.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next_values"> <span class="method-callseq"> next_values → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="next_values-source"> <pre class="c" data-language="c">static VALUE
enumerator_next_values(VALUE obj)
{
    struct enumerator *e = enumerator_ptr(obj);
    VALUE vs;

    if (e-&gt;lookahead != Qundef) {
        vs = e-&gt;lookahead;
        e-&gt;lookahead = Qundef;
        return vs;
    }

    return get_next_values(obj, e);
}</pre> </div> <p>Returns the next object as an array in the enumerator, and move the internal position forward. When the position reached at the end, <a href="stopiteration"><code>StopIteration</code></a> is raised.</p> <p>See class-level notes about external iterators.</p> <p>This method can be used to distinguish <code>yield</code> and <code>yield nil</code>.</p> <h3 id="method-i-next_values-label-Example">Example</h3> <pre class="ruby" data-language="ruby">o = Object.new
def o.each
  yield
  yield 1
  yield 1, 2
  yield nil
  yield [1, 2]
end
e = o.to_enum
p e.next_values
p e.next_values
p e.next_values
p e.next_values
p e.next_values
e = o.to_enum
p e.next
p e.next
p e.next
p e.next
p e.next

## yield args       next_values      next
#  yield            []               nil
#  yield 1          [1]              1
#  yield 1, 2       [1, 2]           [1, 2]
#  yield nil        [nil]            nil
#  yield [1, 2]     [[1, 2]]         [1, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-peek"> <span class="method-callseq"> peek → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="peek-source"> <pre class="c" data-language="c">static VALUE
enumerator_peek(VALUE obj)
{
    VALUE vs = enumerator_peek_values(obj);
    return ary2sv(vs, 1);
}</pre> </div> <p>Returns the next object in the enumerator, but doesn't move the internal position forward. If the position is already at the end, <a href="stopiteration"><code>StopIteration</code></a> is raised.</p> <p>See class-level notes about external iterators.</p> <h3 id="method-i-peek-label-Example">Example</h3> <pre class="ruby" data-language="ruby">a = [1,2,3]
e = a.to_enum
p e.next   #=&gt; 1
p e.peek   #=&gt; 2
p e.peek   #=&gt; 2
p e.peek   #=&gt; 2
p e.next   #=&gt; 2
p e.next   #=&gt; 3
p e.peek   #raises StopIteration
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-peek_values"> <span class="method-callseq"> peek_values → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="peek_values-source"> <pre class="c" data-language="c">static VALUE
enumerator_peek_values_m(VALUE obj)
{
    return rb_ary_dup(enumerator_peek_values(obj));
}</pre> </div> <p>Returns the next object as an array, similar to <a href="enumerator#method-i-next_values"><code>Enumerator#next_values</code></a>, but doesn't move the internal position forward. If the position is already at the end, <a href="stopiteration"><code>StopIteration</code></a> is raised.</p> <p>See class-level notes about external iterators.</p> <h3 id="method-i-peek_values-label-Example">Example</h3> <pre class="ruby" data-language="ruby">o = Object.new
def o.each
  yield
  yield 1
  yield 1, 2
end
e = o.to_enum
p e.peek_values    #=&gt; []
e.next
p e.peek_values    #=&gt; [1]
p e.peek_values    #=&gt; [1]
e.next
p e.peek_values    #=&gt; [1, 2]
e.next
p e.peek_values    # raises StopIteration
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rewind"> <span class="method-callseq"> rewind → e </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rewind-source"> <pre class="c" data-language="c">static VALUE
enumerator_rewind(VALUE obj)
{
    struct enumerator *e = enumerator_ptr(obj);

    rb_check_funcall(e-&gt;obj, id_rewind, 0, 0);

    e-&gt;fib = 0;
    e-&gt;dst = Qnil;
    e-&gt;lookahead = Qundef;
    e-&gt;feedvalue = Qundef;
    e-&gt;stop_exc = Qfalse;
    return obj;
}</pre> </div> <p>Rewinds the enumeration sequence to the beginning.</p> <p>If the enclosed object responds to a “rewind” method, it is called.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → int, Float::INFINITY or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
enumerator_size(VALUE obj)
{
    struct enumerator *e = enumerator_ptr(obj);
    int argc = 0;
    const VALUE *argv = NULL;
    VALUE size;

    if (e-&gt;procs) {
        struct generator *g = generator_ptr(e-&gt;obj);
        VALUE receiver = rb_check_funcall(g-&gt;obj, id_size, 0, 0);
        long i = 0;

        for (i = 0; i &lt; RARRAY_LEN(e-&gt;procs); i++) {
            VALUE proc = RARRAY_AREF(e-&gt;procs, i);
            struct proc_entry *entry = proc_entry_ptr(proc);
            lazyenum_size_func *size_fn = entry-&gt;fn-&gt;size;
            if (!size_fn) {
                return Qnil;
            }
            receiver = (*size_fn)(proc, receiver);
        }
        return receiver;
    }

    if (e-&gt;size_fn) {
        return (*e-&gt;size_fn)(e-&gt;obj, e-&gt;args, obj);
    }
    if (e-&gt;args) {
        argc = (int)RARRAY_LEN(e-&gt;args);
        argv = RARRAY_CONST_PTR(e-&gt;args);
    }
    size = rb_check_funcall_kw(e-&gt;size, id_call, argc, argv, e-&gt;kw_splat);
    if (size != Qundef) return size;
    return e-&gt;size;
}</pre> </div> <p>Returns the size of the enumerator, or <code>nil</code> if it can't be calculated lazily.</p> <pre class="ruby" data-language="ruby">(1..100).to_a.permutation(4).size # =&gt; 94109400
loop.size # =&gt; Float::INFINITY
(1..100).drop_while.size # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-with_index"> <span class="method-callseq"> with_index(offset = 0) {|(*args), idx| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> with_index(offset = 0) </span> </div> <div class="method-description">
<div class="method-source-code" id="with_index-source"> <pre class="c" data-language="c">static VALUE
enumerator_with_index(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo;

    rb_check_arity(argc, 0, 1);
    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enumerator_enum_size);
    memo = (!argc || NIL_P(memo = argv[0])) ? INT2FIX(0) : rb_to_int(memo);
    return enumerator_block_call(obj, enumerator_with_index_i, (VALUE)MEMO_NEW(memo, 0, 0));
}</pre> </div> <p>Iterates the given block for each element with an index, which starts from <code>offset</code>. If no block is given, returns a new <a href="enumerator"><code>Enumerator</code></a> that includes the index, starting from <code>offset</code></p> <dl class="rdoc-list note-list">
<dt>
<code>offset</code> </dt>
<dd> <p>the starting index to use</p> </dd>
</dl>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-with_object"> <span class="method-callseq"> with_object(obj) {|(*args), obj| ... } </span> </div> <div class="method-heading"> <span class="method-callseq"> with_object(obj) </span> </div> <div class="method-description"> <p>Iterates the given block for each element with an arbitrary object, <code>obj</code>, and returns <code>obj</code></p> <p>If no block is given, returns a new <a href="enumerator"><code>Enumerator</code></a>.</p> <h3 id="method-i-with_object-label-Example">Example</h3> <pre class="ruby" data-language="ruby">to_three = Enumerator.new do |y|
  3.times do |x|
    y &lt;&lt; x
  end
end

to_three_with_string = to_three.with_object("foo")
to_three_with_string.each do |x,string|
  puts "#{string}: #{x}"
end

# =&gt; foo: 0
# =&gt; foo: 1
# =&gt; foo: 2
</pre> </div> <div class="aliases"> Alias for: <a href="enumerator#method-i-each_with_object">each_with_object</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
