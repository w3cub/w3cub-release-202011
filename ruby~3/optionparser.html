
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>OptionParser - Ruby 3 - W3cubDocs</title>
  
  <meta name="description" content="OptionParser is a class for command-line option analysis. It is much more advanced, yet also easier to use, than GetoptLong, and is a more Ruby- &hellip;">
  <meta name="keywords" content="class, optionparser, ruby, ruby~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~3/optionparser.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ruby~3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~3/" class="_nav-link" title="" style="margin-left:0;">Ruby 3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-OptionParser" class="class"> class OptionParser </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
</dl> <section class="description"> <h2 id="class-OptionParser-label-OptionParser"><a href="optionparser"><code>OptionParser</code></a></h2> <h3 id="class-OptionParser-label-Introduction">Introduction</h3> <p><a href="optionparser"><code>OptionParser</code></a> is a class for command-line option analysis. It is much more advanced, yet also easier to use, than <a href="getoptlong"><code>GetoptLong</code></a>, and is a more Ruby-oriented solution.</p> <h3 id="class-OptionParser-label-Features">Features</h3> <ol>
<li> <p>The argument specification and the code to handle it are written in the same place.</p> </li>
<li> <p>It can output an option summary; you don't need to maintain this string separately.</p> </li>
<li> <p>Optional and mandatory arguments are specified very gracefully.</p> </li>
<li> <p>Arguments can be automatically converted to a specified class.</p> </li>
<li> <p>Arguments can be restricted to a certain set.</p> </li>
</ol> <p>All of these features are demonstrated in the examples below. See <a href="optionparser#method-i-make_switch"><code>make_switch</code></a> for full documentation.</p> <h3 id="class-OptionParser-label-Minimal+example">Minimal example</h3> <pre class="ruby" data-language="ruby">require 'optparse'

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: example.rb [options]"

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
end.parse!

p options
p ARGV
</pre> <h3 id="class-OptionParser-label-Generating+Help">Generating Help</h3> <p><a href="optionparser"><code>OptionParser</code></a> can be used to automatically generate help for the commands you write:</p> <pre class="ruby" data-language="ruby">require 'optparse'

Options = Struct.new(:name)

class Parser
  def self.parse(options)
    args = Options.new("world")

    opt_parser = OptionParser.new do |opts|
      opts.banner = "Usage: example.rb [options]"

      opts.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
        args.name = n
      end

      opts.on("-h", "--help", "Prints this help") do
        puts opts
        exit
      end
    end

    opt_parser.parse!(options)
    return args
  end
end
options = Parser.parse %w[--help]

#=&gt;
   # Usage: example.rb [options]
   #     -n, --name=NAME                  Name to say hello to
   #     -h, --help                       Prints this help
</pre> <h3 id="class-OptionParser-label-Required+Arguments">Required Arguments</h3> <p>For options that require an argument, option specification strings may include an option name in all caps. If an option is used without the required argument, an exception will be raised.</p> <pre class="ruby" data-language="ruby">require 'optparse'

options = {}
OptionParser.new do |parser|
  parser.on("-r", "--require LIBRARY",
            "Require the LIBRARY before executing your script") do |lib|
    puts "You required #{lib}!"
  end
end.parse!
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb -r
optparse-test.rb:9:in `&lt;main&gt;': missing argument: -r (OptionParser::MissingArgument)
$ ruby optparse-test.rb -r my-library
You required my-library!</pre> <h3 id="class-OptionParser-label-Type+Coercion">Type Coercion</h3> <p><a href="optionparser"><code>OptionParser</code></a> supports the ability to coerce command line arguments into objects for us.</p> <p><a href="optionparser"><code>OptionParser</code></a> comes with a few ready-to-use kinds of type coercion. They are:</p> <ul>
<li> <p><a href="date"><code>Date</code></a> – Anything accepted by <code>Date.parse</code></p> </li>
<li> <p><a href="datetime"><code>DateTime</code></a> – Anything accepted by <code>DateTime.parse</code></p> </li>
<li> <p><a href="time"><code>Time</code></a> – Anything accepted by <code>Time.httpdate</code> or <code>Time.parse</code></p> </li>
<li> <p><a href="uri"><code>URI</code></a> – Anything accepted by <code>URI.parse</code></p> </li>
<li> <p><a href="shellwords"><code>Shellwords</code></a> – Anything accepted by <code>Shellwords.shellwords</code></p> </li>
<li> <p><a href="string"><code>String</code></a> – Any non-empty string</p> </li>
<li> <p><a href="integer"><code>Integer</code></a> – Any integer. Will convert octal. (e.g. 124, -3, 040)</p> </li>
<li> <p><a href="float"><code>Float</code></a> – Any float. (e.g. 10, 3.14, -100E+13)</p> </li>
<li> <p><a href="numeric"><code>Numeric</code></a> – Any integer, float, or rational (1, 3.4, 1/3)</p> </li>
<li> <p><a href="optionparser#DecimalInteger"><code>DecimalInteger</code></a> – Like <code>Integer</code>, but no octal format.</p> </li>
<li> <p><a href="optionparser#OctalInteger"><code>OctalInteger</code></a> – Like <code>Integer</code>, but no decimal format.</p> </li>
<li> <p><a href="optionparser#DecimalNumeric"><code>DecimalNumeric</code></a> – Decimal integer or float.</p> </li>
<li> <p><a href="trueclass"><code>TrueClass</code></a> – Accepts '+, yes, true, -, no, false' and defaults as <code>true</code></p> </li>
<li> <p><a href="falseclass"><code>FalseClass</code></a> – Same as <code>TrueClass</code>, but defaults to <code>false</code></p> </li>
<li> <p><a href="array"><code>Array</code></a> – Strings separated by ',' (e.g. 1,2,3)</p> </li>
<li> <p><a href="regexp"><code>Regexp</code></a> – Regular expressions. Also includes options.</p> </li>
</ul> <p>We can also add our own coercions, which we will cover below.</p> <h4 id="class-OptionParser-label-Using+Built-in+Conversions">Using Built-in Conversions</h4> <p>As an example, the built-in <code>Time</code> conversion is used. The other built-in conversions behave in the same way. <a href="optionparser"><code>OptionParser</code></a> will attempt to parse the argument as a <code>Time</code>. If it succeeds, that time will be passed to the handler block. Otherwise, an exception will be raised.</p> <pre class="ruby" data-language="ruby">require 'optparse'
require 'optparse/time'
OptionParser.new do |parser|
  parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
    p time
  end
end.parse!
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb  -t nonsense
... invalid argument: -t nonsense (OptionParser::InvalidArgument)
$ ruby optparse-test.rb  -t 10-11-12
2010-11-12 00:00:00 -0500
$ ruby optparse-test.rb  -t 9:30
2014-08-13 09:30:00 -0400</pre> <h4 id="class-OptionParser-label-Creating+Custom+Conversions">Creating Custom Conversions</h4> <p>The <code>accept</code> method on <a href="optionparser"><code>OptionParser</code></a> may be used to create converters. It specifies which conversion block to call whenever a class is specified. The example below uses it to fetch a <code>User</code> object before the <code>on</code> handler receives it.</p> <pre class="ruby" data-language="ruby">require 'optparse'

User = Struct.new(:id, :name)

def find_user id
  not_found = -&gt;{ raise "No User Found for id #{id}" }
  [ User.new(1, "Sam"),
    User.new(2, "Gandalf") ].find(not_found) do |u|
    u.id == id
  end
end

op = OptionParser.new
op.accept(User) do |user_id|
  find_user user_id.to_i
end

op.on("--user ID", User) do |user|
  puts user
end

op.parse!
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb --user 1
#&lt;struct User id=1, name="Sam"&gt;
$ ruby optparse-test.rb --user 2
#&lt;struct User id=2, name="Gandalf"&gt;
$ ruby optparse-test.rb --user 3
optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)</pre> <h3 id="class-OptionParser-label-Store+options+to+a+Hash">Store options to a <a href="hash"><code>Hash</code></a>
</h3> <p>The <code>into</code> option of <code>order</code>, <code>parse</code> and so on methods stores command line options into a <a href="hash"><code>Hash</code></a>.</p> <pre class="ruby" data-language="ruby">require 'optparse'

params = {}
OptionParser.new do |opts|
  opts.on('-a')
  opts.on('-b NUM', Integer)
  opts.on('-v', '--verbose')
end.parse!(into: params)

p params
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb -a
{:a=&gt;true}
$ ruby optparse-test.rb -a -v
{:a=&gt;true, :verbose=&gt;true}
$ ruby optparse-test.rb -a -b 100
{:a=&gt;true, :b=&gt;100}</pre> <h3 id="class-OptionParser-label-Complete+example">Complete example</h3> <p>The following example is a complete Ruby program. You can run it and see the effect of specifying various options. This is probably the best way to learn the features of <code>optparse</code>.</p> <pre class="ruby" data-language="ruby">require 'optparse'
require 'optparse/time'
require 'ostruct'
require 'pp'

class OptparseExample
  Version = '1.0.0'

  CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
  CODE_ALIASES = { "jis" =&gt; "iso-2022-jp", "sjis" =&gt; "shift_jis" }

  class ScriptOptions
    attr_accessor :library, :inplace, :encoding, :transfer_type,
                  :verbose, :extension, :delay, :time, :record_separator,
                  :list

    def initialize
      self.library = []
      self.inplace = false
      self.encoding = "utf8"
      self.transfer_type = :auto
      self.verbose = false
    end

    def define_options(parser)
      parser.banner = "Usage: example.rb [options]"
      parser.separator ""
      parser.separator "Specific options:"

      # add additional options
      perform_inplace_option(parser)
      delay_execution_option(parser)
      execute_at_time_option(parser)
      specify_record_separator_option(parser)
      list_example_option(parser)
      specify_encoding_option(parser)
      optional_option_argument_with_keyword_completion_option(parser)
      boolean_verbose_option(parser)

      parser.separator ""
      parser.separator "Common options:"
      # No argument, shows at tail.  This will print an options summary.
      # Try it and see!
      parser.on_tail("-h", "--help", "Show this message") do
        puts parser
        exit
      end
      # Another typical switch to print the version.
      parser.on_tail("--version", "Show version") do
        puts Version
        exit
      end
    end

    def perform_inplace_option(parser)
      # Specifies an optional option argument
      parser.on("-i", "--inplace [EXTENSION]",
                "Edit ARGV files in place",
                "(make backup if EXTENSION supplied)") do |ext|
        self.inplace = true
        self.extension = ext || ''
        self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
      end
    end

    def delay_execution_option(parser)
      # Cast 'delay' argument to a Float.
      parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
        self.delay = n
      end
    end

    def execute_at_time_option(parser)
      # Cast 'time' argument to a Time object.
      parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
        self.time = time
      end
    end

    def specify_record_separator_option(parser)
      # Cast to octal integer.
      parser.on("-F", "--irs [OCTAL]", OptionParser::OctalInteger,
                "Specify record separator (default \\0)") do |rs|
        self.record_separator = rs
      end
    end

    def list_example_option(parser)
      # List of arguments.
      parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
        self.list = list
      end
    end

    def specify_encoding_option(parser)
      # Keyword completion.  We are specifying a specific set of arguments (CODES
      # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
      # the shortest unambiguous text.
      code_list = (CODE_ALIASES.keys + CODES).join(', ')
      parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
                "(#{code_list})") do |encoding|
        self.encoding = encoding
      end
    end

    def optional_option_argument_with_keyword_completion_option(parser)
      # Optional '--type' option argument with keyword completion.
      parser.on("--type [TYPE]", [:text, :binary, :auto],
                "Select transfer type (text, binary, auto)") do |t|
        self.transfer_type = t
      end
    end

    def boolean_verbose_option(parser)
      # Boolean switch.
      parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
        self.verbose = v
      end
    end
  end

  #
  # Return a structure describing the options.
  #
  def parse(args)
    # The options specified on the command line will be collected in
    # *options*.

    @options = ScriptOptions.new
    @args = OptionParser.new do |parser|
      @options.define_options(parser)
      parser.parse!(args)
    end
    @options
  end

  attr_reader :parser, :options
end  # class OptparseExample

example = OptparseExample.new
options = example.parse(ARGV)
pp options # example.options
pp ARGV
</pre> <h3 id="class-OptionParser-label-Shell+Completion">Shell <a href="optionparser/completion"><code>Completion</code></a>
</h3> <p>For modern shells (e.g. bash, zsh, etc.), you can use shell completion for command line options.</p> <h3 id="class-OptionParser-label-Further+documentation">Further documentation</h3> <p>The above examples should be enough to learn how to use this class. If you have any questions, file a ticket at <a href="http://bugs.ruby-lang.org">bugs.ruby-lang.org</a>.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="DecimalInteger">DecimalInteger </dt>
<dd>
<p>Decimal integer format, to be converted to <a href="integer"><code>Integer</code></a>.</p> </dd>
<dt id="DecimalNumeric">DecimalNumeric </dt>
<dd>
<p>Decimal integer/float number format, to be converted to <a href="integer"><code>Integer</code></a> for integer format, <a href="float"><code>Float</code></a> for float format.</p> </dd>
<dt id="OctalInteger">OctalInteger </dt>
<dd>
<p>Ruby/C like octal/hexadecimal/binary integer format, to be converted to <a href="integer"><code>Integer</code></a>.</p> </dd>
<dt id="Version">Version </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-banner"> <span class="method-name">banner</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Heading banner preceding summary.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-default_argv"> <span class="method-name">default_argv</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Strings to be parsed in default.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-program_name"> <span class="method-name">program_name</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Program name to be emitted in error message and default banner, defaults to $0.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-release"> <span class="method-name">release</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Release code</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_banner"> <span class="method-name">set_banner</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Heading banner preceding summary.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_program_name"> <span class="method-name">set_program_name</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Program name to be emitted in error message and default banner, defaults to $0.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_summary_indent"> <span class="method-name">set_summary_indent</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Indentation for summary. Must be <a href="string"><code>String</code></a> (or have + <a href="string"><code>String</code></a> method).</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_summary_width"> <span class="method-name">set_summary_width</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Width for option list portion of summary. Must be <a href="numeric"><code>Numeric</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-summary_indent"> <span class="method-name">summary_indent</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Indentation for summary. Must be <a href="string"><code>String</code></a> (or have + <a href="string"><code>String</code></a> method).</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-summary_width"> <span class="method-name">summary_width</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Width for option list portion of summary. Must be <a href="numeric"><code>Numeric</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-version"> <span class="method-name">version</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p><a href="optionparser#Version"><code>Version</code></a></p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-accept"> <span class="method-name">accept</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1132
def self.accept(*args, &amp;blk) top.accept(*args, &amp;blk) end</pre> </div> <p>See <a href="optionparser#method-i-accept"><code>accept</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-each_const"> <span class="method-name">each_const</span><span class="method-args">(path, base = ::Object)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each_const-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/version.rb, line 50
def each_const(path, base = ::Object)
  path.split(/::|\//).inject(base) do |klass, name|
    raise NameError, path unless Module === klass
    klass.constants.grep(/#{name}/i) do |c|
      klass.const_defined?(c) or next
      klass.const_get(c)
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-getopts"> <span class="method-name">getopts</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getopts-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1742
def self.getopts(*args)
  new.getopts(*args)
end</pre> </div> <p>See <a href="optionparser#method-i-getopts"><code>getopts</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-inc"> <span class="method-name">inc</span><span class="method-args">(arg, default = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inc-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1068
def self.inc(arg, default = nil)
  case arg
  when Integer
    arg.nonzero?
  when nil
    default.to_i + 1
  end
end</pre> </div> <p>Returns an incremented value of <code>default</code> according to <code>arg</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(banner = nil, width = 32, indent = ' ' * 4) { |self| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1087
def initialize(banner = nil, width = 32, indent = ' ' * 4)
  @stack = [DefaultList, List.new, List.new]
  @program_name = nil
  @banner = banner
  @summary_width = width
  @summary_indent = indent
  @default_argv = ARGV
  add_officious
  yield self if block_given?
end</pre> </div> <p>Initializes the instance and yields itself if called with a block.</p> <dl class="rdoc-list note-list">
<dt>
<code>banner</code> </dt>
<dd> <p>Banner message.</p> </dd>
<dt>
<code>width</code> </dt>
<dd> <p>Summary width.</p> </dd>
<dt>
<code>indent</code> </dt>
<dd> <p>Summary indent.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-reject"> <span class="method-name">reject</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1145
def self.reject(*args, &amp;blk) top.reject(*args, &amp;blk) end</pre> </div> <p>See <a href="optionparser#method-i-reject"><code>reject</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-search_const"> <span class="method-name">search_const</span><span class="method-args">(klass, name) { |klass, cname, const| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="search_const-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/version.rb, line 60
def search_const(klass, name)
  klasses = [klass]
  while klass = klasses.shift
    klass.constants.each do |cname|
      klass.const_defined?(cname) or next
      const = klass.const_get(cname)
      yield klass, cname, const if name === cname
      klasses &lt;&lt; const if Module === const and const != ::Object
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-show_version"> <span class="method-name">show_version</span><span class="method-args">(*pkgs)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="show_version-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/version.rb, line 5
def show_version(*pkgs)
  progname = ARGV.options.program_name
  result = false
  show = proc do |klass, cname, version|
    str = "#{progname}"
    unless klass == ::Object and cname == :VERSION
      version = version.join(".") if Array === version
      str &lt;&lt; ": #{klass}" unless klass == Object
      str &lt;&lt; " version #{version}"
    end
    [:Release, :RELEASE].find do |rel|
      if klass.const_defined?(rel)
        str &lt;&lt; " (#{klass.const_get(rel)})"
      end
    end
    puts str
    result = true
  end
  if pkgs.size == 1 and pkgs[0] == "all"
    self.search_const(::Object, /\AV(?:ERSION|ersion)\z/) do |klass, cname, version|
      unless cname[1] == ?e and klass.const_defined?(:Version)
        show.call(klass, cname.intern, version)
      end
    end
  else
    pkgs.each do |pkg|
      begin
        pkg = pkg.split(/::|\//).inject(::Object) {|m, c| m.const_get(c)}
        v = case
            when pkg.const_defined?(:Version)
              pkg.const_get(n = :Version)
            when pkg.const_defined?(:VERSION)
              pkg.const_get(n = :VERSION)
            else
              n = nil
              "unknown"
            end
        show.call(pkg, n, v)
      rescue NameError
      end
    end
  end
  result
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-terminate"> <span class="method-name">terminate</span><span class="method-args">(arg = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="terminate-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1112
def self.terminate(arg = nil)
  throw :terminate, arg
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-top"> <span class="method-name">top</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="top-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1117
def self.top() DefaultList end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-with"> <span class="method-name">with</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="with-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1059
def self.with(*args, &amp;block)
  opts = new(*args)
  opts.instance_eval(&amp;block)
  opts
end</pre> </div> <p>Initializes a new instance and evaluates the optional block in context of the instance. Arguments <code>args</code> are passed to <a href="optionparser#method-i-new"><code>new</code></a>, see there for description of parameters.</p> <p>This method is <strong>deprecated</strong>, its behavior corresponds to the older <a href="optionparser#method-i-new"><code>new</code></a> method.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-abort"> <span class="method-name">abort</span><span class="method-args">(mesg = $!)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="abort-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1226
def abort(mesg = $!)
  super("#{program_name}: #{mesg}")
end</pre> </div> <div class="method-calls-super"> Calls superclass method <a href="kernel#method-i-abort"><code>Kernel#abort</code></a> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-accept"> <span class="method-name">accept</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1128
def accept(*args, &amp;blk) top.accept(*args, &amp;blk) end</pre> </div> <p>Directs to accept specified class <code>t</code>. The argument string is passed to the block in which it should be converted to the desired class.</p> <dl class="rdoc-list note-list">
<dt>
<code>t</code> </dt>
<dd> <p>Argument class specifier, any object including <a href="class"><code>Class</code></a>.</p> </dd>
<dt>
<code>pat</code> </dt>
<dd> <p>Pattern for argument, defaults to <code>t</code> if it responds to match.</p> </dd>
</dl> <pre class="ruby" data-language="ruby">accept(t, pat, &amp;block)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-additional_message"> <span class="method-name">additional_message</span><span class="method-args">(typ, opt)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="additional_message-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1793
def additional_message(typ, opt)
  return unless typ and opt and defined?(DidYouMean::SpellChecker)
  all_candidates = []
  visit(:get_candidates, typ) do |candidates|
    all_candidates.concat(candidates)
  end
  all_candidates.select! {|cand| cand.is_a?(String) }
  checker = DidYouMean::SpellChecker.new(dictionary: all_candidates)
  DidYouMean.formatter.message_for(all_candidates &amp; checker.correct(opt))
end</pre> </div> <p>Returns additional info.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-banner"> <span class="method-name">banner</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="banner-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1170
def banner
  unless @banner
    @banner = +"Usage: #{program_name} [options]"
    visit(:add_banner, @banner)
  end
  @banner
end</pre> </div> <p>Heading banner preceding summary.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-base"> <span class="method-name">base</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="base-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1240
def base
  @stack[1]
end</pre> </div> <p>Subject of <a href="optionparser#method-i-on_tail"><code>on_tail</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-candidate"> <span class="method-name">candidate</span><span class="method-args">(word)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="candidate-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1804
def candidate(word)
  list = []
  case word
  when '-'
    long = short = true
  when /\A--/
    word, arg = word.split(/=/, 2)
    argpat = Completion.regexp(arg, false) if arg and !arg.empty?
    long = true
  when /\A-/
    short = true
  end
  pat = Completion.regexp(word, long)
  visit(:each_option) do |opt|
    next unless Switch === opt
    opts = (long ? opt.long : []) + (short ? opt.short : [])
    opts = Completion.candidate(word, true, pat, &amp;opts.method(:each)).map(&amp;:first) if pat
    if /\A=/ =~ opt.arg
      opts.map! {|sw| sw + "="}
      if arg and CompletingHash === opt.pattern
        if opts = opt.pattern.candidate(arg, false, argpat)
          opts.map!(&amp;:last)
        end
      end
    end
    list.concat(opts)
  end
  list
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-def_head_option"> <span class="method-name">def_head_option</span><span class="method-args">(*opts, &amp;block)</span> </div>  <div class="aliases"> Alias for: <a href="optionparser#method-i-define_head">define_head</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-def_option"> <span class="method-name">def_option</span><span class="method-args">(*opts, &amp;block)</span> </div>  <div class="aliases"> Alias for: <a href="optionparser#method-i-define">define</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-def_tail_option"> <span class="method-name">def_tail_option</span><span class="method-args">(*opts, &amp;block)</span> </div>  <div class="aliases"> Alias for: <a href="optionparser#method-i-define_tail">define_tail</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-define"> <span class="method-name">define</span><span class="method-args">(*opts, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="define-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1501
def define(*opts, &amp;block)
  top.append(*(sw = make_switch(opts, block)))
  sw[0]
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="optionparser#method-i-def_option">def_option</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-define_by_keywords"> <span class="method-name">define_by_keywords</span><span class="method-args">(options, meth, **opts)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="define_by_keywords-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/kwargs.rb, line 5
def define_by_keywords(options, meth, **opts)
  meth.parameters.each do |type, name|
    case type
    when :key, :keyreq
      op, cl = *(type == :key ? %w"[ ]" : ["", ""])
      define("--#{name}=#{op}#{name.upcase}#{cl}", *opts[name]) do |o|
        options[name] = o
      end
    end
  end
  options
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-define_head"> <span class="method-name">define_head</span><span class="method-args">(*opts, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="define_head-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1516
def define_head(*opts, &amp;block)
  top.prepend(*(sw = make_switch(opts, block)))
  sw[0]
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="optionparser#method-i-def_head_option">def_head_option</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-define_tail"> <span class="method-name">define_tail</span><span class="method-args">(*opts, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="define_tail-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1530
def define_tail(*opts, &amp;block)
  base.append(*(sw = make_switch(opts, block)))
  sw[0]
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="optionparser#method-i-def_tail_option">def_tail_option</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-environment"> <span class="method-name">environment</span><span class="method-args">(env = File.basename($0, '.*'))</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="environment-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1874
def environment(env = File.basename($0, '.*'))
  env = ENV[env] || ENV[env.upcase] or return
  require 'shellwords'
  parse(*Shellwords.shellwords(env))
end</pre> </div> <p>Parses environment variable <code>env</code> or its uppercase with splitting like a shell.</p> <p><code>env</code> defaults to the basename of the program.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getopts"> <span class="method-name">getopts</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getopts-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1707
def getopts(*args)
  argv = Array === args.first ? args.shift : default_argv
  single_options, *long_options = *args

  result = {}

  single_options.scan(/(.)(:)?/) do |opt, val|
    if val
      result[opt] = nil
      define("-#{opt} VAL")
    else
      result[opt] = false
      define("-#{opt}")
    end
  end if single_options

  long_options.each do |arg|
    arg, desc = arg.split(';', 2)
    opt, val = arg.split(':', 2)
    if val
      result[opt] = val.empty? ? nil : val
      define("--#{opt}=#{result[opt] || "VAL"}", *[desc].compact)
    else
      result[opt] = false
      define("--#{opt}", *[desc].compact)
    end
  end

  parse_in_order(argv, result.method(:[]=))
  result
end</pre> </div> <p>Wrapper method for getopts.rb.</p> <pre class="ruby" data-language="ruby">params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option")
# params["a"] = true   # -a
# params["b"] = "1"    # -b1
# params["foo"] = "1"  # --foo
# params["bar"] = "x"  # --bar x
# params["zot"] = "z"  # --zot Z
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-help"> <span class="method-name">help</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="help-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1282
def help; summarize("#{banner}".sub(/\n?\z/, "\n")) end</pre> </div> <p>Returns option summary string.</p>  </div> <div class="aliases"> Also aliased as: <a href="optionparser#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inc"> <span class="method-name">inc</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inc-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1076
def inc(*args)
  self.class.inc(*args)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-load"> <span class="method-name">load</span><span class="method-args">(filename = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="load-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1842
def load(filename = nil)
  unless filename
    basename = File.basename($0, '.*')
    return true if load(File.expand_path(basename, '~/.options')) rescue nil
    basename &lt;&lt; ".options"
    return [
      # XDG
      ENV['XDG_CONFIG_HOME'],
      '~/.config',
      *ENV['XDG_CONFIG_DIRS']&amp;.split(File::PATH_SEPARATOR),

      # Haiku
      '~/config/settings',
    ].any? {|dir|
      next if !dir or dir.empty?
      load(File.expand_path(basename, dir)) rescue nil
    }
  end
  begin
    parse(*IO.readlines(filename).each {|s| s.chomp!})
    true
  rescue Errno::ENOENT, Errno::ENOTDIR
    false
  end
end</pre> </div> <p>Loads options from file names as <code>filename</code>. Does nothing when the file is not present. Returns whether successfully loaded.</p> <p><code>filename</code> defaults to basename of the program without suffix in a directory ~/.options, then the basename with '.options' suffix under XDG and Haiku standard places.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-make_switch"> <span class="method-name">make_switch</span><span class="method-args">(opts, block = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="make_switch-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1368
def make_switch(opts, block = nil)
  short, long, nolong, style, pattern, conv, not_pattern, not_conv, not_style = [], [], []
  ldesc, sdesc, desc, arg = [], [], []
  default_style = Switch::NoArgument
  default_pattern = nil
  klass = nil
  q, a = nil
  has_arg = false

  opts.each do |o|
    # argument class
    next if search(:atype, o) do |pat, c|
      klass = notwice(o, klass, 'type')
      if not_style and not_style != Switch::NoArgument
        not_pattern, not_conv = pat, c
      else
        default_pattern, conv = pat, c
      end
    end

    # directly specified pattern(any object possible to match)
    if (!(String === o || Symbol === o)) and o.respond_to?(:match)
      pattern = notwice(o, pattern, 'pattern')
      if pattern.respond_to?(:convert)
        conv = pattern.method(:convert).to_proc
      else
        conv = SPLAT_PROC
      end
      next
    end

    # anything others
    case o
    when Proc, Method
      block = notwice(o, block, 'block')
    when Array, Hash
      case pattern
      when CompletingHash
      when nil
        pattern = CompletingHash.new
        conv = pattern.method(:convert).to_proc if pattern.respond_to?(:convert)
      else
        raise ArgumentError, "argument pattern given twice"
      end
      o.each {|pat, *v| pattern[pat] = v.fetch(0) {pat}}
    when Module
      raise ArgumentError, "unsupported argument type: #{o}", ParseError.filter_backtrace(caller(4))
    when *ArgumentStyle.keys
      style = notwice(ArgumentStyle[o], style, 'style')
    when /^--no-([^\[\]=\s]*)(.+)?/
      q, a = $1, $2
      o = notwice(a ? Object : TrueClass, klass, 'type')
      not_pattern, not_conv = search(:atype, o) unless not_style
      not_style = (not_style || default_style).guess(arg = a) if a
      default_style = Switch::NoArgument
      default_pattern, conv = search(:atype, FalseClass) unless default_pattern
      ldesc &lt;&lt; "--no-#{q}"
      (q = q.downcase).tr!('_', '-')
      long &lt;&lt; "no-#{q}"
      nolong &lt;&lt; q
    when /^--\[no-\]([^\[\]=\s]*)(.+)?/
      q, a = $1, $2
      o = notwice(a ? Object : TrueClass, klass, 'type')
      if a
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      end
      ldesc &lt;&lt; "--[no-]#{q}"
      (o = q.downcase).tr!('_', '-')
      long &lt;&lt; o
      not_pattern, not_conv = search(:atype, FalseClass) unless not_style
      not_style = Switch::NoArgument
      nolong &lt;&lt; "no-#{o}"
    when /^--([^\[\]=\s]*)(.+)?/
      q, a = $1, $2
      if a
        o = notwice(NilClass, klass, 'type')
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      end
      ldesc &lt;&lt; "--#{q}"
      (o = q.downcase).tr!('_', '-')
      long &lt;&lt; o
    when /^-(\[\^?\]?(?:[^\\\]]|\\.)*\])(.+)?/
      q, a = $1, $2
      o = notwice(Object, klass, 'type')
      if a
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      else
        has_arg = true
      end
      sdesc &lt;&lt; "-#{q}"
      short &lt;&lt; Regexp.new(q)
    when /^-(.)(.+)?/
      q, a = $1, $2
      if a
        o = notwice(NilClass, klass, 'type')
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      end
      sdesc &lt;&lt; "-#{q}"
      short &lt;&lt; q
    when /^=/
      style = notwice(default_style.guess(arg = o), style, 'style')
      default_pattern, conv = search(:atype, Object) unless default_pattern
    else
      desc.push(o)
    end
  end

  default_pattern, conv = search(:atype, default_style.pattern) unless default_pattern
  if !(short.empty? and long.empty?)
    if has_arg and default_style == Switch::NoArgument
      default_style = Switch::RequiredArgument
    end
    s = (style || default_style).new(pattern || default_pattern,
                                     conv, sdesc, ldesc, arg, desc, block)
  elsif !block
    if style or pattern
      raise ArgumentError, "no switch given", ParseError.filter_backtrace(caller)
    end
    s = desc
  else
    short &lt;&lt; pattern
    s = (style || default_style).new(pattern,
                                     conv, nil, nil, arg, desc, block)
  end
  return s, short, long,
    (not_style.new(not_pattern, not_conv, sdesc, ldesc, nil, desc, block) if not_style),
    nolong
end</pre> </div> <p>Creates an <a href="optionparser/switch"><code>OptionParser::Switch</code></a> from the parameters. The parsed argument value is passed to the given block, where it can be processed.</p> <p>See at the beginning of <a href="optionparser"><code>OptionParser</code></a> for some full examples.</p> <p><code>opts</code> can include the following elements:</p> <dl class="rdoc-list label-list">
<dt>Argument style: </dt>
<dd> <p>One of the following:</p> <pre>:NONE, :REQUIRED, :OPTIONAL</pre> </dd>
<dt>Argument pattern: </dt>
<dd> <p>Acceptable option argument format, must be pre-defined with <a href="optionparser#method-c-accept"><code>OptionParser.accept</code></a> or <a href="optionparser#method-i-accept"><code>OptionParser#accept</code></a>, or <a href="regexp"><code>Regexp</code></a>. This can appear once or assigned as <a href="string"><code>String</code></a> if not present, otherwise causes an <a href="argumenterror"><code>ArgumentError</code></a>. Examples:</p> <pre>Float, Time, Array</pre> </dd>
<dt>Possible argument values: </dt>
<dd> <p><a href="hash"><code>Hash</code></a> or <a href="array"><code>Array</code></a>.</p> <pre class="ruby" data-language="ruby">[:text, :binary, :auto]
%w[iso-2022-jp shift_jis euc-jp utf8 binary]
{ "jis" =&gt; "iso-2022-jp", "sjis" =&gt; "shift_jis" }
</pre> </dd>
<dt>Long style switch: </dt>
<dd> <p>Specifies a long style switch which takes a mandatory, optional or no argument. It's a string of the following form:</p> <pre class="ruby" data-language="ruby">"--switch=MANDATORY" or "--switch MANDATORY"
"--switch[=OPTIONAL]"
"--switch"
</pre> </dd>
<dt>Short style switch: </dt>
<dd> <p>Specifies short style switch which takes a mandatory, optional or no argument. It's a string of the following form:</p> <pre class="ruby" data-language="ruby">"-xMANDATORY"
"-x[OPTIONAL]"
"-x"
</pre> <p>There is also a special form which matches character range (not full set of regular expression):</p> <pre class="ruby" data-language="ruby">"-[a-z]MANDATORY"
"-[a-z][OPTIONAL]"
"-[a-z]"
</pre> </dd>
<dt>Argument style and description: </dt>
<dd> <p>Instead of specifying mandatory or optional arguments directly in the switch parameter, this separate parameter can be used.</p> <pre class="ruby" data-language="ruby">"=MANDATORY"
"=[OPTIONAL]"
</pre> </dd>
<dt>Description: </dt>
<dd> <p>Description string for the option.</p> <pre class="ruby" data-language="ruby">"Run verbosely"
</pre> <p>If you give multiple description strings, each string will be printed line by line.</p> </dd>
<dt>Handler: </dt>
<dd> <p>Handler for the parsed argument value. Either give a block or pass a <a href="proc"><code>Proc</code></a> or <a href="method"><code>Method</code></a> as an argument.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-new"> <span class="method-name">new</span><span class="method-args">() { |self| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1247
def new
  @stack.push(List.new)
  if block_given?
    yield self
  else
    self
  end
end</pre> </div> <p>Pushes a new <a href="optionparser/list"><code>List</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-on"> <span class="method-name">on</span><span class="method-args">(*opts, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="on-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1510
def on(*opts, &amp;block)
  define(*opts, &amp;block)
  self
end</pre> </div> <p>Add option switch and handler. See <a href="optionparser#method-i-make_switch"><code>make_switch</code></a> for an explanation of parameters.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-on_head"> <span class="method-name">on_head</span><span class="method-args">(*opts, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="on_head-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1524
def on_head(*opts, &amp;block)
  define_head(*opts, &amp;block)
  self
end</pre> </div> <p>Add option switch like with <a href="optionparser#method-i-on"><code>on</code></a>, but at head of summary.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-on_tail"> <span class="method-name">on_tail</span><span class="method-args">(*opts, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="on_tail-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1538
def on_tail(*opts, &amp;block)
  define_tail(*opts, &amp;block)
  self
end</pre> </div> <p>Add option switch like with <a href="optionparser#method-i-on"><code>on</code></a>, but at tail of summary.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-order"> <span class="method-name">order</span><span class="method-args">(*argv, into: nil, &amp;nonopt)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="order-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1560
def order(*argv, into: nil, &amp;nonopt)
  argv = argv[0].dup if argv.size == 1 and Array === argv[0]
  order!(argv, into: into, &amp;nonopt)
end</pre> </div> <p>Parses command line arguments <code>argv</code> in order. When a block is given, each non-option argument is yielded. When optional <code>into</code> keyword argument is provided, the parsed option values are stored there via <code>[]=</code> method (so it can be <a href="hash"><code>Hash</code></a>, or <a href="openstruct"><code>OpenStruct</code></a>, or other similar object).</p> <p>Returns the rest of <code>argv</code> left unparsed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-order-21"> <span class="method-name">order!</span><span class="method-args">(argv = default_argv, into: nil, &amp;nonopt)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="order-21-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1569
def order!(argv = default_argv, into: nil, &amp;nonopt)
  setter = -&gt;(name, val) {into[name.to_sym] = val} if into
  parse_in_order(argv, setter, &amp;nonopt)
end</pre> </div> <p>Same as <a href="optionparser#method-i-order"><code>order</code></a>, but removes switches destructively. Non-option arguments remain in <code>argv</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse"> <span class="method-name">parse</span><span class="method-args">(*argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1680
def parse(*argv, into: nil)
  argv = argv[0].dup if argv.size == 1 and Array === argv[0]
  parse!(argv, into: into)
end</pre> </div> <p>Parses command line arguments <code>argv</code> in order when environment variable POSIXLY_CORRECT is set, and in permutation mode otherwise. When optional <code>into</code> keyword argument is provided, the parsed option values are stored there via <code>[]=</code> method (so it can be <a href="hash"><code>Hash</code></a>, or <a href="openstruct"><code>OpenStruct</code></a>, or other similar object).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse-21"> <span class="method-name">parse!</span><span class="method-args">(argv = default_argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse-21-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1689
def parse!(argv = default_argv, into: nil)
  if ENV.include?('POSIXLY_CORRECT')
    order!(argv, into: into)
  else
    permute!(argv, into: into)
  end
end</pre> </div> <p>Same as <a href="optionparser#method-i-parse"><code>parse</code></a>, but removes switches destructively. Non-option arguments remain in <code>argv</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-permute"> <span class="method-name">permute</span><span class="method-args">(*argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="permute-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1657
def permute(*argv, into: nil)
  argv = argv[0].dup if argv.size == 1 and Array === argv[0]
  permute!(argv, into: into)
end</pre> </div> <p>Parses command line arguments <code>argv</code> in permutation mode and returns list of non-option arguments. When optional <code>into</code> keyword argument is provided, the parsed option values are stored there via <code>[]=</code> method (so it can be <a href="hash"><code>Hash</code></a>, or <a href="openstruct"><code>OpenStruct</code></a>, or other similar object).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-permute-21"> <span class="method-name">permute!</span><span class="method-args">(argv = default_argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="permute-21-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1666
def permute!(argv = default_argv, into: nil)
  nonopts = []
  order!(argv, into: into, &amp;nonopts.method(:&lt;&lt;))
  argv[0, 0] = nonopts
  argv
end</pre> </div> <p>Same as <a href="optionparser#method-i-permute"><code>permute</code></a>, but removes switches destructively. Non-option arguments remain in <code>argv</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-program_name"> <span class="method-name">program_name</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="program_name-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1182
def program_name
  @program_name || File.basename($0, '.*')
end</pre> </div> <p>Program name to be emitted in error message and default banner, defaults to $0.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reject"> <span class="method-name">reject</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1141
def reject(*args, &amp;blk) top.reject(*args, &amp;blk) end</pre> </div> <p>Directs to reject specified class argument.</p> <dl class="rdoc-list note-list">
<dt>
<code>t</code> </dt>
<dd> <p>Argument class specifier, any object including <a href="class"><code>Class</code></a>.</p> </dd>
</dl> <pre class="ruby" data-language="ruby">reject(t)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-release"> <span class="method-name">release</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="release-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1207
def release
  (defined?(@release) &amp;&amp; @release) || (defined?(::Release) &amp;&amp; ::Release) || (defined?(::RELEASE) &amp;&amp; ::RELEASE)
end</pre> </div> <p>Release code</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove"> <span class="method-name">remove</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1259
def remove
  @stack.pop
end</pre> </div> <p>Removes the last <a href="optionparser/list"><code>List</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-separator"> <span class="method-name">separator</span><span class="method-args">(string)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="separator-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1547
def separator(string)
  top.append(string, nil, nil)
end</pre> </div> <p>Add separator in summary.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-summarize"> <span class="method-name">summarize</span><span class="method-args">(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="summarize-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1272
def summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &amp;blk)
  nl = "\n"
  blk ||= proc {|l| to &lt;&lt; (l.index(nl, -1) ? l : l + nl)}
  visit(:summarize, {}, {}, width, max, indent, &amp;blk)
  to
end</pre> </div> <p>Puts option summary into <code>to</code> and returns <code>to</code>. Yields each line if a block is given.</p> <dl class="rdoc-list note-list">
<dt>
<code>to</code> </dt>
<dd> <p>Output destination, which must have method &lt;&lt;. Defaults to [].</p> </dd>
<dt>
<code>width</code> </dt>
<dd> <p>Width of left side, defaults to @summary_width.</p> </dd>
<dt>
<code>max</code> </dt>
<dd> <p>Maximum length allowed for left side, defaults to <code>width</code> - 1.</p> </dd>
<dt>
<code>indent</code> </dt>
<dd> <p>Indentation, defaults to @summary_indent.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-terminate"> <span class="method-name">terminate</span><span class="method-args">(arg = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="terminate-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1109
def terminate(arg = nil)
  self.class.terminate(arg)
end</pre> </div> <p>Terminates option parsing. Optional parameter <code>arg</code> is a string pushed back to be the first non-option argument.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-name">to_a</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1288
def to_a; summarize("#{banner}".split(/^/)) end</pre> </div> <p>Returns option summary list.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="optionparser#method-i-help">help</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-top"> <span class="method-name">top</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="top-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1233
def top
  @stack[-1]
end</pre> </div> <p>Subject of <a href="optionparser#method-i-on"><code>on</code></a> / <a href="optionparser#method-i-on_head"><code>on_head</code></a>, <a href="optionparser#method-i-accept"><code>accept</code></a> / <a href="optionparser#method-i-reject"><code>reject</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ver"> <span class="method-name">ver</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ver-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1214
def ver
  if v = version
    str = +"#{program_name} #{[v].join('.')}"
    str &lt;&lt; " (#{v})" if v = release
    str
  end
end</pre> </div> <p>Returns version string from <a href="optionparser#method-i-program_name"><code>program_name</code></a>, version and release.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-version"> <span class="method-name">version</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="version-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1200
def version
  (defined?(@version) &amp;&amp; @version) || (defined?(::Version) &amp;&amp; ::Version)
end</pre> </div> <p><a href="optionparser#Version"><code>Version</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-warn"> <span class="method-name">warn</span><span class="method-args">(mesg = $!)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="warn-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1222
def warn(mesg = $!)
  super("#{program_name}: #{mesg}")
end</pre> </div> <div class="method-calls-super"> Calls superclass method <a href="kernel#method-i-warn"><code>Kernel#warn</code></a> </div>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-complete"> <span class="method-name">complete</span><span class="method-args">(typ, opt, icase = false, *pat)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="complete-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1778
def complete(typ, opt, icase = false, *pat)
  if pat.empty?
    search(typ, opt) {|sw| return [sw, opt]} # exact match or...
  end
  ambiguous = catch(:ambiguous) {
    visit(:complete, typ, opt, icase, *pat) {|o, *sw| return sw}
  }
  exc = ambiguous ? AmbiguousOption : InvalidOption
  raise exc.new(opt, additional: self.method(:additional_message).curry[typ])
end</pre> </div> <p>Completes shortened long style option switch and returns pair of canonical switch and switch descriptor <a href="optionparser/switch"><code>OptionParser::Switch</code></a>.</p> <dl class="rdoc-list note-list">
<dt>
<code>typ</code> </dt>
<dd> <p>Searching table.</p> </dd>
<dt>
<code>opt</code> </dt>
<dd> <p>Searching key.</p> </dd>
<dt>
<code>icase</code> </dt>
<dd> <p>Search case insensitive if true.</p> </dd>
<dt>
<code>pat</code> </dt>
<dd> <p>Optional pattern for completion.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-notwice"> <span class="method-name">notwice</span><span class="method-args">(obj, prv, msg)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="notwice-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1298
def notwice(obj, prv, msg)
  unless !prv or prv == obj
    raise(ArgumentError, "argument #{msg} given twice: #{obj}",
          ParseError.filter_backtrace(caller(2)))
  end
  obj
end</pre> </div> <p>Checks if an argument is given twice, in which case an <a href="argumenterror"><code>ArgumentError</code></a> is raised. Called from OptionParser#switch only.</p> <dl class="rdoc-list note-list">
<dt>
<code>obj</code> </dt>
<dd> <p>New argument.</p> </dd>
<dt>
<code>prv</code> </dt>
<dd> <p>Previously specified argument.</p> </dd>
<dt>
<code>msg</code> </dt>
<dd> <p><a href="exception"><code>Exception</code></a> message.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-search"> <span class="method-name">search</span><span class="method-args">(id, key) { |k| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="search-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1761
def search(id, key)
  block_given = block_given?
  visit(:search, id, key) do |k|
    return block_given ? yield(k) : k
  end
end</pre> </div> <p>Searches <code>key</code> in @stack for <code>id</code> hash and returns or yields the result.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-visit"> <span class="method-name">visit</span><span class="method-args">(id, *args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="visit-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1750
def visit(id, *args, &amp;block)
  @stack.reverse_each do |el|
    el.__send__(id, *args, &amp;block)
  end
  nil
end</pre> </div> <p>Traverses @stack, sending each element method <code>id</code> with <code>args</code> and <code>block</code>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
