
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Hash - Ruby 3 - W3cubDocs</title>
  
  <meta name="description" content=" A Hash maps each of its unique keys to a specific value. ">
  <meta name="keywords" content="class, hash, ruby, ruby~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~3/hash.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ruby~3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~3/" class="_nav-link" title="" style="margin-left:0;">Ruby 3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Hash" class="class"> class Hash </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable">Enumerable</a></dd>
</dl> <section class="description"> <p>A Hash maps each of its unique keys to a specific value.</p> <p>A Hash has certain similarities to an Array, but:</p> <ul>
<li> <p>An Array index is always an Integer.</p> </li>
<li> <p>A Hash key can be (almost) any object.</p> </li>
</ul> <h3 id="class-Hash-label-Hash+Data+Syntax">Hash Data Syntax</h3> <p>The older syntax for Hash data uses the “hash rocket,” <code>=&gt;</code>:</p> <pre class="ruby" data-language="ruby">h = {:foo =&gt; 0, :bar =&gt; 1, :baz =&gt; 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Alternatively, but only for a Hash key that's a Symbol, you can use a newer JSON-style syntax, where each bareword becomes a Symbol:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>You can also use a String in place of a bareword:</p> <pre class="ruby" data-language="ruby">h = {'foo': 0, 'bar': 1, 'baz': 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>And you can mix the styles:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, :bar =&gt; 1, 'baz': 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>But it's an error to try the JSON-style syntax for a key that's not a bareword or a String:</p> <pre># Raises SyntaxError (syntax error, unexpected ':', expecting =&gt;):
h = {0: 'zero'}</pre> <h3 id="class-Hash-label-Common+Uses">Common Uses</h3> <p>You can use a Hash to give names to objects:</p> <pre class="ruby" data-language="ruby">person = {name: 'Matz', language: 'Ruby'}
person # =&gt; {:name=&gt;"Matz", :language=&gt;"Ruby"}
</pre> <p>You can use a Hash to give names to method arguments:</p> <pre class="ruby" data-language="ruby">def some_method(hash)
  p hash
end
some_method({foo: 0, bar: 1, baz: 2}) # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Note: when the last argument in a method call is a Hash, the curly braces may be omitted:</p> <pre class="ruby" data-language="ruby">some_method(foo: 0, bar: 1, baz: 2) # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>You can use a Hash to initialize an object:</p> <pre class="ruby" data-language="ruby">class Dev
  attr_accessor :name, :language
  def initialize(hash)
    self.name = hash[:name]
    self.language = hash[:language]
  end
end
matz = Dev.new(name: 'Matz', language: 'Ruby')
matz # =&gt; #&lt;Dev: @name="Matz", @language="Ruby"&gt;
</pre> <h3 id="class-Hash-label-Creating+a+Hash">Creating a Hash</h3> <p>Here are three ways to create a Hash:</p> <ul>
<li> <p>Method <code>Hash.new</code></p> </li>
<li> <p>Method <code>Hash[]</code></p> </li>
<li> <p>Literal form: <code>{}</code>.</p> </li>
</ul>  <p>You can create a Hash by calling method <a href="hash#method-c-new"><code>Hash.new</code></a>.</p> <p>Create an empty Hash:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h # =&gt; {}
h.class # =&gt; Hash
</pre>  <p>You can create a Hash by calling method <a href="hash#method-c-5B-5D"><code>Hash.[]</code></a>.</p> <p>Create an empty Hash:</p> <pre class="ruby" data-language="ruby">h = Hash[]
h # =&gt; {}
</pre> <p>Create a Hash with initial entries:</p> <pre class="ruby" data-language="ruby">h = Hash[foo: 0, bar: 1, baz: 2]
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre>  <p>You can create a Hash by using its literal form (curly braces).</p> <p>Create an empty Hash:</p> <pre class="ruby" data-language="ruby">h = {}
h # =&gt; {}
</pre> <p>Create a Hash with initial entries:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <h3 id="class-Hash-label-Hash+Value+Basics">Hash Value Basics</h3> <p>The simplest way to retrieve a Hash value (instance method <a href="hash#method-i-5B-5D"><code>[]</code></a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:foo] # =&gt; 0
</pre> <p>The simplest way to create or update a Hash value (instance method <a href="hash#method-i-5B-5D-3D"><code>[]=</code></a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:bat] = 3 # =&gt; 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
h[:foo] = 4 # =&gt; 4
h # =&gt; {:foo=&gt;4, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
</pre> <p>The simplest way to delete a Hash entry (instance method <a href="hash#method-i-delete"><code>delete</code></a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:bar) # =&gt; 1
h # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre> <h3 id="class-Hash-label-Entry+Order">Entry Order</h3> <p>A Hash object presents its entries in the order of their creation. This is seen in:</p> <ul>
<li> <p>Iterative methods such as <code>each</code>, <code>each_key</code>, <code>each_pair</code>, <code>each_value</code>.</p> </li>
<li> <p>Other order-sensitive methods such as <code>shift</code>, <code>keys</code>, <code>values</code>.</p> </li>
<li> <p>The String returned by method <code>inspect</code>.</p> </li>
</ul> <p>A new Hash has its initial ordering per the given entries:</p> <pre class="ruby" data-language="ruby">h = Hash[foo: 0, bar: 1]
h # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>New entries are added at the end:</p> <pre class="ruby" data-language="ruby">h[:baz] = 2
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Updating a value does not affect the order:</p> <pre class="ruby" data-language="ruby">h[:baz] = 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;3}
</pre> <p>But re-creating a deleted entry can affect the order:</p> <pre class="ruby" data-language="ruby">h.delete(:foo)
h[:foo] = 5
h # =&gt; {:bar=&gt;1, :baz=&gt;3, :foo=&gt;5}
</pre> <h3 id="class-Hash-label-Hash+Keys">Hash Keys</h3> <h4 id="class-Hash-label-Hash+Key+Equivalence">Hash Key Equivalence</h4> <p>Two objects are treated as the same hash key when their <code>hash</code> value is identical and the two objects are <code>eql?</code> to each other.</p> <h4 id="class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key</h4> <p>Modifying a Hash key while it is in use damages the hash's index.</p> <p>This Hash has keys that are Arrays:</p> <pre class="ruby" data-language="ruby">a0 = [ :foo, :bar ]
a1 = [ :baz, :bat ]
h = {a0 =&gt; 0, a1 =&gt; 1}
h.include?(a0) # =&gt; true
h[a0] # =&gt; 0
a0.hash # =&gt; 110002110
</pre> <p>Modifying array element <code>a0[0]</code> changes its hash value:</p> <pre class="ruby" data-language="ruby">a0[0] = :bam
a0.hash # =&gt; 1069447059
</pre> <p>And damages the Hash index:</p> <pre class="ruby" data-language="ruby">h.include?(a0) # =&gt; false
h[a0] # =&gt; nil
</pre> <p>You can repair the hash index using method <code>rehash</code>:</p> <pre class="ruby" data-language="ruby">h.rehash # =&gt; {[:bam, :bar]=&gt;0, [:baz, :bat]=&gt;1}
h.include?(a0) # =&gt; true
h[a0] # =&gt; 0
</pre> <p>A String key is always safe. That's because an unfrozen String passed as a key will be replaced by a duplicated and frozen String:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s.frozen? # =&gt; false
h = {s =&gt; 0}
first_key = h.keys.first
first_key.frozen? # =&gt; true
</pre> <h4 id="class-Hash-label-User-Defined+Hash+Keys">User-Defined Hash Keys</h4> <p>To be useable as a Hash key, objects must implement the methods <code>hash</code> and <code>eql?</code>. Note: this requirement does not apply if the Hash uses compare_by_id since comparison will then rely on the keys' object id instead of <code>hash</code> and <code>eql?</code>.</p> <p>Object defines basic implementation for <code>hash</code> and <code>eq?</code> that makes each object a distinct key. Typically, user-defined classes will want to override these methods to provide meaningful behavior, or for example inherit Struct that has useful definitions for these.</p> <p>A typical implementation of <code>hash</code> is based on the object's data while <code>eql?</code> is usually aliased to the overridden <code>==</code> method:</p> <pre class="ruby" data-language="ruby">class Book
  attr_reader :author, :title

  def initialize(author, title)
    @author = author
    @title = title
  end

  def ==(other)
    self.class === other &amp;&amp;
      other.author == @author &amp;&amp;
      other.title == @title
  end

  alias eql? ==

  def hash
    @author.hash ^ @title.hash # XOR
  end
end

book1 = Book.new 'matz', 'Ruby in a Nutshell'
book2 = Book.new 'matz', 'Ruby in a Nutshell'

reviews = {}

reviews[book1] = 'Great reference!'
reviews[book2] = 'Nice and compact!'

reviews.length #=&gt; 1
</pre> <h3 id="class-Hash-label-Default+Values">Default Values</h3> <p>The methods <a href="hash#method-i-5B-5D"><code>[]</code></a>, <a href="hash#method-i-values_at"><code>values_at</code></a> and <a href="hash#method-i-dig"><code>dig</code></a> need to return the value associated to a certain key. When that key is not found, that value will be determined by its default proc (if any) or else its default (initially `nil`).</p> <p>You can retrieve the default value with method <a href="hash#method-i-default"><code>default</code></a>:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h.default # =&gt; nil
</pre> <p>You can set the default value by passing an argument to method <a href="hash#method-c-new"><code>Hash.new</code></a> or with method <a href="hash#method-i-default-3D"><code>default=</code></a></p> <pre class="ruby" data-language="ruby">h = Hash.new(-1)
h.default # =&gt; -1
h.default = 0
h.default # =&gt; 0
</pre> <p>This default value is returned for <a href="hash#method-i-5B-5D"><code>[]</code></a>, <a href="hash#method-i-values_at"><code>values_at</code></a> and <a href="hash#method-i-dig"><code>dig</code></a> when a key is not found:</p> <pre class="ruby" data-language="ruby">counts = {foo: 42}
counts.default # =&gt; nil (default)
counts[:foo] = 42
counts[:bar] # =&gt; nil
counts.default = 0
counts[:bar] # =&gt; 0
counts.values_at(:foo, :bar, :baz) # =&gt; [42, 0, 0]
counts.dig(:bar) # =&gt; 0
</pre> <p>Note that the default value is used without being duplicated. It is not advised to set the default value to a mutable object:</p> <pre class="ruby" data-language="ruby">synonyms = Hash.new([])
synonyms[:hello] # =&gt; []
synonyms[:hello] &lt;&lt; :hi # =&gt; [:hi], but this mutates the default!
synonyms.default # =&gt; [:hi]
synonyms[:world] &lt;&lt; :universe
synonyms[:world] # =&gt; [:hi, :universe], oops
synonyms.keys # =&gt; [], oops
</pre> <p>To use a mutable object as default, it is recommended to use a default proc</p> <h4 id="class-Hash-label-Default+Proc">Default Proc</h4> <p>When the default proc for a Hash is set (i.e., not <code>nil</code>), the default value returned by method <a href="hash#method-i-5B-5D"><code>[]</code></a> is determined by the default proc alone.</p> <p>You can retrieve the default proc with method <a href="hash#method-i-default_proc"><code>default_proc</code></a>:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h.default_proc # =&gt; nil
</pre> <p>You can set the default proc by calling <a href="hash#method-c-new"><code>Hash.new</code></a> with a block or calling the method <a href="hash#method-i-default_proc-3D"><code>default_proc=</code></a></p> <pre class="ruby" data-language="ruby">h = Hash.new { |hash, key| "Default value for #{key}" }
h.default_proc.class # =&gt; Proc
h.default_proc = proc { |hash, key| "Default value for #{key.inspect}" }
h.default_proc.class # =&gt; Proc
</pre> <p>When the default proc is set (i.e., not <code>nil</code>) and method <a href="hash#method-i-5B-5D"><code>[]</code></a> is called with with a non-existent key, <a href="hash#method-i-5B-5D"><code>[]</code></a> calls the default proc with both the Hash object itself and the missing key, then returns the proc's return value:</p> <pre class="ruby" data-language="ruby">h = Hash.new { |hash, key| "Default value for #{key}" }
h[:nosuch] # =&gt; "Default value for nosuch"
</pre> <p>Note that in the example above no entry for key <code>:nosuch</code> is created:</p> <pre class="ruby" data-language="ruby">h.include?(:nosuch) # =&gt; false
</pre> <p>However, the proc itself can add a new entry:</p> <pre class="ruby" data-language="ruby">synonyms = Hash.new { |hash, key| hash[key] = [] }
synonyms.include?(:hello) # =&gt; false
synonyms[:hello] &lt;&lt; :hi # =&gt; [:hi]
synonyms[:world] &lt;&lt; :universe # =&gt; [:universe]
synonyms.keys # =&gt; [:hello, :world]
</pre> <p>Note that setting the default proc will clear the default value and vice versa.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-5B-5D"> <span class="method-callseq"> Hash[] → new_empty_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Hash[hash] → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> Hash[ [*2_element_arrays] ] → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> Hash[*objects] → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE hash, tmp;

    if (argc == 1) {
        tmp = rb_hash_s_try_convert(Qnil, argv[0]);
        if (!NIL_P(tmp)) {
            hash = hash_alloc(klass);
            hash_copy(hash, tmp);
            return hash;
        }

        tmp = rb_check_array_type(argv[0]);
        if (!NIL_P(tmp)) {
            long i;

            hash = hash_alloc(klass);
            for (i = 0; i &lt; RARRAY_LEN(tmp); ++i) {
                VALUE e = RARRAY_AREF(tmp, i);
                VALUE v = rb_check_array_type(e);
                VALUE key, val = Qnil;

                if (NIL_P(v)) {
                    rb_raise(rb_eArgError, "wrong element type %s at %ld (expected array)",
                             rb_builtin_class_name(e), i);
                }
                switch (RARRAY_LEN(v)) {
                  default:
                    rb_raise(rb_eArgError, "invalid number of elements (%ld for 1..2)",
                             RARRAY_LEN(v));
                  case 2:
                    val = RARRAY_AREF(v, 1);
                  case 1:
                    key = RARRAY_AREF(v, 0);
                    rb_hash_aset(hash, key, val);
                }
            }
            return hash;
        }
    }
    if (argc % 2 != 0) {
        rb_raise(rb_eArgError, "odd number of arguments for Hash");
    }

    hash = hash_alloc(klass);
    rb_hash_bulk_insert(argc, argv, hash);
    hash_verify(hash);
    return hash;
}</pre> </div> <p>Returns a new Hash object populated with the given objects, if any. See <a href="hash#method-c-new"><code>Hash::new</code></a>.</p> <p>With no argument, returns a new empty Hash.</p> <p>When the single given argument is a Hash, returns a new Hash populated with the entries from the given Hash.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
Hash[h] # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>When the single given argument is an Array of 2-element Arrays, returns a new Hash object wherein each 2-element array forms a key-value entry:</p> <pre class="ruby" data-language="ruby">Hash[ [ [:foo, 0], [:bar, 1] ] ] # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>When the argument count is an even number; returns a new Hash object wherein each successive pair of arguments has become a key-value entry:</p> <pre class="ruby" data-language="ruby">Hash[:foo, 0, :bar, 1] # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>Raises an exception if the argument list does not conform to any of the above.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(default_value = nil) → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new {|hash, key| ... } → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_hash_initialize(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_hash_modify(hash);
    if (rb_block_given_p()) {
        rb_check_arity(argc, 0, 0);
        ifnone = rb_block_proc();
        SET_PROC_DEFAULT(hash, ifnone);
    }
    else {
        rb_check_arity(argc, 0, 1);
        ifnone = argc == 0 ? Qnil : argv[0];
        RHASH_SET_IFNONE(hash, ifnone);
    }

    return hash;
}</pre> </div> <p>Returns a new empty Hash object.</p> <p>The initial default value and initial default proc for the new hash depend on which form above was used. See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p> <p>If neither an argument nor a block given, initializes both the default value and the default proc to <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = Hash.new
h.default # =&gt; nil
h.default_proc # =&gt; nil
</pre> <p>If argument <code>default_value</code> given but no block given, initializes the default value to the given <code>default_value</code> and the default proc to <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = Hash.new(false)
h.default # =&gt; false
h.default_proc # =&gt; nil
</pre> <p>If a block given but no argument, stores the block as the default proc and sets the default value to <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = Hash.new {|hash, key| "Default value for #{key}" }
h.default # =&gt; nil
h.default_proc.class # =&gt; Proc
h[:nosuch] # =&gt; "Default value for nosuch"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-ruby2_keywords_hash"> <span class="method-callseq"> ruby2_keywords_hash(hash) → hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ruby2_keywords_hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_ruby2_keywords_hash(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    hash = rb_hash_dup(hash);
    RHASH(hash)-&gt;basic.flags |= RHASH_PASS_AS_KEYWORDS;
    return hash;
}</pre> </div> <p>Duplicates a given hash and adds a ruby2_keywords flag. This method is not for casual use; debugging, researching, and some truly necessary cases like deserialization of arguments.</p> <pre class="ruby" data-language="ruby">h = {k: 1}
h = Hash.ruby2_keywords_hash(h)
def foo(k: 42)
  k
end
foo(*[h]) #=&gt; 1 with neither a warning or an error
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-ruby2_keywords_hash-3F"> <span class="method-callseq"> ruby2_keywords_hash?(hash) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ruby2_keywords_hash-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_ruby2_keywords_hash_p(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    return (RHASH(hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS) ? Qtrue : Qfalse;
}</pre> </div> <p>Checks if a given hash is flagged by <a href="module#method-i-ruby2_keywords"><code>Module#ruby2_keywords</code></a> (or <a href="proc#method-i-ruby2_keywords"><code>Proc#ruby2_keywords</code></a>). This method is not for casual use; debugging, researching, and some truly necessary cases like serialization of arguments.</p> <pre class="ruby" data-language="ruby">ruby2_keywords def foo(*args)
  Hash.ruby2_keywords_hash?(args.last)
end
foo(k: 1)   #=&gt; true
foo({k: 1}) #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-try_convert"> <span class="method-callseq"> try_convert(obj) → obj, new_hash, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="try_convert-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_try_convert(VALUE dummy, VALUE hash)
{
    return rb_check_hash_type(hash);
}</pre> </div> <p>If <code>obj</code> is a Hash object, returns <code>obj</code>.</p> <p>Otherwise if <code>obj</code> responds to <code>:to_hash</code>, calls <code>obj.to_hash</code> and returns the result.</p> <p>Returns <code>nil</code> if <code>obj</code> does not respond to <code>:to_hash</code></p> <p>Raises an exception unless <code>obj.to_hash</code> returns a Hash object.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C"> <span class="method-callseq"> hash &lt; other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-source"> <pre class="c" data-language="c">static VALUE
rb_hash_lt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a proper subset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1}
h2 = {foo: 0, bar: 1, baz: 2}
h1 &lt; h2 # =&gt; true
h2 &lt; h1 # =&gt; false
h1 &lt; h1 # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D"> <span class="method-callseq"> hash &lt;= other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_le(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a subset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1}
h2 = {foo: 0, bar: 1, baz: 2}
h1 &lt;= h2 # =&gt; true
h2 &lt;= h1 # =&gt; false
h1 &lt;= h1 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> hash == object → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_equal(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, FALSE);
}</pre> </div> <p>Returns <code>true</code> if all of the following are true:</p> <ul>
<li> <p><code>object</code> is a Hash object.</p> </li>
<li> <p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p> </li>
<li> <p>For each key <code>key</code>, <code>hash[key] == object[key]</code>.</p> </li>
</ul> <p>Otherwise, returns <code>false</code>.</p> <p>Equal:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1, baz: 2}
h1 == h2 # =&gt; true
h3 = {baz: 2, bar: 1, foo: 0}
h1 == h3 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E"> <span class="method-callseq"> hash &gt; other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-source"> <pre class="c" data-language="c">static VALUE
rb_hash_gt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a proper superset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1}
h1 &gt; h2 # =&gt; true
h2 &gt; h1 # =&gt; false
h1 &gt; h1 # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E-3D"> <span class="method-callseq"> hash &gt;= other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_ge(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre> </div> <p>Returns <code>true</code> if <code>hash</code> is a superset of <code>other_hash</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1}
h1 &gt;= h2 # =&gt; true
h2 &gt;= h1 # =&gt; false
h1 &gt;= h1 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> hash[key] → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_hash_aref(VALUE hash, VALUE key)
{
    st_data_t val;

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        return rb_hash_default_value(hash, key);
    }
}</pre> </div> <p>Returns the value associated with the given <code>key</code>, if found:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:foo] # =&gt; 0
</pre> <p>If <code>key</code> is not found, returns a default value (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h[:nosuch] # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> hash[key] = value → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">VALUE
rb_hash_aset(VALUE hash, VALUE key, VALUE val)
{
    int iter_lev = RHASH_ITER_LEV(hash);

    rb_hash_modify(hash);

    if (RHASH_TABLE_NULL_P(hash)) {
        if (iter_lev &gt; 0) no_new_key();
        ar_alloc_table(hash);
    }

    if (RHASH_TYPE(hash) == &amp;identhash || rb_obj_class(key) != rb_cString) {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset, val);
    }
    else {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset_str, val);
    }
    return val;
}</pre> </div> <p><a href="hash#method-i-store"><code>Hash#store</code></a> is an alias for <a href="hash#method-i-5B-5D-3D"><code>Hash#[]=</code></a>.</p> <p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p> <p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:foo] = 2 # =&gt; 2
h.store(:bar, 3) # =&gt; 3
h # =&gt; {:foo=&gt;2, :bar=&gt;3}
</pre> <p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:baz] = 2 # =&gt; 2
h.store(:bat, 3) # =&gt; 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-store">store</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-any-3F"> <span class="method-callseq"> any? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> any?(object) → true or false </span> </div> <div class="method-heading"> <span class="method-callseq"> any? {|key, value| ... } → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_any_p(int argc, VALUE *argv, VALUE hash)
{
    VALUE args[2];
    args[0] = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (RHASH_EMPTY_P(hash)) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        args[1] = argv[0];

        rb_hash_foreach(hash, any_p_i_pattern, (VALUE)args);
    }
    else {
        if (!rb_block_given_p()) {
            /* yields pairs, never false */
            return Qtrue;
        }
        if (rb_block_pair_yield_optimizable())
            rb_hash_foreach(hash, any_p_i_fast, (VALUE)args);
        else
            rb_hash_foreach(hash, any_p_i, (VALUE)args);
    }
    return args[0];
}</pre> </div> <p>Returns <code>true</code> if any element satisfies a given criterion; <code>false</code> otherwise.</p> <p>With no argument and no block, returns <code>true</code> if <code>self</code> is non-empty; <code>false</code> if empty.</p> <p>With argument <code>object</code> and no block, returns <code>true</code> if for any key <code>key</code> <code>h.assoc(key) == object</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.any?([:bar, 1]) # =&gt; true
h.any?([:bar, 0]) # =&gt; false
h.any?([:baz, 1]) # =&gt; false
</pre> <p>With no argument and a block, calls the block with each key-value pair; returns <code>true</code> if the block returns any truthy value, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.any? {|key, value| value &lt; 3 } # =&gt; true
h.any? {|key, value| value &gt; 3 } # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-assoc"> <span class="method-callseq"> assoc(key) → new_array or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="assoc-source"> <pre class="c" data-language="c">VALUE
rb_hash_assoc(VALUE hash, VALUE key)
{
    st_table *table;
    const struct st_hash_type *orighash;
    VALUE args[2];

    if (RHASH_EMPTY_P(hash)) return Qnil;

    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));
    table = RHASH_ST_TABLE(hash);
    orighash = table-&gt;type;

    if (orighash != &amp;identhash) {
        VALUE value;
        struct reset_hash_type_arg ensure_arg;
        struct st_hash_type assochash;

        assochash.compare = assoc_cmp;
        assochash.hash = orighash-&gt;hash;
        table-&gt;type = &amp;assochash;
        args[0] = hash;
        args[1] = key;
        ensure_arg.hash = hash;
        ensure_arg.orighash = orighash;
        value = rb_ensure(lookup2_call, (VALUE)&amp;args, reset_hash_type, (VALUE)&amp;ensure_arg);
        if (value != Qundef) return rb_assoc_new(key, value);
    }

    args[0] = key;
    args[1] = Qnil;
    rb_hash_foreach(hash, assoc_i, (VALUE)args);
    return args[1];
}</pre> </div> <p>If the given <code>key</code> is found, returns a 2-element Array containing that key and its value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.assoc(:bar) # =&gt; [:bar, 1]
</pre> <p>Returns <code>nil</code> if key <code>key</code> is not found.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-clear"> <span class="method-callseq"> clear → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="clear-source"> <pre class="c" data-language="c">VALUE
rb_hash_clear(VALUE hash)
{
    rb_hash_modify_check(hash);

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_hash_foreach(hash, clear_i, 0);
    }
    else if (RHASH_AR_TABLE_P(hash)) {
        ar_clear(hash);
    }
    else {
        st_clear(RHASH_ST_TABLE(hash));
    }

    return hash;
}</pre> </div> <p>Removes all hash entries; returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compact"> <span class="method-callseq"> compact → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compact-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compact(VALUE hash)
{
    VALUE result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, set_if_not_nil, result);
    }
    return result;
}</pre> </div> <p>Returns a copy of <code>self</code> with all <code>nil</code>-valued entries removed:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: nil, baz: 2, bat: nil}
h1 = h.compact
h1 # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compact-21"> <span class="method-callseq"> compact! → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compact-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compact_bang(VALUE hash)
{
    st_index_t n;
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (n) {
        rb_hash_foreach(hash, delete_if_nil, hash);
        if (n != RHASH_SIZE(hash))
            return hash;
    }
    return Qnil;
}</pre> </div> <p>Returns <code>self</code> with all its <code>nil</code>-valued entries removed (in place):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: nil, baz: 2, bat: nil}
h.compact! # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre> <p>Returns <code>nil</code> if no entries were removed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compare_by_identity"> <span class="method-callseq"> compare_by_identity → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_by_identity-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compare_by_id(VALUE hash)
{
    VALUE tmp;
    st_table *identtable;

    if (rb_hash_compare_by_id_p(hash)) return hash;

    rb_hash_modify_check(hash);
    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));

    tmp = hash_alloc(0);
    identtable = rb_init_identtable_with_size(RHASH_SIZE(hash));
    RHASH_ST_TABLE_SET(tmp, identtable);
    rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
    st_free_table(RHASH_ST_TABLE(hash));
    RHASH_ST_TABLE_SET(hash, identtable);
    RHASH_ST_CLEAR(tmp);
    rb_gc_force_recycle(tmp);

    return hash;
}</pre> </div> <p>Sets <code>self</code> to consider only identity in comparing keys; two keys are considered the same only if they are the same object; returns <code>self</code>.</p> <p>By default, these two object are considered to be the same key, so <code>s1</code> will overwrite <code>s0</code>:</p> <pre class="ruby" data-language="ruby">s0 = 'x'
s1 = 'x'
h = {}
h.compare_by_identity? # =&gt; false
h[s0] = 0
h[s1] = 1
h # =&gt; {"x"=&gt;1}
</pre> <p>After calling #compare_by_identity, the keys are considered to be different, and therefore do not overwrite each other:</p> <pre class="ruby" data-language="ruby">h = {}
h.compare_by_identity # =&gt; {}
h.compare_by_identity? # =&gt; true
h[s0] = 0
h[s1] = 1
h # =&gt; {"x"=&gt;0, "x"=&gt;1}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compare_by_identity-3F"> <span class="method-callseq"> compare_by_identity? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_by_identity-3F-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_compare_by_id_p(VALUE hash)
{
    if (RHASH_ST_TABLE_P(hash) &amp;&amp; RHASH_ST_TABLE(hash)-&gt;type == &amp;identhash) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre> </div> <p>Returns <code>true</code> if <a href="hash#method-i-compare_by_identity"><code>compare_by_identity</code></a> has been called, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-name">deconstruct_keys</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
rb_hash_deconstruct_keys(VALUE hash, VALUE keys)
{
    return hash;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default"> <span class="method-callseq"> default → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> default(key) → object </span> </div> <div class="method-description">
<div class="method-source-code" id="default-source"> <pre class="c" data-language="c">static VALUE
rb_hash_default(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_check_arity(argc, 0, 1);
    ifnone = RHASH_IFNONE(hash);
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        if (argc == 0) return Qnil;
        return call_default_proc(ifnone, hash, argv[0]);
    }
    return ifnone;
}</pre> </div> <p>Returns the default value for the given <code>key</code>. The returned value will be determined either by the default proc or by the default value. See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p> <p>With no argument, returns the current default value:</p> <pre class="ruby" data-language="ruby">h = {}
h.default # =&gt; nil
</pre> <p>If <code>key</code> is given, returns the default value for <code>key</code>, regardless of whether that key exists:</p> <pre class="ruby" data-language="ruby">h = Hash.new { |hash, key| hash[key] = "No key #{key}"}
h[:foo] = "Hello"
h.default(:foo) # =&gt; "No key foo"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default-3D"> <span class="method-callseq"> default = value → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_set_default(VALUE hash, VALUE ifnone)
{
    rb_hash_modify_check(hash);
    SET_DEFAULT(hash, ifnone);
    return ifnone;
}</pre> </div> <p>Sets the default value to <code>value</code>; returns <code>value</code>:</p> <pre class="ruby" data-language="ruby">h = {}
h.default # =&gt; nil
h.default = false # =&gt; false
h.default # =&gt; false
</pre> <p>See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default_proc"> <span class="method-callseq"> default_proc → proc or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_proc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_default_proc(VALUE hash)
{
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        return RHASH_IFNONE(hash);
    }
    return Qnil;
}</pre> </div> <p>Returns the default proc for <code>self</code> (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p> <pre class="ruby" data-language="ruby">h = {}
h.default_proc # =&gt; nil
h.default_proc = proc {|hash, key| "Default value for #{key}" }
h.default_proc.class # =&gt; Proc
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default_proc-3D"> <span class="method-callseq"> default_proc = proc → proc </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_proc-3D-source"> <pre class="c" data-language="c">VALUE
rb_hash_set_default_proc(VALUE hash, VALUE proc)
{
    VALUE b;

    rb_hash_modify_check(hash);
    if (NIL_P(proc)) {
        SET_DEFAULT(hash, proc);
        return proc;
    }
    b = rb_check_convert_type_with_id(proc, T_DATA, "Proc", idTo_proc);
    if (NIL_P(b) || !rb_obj_is_proc(b)) {
        rb_raise(rb_eTypeError,
                 "wrong default_proc type %s (expected Proc)",
                 rb_obj_classname(proc));
    }
    proc = b;
    SET_PROC_DEFAULT(hash, proc);
    return proc;
}</pre> </div> <p>Sets the default proc for <code>self</code> to <code>proc</code>: (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p> <pre class="ruby" data-language="ruby">h = {}
h.default_proc # =&gt; nil
h.default_proc = proc { |hash, key| "Default value for #{key}" }
h.default_proc.class # =&gt; Proc
h.default_proc = nil
h.default_proc # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete"> <span class="method-callseq"> delete(key) → value or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete(key) {|key| ... } → object </span> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="c" data-language="c">static VALUE
rb_hash_delete_m(VALUE hash, VALUE key)
{
    VALUE val;

    rb_hash_modify_check(hash);
    val = rb_hash_delete_entry(hash, key);

    if (val != Qundef) {
        return val;
    }
    else {
        if (rb_block_given_p()) {
            return rb_yield(key);
        }
        else {
            return Qnil;
        }
    }
}</pre> </div> <p>Deletes the entry for the given <code>key</code> and returns its associated value.</p> <p>If no block is given and <code>key</code> is found, deletes the entry and returns the associated value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:bar) # =&gt; 1
h # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre> <p>If no block given and <code>key</code> is not found, returns <code>nil</code>.</p> <p>If a block is given and <code>key</code> is found, ignores the block, deletes the entry, and returns the associated value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:baz) { |key| raise 'Will never happen'} # =&gt; 2
h # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>If a block is given and <code>key</code> is not found, calls the block and returns the block's return value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete(:nosuch) { |key| "Key #{key} not found" } # =&gt; "Key nosuch not found"
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete_if"> <span class="method-callseq"> delete_if {|key, value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete_if → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="c" data-language="c">VALUE
rb_hash_delete_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, delete_if_i, hash);
    }
    return hash;
}</pre> </div> <p>If a block given, calls the block with each key-value pair; deletes each entry for which the block returns a truthy value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.delete_if {|key, value| value &gt; 0 } # =&gt; {:foo=&gt;0}
</pre> <p>If no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.delete_if # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:delete_if&gt;
e.each { |key, value| value &gt; 0 } # =&gt; {:foo=&gt;0}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(key, *identifiers) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_hash_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_hash_aref(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div> <p>Finds and returns the object in nested objects that is specified by <code>key</code> and <code>identifiers</code>. The nested objects may be instances of various classes. See Dig Methods.</p> <p>Nested Hashes:</p> <pre class="ruby" data-language="ruby">h = {foo: {bar: {baz: 2}}}
h.dig(:foo) # =&gt; {:bar=&gt;{:baz=&gt;2}}
h.dig(:foo, :bar) # =&gt; {:bar=&gt;{:baz=&gt;2}}
h.dig(:foo, :bar, :baz) # =&gt; 2
h.dig(:foo, :bar, :BAZ) # =&gt; nil
</pre> <p>Nested Hashes and Arrays:</p> <pre class="ruby" data-language="ruby">h = {foo: {bar: [:a, :b, :c]}}
h.dig(:foo, :bar, 2) # =&gt; :c
</pre> <p>This method will use the <a href="#class-Hash-label-Default+Values">default values</a> for keys that are not present:</p> <pre class="ruby" data-language="ruby">h = {foo: {bar: [:a, :b, :c]}}
h.dig(:hello) # =&gt; nil
h.default_proc = -&gt; (hash, _key) { hash }
h.dig(:hello, :world) # =&gt; h
h.dig(:hello, :world, :foo, :bar, 2) # =&gt; :c
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|key, value| ... } → self </span> </div> <div class="method-heading"> <span class="method-callseq"> each → new_enumerator </span> </div> <div class="method-description"> <p><a href="hash#method-i-each"><code>Hash#each</code></a> is an alias for <a href="hash#method-i-each_pair"><code>Hash#each_pair</code></a>.</p> <p>Calls the given block with each key-value pair; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_pair {|key, value| puts "#{key}: #{value}"} # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_pair # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;
h1 = e.each {|key, value| puts "#{key}: #{value}"}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre> </div> <div class="aliases"> Alias for: <a href="hash#method-i-each_pair">each_pair</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_key"> <span class="method-callseq"> each_key {|key| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_key → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_key-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_key(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_key_i, 0);
    return hash;
}</pre> </div> <p>Calls the given block with each key; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_key {|key| puts key }  # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">foo
bar
baz
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_key # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_key&gt;
h1 = e.each {|key| puts key }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">foo
bar
baz
</pre>  </div> </div> <div id="method-i-each_pair" class="method-detail "> <div class="method-description">
<div class="method-source-code" id="each_pair-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_pair(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (rb_block_pair_yield_optimizable())
        rb_hash_foreach(hash, each_pair_i_fast, 0);
    else
        rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}</pre> </div> <p><a href="hash#method-i-each"><code>Hash#each</code></a> is an alias for <a href="hash#method-i-each_pair"><code>Hash#each_pair</code></a>.</p> <p>Calls the given block with each key-value pair; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_pair {|key, value| puts "#{key}: #{value}"} # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_pair # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;
h1 = e.each {|key, value| puts "#{key}: #{value}"}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre>foo: 0
bar: 1
baz: 2</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-each">each</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_value"> <span class="method-callseq"> each_value {|value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_value → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_value-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_value(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_value_i, 0);
    return hash;
}</pre> </div> <p>Calls the given block with each value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.each_value {|value| puts value } # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">0
1
2
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.each_value # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_value&gt;
h1 = e.each {|value| puts value }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">0
1
2
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-empty-3F"> <span class="method-callseq"> empty? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_empty_p(VALUE hash)
{
    return RHASH_EMPTY_P(hash) ? Qtrue : Qfalse;
}</pre> </div> <p>Returns <code>true</code> if there are no hash entries, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">{}.empty? # =&gt; true
{foo: 0, bar: 1, baz: 2}.empty? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql? object → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_eql(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, TRUE);
}</pre> </div> <p>Returns <code>true</code> if all of the following are true:</p> <ul>
<li> <p><code>object</code> is a Hash object.</p> </li>
<li> <p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p> </li>
<li> <p>For each key <code>key</code>, <code>h[key] eql? object[key]</code>.</p> </li>
</ul> <p>Otherwise, returns <code>false</code>.</p> <p>Equal:</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1, baz: 2}
h1.eql? h2 # =&gt; true
h3 = {baz: 2, bar: 1, foo: 0}
h1.eql? h3 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-except"> <span class="method-callseq"> except(*keys) → a_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="except-source"> <pre class="c" data-language="c">static VALUE
rb_hash_except(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, result;

    result = hash_alloc(rb_cHash);
    hash_copy(result, hash);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        rb_hash_delete(result, key);
    }

    return result;
}</pre> </div> <p>Returns a new Hash excluding entries for the given <code>keys</code>:</p> <pre class="ruby" data-language="ruby">h = { a: 100, b: 200, c: 300 }
h.except(:a)          #=&gt; {:b=&gt;200, :c=&gt;300}
</pre> <p>Any given <code>keys</code> that are not found are ignored.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fetch"> <span class="method-callseq"> fetch(key) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch(key, default_value) → object </span> </div> <div class="method-heading"> <span class="method-callseq"> fetch(key) {|key| ... } → object </span> </div> <div class="method-description">
<div class="method-source-code" id="fetch-source"> <pre class="c" data-language="c">static VALUE
rb_hash_fetch_m(int argc, VALUE *argv, VALUE hash)
{
    VALUE key;
    st_data_t val;
    long block_given;

    rb_check_arity(argc, 1, 2);
    key = argv[0];

    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn("block supersedes default value argument");
    }

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        if (block_given) {
            return rb_yield(key);
        }
        else if (argc == 1) {
            VALUE desc = rb_protect(rb_inspect, key, 0);
            if (NIL_P(desc)) {
                desc = rb_any_to_s(key);
            }
            desc = rb_str_ellipsize(desc, 65);
            rb_key_err_raise(rb_sprintf("key not found: %"PRIsVALUE, desc), hash, key);
        }
        else {
            return argv[1];
        }
    }
}</pre> </div> <p>Returns the value for the given <code>key</code>, if found.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.fetch(:bar) # =&gt; 1
</pre> <p>If <code>key</code> is not found and no block was given, returns <code>default_value</code>:</p> <pre class="ruby" data-language="ruby">{}.fetch(:nosuch, :default) # =&gt; :default
{}.fetch(:nosuch) # =&gt; nil
</pre> <p>If <code>key</code> is not found and a block was given, yields <code>key</code> to the block and returns the block's return value:</p> <pre class="ruby" data-language="ruby">{}.fetch(:nosuch) {|key| "No key #{key}"} # =&gt; "No key nosuch"
</pre> <p>Raises <a href="keyerror"><code>KeyError</code></a> if neither <code>default_value</code> nor a block was given.</p> <p>Note that this method does not use the values of either <a href="hash#method-i-default"><code>default</code></a> or <a href="hash#method-i-default_proc"><code>default_proc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fetch_values"> <span class="method-callseq"> fetch_values(*keys) → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch_values(*keys) {|key| ... } → new_array </span> </div> <div class="method-description">
<div class="method-source-code" id="fetch_values-source"> <pre class="c" data-language="c">static VALUE
rb_hash_fetch_values(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_fetch(hash, argv[i]));
    }
    return result;
}</pre> </div> <p>Returns a new Array containing the values associated with the given keys *keys:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.fetch_values(:baz, :foo) # =&gt; [2, 0]
</pre> <p>Returns a new empty Array if no arguments given.</p> <p>When a block is given, calls the block with each missing key, treating the block's return value as the value for that key:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
values = h.fetch_values(:bar, :foo, :bad, :bam) {|key| key.to_s}
values # =&gt; [1, 0, "bad", "bam"]
</pre> <p>When no block is given, raises an exception if any given key is not found.</p>  </div> </div> <div id="method-i-filter" class="method-detail method-alias"> <div class="method-description"> <p><a href="hash#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="hash#method-i-select"><code>Hash#select</code></a>.</p> <p>Returns a new Hash object whose entries are those for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.select {|key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.select # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select&gt;
e.each {|key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> </div> <div class="aliases"> Alias for: <a href="hash#method-i-select">select</a> </div> </div> <div id="method-i-filter-21" class="method-detail method-alias"> <div class="method-description"> <p><a href="hash#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="hash#method-i-select-21"><code>Hash#select!</code></a>.</p> <p>Returns <code>self</code>, whose entries are those for which the block returns a truthy value:</p> <pre>h = {foo: 0, bar: 1, baz: 2}
h.select! {|key, value| value &lt; 2 }  =&gt; {:foo=&gt;0, :bar=&gt;1}</pre> <p>Returns <code>nil</code> if no entries were removed.</p> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.select!  # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select!&gt;
e.each { |key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> </div> <div class="aliases"> Alias for: <a href="hash#method-i-select-21">select!</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flatten"> <span class="method-callseq"> flatten → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> flatten(level) → new_array </span> </div> <div class="method-description">
<div class="method-source-code" id="flatten-source"> <pre class="c" data-language="c">static VALUE
rb_hash_flatten(int argc, VALUE *argv, VALUE hash)
{
    VALUE ary;

    rb_check_arity(argc, 0, 1);

    if (argc) {
        int level = NUM2INT(argv[0]);

        if (level == 0) return rb_hash_to_a(hash);

        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
        level--;

        if (level &gt; 0) {
            VALUE ary_flatten_level = INT2FIX(level);
            rb_funcallv(ary, id_flatten_bang, 1, &amp;ary_flatten_level);
        }
        else if (level &lt; 0) {
            /* flatten recursively */
            rb_funcallv(ary, id_flatten_bang, 0, 0);
        }
    }
    else {
        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
    }

    return ary;
}</pre> </div> <p>Returns a new Array object that is a 1-dimensional flattening of <code>self</code>.</p>  <p>By default, nested Arrays are not flattened:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, 3], baz: 2}
h.flatten # =&gt; [:foo, 0, :bar, [:bat, 3], :baz, 2]
</pre> <p>Takes the depth of recursive flattening from Integer argument <code>level</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
h.flatten(1) # =&gt; [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]
h.flatten(2) # =&gt; [:foo, 0, :bar, :bat, [:baz, [:bat]]]
h.flatten(3) # =&gt; [:foo, 0, :bar, :bat, :baz, [:bat]]
h.flatten(4) # =&gt; [:foo, 0, :bar, :bat, :baz, :bat]
</pre> <p>When <code>level</code> is negative, flattens all nested Arrays:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
h.flatten(-1) # =&gt; [:foo, 0, :bar, :bat, :baz, :bat]
h.flatten(-2) # =&gt; [:foo, 0, :bar, :bat, :baz, :bat]
</pre> <p>When <code>level</code> is zero, returns the equivalent of <a href="hash#method-i-to_a"><code>to_a</code></a> :</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: [:bat, 3], baz: 2}
h.flatten(0) # =&gt; [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]
h.flatten(0) == h.to_a # =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-has_key-3F"> <span class="method-callseq"> has_key?(key) → true or false </span> </div> <div class="method-description"> <p>Methods <a href="hash#method-i-has_key-3F"><code>has_key?</code></a>, <a href="hash#method-i-key-3F"><code>key?</code></a>, and <a href="hash#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-has_value-3F"> <span class="method-callseq"> has_value?(value) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="has_value-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_has_value(VALUE hash, VALUE val)
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    rb_hash_foreach(hash, rb_hash_search_value, (VALUE)data);
    return data[0];
}</pre> </div> <p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-value-3F">value?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → an_integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_hash(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    st_index_t hval = rb_hash_start(size);
    hval = rb_hash_uint(hval, (st_index_t)rb_hash_hash);
    if (size) {
        rb_hash_foreach(hash, hash_i, (VALUE)&amp;hval);
    }
    hval = rb_hash_end(hval);
    return ST2FIX(hval);
}</pre> </div> <p>Returns the Integer hash-code for the hash.</p> <p>Two Hash objects have the same hash-code if their content is the same (regardless or order):</p> <pre class="ruby" data-language="ruby">h1 = {foo: 0, bar: 1, baz: 2}
h2 = {baz: 2, bar: 1, foo: 0}
h2.hash == h1.hash # =&gt; true
h2.eql? h1 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-include-3F"> <span class="method-callseq"> include?(key) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="include-3F-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    if (hash_stlike_lookup(hash, key, NULL)) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre> </div> <p>Methods <a href="hash#method-i-has_key-3F"><code>has_key?</code></a>, <a href="hash#method-i-key-3F"><code>key?</code></a>, and <a href="hash#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-member-3F">member?</a>, <a href="hash#method-i-has_key-3F">has_key?</a>, <a href="hash#method-i-key-3F">key?</a> </div> </div> <div id="method-i-initialize_copy" class="method-detail "> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="c" data-language="c">static VALUE
rb_hash_replace(VALUE hash, VALUE hash2)
{
    rb_hash_modify_check(hash);
    if (hash == hash2) return hash;
    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, "can't replace hash during iteration");
    }
    hash2 = to_hash(hash2);

    COPY_DEFAULT(hash, hash2);

    if (RHASH_AR_TABLE_P(hash)) {
        if (RHASH_AR_TABLE_P(hash2)) {
            ar_clear(hash);
        }
        else {
            ar_free_and_clear_table(hash);
            RHASH_ST_TABLE_SET(hash, st_init_table_with_size(RHASH_TYPE(hash2), RHASH_SIZE(hash2)));
        }
    }
    else {
        if (RHASH_AR_TABLE_P(hash2)) {
            st_free_table(RHASH_ST_TABLE(hash));
            RHASH_ST_CLEAR(hash);
        }
        else {
            st_clear(RHASH_ST_TABLE(hash));
            RHASH_TBL_RAW(hash)-&gt;type = RHASH_ST_TABLE(hash2)-&gt;type;
        }
    }
    rb_hash_foreach(hash2, rb_hash_rehash_i, (VALUE)hash);

    rb_gc_writebarrier_remember(hash);

    return hash;
}</pre> </div> <p>Replaces the entire contents of <code>self</code> with the contents of <code>other_hash</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.replace({bat: 3, bam: 4}) # =&gt; {:bat=&gt;3, :bam=&gt;4}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-replace">replace</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → new_string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_hash_inspect(VALUE hash)
{
    if (RHASH_EMPTY_P(hash))
        return rb_usascii_str_new2("{}");
    return rb_exec_recursive(inspect_hash, hash, 0);
}</pre> </div> <p>Returns a new String containing the hash entries:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.inspect # =&gt; "{:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}"
</pre> <p><a href="hash#method-i-to_s"><code>Hash#to_s</code></a> is an alias for <a href="hash#method-i-inspect"><code>Hash#inspect</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-invert"> <span class="method-callseq"> invert → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="invert-source"> <pre class="c" data-language="c">static VALUE
rb_hash_invert(VALUE hash)
{
    VALUE h = rb_hash_new_with_size(RHASH_SIZE(hash));

    rb_hash_foreach(hash, rb_hash_invert_i, h);
    return h;
}</pre> </div> <p>Returns a new Hash object with the each key-value pair inverted:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.invert
h1 # =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}
</pre> <p>Overwrites any repeated new keys: (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 0, baz: 0}
h.invert # =&gt; {0=&gt;:baz}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-keep_if"> <span class="method-callseq"> keep_if {|key, value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> keep_if → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="keep_if-source"> <pre class="c" data-language="c">static VALUE
rb_hash_keep_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, keep_if_i, hash);
    }
    return hash;
}</pre> </div> <p>Calls the block for each key-value pair; retains the entry if the block returns a truthy value; otherwise deletes the entry; returns <code>self</code>.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.keep_if { |key, value| key.start_with?('b') } # =&gt; {:bar=&gt;1, :baz=&gt;2}
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.keep_if # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:keep_if&gt;
e.each { |key, value| key.start_with?('b') } # =&gt; {:bar=&gt;1, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-key"> <span class="method-callseq"> key(value) → key or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="key-source"> <pre class="c" data-language="c">static VALUE
rb_hash_key(VALUE hash, VALUE value)
{
    VALUE args[2];

    args[0] = value;
    args[1] = Qnil;

    rb_hash_foreach(hash, key_i, (VALUE)args);

    return args[1];
}</pre> </div> <p>Returns the key for the first-found entry with the given <code>value</code> (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 2, baz: 2}
h.key(0) # =&gt; :foo
h.key(2) # =&gt; :bar
</pre> <p>Returns <code>nil</code> if so such value is found.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-key-3F"> <span class="method-callseq"> key?(key) → true or false </span> </div> <div class="method-description"> <p>Methods <a href="hash#method-i-has_key-3F"><code>has_key?</code></a>, <a href="hash#method-i-key-3F"><code>key?</code></a>, and <a href="hash#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-keys"> <span class="method-callseq"> keys → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="keys-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_keys(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    VALUE keys =  rb_ary_new_capa(size);

    if (size == 0) return keys;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        RARRAY_PTR_USE_TRANSIENT(keys, ptr, {
            if (RHASH_AR_TABLE_P(hash)) {
                size = ar_keys(hash, ptr, size);
            }
            else {
                st_table *table = RHASH_ST_TABLE(hash);
                size = st_keys(table, ptr, size);
            }
        });
        rb_gc_writebarrier_remember(keys);
        rb_ary_set_len(keys, size);
    }
    else {
        rb_hash_foreach(hash, keys_i, keys);
    }

    return keys;
}</pre> </div> <p>Returns a new Array containing all keys in <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.keys # =&gt; [:foo, :bar, :baz]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> </div> <div class="method-description"> <p>Returns the count of entries in <code>self</code>:</p> <pre class="ruby" data-language="ruby">{foo: 0, bar: 1, baz: 2}.length # =&gt; 3
</pre> <p><a href="hash#method-i-length"><code>Hash#length</code></a> is an alias for <a href="hash#method-i-size"><code>Hash#size</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="hash#method-i-size">size</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-member-3F"> <span class="method-callseq"> member?(key) → true or false </span> </div> <div class="method-description"> <p>Methods <a href="hash#method-i-has_key-3F"><code>has_key?</code></a>, <a href="hash#method-i-key-3F"><code>key?</code></a>, and <a href="hash#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p> <p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-merge"> <span class="method-callseq"> merge → copy_of_self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> merge(*other_hashes) → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> merge(*other_hashes) { |key, old_value, new_value| ... } → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="merge-source"> <pre class="c" data-language="c">static VALUE
rb_hash_merge(int argc, VALUE *argv, VALUE self)
{
    return rb_hash_update(argc, argv, rb_hash_dup(self));
}</pre> </div> <p>Returns the new Hash formed by merging each of <code>other_hashes</code> into a copy of <code>self</code>.</p> <p>Each argument in <code>other_hashes</code> must be a Hash.</p>  <p>With arguments and no block:</p> <ul>
<li> <p>Returns the new Hash object formed by merging each successive Hash in <code>other_hashes</code> into <code>self</code>.</p> </li>
<li> <p>Each new-key entry is added at the end.</p> </li>
<li> <p>Each duplicate-key entry's value overwrites the previous value.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h.merge(h1, h2) # =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}
</pre> <p>With arguments and a block:</p> <ul>
<li> <p>Returns a new Hash object that is the merge of <code>self</code> and each given hash.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new-key entry is added at the end.</p> </li>
<li> <p>For each duplicate key:</p> <ul>
<li> <p>Calls the block with the key and the old and new values.</p> </li>
<li> <p>The block's return value becomes the new value for the entry.</p> </li>
</ul> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h3 = h.merge(h1, h2) { |key, old_value, new_value| old_value + new_value }
h3 # =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}
</pre> <p>With no arguments:</p> <ul>
<li> <p>Returns a copy of <code>self</code>.</p> </li>
<li> <p>The block, if given, is ignored.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.merge # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
h1 = h.merge { |key, old_value, new_value| raise 'Cannot happen' }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-merge-21"> <span class="method-callseq"> merge! → self </span> </div> <div class="method-heading"> <span class="method-callseq"> merge!(*other_hashes) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> merge!(*other_hashes) { |key, old_value, new_value| ... } → self </span> </div> <div class="method-description"> <p>Merges each of <code>other_hashes</code> into <code>self</code>; returns <code>self</code>.</p> <p>Each argument in <code>other_hashes</code> must be a Hash.</p> <p>Method <a href="hash#method-i-update"><code>update</code></a> is an alias for #merge!.</p> <p>With arguments and no block:</p> <ul>
<li> <p>Returns <code>self</code>, after the given hashes are merged into it.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new entry is added at the end.</p> </li>
<li> <p>Each duplicate-key entry's value overwrites the previous value.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h.merge!(h1, h2) # =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}
</pre> <p>With arguments and a block:</p> <ul>
<li> <p>Returns <code>self</code>, after the given hashes are merged.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new-key entry is added at the end.</p> </li>
<li> <p>For each duplicate key:</p> <ul>
<li> <p>Calls the block with the key and the old and new values.</p> </li>
<li> <p>The block's return value becomes the new value for the entry.</p> </li>
</ul> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
h3 # =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}
</pre> <p>With no arguments:</p> <ul>
<li> <p>Returns <code>self</code>, unmodified.</p> </li>
<li> <p>The block, if given, is ignored.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.merge # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> </div> <div class="aliases"> Alias for: <a href="hash#method-i-update">update</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rassoc"> <span class="method-callseq"> rassoc(value) → new_array or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rassoc-source"> <pre class="c" data-language="c">VALUE
rb_hash_rassoc(VALUE hash, VALUE obj)
{
    VALUE args[2];

    args[0] = obj;
    args[1] = Qnil;
    rb_hash_foreach(hash, rassoc_i, (VALUE)args);
    return args[1];
}</pre> </div> <p>Returns a new 2-element Array consisting of the key and value of the first-found entry whose value is <code>==</code> to value (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 1}
h.rassoc(1) # =&gt; [:bar, 1]
</pre> <p>Returns <code>nil</code> if no such value found.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rehash"> <span class="method-callseq"> rehash → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rehash-source"> <pre class="c" data-language="c">VALUE
rb_hash_rehash(VALUE hash)
{
    VALUE tmp;
    st_table *tbl;

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, "rehash during iteration");
    }
    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        tmp = hash_alloc(0);
        ar_alloc_table(tmp);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        ar_free_and_clear_table(hash);
        ar_copy(hash, tmp);
        ar_free_and_clear_table(tmp);
    }
    else if (RHASH_ST_TABLE_P(hash)) {
        st_table *old_tab = RHASH_ST_TABLE(hash);
        tmp = hash_alloc(0);
        tbl = st_init_table_with_size(old_tab-&gt;type, old_tab-&gt;num_entries);
        RHASH_ST_TABLE_SET(tmp, tbl);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        st_free_table(old_tab);
        RHASH_ST_TABLE_SET(hash, tbl);
        RHASH_ST_CLEAR(tmp);
    }
    hash_verify(hash);
    return hash;
}</pre> </div> <p>Rebuilds the hash table by recomputing the hash index for each key; returns <code>self</code>.</p> <p>The hash table becomes invalid if the hash value of a key has changed after the entry was created. See <a href="#class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reject"> <span class="method-callseq"> reject {|key, value| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="c" data-language="c">VALUE
rb_hash_reject(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (RTEST(ruby_verbose)) {
        VALUE klass;
        if (HAS_EXTRA_STATES(hash, klass)) {
            rb_warn("extra states are no longer copied: %+"PRIsVALUE, hash);
        }
    }
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, reject_i, result);
    }
    return result;
}</pre> </div> <p>Returns a new Hash object whose entries are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.reject {|key, value| key.start_with?('b') }
h1 # =&gt; {:foo=&gt;0}
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.reject # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject&gt;
h1 = e.each {|key, value| key.start_with?('b') }
h1 # =&gt; {:foo=&gt;0}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reject-21"> <span class="method-callseq"> reject! {|key, value| ... } → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject! → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="reject-21-source"> <pre class="c" data-language="c">VALUE
rb_hash_reject_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, delete_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre> </div> <p>Returns <code>self</code>, whose remaining entries are those for which the block returns <code>false</code> or <code>nil</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.reject! {|key, value| value &lt; 2 } # =&gt; {:baz=&gt;2}
</pre> <p>Returns <code>nil</code> if no entries are removed.</p> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.reject! # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject!&gt;
e.each {|key, value| key.start_with?('b') } # =&gt; {:foo=&gt;0}
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-replace"> <span class="method-callseq"> replace(other_hash) → self </span> </div> <div class="method-description"> <p>Replaces the entire contents of <code>self</code> with the contents of <code>other_hash</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.replace({bat: 3, bam: 4}) # =&gt; {:bat=&gt;3, :bam=&gt;4}
</pre> </div> <div class="aliases"> Alias for: <a href="hash#method-i-initialize_copy">initialize_copy</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select {|key, value| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_hash_select(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, select_i, result);
    }
    return result;
}</pre> </div> <p><a href="hash#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="hash#method-i-select"><code>Hash#select</code></a>.</p> <p>Returns a new Hash object whose entries are those for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.select {|key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.select # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select&gt;
e.each {|key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-filter">filter</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select-21"> <span class="method-callseq"> select! {|key, value| ... } → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select! → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="select-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_select_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, keep_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre> </div> <p><a href="hash#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="hash#method-i-select-21"><code>Hash#select!</code></a>.</p> <p>Returns <code>self</code>, whose entries are those for which the block returns a truthy value:</p> <pre>h = {foo: 0, bar: 1, baz: 2}
h.select! {|key, value| value &lt; 2 }  =&gt; {:foo=&gt;0, :bar=&gt;1}</pre> <p>Returns <code>nil</code> if no entries were removed.</p> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.select!  # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select!&gt;
e.each { |key, value| value &lt; 2 } # =&gt; {:foo=&gt;0, :bar=&gt;1}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-filter-21">filter!</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shift"> <span class="method-callseq"> shift → [key, value] or default_value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shift-source"> <pre class="c" data-language="c">static VALUE
rb_hash_shift(VALUE hash)
{
    struct shift_var var;

    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (ar_shift(hash, &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    if (RHASH_ST_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (st_shift(RHASH_ST_TABLE(hash), &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    return rb_hash_default_value(hash, Qnil);
}</pre> </div> <p>Removes the first hash entry (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>); returns a 2-element Array containing the removed key and value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.shift # =&gt; [:foo, 0]
h # =&gt; {:bar=&gt;1, :baz=&gt;2}
</pre> <p>Returns the default value if the hash is empty (see <a href="#class-Hash-label-Default+Values">Default Values</a>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">VALUE
rb_hash_size(VALUE hash)
{
    return INT2FIX(RHASH_SIZE(hash));
}</pre> </div> <p>Returns the count of entries in <code>self</code>:</p> <pre class="ruby" data-language="ruby">{foo: 0, bar: 1, baz: 2}.length # =&gt; 3
</pre> <p><a href="hash#method-i-length"><code>Hash#length</code></a> is an alias for <a href="hash#method-i-size"><code>Hash#size</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-length">length</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-slice"> <span class="method-callseq"> slice(*keys) → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="slice-source"> <pre class="c" data-language="c">static VALUE
rb_hash_slice(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, value, result;

    if (argc == 0 || RHASH_EMPTY_P(hash)) {
        return rb_hash_new();
    }
    result = rb_hash_new_with_size(argc);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        value = rb_hash_lookup2(hash, key, Qundef);
        if (value != Qundef)
            rb_hash_aset(result, key, value);
    }

    return result;
}</pre> </div> <p>Returns a new Hash object containing the entries for the given <code>keys</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.slice(:baz, :foo) # =&gt; {:baz=&gt;2, :foo=&gt;0}
</pre> <p>Any given <code>keys</code> that are not found are ignored.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-store"> <span class="method-callseq"> store(key, value) </span> </div> <div class="method-description"> <p><a href="hash#method-i-store"><code>Hash#store</code></a> is an alias for <a href="hash#method-i-5B-5D-3D"><code>Hash#[]=</code></a>.</p> <p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p> <p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:foo] = 2 # =&gt; 2
h.store(:bar, 3) # =&gt; 3
h # =&gt; {:foo=&gt;2, :bar=&gt;3}
</pre> <p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1}
h[:baz] = 2 # =&gt; 2
h.store(:bat, 3) # =&gt; 3
h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}
</pre> </div> <div class="aliases"> Alias for: <a href="hash#method-i-5B-5D-3D">[]=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_a(VALUE hash)
{
    VALUE ary;

    ary = rb_ary_new_capa(RHASH_SIZE(hash));
    rb_hash_foreach(hash, to_a_i, ary);

    return ary;
}</pre> </div> <p>Returns a new Array of 2-element Array objects; each nested Array contains a key-value pair from <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.to_a # =&gt; [[:foo, 0], [:bar, 1], [:baz, 2]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → self or new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h {|key, value| ... } → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_h(VALUE hash)
{
    if (rb_block_given_p()) {
        return rb_hash_to_h_block(hash);
    }
    if (rb_obj_class(hash) != rb_cHash) {
        const VALUE flags = RBASIC(hash)-&gt;flags;
        hash = hash_dup(hash, rb_cHash, flags &amp; RHASH_PROC_DEFAULT);
    }
    return hash;
}</pre> </div> <p>For an instance of Hash, returns <code>self</code>.</p> <p>For a subclass of Hash, returns a new Hash containing the content of <code>self</code>.</p> <p>When a block is given, returns a new Hash object whose content is based on the block; the block should return a 2-element Array object specifying the key-value pair to be included in the returned Array:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.to_h {|key, value| [value, key] }
h1 # =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_hash"> <span class="method-callseq"> to_hash → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_hash(VALUE hash)
{
    return hash;
}</pre> </div> <p>Returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_proc"> <span class="method-callseq"> to_proc → proc </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_proc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_proc(VALUE hash)
{
    return rb_func_lambda_new(hash_proc_call, hash, 1, 1);
}</pre> </div> <p>Returns a Proc object that maps a key to its value:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
proc = h.to_proc
proc.class # =&gt; Proc
proc.call(:foo) # =&gt; 0
proc.call(:bar) # =&gt; 1
proc.call(:nosuch) # =&gt; nil
</pre>  </div> </div> <div id="method-i-to_s" class="method-detail method-alias"> <div class="method-description"> <p>Returns a new String containing the hash entries:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.inspect # =&gt; "{:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}"
</pre> <p><a href="hash#method-i-to_s"><code>Hash#to_s</code></a> is an alias for <a href="hash#method-i-inspect"><code>Hash#inspect</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="hash#method-i-inspect">inspect</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_keys"> <span class="method-callseq"> transform_keys {|key| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys(hash2) → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys(hash2) {|other_key| ...} → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_keys-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_keys(int argc, VALUE *argv, VALUE hash)
{
    VALUE result;
    struct transform_keys_args transarg = {0};

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        transarg.trans = to_hash(argv[0]);
        transarg.block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        if (transarg.trans) {
            transarg.result = result;
            rb_hash_foreach(hash, transform_keys_hash_i, (VALUE)&amp;transarg);
        }
        else {
            rb_hash_foreach(hash, transform_keys_i, result);
        }
    }

    return result;
}</pre> </div> <p>Returns a new Hash object; each entry has:</p> <ul>
<li> <p>A key provided by the block.</p> </li>
<li> <p>The value from <code>self</code>.</p> </li>
</ul> <p>An optional hash argument can be provided to map keys to new keys. Any key not given will be mapped using the provided block, or remain the same if no block is given.</p> <p>Transform keys:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.transform_keys {|key| key.to_s }
h1 # =&gt; {"foo"=&gt;0, "bar"=&gt;1, "baz"=&gt;2}

h.transform_keys(foo: :bar, bar: :foo)
#=&gt; {bar: 0, foo: 1, baz: 2}

h.transform_keys(foo: :hello, &amp;:to_s)
#=&gt; {:hello=&gt;0, "bar"=&gt;1, "baz"=&gt;2}
</pre> <p>Overwrites values for duplicate keys:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.transform_keys {|key| :bat }
h1 # =&gt; {:bat=&gt;2}
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.transform_keys # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_keys&gt;
h1 = e.each { |key| key.to_s }
h1 # =&gt; {"foo"=&gt;0, "bar"=&gt;1, "baz"=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_keys-21"> <span class="method-callseq"> transform_keys! {|key| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys!(hash2) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys!(hash2) {|other_key| ...} → self </span> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys! → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_keys-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_keys_bang(int argc, VALUE *argv, VALUE hash)
{
    VALUE trans = 0;
    int block_given = 0;

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        trans = to_hash(argv[0]);
        block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        long i;
        VALUE pairs = rb_hash_flatten(0, NULL, hash);
        rb_hash_clear(hash);
        for (i = 0; i &lt; RARRAY_LEN(pairs); i += 2) {
            VALUE key = RARRAY_AREF(pairs, i), new_key, val;

            if (!trans) {
                new_key = rb_yield(key);
            }
            else if ((new_key = rb_hash_lookup2(trans, key, Qundef)) != Qundef) {
                /* use the transformed key */
            }
            else if (block_given) {
                new_key = rb_yield(key);
            }
            else {
                new_key = key;
            }
            val = RARRAY_AREF(pairs, i+1);
            rb_hash_aset(hash, new_key, val);
        }
    }
    return hash;
}</pre> </div> <p>Same as <a href="hash#method-i-transform_keys"><code>Hash#transform_keys</code></a> but modifies the receiver in place instead of returning a new hash.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_values"> <span class="method-callseq"> transform_values {|value| ... } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_values → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_values-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_values(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_copy(hash_alloc(rb_cHash), hash);
    SET_DEFAULT(result, Qnil);

    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(result, transform_values_foreach_func, transform_values_foreach_replace, result);
    }

    return result;
}</pre> </div> <p>Returns a new Hash object; each entry has:</p> <ul>
<li> <p>A key from <code>self</code>.</p> </li>
<li> <p>A value provided by the block.</p> </li>
</ul> <p>Transform values:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = h.transform_values {|value| value * 100}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.transform_values # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_values&gt;
h1 = e.each { |value| value * 100}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_values-21"> <span class="method-callseq"> transform_values! {|value| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_values! → new_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_values-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_values_bang(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);

    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(hash, transform_values_foreach_func, transform_values_foreach_replace, hash);
    }

    return hash;
}</pre> </div> <p>Returns <code>self</code>, whose keys are unchanged, and whose values are determined by the given block.</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.transform_values! {|value| value * 100} # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre> <p>Returns a new Enumerator if no block given:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
e = h.transform_values! # =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}:transform_values!&gt;
h1 = e.each {|value| value * 100}
h1 # =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}
</pre>  </div> </div> <div id="method-i-update" class="method-detail "> <div class="method-description">
<div class="method-source-code" id="update-source"> <pre class="c" data-language="c">static VALUE
rb_hash_update(int argc, VALUE *argv, VALUE self)
{
    int i;
    bool block_given = rb_block_given_p();

    rb_hash_modify(self);
    for (i = 0; i &lt; argc; i++){
       VALUE hash = to_hash(argv[i]);
       if (block_given) {
           rb_hash_foreach(hash, rb_hash_update_block_i, self);
       }
       else {
           rb_hash_foreach(hash, rb_hash_update_i, self);
       }
    }
    return self;
}</pre> </div> <p>Merges each of <code>other_hashes</code> into <code>self</code>; returns <code>self</code>.</p> <p>Each argument in <code>other_hashes</code> must be a Hash.</p> <p>Method <a href="hash#method-i-update"><code>update</code></a> is an alias for #merge!.</p> <p>With arguments and no block:</p> <ul>
<li> <p>Returns <code>self</code>, after the given hashes are merged into it.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new entry is added at the end.</p> </li>
<li> <p>Each duplicate-key entry's value overwrites the previous value.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h.merge!(h1, h2) # =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}
</pre> <p>With arguments and a block:</p> <ul>
<li> <p>Returns <code>self</code>, after the given hashes are merged.</p> </li>
<li> <p>The given hashes are merged left to right.</p> </li>
<li> <p>Each new-key entry is added at the end.</p> </li>
<li> <p>For each duplicate key:</p> <ul>
<li> <p>Calls the block with the key and the old and new values.</p> </li>
<li> <p>The block's return value becomes the new value for the entry.</p> </li>
</ul> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h1 = {bat: 3, bar: 4}
h2 = {bam: 5, bat:6}
h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
h3 # =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}
</pre> <p>With no arguments:</p> <ul>
<li> <p>Returns <code>self</code>, unmodified.</p> </li>
<li> <p>The block, if given, is ignored.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.merge # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
h1 # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-merge-21">merge!</a> </div> </div> <div id="method-i-value-3F" class="method-detail method-alias"> <div class="method-description"> <p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p> </div> <div class="aliases"> Alias for: <a href="hash#method-i-has_value-3F">has_value?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values"> <span class="method-callseq"> values → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="c" data-language="c">VALUE
rb_hash_values(VALUE hash)
{
    VALUE values;
    st_index_t size = RHASH_SIZE(hash);

    values = rb_ary_new_capa(size);
    if (size == 0) return values;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        if (RHASH_AR_TABLE_P(hash)) {
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = ar_values(hash, ptr, size);
            });
        }
        else if (RHASH_ST_TABLE_P(hash)) {
            st_table *table = RHASH_ST_TABLE(hash);
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = st_values(table, ptr, size);
            });
        }
        rb_ary_set_len(values, size);
    }

    else {
        rb_hash_foreach(hash, values_i, values);
    }

    return values;
}</pre> </div> <p>Returns a new Array containing all values in <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.values # =&gt; [0, 1, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(*keys) → new_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">VALUE
rb_hash_values_at(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_aref(hash, argv[i]));
    }
    return result;
}</pre> </div> <p>Returns a new Array containing values for the given <code>keys</code>:</p> <pre class="ruby" data-language="ruby">h = {foo: 0, bar: 1, baz: 2}
h.values_at(:baz, :foo) # =&gt; [2, 0]
</pre> <p>The <a href="#class-Hash-label-Default+Values">default values</a> are returned for any keys that are not found:</p> <pre class="ruby" data-language="ruby">h.values_at(:hello, :foo) # =&gt; [nil, 0]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
