
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>MemorySegment - OpenJDK 21 - W3cubDocs</title>
  
  <meta name="description" content=" There are two kinds of memory segments&#58; ">
  <meta name="keywords" content="interface, memorysegment, openjdk, openjdk~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~21/java.base/java/lang/foreign/memorysegment.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/openjdk~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~21/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<h1 title="Interface MemorySegment" class="title">Interface MemorySegment</h1> <section class="class-description" id="class-description">  <pre class="lang-java" data-language="java">public sealed interface MemorySegment</pre> <div class="preview-block" id="preview-java.lang.foreign.MemorySegment">
<span class="preview-label"><code>MemorySegment</code> is a preview API of the Java platform.</span> <div class="preview-comment">Programs can only use <code>MemorySegment</code> when preview features are enabled.</div> <div class="preview-comment">Preview features may be removed in a future release, or upgraded to permanent features of the Java platform.</div> </div> <div class="block">A memory segment provides access to a contiguous region of memory. <p> There are two kinds of memory segments: </p>
<ul> <li>A <em>heap segment</em> is backed by, and provides access to, a region of memory inside the Java heap (an "on-heap" region).</li> <li>A <em>native segment</em> is backed by, and provides access to, a region of memory outside the Java heap (an "off-heap" region).</li> </ul> Heap segments can be obtained by calling one of the <a href="#ofArray(int%5B%5D)"><code>ofArray(int[])</code></a> factory methods. These methods return a memory segment backed by the on-heap region that holds the specified Java array. <p> Native segments can be obtained by calling one of the <a href="arena#allocate(long,long)"><code>Arena.allocate(long, long)</code></a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup> factory methods, which return a memory segment backed by a newly allocated off-heap region with the given size and aligned to the given alignment constraint. Alternatively, native segments can be obtained by <a href="../../nio/channels/filechannel#map(java.nio.channels.FileChannel.MapMode,long,long,java.lang.foreign.Arena)"><code>mapping</code></a><sup><a href="../../nio/channels/filechannel#preview-map(java.nio.channels.FileChannel.MapMode,long,long,java.lang.foreign.Arena)">PREVIEW</a></sup> a file into a new off-heap region (in some systems, this operation is sometimes referred to as <code>mmap</code>). Segments obtained in this way are called <em>mapped</em> segments, and their contents can be <a href="#force()">persisted</a> and <a href="#load()">loaded</a> to and from the underlying memory-mapped file. </p>
<p> Both kinds of segments are read and written using the same methods, known as <a href="#segment-deref">access operations</a>. An access operation on a memory segment always and only provides access to the region for which the segment was obtained. </p>
<h2 id="segment-characteristics">Characteristics of memory segments</h2> Every memory segment has an <a href="#address()">address</a>, expressed as a <code>long</code> value. The nature of a segment's address depends on the kind of the segment: <ul> <li>The address of a heap segment is not a physical address, but rather an offset within the region of memory which backs the segment. The region is inside the Java heap, so garbage collection might cause the region to be relocated in physical memory over time, but this is not exposed to clients of the <code>MemorySegment</code> API who see a stable <em>virtualized</em> address for a heap segment backed by the region. A heap segment obtained from one of the <a href="#ofArray(int%5B%5D)"><code>ofArray(int[])</code></a> factory methods has an address of zero.</li> <li>The address of a native segment (including mapped segments) denotes the physical address of the region of memory which backs the segment.</li> </ul> <p> Every memory segment has a <a href="#byteSize()">size</a>. The size of a heap segment is derived from the Java array from which it is obtained. This size is predictable across Java runtimes. The size of a native segment is either passed explicitly (as in <a href="arena#allocate(long,long)"><code>Arena.allocate(long, long)</code></a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup>) or derived from a <a href="memorylayout" title="interface in java.lang.foreign"><code>MemoryLayout</code></a><sup><a href="memorylayout#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup> (as in <a href="segmentallocator#allocate(java.lang.foreign.MemoryLayout)"><code>SegmentAllocator.allocate(MemoryLayout)</code></a><sup><a href="segmentallocator#preview-java.lang.foreign.SegmentAllocator">PREVIEW</a></sup>). The size of a memory segment is typically a positive number but may be <a href="#wrapping-addresses">zero</a>, but never negative. </p>
<p> The address and size of a memory segment jointly ensure that access operations on the segment cannot fall <em>outside</em> the boundaries of the region of memory which backs the segment. That is, a memory segment has <em>spatial bounds</em>. </p>
<p> Every memory segment is associated with a <a href="memorysegment.scope" title="interface in java.lang.foreign">scope</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>. This ensures that access operations on a memory segment cannot occur when the region of memory which backs the memory segment is no longer available (e.g., after the scope associated with the accessed memory segment is no longer <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>). That is, a memory segment has <em>temporal bounds</em>. </p>
<p> Finally, access operations on a memory segment can be subject to additional thread-confinement checks. Heap segments can be accessed from any thread. Conversely, native segments can only be accessed compatibly with the <a href="arena#thread-confinement">confinement characteristics</a> of the arena used to obtain them. </p>
<h2 id="segment-deref">Accessing memory segments</h2> A memory segment can be read or written using various access operations provided in this class (e.g. <a href="#get(java.lang.foreign.ValueLayout.OfInt,long)"><code>get(ValueLayout.OfInt, long)</code></a>). Each access operation takes a <a href="valuelayout" title="interface in java.lang.foreign">value layout</a><sup><a href="valuelayout#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>, which specifies the size and shape of the value, and an offset, expressed in bytes. For instance, to read an int from a segment, using <a href="../../nio/byteorder#nativeOrder()">default endianness</a>, the following code can be used: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment segment = ...
int value = segment.get(ValueLayout.JAVA_INT, 0);
</code></pre> </div> If the value to be read is stored in memory using <a href="../../nio/byteorder#BIG_ENDIAN">big-endian</a> encoding, the access operation can be expressed as follows: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment segment = ...
int value = segment.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);
</code></pre> </div> For more complex access operations (e.g. structured memory access), clients can obtain a <a href="../invoke/methodhandles#memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)">var handle</a><sup><a href="../invoke/methodhandles#preview-memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)">PREVIEW</a></sup> that accepts a segment and a <code>long</code> offset. More complex var handles can be obtained by adapting a segment var handle view using the var handle combinator functions defined in the <a href="../invoke/methodhandles" title="class in java.lang.invoke"><code>MethodHandles</code></a> class: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment segment = ...
VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);
MethodHandle multiplyExact = MethodHandles.lookup()
                                          .findStatic(Math.class, "multiplyExact",
                                                                  MethodType.methodType(long.class, long.class, long.class));
intHandle = MethodHandles.filterCoordinates(intHandle, 1,
                                            MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));
int value = (int) intHandle.get(segment, 3L); // get int element at offset 3 * 4 = 12
</code></pre> </div> Alternatively, complex var handles can can be obtained from <a href="memorylayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...)">memory layouts</a><sup><a href="memorylayout#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup> by providing a so called <a href="memorylayout#layout-paths"><em>layout path</em></a>: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment segment = ...
VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();
int value = (int) intHandle.get(segment, 3L); // get int element at offset 3 * 4 = 12
</code></pre> </div> <h2 id="slicing">Slicing memory segments</h2> Memory segments support <a href="#asSlice(long,long)">slicing</a>. Slicing a memory segment returns a new memory segment that is backed by the same region of memory as the original. The address of the sliced segment is derived from the address of the original segment, by adding an offset (expressed in bytes). The size of the sliced segment is either derived implicitly (by subtracting the specified offset from the size of the original segment), or provided explicitly. In other words, a sliced segment has <em>stricter</em> spatial bounds than those of the original segment: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java"> Arena arena = ...
 MemorySegment segment = arena.allocate(100);
 MemorySegment slice = segment.asSlice(50, 10);
 slice.get(ValueLayout.JAVA_INT, 20); // Out of bounds!
 arena.close();
 slice.get(ValueLayout.JAVA_INT, 0); // Already closed!
</code></pre> </div> The above code creates a native segment that is 100 bytes long; then, it creates a slice that starts at offset 50 of <code>segment</code>, and is 10 bytes long. That is, the address of the <code>slice</code> is <code>segment.address() + 50</code>, and its size is 10. As a result, attempting to read an int value at offset 20 of the <code>slice</code> segment will result in an exception. The <a href="arena" title="interface in java.lang.foreign">temporal bounds</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup> of the original segment is inherited by its slices; that is, when the scope associated with <code>segment</code> is no longer <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>, <code>slice</code> will also be become inaccessible. <p> A client might obtain a <a href="../../util/stream/stream" title="interface in java.util.stream"><code>Stream</code></a> from a segment, which can then be used to slice the segment (according to a given element layout) and even allow multiple threads to work in parallel on disjoint segment slices (to do this, the segment has to be <a href="#isAccessibleBy(java.lang.Thread)">accessible</a> from multiple threads). The following code can be used to sum all int values in a memory segment in parallel: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java"> try (Arena arena = Arena.ofShared()) {
     SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);
     MemorySegment segment = arena.allocate(SEQUENCE_LAYOUT);
     int sum = segment.elements(ValueLayout.JAVA_INT).parallel()
                      .mapToInt(s -&gt; s.get(ValueLayout.JAVA_INT, 0))
                      .sum();
 }
</code></pre> </div> <h2 id="segment-alignment">Alignment</h2> Access operations on a memory segment are constrained not only by the spatial and temporal bounds of the segment, but also by the <em>alignment constraint</em> of the value layout specified to the operation. An access operation can access only those offsets in the segment that denote addresses in physical memory which are <em>aligned</em> according to the layout. An address in physical memory is <em>aligned</em> according to a layout if the address is an integer multiple of the layout's alignment constraint. For example, the address 1000 is aligned according to an 8-byte alignment constraint (because 1000 is an integer multiple of 8), and to a 4-byte alignment constraint, and to a 2-byte alignment constraint; in contrast, the address 1004 is aligned according to a 4-byte alignment constraint, and to a 2-byte alignment constraint, but not to an 8-byte alignment constraint. Access operations are required to respect alignment because it can impact the performance of access operations, and can also determine which access operations are available at a given physical address. For instance, <a href="../invoke/varhandle#compareAndSet(java.lang.Object...)">atomic access operations</a> operations using <a href="../invoke/varhandle" title="class in java.lang.invoke"><code>VarHandle</code></a> are only permitted at aligned addresses. In addition, alignment applies to an access operation whether the segment being accessed is a native segment or a heap segment. <p> If the segment being accessed is a native segment, then its <a href="#address()">address</a> in physical memory can be combined with the offset to obtain the <em>target address</em> in physical memory. The pseudo-function below demonstrates this: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {
  return ((segment.address() + offset) % layout.byteAlignment()) == 0;
}
</code></pre> </div> For example: <ul> <li>A native segment with address 1000 can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint, because the target addresses (1000, 1008, 1016, 1024) are 8-byte aligned. Access at offsets 1-7 or 9-15 or 17-23 is disallowed because the target addresses would not be 8-byte aligned.</li> <li>A native segment with address 1000 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. Access at offsets 1-3 or 5-7 or 9-11 is disallowed because the target addresses would not be 4-byte aligned.</li> <li>A native segment with address 1000 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses (1000, 1002, 1004, 1006) are 2-byte aligned. Access at offsets 1 or 3 or 5 is disallowed because the target addresses would not be 2-byte aligned.</li> <li>A native segment with address 1004 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, and at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint. Under an 8-byte alignment constraint, it can be accessed at offsets 4, 12, 20, 28, etc.</li> <li>A native segment with address 1006 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint. Under a 4-byte alignment constraint, it can be accessed at offsets 2, 6, 10, 14, etc. Under an 8-byte alignment constraint, it can be accessed at offsets 2, 10, 18, 26, etc. </li>
<li>A native segment with address 1007 can be accessed at offsets 0, 1, 2, 3, etc under a 1-byte alignment constraint. Under a 2-byte alignment constraint, it can be accessed at offsets 1, 3, 5, 7, etc. Under a 4-byte alignment constraint, it can be accessed at offsets 1, 5, 9, 13, etc. Under an 8-byte alignment constraint, it can be accessed at offsets 1, 9, 17, 25, etc.</li> </ul> <p> The alignment constraint used to access a segment is typically dictated by the shape of the data structure stored in the segment. For example, if the programmer wishes to store a sequence of 8-byte values in a native segment, then the segment should be allocated by specifying a 8-byte alignment constraint, either via <a href="arena#allocate(long,long)"><code>Arena.allocate(long, long)</code></a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup> or <a href="segmentallocator#allocate(java.lang.foreign.MemoryLayout)"><code>SegmentAllocator.allocate(MemoryLayout)</code></a><sup><a href="segmentallocator#preview-java.lang.foreign.SegmentAllocator">PREVIEW</a></sup>. These factories ensure that the off-heap region of memory backing the returned segment has a starting address that is 8-byte aligned. Subsequently, the programmer can access the segment at the offsets of interest -- 0, 8, 16, 24, etc -- in the knowledge that every such access is aligned. </p>
<p> If the segment being accessed is a heap segment, then determining whether access is aligned is more complex. The address of the segment in physical memory is not known, and is not even fixed (it may change when the segment is relocated during garbage collection). This means that the address cannot be combined with the specified offset to determine a target address in physical memory. Since the alignment constraint <em>always</em> refers to alignment of addresses in physical memory, it is not possible in principle to determine if any offset in a heap segment is aligned. For example, suppose the programmer chooses a 8-byte alignment constraint and tries to access offset 16 in a heap segment. If the heap segment's address 0 corresponds to physical address 1000, then the target address (1016) would be aligned, but if address 0 corresponds to physical address 1004, then the target address (1020) would not be aligned. It is undesirable to allow access to target addresses that are aligned according to the programmer's chosen alignment constraint, but might not be predictably aligned in physical memory (e.g. because of platform considerations and/or garbage collection behavior). </p>
<p> In practice, the Java runtime lays out arrays in memory so that each n-byte element occurs at an n-byte aligned physical address (except for <code>long[]</code> and <code>double[]</code>, where alignment is platform-dependent, as explained below). The runtime preserves this invariant even if the array is relocated during garbage collection. Access operations rely on this invariant to determine if the specified offset in a heap segment refers to an aligned address in physical memory. For example: </p>
<ul> <li>The starting physical address of a <code>short[]</code> array will be 2-byte aligned (e.g. 1006) so that successive short elements occur at 2-byte aligned addresses (e.g. 1006, 1008, 1010, 1012, etc). A heap segment backed by a <code>short[]</code> array can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint. The segment cannot be accessed at <em>any</em> offset under a 4-byte alignment constraint, because there is no guarantee that the target address would be 4-byte aligned, e.g., offset 0 would correspond to physical address 1006 while offset 1 would correspond to physical address 1007. Similarly, the segment cannot be accessed at any offset under an 8-byte alignment constraint, because because there is no guarantee that the target address would be 8-byte aligned, e.g., offset 2 would correspond to physical address 1008 but offset 4 would correspond to physical address 1010.</li> <li>The starting physical address of a <code>long[]</code> array will be 8-byte aligned (e.g. 1000) on 64-bit platforms, so that successive long elements occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) On 64-bit platforms, a heap segment backed by a <code>long[]</code> array can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.</li> <li>The starting physical address of a <code>long[]</code> array will be 4-byte aligned (e.g. 1004) on 32-bit platforms, so that successive long elements occur at 4-byte aligned addresses (e.g., 1004, 1008, 1012, 1016, etc.) On 32-bit platforms, a heap segment backed by a <code>long[]</code> array can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses (1004, 1008, 1012, 1016) are 4-byte aligned. And, the segment can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.</li> </ul> <p> In other words, heap segments feature a (platform-dependent) <em>maximum</em> alignment which is derived from the size of the elements of the Java array backing the segment, as shown in the following table: </p>
<blockquote><table class="plain"> <caption style="display:none">Maximum alignment of heap segments</caption> <thead> <tr> <th scope="col">Array type (of backing region)</th> <th scope="col">Maximum supported alignment (in bytes)</th> </tr> </thead> <tbody> <tr>
<th scope="row" style="font-weight:normal"><code>boolean[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_BOOLEAN.byteAlignment()</code></td>
</tr> <tr>
<th scope="row" style="font-weight:normal"><code>byte[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_BYTE.byteAlignment()</code></td>
</tr> <tr>
<th scope="row" style="font-weight:normal"><code>char[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_CHAR.byteAlignment()</code></td>
</tr> <tr>
<th scope="row" style="font-weight:normal"><code>short[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_SHORT.byteAlignment()</code></td>
</tr> <tr>
<th scope="row" style="font-weight:normal"><code>int[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_INT.byteAlignment()</code></td>
</tr> <tr>
<th scope="row" style="font-weight:normal"><code>float[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_FLOAT.byteAlignment()</code></td>
</tr> <tr>
<th scope="row" style="font-weight:normal"><code>long[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_LONG.byteAlignment()</code></td>
</tr> <tr>
<th scope="row" style="font-weight:normal"><code>double[]</code></th> <td style="text-align:center;"><code>ValueLayout.JAVA_DOUBLE.byteAlignment()</code></td>
</tr> </tbody> </table></blockquote> Heap segments can only be accessed using a layout whose alignment is smaller or equal to the maximum alignment associated with the heap segment. Attempting to access a heap segment using a layout whose alignment is greater than the maximum alignment associated with the heap segment will fail, as demonstrated in the following example: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);
byteSegment.get(ValueLayout.JAVA_INT, 0); // fails: ValueLayout.JAVA_INT.byteAlignment() &gt; ValueLayout.JAVA_BYTE.byteAlignment()
</code></pre> </div> In such circumstances, clients have two options. They can use a heap segment backed by a different array type (e.g. <code>long[]</code>), capable of supporting greater maximum alignment. More specifically, the maximum alignment associated with <code>long[]</code> is set to <code>ValueLayout.JAVA_LONG.byteAlignment()</code> which is a platform-dependent value (set to <code>ValueLayout.ADDRESS.byteSize()</code>). That is, <code>long[]</code>) is guaranteed to provide at least 8-byte alignment in 64-bit platforms, but only 4-byte alignment in 32-bit platforms: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment longSegment = MemorySegment.ofArray(new long[10]);
longSegment.get(ValueLayout.JAVA_INT, 0); // ok: ValueLayout.JAVA_INT.byteAlignment() &lt;= ValueLayout.JAVA_LONG.byteAlignment()
</code></pre> </div> Alternatively, they can invoke the access operation with an <em>unaligned layout</em>. All unaligned layout constants (e.g. <a href="valuelayout#JAVA_INT_UNALIGNED"><code>ValueLayout.JAVA_INT_UNALIGNED</code></a><sup><a href="valuelayout#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>) have their alignment constraint set to 1: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);
byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); // ok: ValueLayout.JAVA_INT_UNALIGNED.byteAlignment() == ValueLayout.JAVA_BYTE.byteAlignment()
</code></pre> </div> <h2 id="wrapping-addresses">Zero-length memory segments</h2> When interacting with <a href="package-summary#ffa">foreign functions</a>, it is common for those functions to allocate a region of memory and return a pointer to that region. Modeling the region of memory with a memory segment is challenging because the Java runtime has no insight into the size of the region. Only the address of the start of the region, stored in the pointer, is available. For example, a C function with return type <code>char*</code> might return a pointer to a region containing a single <code>char</code> value, or to a region containing an array of <code>char</code> values, where the size of the array might be provided in a separate parameter. The size of the array is not readily apparent to the code calling the foreign function and hoping to use its result. In addition to having no insight into the size of the region of memory backing a pointer returned from a foreign function, it also has no insight into the lifetime intended for said region of memory by the foreign function that allocated it. <p> The <code>MemorySegment</code> API uses <em>zero-length memory segments</em> to represent: </p>
<ul> <li>pointers <a href="linker#by-ref">returned from a foreign function</a>;</li> <li>pointers <a href="linker#function-pointers">passed by a foreign function to an upcall stub</a>; and</li> <li>pointers read from a memory segment (more on that below).</li> </ul> The address of the zero-length segment is the address stored in the pointer. The spatial and temporal bounds of the zero-length segment are as follows: <ul> <li>The size of the segment is zero. any attempt to access these segments will fail with <a href="../indexoutofboundsexception" title="class in java.lang"><code>IndexOutOfBoundsException</code></a>. This is a crucial safety feature: as these segments are associated with a region of memory whose size is not known, any access operations involving these segments cannot be validated. In effect, a zero-length memory segment <em>wraps</em> an address, and it cannot be used without explicit intent (see below);</li> <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length memory segments cannot be accessed directly, they can be passed, opaquely, to other pointer-accepting foreign functions.</li> </ul> <p> To demonstrate how clients can work with zero-length memory segments, consider the case of a client that wants to read a pointer from some memory segment. This can be done via the <a href="#get(java.lang.foreign.AddressLayout,long)">get(AddressLayout, long)</a> access method. This method accepts an <a href="addresslayout" title="interface in java.lang.foreign">address layout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> (e.g. <a href="valuelayout#ADDRESS"><code>ValueLayout.ADDRESS</code></a><sup><a href="valuelayout#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>), the layout of the pointer to be read. For instance on a 64-bit platform, the size of an address layout is 8 bytes. The access operation also accepts an offset, expressed in bytes, which indicates the position (relative to the start of the memory segment) at which the pointer is stored. The access operation returns a zero-length native memory segment, backed by a region of memory whose starting address is the 64-bit value read at the specified offset. </p>
<p> The returned zero-length memory segment cannot be accessed directly by the client: since the size of the segment is zero, any access operation would result in out-of-bounds access. Instead, the client must, <em>unsafely</em>, assign new spatial bounds to the zero-length memory segment. This can be done via the <a href="#reinterpret(long)"><code>reinterpret(long)</code></a> method, as follows: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java"> MemorySegment z = segment.get(ValueLayout.ADDRESS, ...);   // size = 0
 MemorySegment ptr = z.reinterpret(16);                     // size = 16
 int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);           // ok
</code></pre> </div> <p> In some cases, the client might additionally want to assign new temporal bounds to a zero-length memory segment. This can be done via the <a href="#reinterpret(long,java.lang.foreign.Arena,java.util.function.Consumer)"><code>reinterpret(long, Arena, Consumer)</code></a> method, which returns a new native segment with the desired size and the same temporal bounds as those of the provided arena: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java"> MemorySegment ptr = null;
 try (Arena arena = Arena.ofConfined()) {
       MemorySegment z = segment.get(ValueLayout.ADDRESS, ...);    // size = 0, scope = always alive
       ptr = z.reinterpret(16, arena, null);                       // size = 4, scope = arena.scope()
       int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);            // ok
 }
 int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);                  // throws IllegalStateException
</code></pre> </div> Alternatively, if the size of the region of memory backing the zero-length memory segment is known statically, the client can overlay a <a href="addresslayout#withTargetLayout(java.lang.foreign.MemoryLayout)">target layout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> on the address layout used when reading a pointer. The target layout is then used to dynamically <em>expand</em> the size of the native memory segment returned by the access operation, so that the size of the segment is the same as the size of the target layout. In other words, the returned segment is no longer a zero-length memory segment, and the pointer it represents can be dereferenced directly: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java"> AddressLayout intArrPtrLayout = ValueLayout.ADDRESS.withTargetLayout(
         MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT)); // layout for int (*ptr)[4]
 MemorySegment ptr = segment.get(intArrPtrLayout, ...);         // size = 16
 int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);               // ok
</code></pre> </div> <p> All the methods which can be used to manipulate zero-length memory segments (<a href="#reinterpret(long)"><code>reinterpret(long)</code></a>, <a href="#reinterpret(java.lang.foreign.Arena,java.util.function.Consumer)"><code>reinterpret(Arena, Consumer)</code></a>, <a href="#reinterpret(long,java.lang.foreign.Arena,java.util.function.Consumer)"><code>reinterpret(long, Arena, Consumer)</code></a> and <a href="addresslayout#withTargetLayout(java.lang.foreign.MemoryLayout)"><code>AddressLayout.withTargetLayout(MemoryLayout)</code></a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup>) are <a href="package-summary#restricted"><em>restricted</em></a> methods, and should be used with caution: assigning a segment incorrect spatial and/or temporal bounds could result in a VM crash when attempting to access the memory segment.</p>
</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>Implementations of this interface are immutable, thread-safe and <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.</dd> <dt>Since:</dt> <dd>19</dd> </dl> </section> <section class="summary"> <section class="nested-class-summary" id="nested-class-summary"> <h2>Nested Class Summary</h2>  <table class="summary-table three-column-summary">       <tr>
<th>Modifier and Type</th>
<th>Interface</th>
<th>Description</th>
</tr>
<tr>
<td><code>static interface </code></td>
<td><code><a href="memorysegment.scope" class="type-name-link" title="interface in java.lang.foreign">MemorySegment.Scope</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup></code></td>
<td> <div class="block"><span class="preview-label">Preview.</span></div> <div class="block">A scope models the <em>lifetime</em> of all the memory segments associated with it.</div> </td>
</tr>
</table> </section><section class="field-summary" id="field-summary"> <h2>Field Summary</h2>  <table class="summary-table three-column-summary">       <tr>
<th>Modifier and Type</th>
<th>Field</th>
<th>Description</th>
</tr>
<tr>
<td><code>static final <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#NULL" class="member-name-link">NULL</a></code></td>
<td> <div class="block">A zero-length native segment modelling the <code>NULL</code> address.</div> </td>
</tr>
</table> </section><section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                                                                                                                                                                                                                               <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#address()" class="member-name-link">address</a>()</code></td>
<td> <div class="block">Returns the address of this memory segment.</div> </td>
</tr>
<tr>
<td><code><a href="../../nio/bytebuffer" title="class in java.nio">ByteBuffer</a></code></td>
<td><code><a href="#asByteBuffer()" class="member-name-link">asByteBuffer</a>()</code></td>
<td> <div class="block">Wraps this segment in a <a href="../../nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a>.</div> </td>
</tr>
<tr>
<td><code><a href="../../util/optional" title="class in java.util">Optional</a><wbr>&lt;<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&gt;</wbr></code></td>
<td><code><a href="#asOverlappingSlice(java.lang.foreign.MemorySegment)" class="member-name-link">asOverlappingSlice</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> other)</wbr></code></td>
<td> <div class="block">Returns a slice of this segment that is the overlap between this and the provided segment.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#asReadOnly()" class="member-name-link">asReadOnly</a>()</code></td>
<td> <div class="block">Returns a read-only view of this segment.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#asSlice(long)" class="member-name-link">asSlice</a><wbr>(long offset)</wbr></code></td>
<td> <div class="block">Returns a slice of this memory segment, at the given offset.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#asSlice(long,long)" class="member-name-link">asSlice</a><wbr>(long offset,
 long newSize)</wbr></code></td>
<td> <div class="block">Returns a slice of this memory segment, at the given offset.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#asSlice(long,long,long)" class="member-name-link">asSlice</a><wbr>(long offset,
 long newSize,
 long byteAlignment)</wbr></code></td>
<td> <div class="block">Returns a slice of this memory segment, at the given offset, with the provided alignment constraint.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#asSlice(long,java.lang.foreign.MemoryLayout)" class="member-name-link">asSlice</a><wbr>(long offset,
 <a href="memorylayout" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="memorylayout#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup> layout)</wbr></code></td>
<td> <div class="block">Returns a slice of this memory segment with the given layout, at the given offset.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#byteSize()" class="member-name-link">byteSize</a>()</code></td>
<td> <div class="block">Returns the size (in bytes) of this memory segment.</div> </td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code><a href="#copy(java.lang.foreign.MemorySegment,long,java.lang.foreign.MemorySegment,long,long)" class="member-name-link">copy</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> srcSegment,
 long srcOffset,
 <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> dstSegment,
 long dstOffset,
 long bytes)</wbr></code></td>
<td> <div class="block">Performs a bulk copy from source segment to destination segment.</div> </td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code><a href="#copy(java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,long)" class="member-name-link">copy</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> srcSegment,
 <a href="valuelayout" title="interface in java.lang.foreign">ValueLayout</a><sup><a href="valuelayout#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup> srcElementLayout,
 long srcOffset,
 <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> dstSegment,
 <a href="valuelayout" title="interface in java.lang.foreign">ValueLayout</a><sup><a href="valuelayout#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup> dstElementLayout,
 long dstOffset,
 long elementCount)</wbr></code></td>
<td> <div class="block">Performs a bulk copy from source segment to destination segment.</div> </td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code><a href="#copy(java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,java.lang.Object,int,int)" class="member-name-link">copy</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> srcSegment,
 <a href="valuelayout" title="interface in java.lang.foreign">ValueLayout</a><sup><a href="valuelayout#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup> srcLayout,
 long srcOffset,
 <a href="../object" title="class in java.lang">Object</a> dstArray,
 int dstIndex,
 int elementCount)</wbr></code></td>
<td> <div class="block">Copies a number of elements from a source memory segment to a destination array.</div> </td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code><a href="#copy(java.lang.Object,int,java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,int)" class="member-name-link">copy</a><wbr>(<a href="../object" title="class in java.lang">Object</a> srcArray,
 int srcIndex,
 <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> dstSegment,
 <a href="valuelayout" title="interface in java.lang.foreign">ValueLayout</a><sup><a href="valuelayout#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup> dstLayout,
 long dstOffset,
 int elementCount)</wbr></code></td>
<td> <div class="block">Copies a number of elements from a source array to a destination memory segment.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#copyFrom(java.lang.foreign.MemorySegment)" class="member-name-link">copyFrom</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> src)</wbr></code></td>
<td> <div class="block">Performs a bulk copy from given source segment to this segment.</div> </td>
</tr>
<tr>
<td><code><a href="../../util/stream/stream" title="interface in java.util.stream">Stream</a><wbr>&lt;<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&gt;</wbr></code></td>
<td><code><a href="#elements(java.lang.foreign.MemoryLayout)" class="member-name-link">elements</a><wbr>(<a href="memorylayout" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="memorylayout#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Returns a sequential <code>Stream</code> over disjoint slices (whose size matches that of the specified layout) in this segment.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#equals(java.lang.Object)" class="member-name-link">equals</a><wbr>(<a href="../object" title="class in java.lang">Object</a> that)</wbr></code></td>
<td> <div class="block">Compares the specified object with this memory segment for equality.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#fill(byte)" class="member-name-link">fill</a><wbr>(byte value)</wbr></code></td>
<td> <div class="block">Fills the contents of this memory segment with the given value.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#force()" class="member-name-link">force</a>()</code></td>
<td> <div class="block">Forces any changes made to the contents of this mapped segment to be written to the storage device described by the mapped segment's file descriptor.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#get(java.lang.foreign.AddressLayout,long)" class="member-name-link">get</a><wbr>(<a href="addresslayout" title="interface in java.lang.foreign">AddressLayout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads an address from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfBoolean,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.ofboolean" title="interface in java.lang.foreign">ValueLayout.OfBoolean</a><sup><a href="valuelayout.ofboolean#preview-java.lang.foreign.ValueLayout.OfBoolean">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads a boolean from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default byte</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfByte,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.ofbyte" title="interface in java.lang.foreign">ValueLayout.OfByte</a><sup><a href="valuelayout.ofbyte#preview-java.lang.foreign.ValueLayout.OfByte">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads a byte from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default char</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfChar,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.ofchar" title="interface in java.lang.foreign">ValueLayout.OfChar</a><sup><a href="valuelayout.ofchar#preview-java.lang.foreign.ValueLayout.OfChar">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads a char from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default double</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfDouble,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.ofdouble" title="interface in java.lang.foreign">ValueLayout.OfDouble</a><sup><a href="valuelayout.ofdouble#preview-java.lang.foreign.ValueLayout.OfDouble">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads a double from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default float</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfFloat,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.offloat" title="interface in java.lang.foreign">ValueLayout.OfFloat</a><sup><a href="valuelayout.offloat#preview-java.lang.foreign.ValueLayout.OfFloat">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads a float from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default int</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfInt,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.ofint" title="interface in java.lang.foreign">ValueLayout.OfInt</a><sup><a href="valuelayout.ofint#preview-java.lang.foreign.ValueLayout.OfInt">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads an int from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default long</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfLong,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.oflong" title="interface in java.lang.foreign">ValueLayout.OfLong</a><sup><a href="valuelayout.oflong#preview-java.lang.foreign.ValueLayout.OfLong">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads a long from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default short</code></td>
<td><code><a href="#get(java.lang.foreign.ValueLayout.OfShort,long)" class="member-name-link">get</a><wbr>(<a href="valuelayout.ofshort" title="interface in java.lang.foreign">ValueLayout.OfShort</a><sup><a href="valuelayout.ofshort#preview-java.lang.foreign.ValueLayout.OfShort">PREVIEW</a></sup> layout,
 long offset)</wbr></code></td>
<td> <div class="block">Reads a short from this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.AddressLayout,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="addresslayout" title="interface in java.lang.foreign">AddressLayout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads an address from this segment at the given at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfBoolean,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.ofboolean" title="interface in java.lang.foreign">ValueLayout.OfBoolean</a><sup><a href="valuelayout.ofboolean#preview-java.lang.foreign.ValueLayout.OfBoolean">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads a boolean from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default byte</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfByte,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.ofbyte" title="interface in java.lang.foreign">ValueLayout.OfByte</a><sup><a href="valuelayout.ofbyte#preview-java.lang.foreign.ValueLayout.OfByte">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads a byte from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default char</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfChar,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.ofchar" title="interface in java.lang.foreign">ValueLayout.OfChar</a><sup><a href="valuelayout.ofchar#preview-java.lang.foreign.ValueLayout.OfChar">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads a char from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default double</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfDouble,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.ofdouble" title="interface in java.lang.foreign">ValueLayout.OfDouble</a><sup><a href="valuelayout.ofdouble#preview-java.lang.foreign.ValueLayout.OfDouble">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads a double from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default float</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfFloat,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.offloat" title="interface in java.lang.foreign">ValueLayout.OfFloat</a><sup><a href="valuelayout.offloat#preview-java.lang.foreign.ValueLayout.OfFloat">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads a float from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default int</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfInt,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.ofint" title="interface in java.lang.foreign">ValueLayout.OfInt</a><sup><a href="valuelayout.ofint#preview-java.lang.foreign.ValueLayout.OfInt">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads an int from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default long</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfLong,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.oflong" title="interface in java.lang.foreign">ValueLayout.OfLong</a><sup><a href="valuelayout.oflong#preview-java.lang.foreign.ValueLayout.OfLong">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads a long from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default short</code></td>
<td><code><a href="#getAtIndex(java.lang.foreign.ValueLayout.OfShort,long)" class="member-name-link">getAtIndex</a><wbr>(<a href="valuelayout.ofshort" title="interface in java.lang.foreign">ValueLayout.OfShort</a><sup><a href="valuelayout.ofshort#preview-java.lang.foreign.ValueLayout.OfShort">PREVIEW</a></sup> layout,
 long index)</wbr></code></td>
<td> <div class="block">Reads a short from this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default <a href="../string" title="class in java.lang">String</a></code></td>
<td><code><a href="#getUtf8String(long)" class="member-name-link">getUtf8String</a><wbr>(long offset)</wbr></code></td>
<td> <div class="block">Reads a UTF-8 encoded, null-terminated string from this segment at the given offset.</div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#hashCode()" class="member-name-link">hashCode</a>()</code></td>
<td> <div class="block">Returns the hash code value for this memory segment.</div> </td>
</tr>
<tr>
<td><code><a href="../../util/optional" title="class in java.util">Optional</a><wbr>&lt;<a href="../object" title="class in java.lang">Object</a>&gt;</wbr></code></td>
<td><code><a href="#heapBase()" class="member-name-link">heapBase</a>()</code></td>
<td> <div class="block">Returns the Java object stored in the on-heap region of memory backing this memory segment, if any.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isAccessibleBy(java.lang.Thread)" class="member-name-link">isAccessibleBy</a><wbr>(<a href="../thread" title="class in java.lang">Thread</a> thread)</wbr></code></td>
<td> <div class="block">Returns <code>true</code> if this segment can be accessed from the provided thread.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isLoaded()" class="member-name-link">isLoaded</a>()</code></td>
<td> <div class="block">Determines whether the contents of this mapped segment is resident in physical memory.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isMapped()" class="member-name-link">isMapped</a>()</code></td>
<td> <div class="block">Returns <code>true</code> if this segment is a mapped segment.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isNative()" class="member-name-link">isNative</a>()</code></td>
<td> <div class="block">Returns <code>true</code> if this segment is a native segment.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isReadOnly()" class="member-name-link">isReadOnly</a>()</code></td>
<td> <div class="block">Returns <code>true</code>, if this segment is read-only.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#load()" class="member-name-link">load</a>()</code></td>
<td> <div class="block">Loads the contents of this mapped segment into physical memory.</div> </td>
</tr>
<tr>
<td><code>default long</code></td>
<td><code><a href="#mismatch(java.lang.foreign.MemorySegment)" class="member-name-link">mismatch</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> other)</wbr></code></td>
<td> <div class="block">Finds and returns the offset, in bytes, of the first mismatch between this segment and the given other segment.</div> </td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code><a href="#mismatch(java.lang.foreign.MemorySegment,long,long,java.lang.foreign.MemorySegment,long,long)" class="member-name-link">mismatch</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> srcSegment,
 long srcFromOffset,
 long srcToOffset,
 <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> dstSegment,
 long dstFromOffset,
 long dstToOffset)</wbr></code></td>
<td> <div class="block">Finds and returns the relative offset, in bytes, of the first mismatch between the source and the destination segments.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofAddress(long)" class="member-name-link">ofAddress</a><wbr>(long address)</wbr></code></td>
<td> <div class="block">Creates a zero-length native segment from the given <a href="#address()">address value</a>.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofArray(byte%5B%5D)" class="member-name-link">ofArray</a><wbr>(byte[] byteArray)</wbr></code></td>
<td> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given byte array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofArray(char%5B%5D)" class="member-name-link">ofArray</a><wbr>(char[] charArray)</wbr></code></td>
<td> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given char array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofArray(double%5B%5D)" class="member-name-link">ofArray</a><wbr>(double[] doubleArray)</wbr></code></td>
<td> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given double array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofArray(float%5B%5D)" class="member-name-link">ofArray</a><wbr>(float[] floatArray)</wbr></code></td>
<td> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given float array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofArray(int%5B%5D)" class="member-name-link">ofArray</a><wbr>(int[] intArray)</wbr></code></td>
<td> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given int array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofArray(long%5B%5D)" class="member-name-link">ofArray</a><wbr>(long[] longArray)</wbr></code></td>
<td> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given long array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofArray(short%5B%5D)" class="member-name-link">ofArray</a><wbr>(short[] shortArray)</wbr></code></td>
<td> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given short array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#ofBuffer(java.nio.Buffer)" class="member-name-link">ofBuffer</a><wbr>(<a href="../../nio/buffer" title="class in java.nio">Buffer</a> buffer)</wbr></code></td>
<td> <div class="block">Creates a memory segment that is backed by the same region of memory that backs the given <a href="../../nio/buffer" title="class in java.nio"><code>Buffer</code></a> instance.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#reinterpret(long)" class="member-name-link">reinterpret</a><wbr>(long newSize)</wbr></code></td>
<td> <div class="block">Returns a new memory segment that has the same address and scope as this segment, but with the provided size.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#reinterpret(long,java.lang.foreign.Arena,java.util.function.Consumer)" class="member-name-link">reinterpret</a><wbr>(long newSize,
 <a href="arena" title="interface in java.lang.foreign">Arena</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup> arena,
 <a href="../../util/function/consumer" title="interface in java.util.function">Consumer</a>&lt;<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&gt; cleanup)</wbr></code></td>
<td> <div class="block">Returns a new segment with the same address as this segment, but with the provided size and scope.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup></code></td>
<td><code><a href="#reinterpret(java.lang.foreign.Arena,java.util.function.Consumer)" class="member-name-link">reinterpret</a><wbr>(<a href="arena" title="interface in java.lang.foreign">Arena</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup> arena,
 <a href="../../util/function/consumer" title="interface in java.util.function">Consumer</a>&lt;<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&gt; cleanup)</wbr></code></td>
<td> <div class="block">Returns a new memory segment with the same address and size as this segment, but with the provided scope.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment.scope" title="interface in java.lang.foreign">MemorySegment.Scope</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup></code></td>
<td><code><a href="#scope()" class="member-name-link">scope</a>()</code></td>
<td> <div class="block">Returns the scope associated with this memory segment.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#segmentOffset(java.lang.foreign.MemorySegment)" class="member-name-link">segmentOffset</a><wbr>(<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> other)</wbr></code></td>
<td> <div class="block">Returns the offset, in bytes, of the provided segment, relative to this segment.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.AddressLayout,long,java.lang.foreign.MemorySegment)" class="member-name-link">set</a><wbr>(<a href="addresslayout" title="interface in java.lang.foreign">AddressLayout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> layout,
 long offset,
 <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> value)</wbr></code></td>
<td> <div class="block">Writes an address into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfBoolean,long,boolean)" class="member-name-link">set</a><wbr>(<a href="valuelayout.ofboolean" title="interface in java.lang.foreign">ValueLayout.OfBoolean</a><sup><a href="valuelayout.ofboolean#preview-java.lang.foreign.ValueLayout.OfBoolean">PREVIEW</a></sup> layout,
 long offset,
 boolean value)</wbr></code></td>
<td> <div class="block">Writes a boolean into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfByte,long,byte)" class="member-name-link">set</a><wbr>(<a href="valuelayout.ofbyte" title="interface in java.lang.foreign">ValueLayout.OfByte</a><sup><a href="valuelayout.ofbyte#preview-java.lang.foreign.ValueLayout.OfByte">PREVIEW</a></sup> layout,
 long offset,
 byte value)</wbr></code></td>
<td> <div class="block">Writes a byte into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfChar,long,char)" class="member-name-link">set</a><wbr>(<a href="valuelayout.ofchar" title="interface in java.lang.foreign">ValueLayout.OfChar</a><sup><a href="valuelayout.ofchar#preview-java.lang.foreign.ValueLayout.OfChar">PREVIEW</a></sup> layout,
 long offset,
 char value)</wbr></code></td>
<td> <div class="block">Writes a char into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfDouble,long,double)" class="member-name-link">set</a><wbr>(<a href="valuelayout.ofdouble" title="interface in java.lang.foreign">ValueLayout.OfDouble</a><sup><a href="valuelayout.ofdouble#preview-java.lang.foreign.ValueLayout.OfDouble">PREVIEW</a></sup> layout,
 long offset,
 double value)</wbr></code></td>
<td> <div class="block">Writes a double into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfFloat,long,float)" class="member-name-link">set</a><wbr>(<a href="valuelayout.offloat" title="interface in java.lang.foreign">ValueLayout.OfFloat</a><sup><a href="valuelayout.offloat#preview-java.lang.foreign.ValueLayout.OfFloat">PREVIEW</a></sup> layout,
 long offset,
 float value)</wbr></code></td>
<td> <div class="block">Writes a float into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfInt,long,int)" class="member-name-link">set</a><wbr>(<a href="valuelayout.ofint" title="interface in java.lang.foreign">ValueLayout.OfInt</a><sup><a href="valuelayout.ofint#preview-java.lang.foreign.ValueLayout.OfInt">PREVIEW</a></sup> layout,
 long offset,
 int value)</wbr></code></td>
<td> <div class="block">Writes an int into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfLong,long,long)" class="member-name-link">set</a><wbr>(<a href="valuelayout.oflong" title="interface in java.lang.foreign">ValueLayout.OfLong</a><sup><a href="valuelayout.oflong#preview-java.lang.foreign.ValueLayout.OfLong">PREVIEW</a></sup> layout,
 long offset,
 long value)</wbr></code></td>
<td> <div class="block">Writes a long into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#set(java.lang.foreign.ValueLayout.OfShort,long,short)" class="member-name-link">set</a><wbr>(<a href="valuelayout.ofshort" title="interface in java.lang.foreign">ValueLayout.OfShort</a><sup><a href="valuelayout.ofshort#preview-java.lang.foreign.ValueLayout.OfShort">PREVIEW</a></sup> layout,
 long offset,
 short value)</wbr></code></td>
<td> <div class="block">Writes a short into this segment at the given offset, with the given layout.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.AddressLayout,long,java.lang.foreign.MemorySegment)" class="member-name-link">setAtIndex</a><wbr>(<a href="addresslayout" title="interface in java.lang.foreign">AddressLayout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> layout,
 long index,
 <a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> value)</wbr></code></td>
<td> <div class="block">Writes an address into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfBoolean,long,boolean)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.ofboolean" title="interface in java.lang.foreign">ValueLayout.OfBoolean</a><sup><a href="valuelayout.ofboolean#preview-java.lang.foreign.ValueLayout.OfBoolean">PREVIEW</a></sup> layout,
 long index,
 boolean value)</wbr></code></td>
<td> <div class="block">Writes a boolean into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfByte,long,byte)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.ofbyte" title="interface in java.lang.foreign">ValueLayout.OfByte</a><sup><a href="valuelayout.ofbyte#preview-java.lang.foreign.ValueLayout.OfByte">PREVIEW</a></sup> layout,
 long index,
 byte value)</wbr></code></td>
<td> <div class="block">Writes a byte into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfChar,long,char)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.ofchar" title="interface in java.lang.foreign">ValueLayout.OfChar</a><sup><a href="valuelayout.ofchar#preview-java.lang.foreign.ValueLayout.OfChar">PREVIEW</a></sup> layout,
 long index,
 char value)</wbr></code></td>
<td> <div class="block">Writes a char into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfDouble,long,double)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.ofdouble" title="interface in java.lang.foreign">ValueLayout.OfDouble</a><sup><a href="valuelayout.ofdouble#preview-java.lang.foreign.ValueLayout.OfDouble">PREVIEW</a></sup> layout,
 long index,
 double value)</wbr></code></td>
<td> <div class="block">Writes a double into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfFloat,long,float)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.offloat" title="interface in java.lang.foreign">ValueLayout.OfFloat</a><sup><a href="valuelayout.offloat#preview-java.lang.foreign.ValueLayout.OfFloat">PREVIEW</a></sup> layout,
 long index,
 float value)</wbr></code></td>
<td> <div class="block">Writes a float into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfInt,long,int)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.ofint" title="interface in java.lang.foreign">ValueLayout.OfInt</a><sup><a href="valuelayout.ofint#preview-java.lang.foreign.ValueLayout.OfInt">PREVIEW</a></sup> layout,
 long index,
 int value)</wbr></code></td>
<td> <div class="block">Writes an int into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfLong,long,long)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.oflong" title="interface in java.lang.foreign">ValueLayout.OfLong</a><sup><a href="valuelayout.oflong#preview-java.lang.foreign.ValueLayout.OfLong">PREVIEW</a></sup> layout,
 long index,
 long value)</wbr></code></td>
<td> <div class="block">Writes a long into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setAtIndex(java.lang.foreign.ValueLayout.OfShort,long,short)" class="member-name-link">setAtIndex</a><wbr>(<a href="valuelayout.ofshort" title="interface in java.lang.foreign">ValueLayout.OfShort</a><sup><a href="valuelayout.ofshort#preview-java.lang.foreign.ValueLayout.OfShort">PREVIEW</a></sup> layout,
 long index,
 short value)</wbr></code></td>
<td> <div class="block">Writes a short into this segment at the given index, scaled by the given layout size.</div> </td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code><a href="#setUtf8String(long,java.lang.String)" class="member-name-link">setUtf8String</a><wbr>(long offset,
 <a href="../string" title="class in java.lang">String</a> str)</wbr></code></td>
<td> <div class="block">Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.</div> </td>
</tr>
<tr>
<td><code><a href="../../util/spliterator" title="interface in java.util">Spliterator</a><wbr>&lt;<a href="memorysegment" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&gt;</wbr></code></td>
<td><code><a href="#spliterator(java.lang.foreign.MemoryLayout)" class="member-name-link">spliterator</a><wbr>(<a href="memorylayout" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="memorylayout#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Returns a spliterator for this memory segment.</div> </td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code><a href="#toArray(java.lang.foreign.ValueLayout.OfByte)" class="member-name-link">toArray</a><wbr>(<a href="valuelayout.ofbyte" title="interface in java.lang.foreign">ValueLayout.OfByte</a><sup><a href="valuelayout.ofbyte#preview-java.lang.foreign.ValueLayout.OfByte">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Copy the contents of this memory segment into a new byte array.</div> </td>
</tr>
<tr>
<td><code>char[]</code></td>
<td><code><a href="#toArray(java.lang.foreign.ValueLayout.OfChar)" class="member-name-link">toArray</a><wbr>(<a href="valuelayout.ofchar" title="interface in java.lang.foreign">ValueLayout.OfChar</a><sup><a href="valuelayout.ofchar#preview-java.lang.foreign.ValueLayout.OfChar">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Copy the contents of this memory segment into a new char array.</div> </td>
</tr>
<tr>
<td><code>double[]</code></td>
<td><code><a href="#toArray(java.lang.foreign.ValueLayout.OfDouble)" class="member-name-link">toArray</a><wbr>(<a href="valuelayout.ofdouble" title="interface in java.lang.foreign">ValueLayout.OfDouble</a><sup><a href="valuelayout.ofdouble#preview-java.lang.foreign.ValueLayout.OfDouble">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Copy the contents of this memory segment into a new double array.</div> </td>
</tr>
<tr>
<td><code>float[]</code></td>
<td><code><a href="#toArray(java.lang.foreign.ValueLayout.OfFloat)" class="member-name-link">toArray</a><wbr>(<a href="valuelayout.offloat" title="interface in java.lang.foreign">ValueLayout.OfFloat</a><sup><a href="valuelayout.offloat#preview-java.lang.foreign.ValueLayout.OfFloat">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Copy the contents of this memory segment into a new float array.</div> </td>
</tr>
<tr>
<td><code>int[]</code></td>
<td><code><a href="#toArray(java.lang.foreign.ValueLayout.OfInt)" class="member-name-link">toArray</a><wbr>(<a href="valuelayout.ofint" title="interface in java.lang.foreign">ValueLayout.OfInt</a><sup><a href="valuelayout.ofint#preview-java.lang.foreign.ValueLayout.OfInt">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Copy the contents of this memory segment into a new int array.</div> </td>
</tr>
<tr>
<td><code>long[]</code></td>
<td><code><a href="#toArray(java.lang.foreign.ValueLayout.OfLong)" class="member-name-link">toArray</a><wbr>(<a href="valuelayout.oflong" title="interface in java.lang.foreign">ValueLayout.OfLong</a><sup><a href="valuelayout.oflong#preview-java.lang.foreign.ValueLayout.OfLong">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Copy the contents of this memory segment into a new long array.</div> </td>
</tr>
<tr>
<td><code>short[]</code></td>
<td><code><a href="#toArray(java.lang.foreign.ValueLayout.OfShort)" class="member-name-link">toArray</a><wbr>(<a href="valuelayout.ofshort" title="interface in java.lang.foreign">ValueLayout.OfShort</a><sup><a href="valuelayout.ofshort#preview-java.lang.foreign.ValueLayout.OfShort">PREVIEW</a></sup> elementLayout)</wbr></code></td>
<td> <div class="block">Copy the contents of this memory segment into a new short array.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#unload()" class="member-name-link">unload</a>()</code></td>
<td> <div class="block">Unloads the contents of this mapped segment from physical memory.</div> </td>
</tr>
</table> </div> </div> </section> </section> <section class="details"> <section class="field-details" id="field-detail"> <h2>Field Details</h2>  </section><section class="detail" id="NULL"> <h3>NULL</h3> <pre class="lang-java" data-language="java">static final MemorySegmentPREVIEW NULL</pre> <div class="block">A zero-length native segment modelling the <code>NULL</code> address.</div> </section><section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="address()"> <h3>address</h3> <pre class="lang-java" data-language="java">long address()</pre> <div class="block">Returns the address of this memory segment.</div> <dl class="notes"> <dt>API Note:</dt> <dd>When using this method to pass a segment address to some external operation (e.g. a JNI function), clients must ensure that the segment is kept <a href="../ref/package#reachability">reachable</a> for the entire duration of the operation. A failure to do so might result in the premature deallocation of the region of memory backing the memory segment, in case the segment has been allocated with an <a href="arena#ofAuto()">automatic arena</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup>.</dd> <dt>Returns:</dt> <dd>the address of this memory segment</dd> </dl> </section><section class="detail" id="heapBase()"> <h3>heapBase</h3> <pre class="lang-java" data-language="java">Optional&lt;Object&gt; heapBase()</pre> <div class="block">Returns the Java object stored in the on-heap region of memory backing this memory segment, if any. For instance, if this memory segment is a heap segment created with the <a href="#ofArray(byte%5B%5D)"><code>ofArray(byte[])</code></a> factory method, this method will return the <code>byte[]</code> object which was used to obtain the segment. This method returns an empty <code>Optional</code> value if either this segment is a <a href="#isNative()">native</a> segment, or if this segment is <a href="#isReadOnly()">read-only</a>.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the Java object associated with this memory segment, if any.</dd> </dl> </section><section class="detail" id="spliterator(java.lang.foreign.MemoryLayout)"> <h3>spliterator</h3> <pre class="lang-java" data-language="java">Spliterator&lt;MemorySegmentPREVIEW&gt; spliterator(MemoryLayoutPREVIEW elementLayout)</pre> <div class="block">Returns a spliterator for this memory segment. The returned spliterator reports <a href="../../util/spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="../../util/spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="../../util/spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>, <a href="../../util/spliterator#NONNULL"><code>Spliterator.NONNULL</code></a> and <a href="../../util/spliterator#ORDERED"><code>Spliterator.ORDERED</code></a> characteristics. <p> The returned spliterator splits this segment according to the specified element layout; that is, if the supplied layout has size N, then calling <a href="../../util/spliterator#trySplit()"><code>Spliterator.trySplit()</code></a> will result in a spliterator serving approximately <code>S/N</code> elements (depending on whether N is even or not), where <code>S</code> is the size of this segment. As such, splitting is possible as long as <code>S/N &gt;= 2</code>. The spliterator returns segments that have the same lifetime as that of this segment. </p>
<p> The returned spliterator effectively allows to slice this segment into disjoint <a href="#asSlice(long,long)">slices</a>, which can then be processed in parallel by multiple threads.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the layout to be used for splitting.</dd> <dt>Returns:</dt> <dd>the element spliterator for this segment</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementLayout.byteSize() == 0</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>byteSize() % elementLayout.byteSize() != 0</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementLayout.byteSize() % elementLayout.byteAlignment() != 0</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if this segment is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> </dl> </section><section class="detail" id="elements(java.lang.foreign.MemoryLayout)"> <h3>elements</h3> <pre class="lang-java" data-language="java">Stream&lt;MemorySegmentPREVIEW&gt; elements(MemoryLayoutPREVIEW elementLayout)</pre> <div class="block">Returns a sequential <code>Stream</code> over disjoint slices (whose size matches that of the specified layout) in this segment. Calling this method is equivalent to the following code: <div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">StreamSupport.stream(segment.spliterator(elementLayout), false);
</code></pre> </div> </div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the layout to be used for splitting.</dd> <dt>Returns:</dt> <dd>a sequential <code>Stream</code> over disjoint slices in this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementLayout.byteSize() == 0</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>byteSize() % elementLayout.byteSize() != 0</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementLayout.byteSize() % elementLayout.byteAlignment() != 0</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if this segment is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> </dl> </section><section class="detail" id="scope()"> <h3>scope</h3> <pre class="lang-java" data-language="java">MemorySegment.ScopePREVIEW scope()</pre> <div class="block">Returns the scope associated with this memory segment.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the scope associated with this memory segment</dd> </dl> </section><section class="detail" id="isAccessibleBy(java.lang.Thread)"> <h3>isAccessibleBy</h3> <pre class="lang-java" data-language="java">boolean isAccessibleBy(Thread thread)</pre> <div class="block">Returns <code>true</code> if this segment can be accessed from the provided thread.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>thread</code> - the thread to be tested.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this segment can be accessed from the provided thread</dd> </dl> </section><section class="detail" id="byteSize()"> <h3>byteSize</h3> <pre class="lang-java" data-language="java">long byteSize()</pre> <div class="block">Returns the size (in bytes) of this memory segment.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the size (in bytes) of this memory segment</dd> </dl> </section><section class="detail" id="asSlice(long,long)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW asSlice(long offset, long newSize)</pre> <div class="block">Returns a slice of this memory segment, at the given offset. The returned segment's address is the address of this segment plus the given offset; its size is specified by the given argument. <p> Equivalent to the following code: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">asSlice(offset, newSize, 1);
</code></pre> </div> </div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - The new segment base offset (relative to the address of this segment), specified in bytes.</dd> <dd>
<code>newSize</code> - The new segment size, specified in bytes.</dd> <dt>Returns:</dt> <dd>a slice of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, <code>newSize &lt; 0</code>, or <code>newSize &gt; byteSize() - offset</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#asSlice(long,long,long)"><code>asSlice(long, long, long)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="asSlice(long,long,long)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW asSlice(long offset, long newSize, long byteAlignment)</pre> <div class="block">Returns a slice of this memory segment, at the given offset, with the provided alignment constraint. The returned segment's address is the address of this segment plus the given offset; its size is specified by the given argument.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - The new segment base offset (relative to the address of this segment), specified in bytes.</dd> <dd>
<code>newSize</code> - The new segment size, specified in bytes.</dd> <dd>
<code>byteAlignment</code> - The alignment constraint (in bytes) of the returned slice.</dd> <dt>Returns:</dt> <dd>a slice of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, <code>newSize &lt; 0</code>, or <code>newSize &gt; byteSize() - offset</code>
</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if this segment cannot be accessed at <code>offset</code> under the provided alignment constraint.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>byteAlignment &lt;= 0</code>, or if <code>byteAlignment</code> is not a power of 2.</dd> </dl> </section><section class="detail" id="asSlice(long,java.lang.foreign.MemoryLayout)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">default MemorySegmentPREVIEW asSlice(long offset, MemoryLayoutPREVIEW layout)</pre> <div class="block">Returns a slice of this memory segment with the given layout, at the given offset. The returned segment's address is the address of this segment plus the given offset; its size is the same as the size of the provided layout. <p> Equivalent to the following code: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">asSlice(offset, layout.byteSize(), layout.byteAlignment());
</code></pre> </div> </div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - The new segment base offset (relative to the address of this segment), specified in bytes.</dd> <dd>
<code>layout</code> - The layout of the segment slice.</dd> <dt>Returns:</dt> <dd>a slice of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, or <code>layout.byteSize() &gt; byteSize() - offset</code>
</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if this segment cannot be accessed at <code>offset</code> under the alignment constraint specified by <code>layout</code>.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#asSlice(long,long,long)"><code>asSlice(long, long, long)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="asSlice(long)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW asSlice(long offset)</pre> <div class="block">Returns a slice of this memory segment, at the given offset. The returned segment's address is the address of this segment plus the given offset; its size is computed by subtracting the specified offset from this segment size. <p> Equivalent to the following code: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">asSlice(offset, byteSize() - offset);
</code></pre> </div> </div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - The new segment base offset (relative to the address of this segment), specified in bytes.</dd> <dt>Returns:</dt> <dd>a slice of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, or <code>offset &gt; byteSize()</code>.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="reinterpret(long)"> <h3>reinterpret</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW reinterpret(long newSize)</pre> <div class="block">Returns a new memory segment that has the same address and scope as this segment, but with the provided size. <p> This method is <a href="package-summary#restricted"><em>restricted</em></a>. Restricted methods are unsafe, and, if used incorrectly, their use might crash the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on restricted methods, and use safe and supported functionalities, where possible.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>newSize</code> - the size of the returned segment.</dd> <dt>Returns:</dt> <dd>a new memory segment that has the same address and scope as this segment, but the new provided size.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>newSize &lt; 0</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a <a href="#isNative()">native</a> segment.</dd> <dd>
<code><a href="../illegalcallerexception" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have native access enabled.</dd> </dl> </section><section class="detail" id="reinterpret(java.lang.foreign.Arena,java.util.function.Consumer)"> <h3>reinterpret</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW reinterpret(ArenaPREVIEW arena, Consumer&lt;MemorySegmentPREVIEW&gt; cleanup)</pre> <div class="block">Returns a new memory segment with the same address and size as this segment, but with the provided scope. As such, the returned segment cannot be accessed after the provided arena has been closed. Moreover, the returned segment can be accessed compatibly with the confinement restrictions associated with the provided arena: that is, if the provided arena is a <a href="arena#ofConfined()">confined arena</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup>, the returned segment can only be accessed by the arena's owner thread, regardless of the confinement restrictions associated with this segment. In other words, this method returns a segment that behaves as if it had been allocated using the provided arena. <p> Clients can specify an optional cleanup action that should be executed when the provided scope becomes invalid. This cleanup action receives a fresh memory segment that is obtained from this segment as follows: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address())
                                            .reinterpret(byteSize());
</code></pre> </div> That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive, and is accessible from any thread. The size of the segment accepted by the cleanup action is <a href="#byteSize()"><code>byteSize()</code></a>. <p> This method is <a href="package-summary#restricted"><em>restricted</em></a>. Restricted methods are unsafe, and, if used incorrectly, their use might crash the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on restricted methods, and use safe and supported functionalities, where possible.</p>
</div> <dl class="notes"> <dt>API Note:</dt> <dd>The cleanup action (if present) should take care not to leak the received segment to external clients which might access the segment after its backing region of memory is no longer available. Furthermore, if the provided scope is the scope of an <a href="arena#ofAuto()">automatic arena</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup>, the cleanup action must not prevent the scope from becoming <a href="../ref/package#reachability">unreachable</a>. A failure to do so will permanently prevent the regions of memory allocated by the automatic arena from being deallocated.</dd> <dt>Parameters:</dt> <dd>
<code>arena</code> - the arena to be associated with the returned segment.</dd> <dd>
<code>cleanup</code> - the cleanup action that should be executed when the provided arena is closed (can be <code>null</code>).</dd> <dt>Returns:</dt> <dd>a new memory segment with unbounded size.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if <code>arena.scope().isAlive() == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a <a href="#isNative()">native</a> segment.</dd> <dd>
<code><a href="../illegalcallerexception" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have native access enabled.</dd> </dl> </section><section class="detail" id="reinterpret(long,java.lang.foreign.Arena,java.util.function.Consumer)"> <h3>reinterpret</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW reinterpret(long newSize, ArenaPREVIEW arena, Consumer&lt;MemorySegmentPREVIEW&gt; cleanup)</pre> <div class="block">Returns a new segment with the same address as this segment, but with the provided size and scope. As such, the returned segment cannot be accessed after the provided arena has been closed. Moreover, if the returned segment can be accessed compatibly with the confinement restrictions associated with the provided arena: that is, if the provided arena is a <a href="arena#ofConfined()">confined arena</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup>, the returned segment can only be accessed by the arena's owner thread, regardless of the confinement restrictions associated with this segment. In other words, this method returns a segment that behaves as if it had been allocated using the provided arena. <p> Clients can specify an optional cleanup action that should be executed when the provided scope becomes invalid. This cleanup action receives a fresh memory segment that is obtained from this segment as follows: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address())
                                            .reinterpret(newSize);
</code></pre> </div> That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive, and is accessible from any thread. The size of the segment accepted by the cleanup action is <code>newSize</code>. <p> This method is <a href="package-summary#restricted"><em>restricted</em></a>. Restricted methods are unsafe, and, if used incorrectly, their use might crash the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on restricted methods, and use safe and supported functionalities, where possible.</p>
</div> <dl class="notes"> <dt>API Note:</dt> <dd>The cleanup action (if present) should take care not to leak the received segment to external clients which might access the segment after its backing region of memory is no longer available. Furthermore, if the provided scope is the scope of an <a href="arena#ofAuto()">automatic arena</a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup>, the cleanup action must not prevent the scope from becoming <a href="../ref/package#reachability">unreachable</a>. A failure to do so will permanently prevent the regions of memory allocated by the automatic arena from being deallocated.</dd> <dt>Parameters:</dt> <dd>
<code>newSize</code> - the size of the returned segment.</dd> <dd>
<code>arena</code> - the arena to be associated with the returned segment.</dd> <dd>
<code>cleanup</code> - the cleanup action that should be executed when the provided arena is closed (can be <code>null</code>).</dd> <dt>Returns:</dt> <dd>a new segment that has the same address as this segment, but with new size and its scope set to that of the provided arena.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a <a href="#isNative()">native</a> segment.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>newSize &lt; 0</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if <code>arena.scope().isAlive() == false</code>.</dd> <dd>
<code><a href="../illegalcallerexception" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have native access enabled.</dd> </dl> </section><section class="detail" id="isReadOnly()"> <h3>isReadOnly</h3> <pre class="lang-java" data-language="java">boolean isReadOnly()</pre> <div class="block">Returns <code>true</code>, if this segment is read-only.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code>, if this segment is read-only</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#asReadOnly()"><code>asReadOnly()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="asReadOnly()"> <h3>asReadOnly</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW asReadOnly()</pre> <div class="block">Returns a read-only view of this segment. The resulting segment will be identical to this one, but attempts to overwrite the contents of the returned segment will cause runtime exceptions.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a read-only view of this segment</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#isReadOnly()"><code>isReadOnly()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="isNative()"> <h3>isNative</h3> <pre class="lang-java" data-language="java">boolean isNative()</pre> <div class="block">Returns <code>true</code> if this segment is a native segment. A native segment is created e.g. using the <a href="arena#allocate(long,long)"><code>Arena.allocate(long, long)</code></a><sup><a href="arena#preview-java.lang.foreign.Arena">PREVIEW</a></sup> (and related) factory, or by <a href="#ofBuffer(java.nio.Buffer)">wrapping</a> a <a href="../../nio/bytebuffer#allocateDirect(int)">direct buffer</a>.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if this segment is native segment.</dd> </dl> </section><section class="detail" id="isMapped()"> <h3>isMapped</h3> <pre class="lang-java" data-language="java">boolean isMapped()</pre> <div class="block">Returns <code>true</code> if this segment is a mapped segment. A mapped memory segment is created e.g. using the <a href="../../nio/channels/filechannel#map(java.nio.channels.FileChannel.MapMode,long,long,java.lang.foreign.Arena)"><code>FileChannel.map(FileChannel.MapMode, long, long, Arena)</code></a><sup><a href="../../nio/channels/filechannel#preview-map(java.nio.channels.FileChannel.MapMode,long,long,java.lang.foreign.Arena)">PREVIEW</a></sup> factory, or by <a href="#ofBuffer(java.nio.Buffer)">wrapping</a> a <a href="../../nio/mappedbytebuffer" title="class in java.nio">mapped byte buffer</a>.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if this segment is a mapped segment.</dd> </dl> </section><section class="detail" id="asOverlappingSlice(java.lang.foreign.MemorySegment)"> <h3>asOverlappingSlice</h3> <pre class="lang-java" data-language="java">Optional&lt;MemorySegmentPREVIEW&gt; asOverlappingSlice(MemorySegmentPREVIEW other)</pre> <div class="block">Returns a slice of this segment that is the overlap between this and the provided segment. <p>Two segments <code>S1</code> and <code>S2</code> are said to overlap if it is possible to find at least two slices <code>L1</code> (from <code>S1</code>) and <code>L2</code> (from <code>S2</code>) that are backed by the same region of memory. As such, it is not possible for a <a href="#isNative()">native</a> segment to overlap with a heap segment; in this case, or when no overlap occurs, an empty <code>Optional</code> is returned.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>other</code> - the segment to test for an overlap with this segment.</dd> <dt>Returns:</dt> <dd>a slice of this segment (where overlapping occurs).</dd> </dl> </section><section class="detail" id="segmentOffset(java.lang.foreign.MemorySegment)"> <h3>segmentOffset</h3> <pre class="lang-java" data-language="java">long segmentOffset(MemorySegmentPREVIEW other)</pre> <div class="block">Returns the offset, in bytes, of the provided segment, relative to this segment. <p>The offset is relative to the address of this segment and can be a negative or positive value. For instance, if both segments are native segments, or heap segments backed by the same array, the resulting offset can be computed as follows: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">other.address() - address()
</code></pre> </div> If the segments share the same address, <code>0</code> is returned. If <code>other</code> is a slice of this segment, the offset is always <code>0 &lt;= x &lt; this.byteSize()</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>other</code> - the segment to retrieve an offset to.</dd> <dt>Returns:</dt> <dd>the relative offset, in bytes, of the provided segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if the two segments cannot be compared, e.g. because they are of different kinds, or because they are backed by different Java arrays.</dd> </dl> </section><section class="detail" id="fill(byte)"> <h3>fill</h3> <pre class="lang-java" data-language="java">MemorySegmentPREVIEW fill(byte value)</pre> <div class="block">Fills the contents of this memory segment with the given value. <p> More specifically, the given value is written into each address of this segment. Equivalent to (but likely more efficient than) the following code: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">for (long offset = 0; offset &lt; segment.byteSize(); offset++) {
    byteHandle.set(ValueLayout.JAVA_BYTE, offset, value);
}
</code></pre> </div> But without any regard or guarantees on the ordering of particular memory elements being set. <p> This method can be useful to initialize or reset the contents of a memory segment.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>value</code> - the value to write into this segment.</dd> <dt>Returns:</dt> <dd>this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="copyFrom(java.lang.foreign.MemorySegment)"> <h3>copyFrom</h3> <pre class="lang-java" data-language="java">default MemorySegmentPREVIEW copyFrom(MemorySegmentPREVIEW src)</pre> <div class="block">Performs a bulk copy from given source segment to this segment. More specifically, the bytes at offset <code>0</code> through <code>src.byteSize() - 1</code> in the source segment are copied into this segment at offset <code>0</code> through <code>src.byteSize() - 1</code>. <p> Calling this method is equivalent to the following code: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment.copy(src, 0, this, 0, src.byteSize());
</code></pre> </div> </div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>src</code> - the source segment.</dd> <dt>Returns:</dt> <dd>this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>src.byteSize() &gt; this.byteSize()</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>src</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>src.isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="mismatch(java.lang.foreign.MemorySegment)"> <h3>mismatch</h3> <pre class="lang-java" data-language="java">default long mismatch(MemorySegmentPREVIEW other)</pre> <div class="block">Finds and returns the offset, in bytes, of the first mismatch between this segment and the given other segment. The offset is relative to the <a href="#address()">address</a> of each segment and will be in the range of 0 (inclusive) up to the <a href="#byteSize()">size</a> (in bytes) of the smaller memory segment (exclusive). <p> If the two segments share a common prefix then the returned offset is the length of the common prefix, and it follows that there is a mismatch between the two segments at that offset within the respective segments. If one segment is a proper prefix of the other, then the returned offset is the smallest of the segment sizes, and it follows that the offset is only valid for the larger segment. Otherwise, there is no mismatch and <code>
 -1</code> is returned.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>other</code> - the segment to be tested for a mismatch with this segment.</dd> <dt>Returns:</dt> <dd>the relative offset, in bytes, of the first mismatch between this and the given other segment, otherwise -1 if no mismatch.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>other</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>other.isAccessibleBy(T) == false</code>.</dd> </dl> </section><section class="detail" id="isLoaded()"> <h3>isLoaded</h3> <pre class="lang-java" data-language="java">boolean isLoaded()</pre> <div class="block">Determines whether the contents of this mapped segment is resident in physical memory. <p> A return value of <code>true</code> implies that it is highly likely that all the data in this segment is resident in physical memory and may therefore be accessed without incurring any virtual-memory page faults or I/O operations. A return value of <code>false</code> does not necessarily imply that this segment's content is not resident in physical memory. </p>
<p> The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of this segment's data by the time that an invocation of this method returns. </p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if it is likely that the contents of this segment is resident in physical memory</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> </dl> </section><section class="detail" id="load()"> <h3>load</h3> <pre class="lang-java" data-language="java">void load()</pre> <div class="block">Loads the contents of this mapped segment into physical memory. <p> This method makes a best effort to ensure that, when it returns, this contents of this segment is resident in physical memory. Invoking this method may cause some number of page faults and I/O operations to occur. </p>
</div> <dl class="notes"> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> </dl> </section><section class="detail" id="unload()"> <h3>unload</h3> <pre class="lang-java" data-language="java">void unload()</pre> <div class="block">Unloads the contents of this mapped segment from physical memory. <p> This method makes a best effort to ensure that the contents of this segment are are no longer resident in physical memory. Accessing this segment's contents after invoking this method may cause some number of page faults and I/O operations to occur (as this segment's contents might need to be paged back in). </p>
</div> <dl class="notes"> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> </dl> </section><section class="detail" id="force()"> <h3>force</h3> <pre class="lang-java" data-language="java">void force()</pre> <div class="block">Forces any changes made to the contents of this mapped segment to be written to the storage device described by the mapped segment's file descriptor. <p> If the file descriptor associated with this mapped segment resides on a local storage device then when this method returns it is guaranteed that all changes made to this segment since it was created, or since this method was last invoked, will have been written to that device. </p>
<p> If the file descriptor associated with this mapped segment does not reside on a local device then no such guarantee is made. </p>
<p> If this segment was not mapped in read/write mode (<a href="../../nio/channels/filechannel.mapmode#READ_WRITE"><code>FileChannel.MapMode.READ_WRITE</code></a>) then invoking this method may have no effect. In particular, the method has no effect for segments mapped in read-only or private mapping modes. This method may or may not have an effect for implementation-specific mapping modes. </p>
</div> <dl class="notes"> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> <dd>
<code><a href="../../io/uncheckedioexception" title="class in java.io">UncheckedIOException</a></code> - if there is an I/O error writing the contents of this segment to the associated storage device</dd> </dl> </section><section class="detail" id="asByteBuffer()"> <h3>asByteBuffer</h3> <pre class="lang-java" data-language="java">ByteBuffer asByteBuffer()</pre> <div class="block">Wraps this segment in a <a href="../../nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a>. Some properties of the returned buffer are linked to the properties of this segment. More specifically, the resulting buffer has the following characteristics: <ul> <li>It is <a href="../../nio/buffer#isReadOnly()">read-only</a>, if this segment is a <a href="#isReadOnly()">read-only segment</a>;</li> <li>Its <a href="../../nio/buffer#position()">position</a> is set to zero; </li>
<li>Its <a href="../../nio/buffer#capacity()">capacity</a> and <a href="../../nio/buffer#limit()">limit</a> are both set to this segment' <a href="#byteSize()">size</a>. For this reason, a byte buffer cannot be returned if this segment's size is greater than <a href="../integer#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>;</li> <li>It is a <a href="../../nio/bytebuffer#isDirect()">direct buffer</a>, if this is a native segment.</li> </ul> <p> The life-cycle of the returned buffer is tied to that of this segment. That is, accessing the returned buffer after the scope associated with this segment is no longer <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>, will throw an <a href="../illegalstateexception" title="class in java.lang"><code>IllegalStateException</code></a>. Similarly, accessing the returned buffer from a thread <code>T</code> such that <code>isAccessible(T) == false</code> will throw a <a href="../wrongthreadexception" title="class in java.lang"><code>WrongThreadException</code></a>. </p>
<p> If this segment is <a href="#isAccessibleBy(java.lang.Thread)">accessible</a> from a single thread, calling read/write I/O operations on the resulting buffer might result in unspecified exceptions being thrown. Examples of such problematic operations are <a href="../../nio/channels/asynchronoussocketchannel#read(java.nio.ByteBuffer)"><code>AsynchronousSocketChannel.read(ByteBuffer)</code></a> and <a href="../../nio/channels/asynchronoussocketchannel#write(java.nio.ByteBuffer)"><code>AsynchronousSocketChannel.write(ByteBuffer)</code></a>. </p>
<p> Finally, the resulting buffer's byte order is <a href="../../nio/byteorder#BIG_ENDIAN"><code>ByteOrder.BIG_ENDIAN</code></a>; this can be changed using <a href="../../nio/bytebuffer#order(java.nio.ByteOrder)"><code>ByteBuffer.order(java.nio.ByteOrder)</code></a>.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>a <a href="../../nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a> view of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment cannot be mapped onto a <a href="../../nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a> instance, e.g. if it is a heap segment backed by an array other than <code>byte[]</code>), or if its size is greater than <a href="../integer#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>.</dd> </dl> </section><section class="detail" id="toArray(java.lang.foreign.ValueLayout.OfByte)"> <h3>toArray</h3> <pre class="lang-java" data-language="java">byte[] toArray(ValueLayout.OfBytePREVIEW elementLayout)</pre> <div class="block">Copy the contents of this memory segment into a new byte array.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dt>Returns:</dt> <dd>a new byte array whose contents are copied from this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if this segment's contents cannot be copied into a <code>byte[]</code> instance, e.g. its size is greater than <a href="../integer#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>.</dd> </dl> </section><section class="detail" id="toArray(java.lang.foreign.ValueLayout.OfShort)"> <h3>toArray</h3> <pre class="lang-java" data-language="java">short[] toArray(ValueLayout.OfShortPREVIEW elementLayout)</pre> <div class="block">Copy the contents of this memory segment into a new short array.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dt>Returns:</dt> <dd>a new short array whose contents are copied from this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if this segment's contents cannot be copied into a <code>short[]</code> instance, e.g. because <code>byteSize() % 2 != 0</code>, or <code>byteSize() / 2 &gt; Integer.MAX_VALUE</code>
</dd> </dl> </section><section class="detail" id="toArray(java.lang.foreign.ValueLayout.OfChar)"> <h3>toArray</h3> <pre class="lang-java" data-language="java">char[] toArray(ValueLayout.OfCharPREVIEW elementLayout)</pre> <div class="block">Copy the contents of this memory segment into a new char array.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dt>Returns:</dt> <dd>a new char array whose contents are copied from this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if this segment's contents cannot be copied into a <code>char[]</code> instance, e.g. because <code>byteSize() % 2 != 0</code>, or <code>byteSize() / 2 &gt; Integer.MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toArray(java.lang.foreign.ValueLayout.OfInt)"> <h3>toArray</h3> <pre class="lang-java" data-language="java">int[] toArray(ValueLayout.OfIntPREVIEW elementLayout)</pre> <div class="block">Copy the contents of this memory segment into a new int array.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dt>Returns:</dt> <dd>a new int array whose contents are copied from this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if this segment's contents cannot be copied into a <code>int[]</code> instance, e.g. because <code>byteSize() % 4 != 0</code>, or <code>byteSize() / 4 &gt; Integer.MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toArray(java.lang.foreign.ValueLayout.OfFloat)"> <h3>toArray</h3> <pre class="lang-java" data-language="java">float[] toArray(ValueLayout.OfFloatPREVIEW elementLayout)</pre> <div class="block">Copy the contents of this memory segment into a new float array.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dt>Returns:</dt> <dd>a new float array whose contents are copied from this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if this segment's contents cannot be copied into a <code>float[]</code> instance, e.g. because <code>byteSize() % 4 != 0</code>, or <code>byteSize() / 4 &gt; Integer.MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toArray(java.lang.foreign.ValueLayout.OfLong)"> <h3>toArray</h3> <pre class="lang-java" data-language="java">long[] toArray(ValueLayout.OfLongPREVIEW elementLayout)</pre> <div class="block">Copy the contents of this memory segment into a new long array.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dt>Returns:</dt> <dd>a new long array whose contents are copied from this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if this segment's contents cannot be copied into a <code>long[]</code> instance, e.g. because <code>byteSize() % 8 != 0</code>, or <code>byteSize() / 8 &gt; Integer.MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toArray(java.lang.foreign.ValueLayout.OfDouble)"> <h3>toArray</h3> <pre class="lang-java" data-language="java">double[] toArray(ValueLayout.OfDoublePREVIEW elementLayout)</pre> <div class="block">Copy the contents of this memory segment into a new double array.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dt>Returns:</dt> <dd>a new double array whose contents are copied from this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if this segment's contents cannot be copied into a <code>double[]</code> instance, e.g. because <code>byteSize() % 8 != 0</code>, or <code>byteSize() / 8 &gt; Integer.MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="getUtf8String(long)"> <h3>getUtf8String</h3> <pre class="lang-java" data-language="java">default String getUtf8String(long offset)</pre> <div class="block">Reads a UTF-8 encoded, null-terminated string from this segment at the given offset. <p> This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement string. The <a href="../../nio/charset/charsetdecoder" title="class in java.nio.charset"><code>CharsetDecoder</code></a> class should be used when more control over the decoding process is required.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a Java string constructed from the bytes read from the given starting address up to (but not including) the first <code>'\0'</code> terminator character (assuming one is found).</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the size of the UTF-8 string is greater than the largest string supported by the platform.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code> or <code>offset &gt; byteSize() - S</code>, where <code>S</code> is the size of the UTF-8 string (including the terminator character).</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> </dl> </section><section class="detail" id="setUtf8String(long,java.lang.String)"> <h3>setUtf8String</h3> <pre class="lang-java" data-language="java">default void setUtf8String(long offset, String str)</pre> <div class="block">Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding. <p> This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement string. The <a href="../../nio/charset/charsetdecoder" title="class in java.nio.charset"><code>CharsetDecoder</code></a> class should be used when more control over the decoding process is required. </p>
<p> If the given string contains any <code>'\0'</code> characters, they will be copied as well. This means that, depending on the method used to read the string, such as <a href="#getUtf8String(long)"><code>getUtf8String(long)</code></a>, the string will appear truncated when read again.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur. the final address of this write operation can be expressed as <code>address() + offset</code>.</dd> <dd>
<code>str</code> - the Java string to be written into this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code> or <code>offset &gt; byteSize() - str.getBytes().length() + 1</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> </dl> </section><section class="detail" id="ofBuffer(java.nio.Buffer)"> <h3>ofBuffer</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofBuffer(Buffer buffer)</pre> <div class="block">Creates a memory segment that is backed by the same region of memory that backs the given <a href="../../nio/buffer" title="class in java.nio"><code>Buffer</code></a> instance. The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive). <p> If the buffer is <a href="../../nio/buffer#isReadOnly()">read-only</a>, the resulting segment is also <a href="../../nio/buffer#isReadOnly()">read-only</a>. Moreover, if the buffer is a <a href="../../nio/buffer#isDirect()">direct buffer</a>, the returned segment is a native segment; otherwise the returned memory segment is a heap segment. </p>
<p> If the provided buffer has been obtained by calling <a href="#asByteBuffer()"><code>asByteBuffer()</code></a> on a memory segment whose <a href="memorysegment.scope" title="interface in java.lang.foreign">scope</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup> is <code>S</code>, the returned segment will be associated with the same scope <code>S</code>. Otherwise, the scope of the returned segment is a fresh scope that is always alive. </p>
<p> The scope associated with the returned segment keeps the provided buffer reachable. As such, if the provided buffer is a direct buffer, its backing memory region will not be deallocated as long as the returned segment (or any of its slices) are kept reachable.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>buffer</code> - the buffer instance to be turned into a new memory segment.</dd> <dt>Returns:</dt> <dd>a memory segment, derived from the given buffer instance.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the provided <code>buffer</code> is a heap buffer but is not backed by an array. For example, buffers directly or indirectly obtained via (<a href="../../nio/charbuffer#wrap(java.lang.CharSequence)"><code>CharBuffer.wrap(CharSequence)</code></a> or <a href="../../nio/charbuffer#wrap(char%5B%5D,int,int)"><code>CharBuffer.wrap(char[], int, int)</code></a> are not backed by an array.</dd> </dl> </section><section class="detail" id="ofArray(byte[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofArray(byte[] byteArray)</pre> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given byte array. The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable. The returned segment is always accessible, from any thread. Its <a href="#address()"><code>address()</code></a> is set to zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>byteArray</code> - the primitive array backing the heap memory segment.</dd> <dt>Returns:</dt> <dd>a heap memory segment backed by a byte array.</dd> </dl> </section><section class="detail" id="ofArray(char[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofArray(char[] charArray)</pre> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given char array. The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable. The returned segment is always accessible, from any thread. Its <a href="#address()"><code>address()</code></a> is set to zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>charArray</code> - the primitive array backing the heap segment.</dd> <dt>Returns:</dt> <dd>a heap memory segment backed by a char array.</dd> </dl> </section><section class="detail" id="ofArray(short[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofArray(short[] shortArray)</pre> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given short array. The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable. The returned segment is always accessible, from any thread. Its <a href="#address()"><code>address()</code></a> is set to zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>shortArray</code> - the primitive array backing the heap segment.</dd> <dt>Returns:</dt> <dd>a heap memory segment backed by a short array.</dd> </dl> </section><section class="detail" id="ofArray(int[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofArray(int[] intArray)</pre> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given int array. The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable. The returned segment is always accessible, from any thread. Its <a href="#address()"><code>address()</code></a> is set to zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>intArray</code> - the primitive array backing the heap segment.</dd> <dt>Returns:</dt> <dd>a heap memory segment backed by an int array.</dd> </dl> </section><section class="detail" id="ofArray(float[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofArray(float[] floatArray)</pre> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given float array. The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable. The returned segment is always accessible, from any thread. Its <a href="#address()"><code>address()</code></a> is set to zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>floatArray</code> - the primitive array backing the heap segment.</dd> <dt>Returns:</dt> <dd>a heap memory segment backed by a float array.</dd> </dl> </section><section class="detail" id="ofArray(long[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofArray(long[] longArray)</pre> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given long array. The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable. The returned segment is always accessible, from any thread. Its <a href="#address()"><code>address()</code></a> is set to zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>longArray</code> - the primitive array backing the heap segment.</dd> <dt>Returns:</dt> <dd>a heap memory segment backed by a long array.</dd> </dl> </section><section class="detail" id="ofArray(double[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofArray(double[] doubleArray)</pre> <div class="block">Creates a heap segment backed by the on-heap region of memory that holds the given double array. The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable. The returned segment is always accessible, from any thread. Its <a href="#address()"><code>address()</code></a> is set to zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>doubleArray</code> - the primitive array backing the heap segment.</dd> <dt>Returns:</dt> <dd>a heap memory segment backed by a double array.</dd> </dl> </section><section class="detail" id="ofAddress(long)"> <h3>ofAddress</h3> <pre class="lang-java" data-language="java">static MemorySegmentPREVIEW ofAddress(long address)</pre> <div class="block">Creates a zero-length native segment from the given <a href="#address()">address value</a>. The returned segment is associated with a scope that is always alive, and is accessible from any thread. <p> On 32-bit platforms, the given address value will be normalized such that the highest-order ("leftmost") 32 bits of the <a href="#address()"><code>address</code></a> of the returned memory segment are set to zero.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>address</code> - the address of the returned native segment.</dd> <dt>Returns:</dt> <dd>a zero-length native segment with the given address.</dd> </dl> </section><section class="detail" id="copy(java.lang.foreign.MemorySegment,long,java.lang.foreign.MemorySegment,long,long)"> <h3>copy</h3> <pre class="lang-java" data-language="java">static void copy(MemorySegmentPREVIEW srcSegment, long srcOffset, MemorySegmentPREVIEW dstSegment, long dstOffset, long bytes)</pre> <div class="block">Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset <code>srcOffset</code> through <code>srcOffset + bytes - 1</code> in the source segment are copied into the destination segment at offset <code>dstOffset</code> through <code>dstOffset + bytes - 1</code>. <p> If the source segment overlaps with the destination segment, then the copying is performed as if the bytes at offset <code>srcOffset</code> through <code>srcOffset + bytes - 1</code> in the source segment were first copied into a temporary segment with size <code>bytes</code>, and then the contents of the temporary segment were copied into the destination segment at offset <code>dstOffset</code> through <code>dstOffset + bytes - 1</code>. </p>
<p> The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment do not overlap, but refer to overlapping regions of the same backing storage using different addresses. For example, this may occur if the same file is <a href="../../nio/channels/filechannel#map(java.nio.channels.FileChannel.MapMode,long,long)">mapped</a> to two segments. </p>
<p> Calling this method is equivalent to the following code: </p>
<div class="snippet-container">
<button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjwhLS0KIENvcHlyaWdodCAoYykgMjAyMSwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi4KCiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXMKIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpcwogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlICJDbGFzc3BhdGgiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZAogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuCgogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUCiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IKIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQKIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuCgogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbgogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLAogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLgoKIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBCiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55CiBxdWVzdGlvbnMuCi0tPgoKPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM4MCA0NjAiIGZpbGw9IiM1MDUwNTAiPgogIDxwYXRoCiAgICAgZD0iTSAzNDYsOCBIIDEwOCBDIDkwLDggNzUsMjMgNzUsNDEgdiAzMTYgYyAwLDE4IDE1LDMzIDMzLDMzIGggMjM4IGMgMTgsMCAzMywtMTUgMzMsLTMzIFYgNDEgQyAzNzksMjMgMzY0LDggMzQ2LDggWiBtIC04LDM0NCBIIDExNiBjIC0yLDAgLTMsLTEgLTMsLTMgViA0OSBjIDAsLTIgMSwtMyAzLC0zIGggMjIyIGMgMiwwIDMsMSAzLDMgdiAzMDAgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgeiIvPgogIDxwYXRoCiAgICAgZD0ibSAyOTAsMzg5IHYgMjYgaCAxMGUtNCBjIDAsMiAtMSwzIC0zLDMgSCA0OSBjIC0yLDAgLTMsLTEgLTMsLTMgViA5OSBjIDAsLTIgMSwtMyAzLC0zIGggMjcgdiAwIGwgLTVlLTQsLTM4IEggNDEgQyAyMyw1OCA4LDczIDgsOTEgdiAzMzIgYyAxMGUtNCwxOCAxNSwzMyAzMywzMyBoIDI1NCBjIDE4LDAgMzMsLTE1IDMzLC0zMyB2IC0zNCIvPgo8L3N2Zz4K" alt="Copy snippet"></button> <pre class="lang-java" data-language="java"><code class="language-java">MemorySegment.copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);
</code></pre> </div> </div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>srcSegment</code> - the source segment.</dd> <dd>
<code>srcOffset</code> - the starting offset, in bytes, of the source segment.</dd> <dd>
<code>dstSegment</code> - the destination segment.</dd> <dd>
<code>dstOffset</code> - the starting offset, in bytes, of the destination segment.</dd> <dd>
<code>bytes</code> - the number of bytes to be copied.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>srcSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>srcSegment.isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>dstSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>dstSegment.isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>srcOffset &gt; srcSegment.byteSize() - bytes</code> or if <code>dstOffset &gt; dstSegment.byteSize() - bytes</code>, or if either <code>srcOffset</code>, <code>dstOffset</code> or <code>bytes</code> are <code>&lt; 0</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>dstSegment</code> is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="copy(java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,long)"> <h3>copy</h3> <pre class="lang-java" data-language="java">static void copy(MemorySegmentPREVIEW srcSegment, ValueLayoutPREVIEW srcElementLayout, long srcOffset, MemorySegmentPREVIEW dstSegment, ValueLayoutPREVIEW dstElementLayout, long dstOffset, long elementCount)</pre> <div class="block">Performs a bulk copy from source segment to destination segment. More specifically, if <code>S</code> is the byte size of the element layouts, the bytes at offset <code>srcOffset</code> through <code>srcOffset + (elementCount * S) - 1</code> in the source segment are copied into the destination segment at offset <code>dstOffset</code> through <code>dstOffset + (elementCount * S) - 1</code>. <p> The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements whose layout is <code>srcElementLayout</code>, whereas the bytes in the destination segment are interpreted as a sequence of elements whose layout is <code>dstElementLayout</code>. Both element layouts must have same size <code>S</code>. If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied are swapped accordingly during the copy operation. </p>
<p> If the source segment overlaps with the destination segment, then the copying is performed as if the bytes at offset <code>srcOffset</code> through <code>srcOffset + (elementCount * S) - 1</code> in the source segment were first copied into a temporary segment with size <code>bytes</code>, and then the contents of the temporary segment were copied into the destination segment at offset <code>dstOffset</code> through <code>dstOffset + (elementCount * S) - 1</code>. </p>
<p> The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment do not overlap, but refer to overlapping regions of the same backing storage using different addresses. For example, this may occur if the same file is <a href="../../nio/channels/filechannel#map(java.nio.channels.FileChannel.MapMode,long,long)">mapped</a> to two segments.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>srcSegment</code> - the source segment.</dd> <dd>
<code>srcElementLayout</code> - the element layout associated with the source segment.</dd> <dd>
<code>srcOffset</code> - the starting offset, in bytes, of the source segment.</dd> <dd>
<code>dstSegment</code> - the destination segment.</dd> <dd>
<code>dstElementLayout</code> - the element layout associated with the destination segment.</dd> <dd>
<code>dstOffset</code> - the starting offset, in bytes, of the destination segment.</dd> <dd>
<code>elementCount</code> - the number of elements to be copied.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the element layouts have different sizes, if the source (resp. destination) segment/offset are <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the source (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>srcSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>srcSegment().isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>dstSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>dstSegment().isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>dstSegment</code> is <a href="#isReadOnly()">read-only</a>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>elementCount * srcLayout.byteSize()</code> or <code>elementCount * dtsLayout.byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>dstOffset &gt; dstSegment.byteSize() - (elementCount * dstLayout.byteSize())</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if either <code>srcOffset</code>, <code>dstOffset</code> or <code>elementCount</code> are <code>&lt; 0</code>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfByte,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default byte get(ValueLayout.OfBytePREVIEW layout, long offset)</pre> <div class="block">Reads a byte from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a byte value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfByte,long,byte)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfBytePREVIEW layout, long offset, byte value)</pre> <div class="block">Writes a byte into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the byte value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfBoolean,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default boolean get(ValueLayout.OfBooleanPREVIEW layout, long offset)</pre> <div class="block">Reads a boolean from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a boolean value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfBoolean,long,boolean)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfBooleanPREVIEW layout, long offset, boolean value)</pre> <div class="block">Writes a boolean into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the boolean value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfChar,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default char get(ValueLayout.OfCharPREVIEW layout, long offset)</pre> <div class="block">Reads a char from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a char value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfChar,long,char)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfCharPREVIEW layout, long offset, char value)</pre> <div class="block">Writes a char into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the char value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfShort,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default short get(ValueLayout.OfShortPREVIEW layout, long offset)</pre> <div class="block">Reads a short from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a short value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfShort,long,short)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfShortPREVIEW layout, long offset, short value)</pre> <div class="block">Writes a short into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the short value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfInt,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default int get(ValueLayout.OfIntPREVIEW layout, long offset)</pre> <div class="block">Reads an int from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>an int value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfInt,long,int)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfIntPREVIEW layout, long offset, int value)</pre> <div class="block">Writes an int into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the int value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfFloat,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default float get(ValueLayout.OfFloatPREVIEW layout, long offset)</pre> <div class="block">Reads a float from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a float value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfFloat,long,float)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfFloatPREVIEW layout, long offset, float value)</pre> <div class="block">Writes a float into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the float value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfLong,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default long get(ValueLayout.OfLongPREVIEW layout, long offset)</pre> <div class="block">Reads a long from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a long value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfLong,long,long)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfLongPREVIEW layout, long offset, long value)</pre> <div class="block">Writes a long into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the long value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.ValueLayout.OfDouble,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default double get(ValueLayout.OfDoublePREVIEW layout, long offset)</pre> <div class="block">Reads a double from this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a double value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.ValueLayout.OfDouble,long,double)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(ValueLayout.OfDoublePREVIEW layout, long offset, double value)</pre> <div class="block">Writes a double into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the double value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="get(java.lang.foreign.AddressLayout,long)"> <h3>get</h3> <pre class="lang-java" data-language="java">default MemorySegmentPREVIEW get(AddressLayoutPREVIEW layout, long offset)</pre> <div class="block">Reads an address from this segment at the given offset, with the given layout. The read address is wrapped in a native segment, associated with a fresh scope that is always alive. Under normal conditions, the size of the returned segment is <code>0</code>. However, if the provided address layout has a <a href="addresslayout#targetLayout()">target layout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> <code>T</code>, then the size of the returned segment is set to <code>T.byteSize()</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dt>Returns:</dt> <dd>a native segment wrapping an address read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if provided address layout has a <a href="addresslayout#targetLayout()">target layout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> <code>T</code>, and the address of the returned segment <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in <code>T</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="set(java.lang.foreign.AddressLayout,long,java.lang.foreign.MemorySegment)"> <h3>set</h3> <pre class="lang-java" data-language="java">default void set(AddressLayoutPREVIEW layout, long offset, MemorySegmentPREVIEW value)</pre> <div class="block">Writes an address into this segment at the given offset, with the given layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>offset</code> - offset in bytes (relative to this segment address) at which this access operation will occur.</dd> <dd>
<code>value</code> - the address value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>value</code> is not a <a href="#isNative()">native</a> segment.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfByte,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default byte getAtIndex(ValueLayout.OfBytePREVIEW layout, long index)</pre> <div class="block">Reads a byte from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a byte value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfBoolean,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default boolean getAtIndex(ValueLayout.OfBooleanPREVIEW layout, long index)</pre> <div class="block">Reads a boolean from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a boolean value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfChar,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default char getAtIndex(ValueLayout.OfCharPREVIEW layout, long index)</pre> <div class="block">Reads a char from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a char value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfChar,long,char)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfCharPREVIEW layout, long index, char value)</pre> <div class="block">Writes a char into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the char value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfShort,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default short getAtIndex(ValueLayout.OfShortPREVIEW layout, long index)</pre> <div class="block">Reads a short from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a short value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfByte,long,byte)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfBytePREVIEW layout, long index, byte value)</pre> <div class="block">Writes a byte into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the short value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfBoolean,long,boolean)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfBooleanPREVIEW layout, long index, boolean value)</pre> <div class="block">Writes a boolean into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the short value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfShort,long,short)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfShortPREVIEW layout, long index, short value)</pre> <div class="block">Writes a short into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the short value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfInt,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default int getAtIndex(ValueLayout.OfIntPREVIEW layout, long index)</pre> <div class="block">Reads an int from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>an int value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfInt,long,int)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfIntPREVIEW layout, long index, int value)</pre> <div class="block">Writes an int into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the int value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfFloat,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default float getAtIndex(ValueLayout.OfFloatPREVIEW layout, long index)</pre> <div class="block">Reads a float from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a float value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfFloat,long,float)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfFloatPREVIEW layout, long index, float value)</pre> <div class="block">Writes a float into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the float value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfLong,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default long getAtIndex(ValueLayout.OfLongPREVIEW layout, long index)</pre> <div class="block">Reads a long from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a long value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfLong,long,long)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfLongPREVIEW layout, long index, long value)</pre> <div class="block">Writes a long into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the long value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.ValueLayout.OfDouble,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default double getAtIndex(ValueLayout.OfDoublePREVIEW layout, long index)</pre> <div class="block">Reads a double from this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a double value read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.ValueLayout.OfDouble,long,double)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(ValueLayout.OfDoublePREVIEW layout, long index, double value)</pre> <div class="block">Writes a double into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the double value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> </dl> </section><section class="detail" id="getAtIndex(java.lang.foreign.AddressLayout,long)"> <h3>getAtIndex</h3> <pre class="lang-java" data-language="java">default MemorySegmentPREVIEW getAtIndex(AddressLayoutPREVIEW layout, long index)</pre> <div class="block">Reads an address from this segment at the given at the given index, scaled by the given layout size. The read address is wrapped in a native segment, associated with a fresh scope that is always alive. Under normal conditions, the size of the returned segment is <code>0</code>. However, if the provided address layout has a <a href="addresslayout#targetLayout()">target layout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> <code>T</code>, then the size of the returned segment is set to <code>T.byteSize()</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be read.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dt>Returns:</dt> <dd>a native segment wrapping an address read from this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if provided address layout has a <a href="addresslayout#targetLayout()">target layout</a><sup><a href="addresslayout#preview-java.lang.foreign.AddressLayout">PREVIEW</a></sup> <code>T</code>, and the address of the returned segment <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in <code>T</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> </dl> </section><section class="detail" id="setAtIndex(java.lang.foreign.AddressLayout,long,java.lang.foreign.MemorySegment)"> <h3>setAtIndex</h3> <pre class="lang-java" data-language="java">default void setAtIndex(AddressLayoutPREVIEW layout, long index, MemorySegmentPREVIEW value)</pre> <div class="block">Writes an address into this segment at the given index, scaled by the given layout size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the region of memory to be written.</dd> <dd>
<code>index</code> - a logical index. The offset in bytes (relative to this segment address) at which the access operation will occur can be expressed as <code>(index * layout.byteSize())</code>.</dd> <dd>
<code>value</code> - the address value to be written.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with this segment is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the access operation is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the provided layout, or if the layout alignment is greater than its size.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>index * byteSize() &gt; byteSize() - layout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is <a href="#isReadOnly()">read-only</a>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>value</code> is not a <a href="#isNative()">native</a> segment.</dd> </dl> </section><section class="detail" id="equals(java.lang.Object)"> <h3>equals</h3> <pre class="lang-java" data-language="java">boolean equals(Object that)</pre> <div class="block">Compares the specified object with this memory segment for equality. Returns <code>true</code> if and only if the specified object is also a memory segment, and if the two segments refer to the same location, in some region of memory. More specifically, for two segments <code>s1</code> and <code>s2</code> to be considered equals, all the following must be true: <ul> <li>
<code>s1.heapBase().equals(s2.heapBase())</code>, that is, the two segments must be of the same kind; either both are <a href="#isNative()">native segments</a>, backed by off-heap memory, or both are backed by the same on-heap <a href="#heapBase()">Java object</a>; </li>
<li>
<code>s1.address() == s2.address()</code>, that is, the address of the two segments should be the same. This means that the two segments either refer to the same location in some off-heap region, or they refer to the same offset inside their associated <a href="#heapBase()">Java object</a>.</li> </ul>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../object#equals(java.lang.Object)">equals</a></code> in class <code><a href="../object" title="class in java.lang">Object</a></code>
</dd> <dt>API Note:</dt> <dd>This method does not perform a structural comparison of the contents of the two memory segments. Clients can compare memory segments structurally by using the <a href="#mismatch(java.lang.foreign.MemorySegment)"><code>mismatch(MemorySegment)</code></a> method instead. Note that this method does <em>not</em> compare the temporal and spatial bounds of two segments. As such it is suitable to check whether two segments have the same address.</dd> <dt>Parameters:</dt> <dd>
<code>that</code> - the object to be compared for equality with this memory segment.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified object is equal to this memory segment.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#mismatch(java.lang.foreign.MemorySegment)"><code>mismatch(MemorySegment)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="hashCode()"> <h3>hashCode</h3> <pre class="lang-java" data-language="java">int hashCode()</pre> <div class="block">Returns the hash code value for this memory segment.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../object#hashCode()">hashCode</a></code> in class <code><a href="../object" title="class in java.lang">Object</a></code>
</dd> <dt>Returns:</dt> <dd>the hash code value for this memory segment</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="../object#equals(java.lang.Object)"><code>Object.equals(java.lang.Object)</code></a></li> <li><a href="../system#identityHashCode(java.lang.Object)"><code>System.identityHashCode(java.lang.Object)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="copy(java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,java.lang.Object,int,int)"> <h3>copy</h3> <pre class="lang-java" data-language="java">static void copy(MemorySegmentPREVIEW srcSegment, ValueLayoutPREVIEW srcLayout, long srcOffset, Object dstArray, int dstIndex, int elementCount)</pre> <div class="block">Copies a number of elements from a source memory segment to a destination array. The elements, whose size and alignment constraints are specified by the given layout, are read from the source segment, starting at the given offset (expressed in bytes), and are copied into the destination array, at the given index. Supported array types are <code>byte[]</code>, <code>char[]</code>, <code>short[]</code>, <code>int[]</code>, <code>float[]</code>, <code>long[]</code> and <code>double[]</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>srcSegment</code> - the source segment.</dd> <dd>
<code>srcLayout</code> - the source element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dd>
<code>srcOffset</code> - the starting offset, in bytes, of the source segment.</dd> <dd>
<code>dstArray</code> - the destination array.</dd> <dd>
<code>dstIndex</code> - the starting index of the destination array.</dd> <dd>
<code>elementCount</code> - the number of array elements to be copied.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>srcSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>srcSegment().isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>dstArray</code> is not an array, or if it is an array but whose type is not supported.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the destination array component type does not match <code>srcLayout.carrier()</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>offset</code> is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the source element layout.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>srcLayout.byteAlignment() &gt; srcLayout.byteSize()</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>elementCount * srcLayout.byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>srcOffset &gt; srcSegment.byteSize() - (elementCount * srcLayout.byteSize())</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>dstIndex &gt; dstArray.length - elementCount</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if either <code>srcOffset</code>, <code>dstIndex</code> or <code>elementCount</code> are <code>&lt; 0</code>.</dd> </dl> </section><section class="detail" id="copy(java.lang.Object,int,java.lang.foreign.MemorySegment,java.lang.foreign.ValueLayout,long,int)"> <h3>copy</h3> <pre class="lang-java" data-language="java">static void copy(Object srcArray, int srcIndex, MemorySegmentPREVIEW dstSegment, ValueLayoutPREVIEW dstLayout, long dstOffset, int elementCount)</pre> <div class="block">Copies a number of elements from a source array to a destination memory segment. The elements, whose size and alignment constraints are specified by the given layout, are read from the source array, starting at the given index, and are copied into the destination segment, at the given offset (expressed in bytes). Supported array types are <code>byte[]</code>, <code>char[]</code>, <code>short[]</code>, <code>int[]</code>, <code>float[]</code>, <code>long[]</code> and <code>double[]</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>srcArray</code> - the source array.</dd> <dd>
<code>srcIndex</code> - the starting index of the source array.</dd> <dd>
<code>dstSegment</code> - the destination segment.</dd> <dd>
<code>dstLayout</code> - the destination element layout. If the byte order associated with the layout is different from the <a href="../../nio/byteorder#nativeOrder()">native order</a>, a byte swap operation will be performed on each array element.</dd> <dd>
<code>dstOffset</code> - the starting offset, in bytes, of the destination segment.</dd> <dd>
<code>elementCount</code> - the number of array elements to be copied.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>dstSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>dstSegment().isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>srcArray</code> is not an array, or if it is an array but whose type is not supported.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the source array component type does not match <code>srcLayout.carrier()</code>.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>offset</code> is <a href="memorysegment#segment-alignment">incompatible with the alignment constraint</a> in the source element layout.</dd> <dd>
<code><a href="../illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>dstLayout.byteAlignment() &gt; dstLayout.byteSize()</code>.</dd> <dd>
<code><a href="../unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>dstSegment</code> is <a href="#isReadOnly()">read-only</a>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>elementCount * dstLayout.byteSize()</code> overflows.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>dstOffset &gt; dstSegment.byteSize() - (elementCount * dstLayout.byteSize())</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>srcIndex &gt; srcArray.length - elementCount</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if either <code>srcIndex</code>, <code>dstOffset</code> or <code>elementCount</code> are <code>&lt; 0</code>.</dd> </dl> </section><section class="detail" id="mismatch(java.lang.foreign.MemorySegment,long,long,java.lang.foreign.MemorySegment,long,long)"> <h3>mismatch</h3> <pre class="lang-java" data-language="java">static long mismatch(MemorySegmentPREVIEW srcSegment, long srcFromOffset, long srcToOffset, MemorySegmentPREVIEW dstSegment, long dstFromOffset, long dstToOffset)</pre> <div class="block">Finds and returns the relative offset, in bytes, of the first mismatch between the source and the destination segments. More specifically, the bytes at offset <code>srcFromOffset</code> through <code>srcToOffset - 1</code> in the source segment are compared against the bytes at offset <code>dstFromOffset</code> through <code>dstToOffset - 1</code> in the destination segment. <p> If the two segments, over the specified ranges, share a common prefix then the returned offset is the length of the common prefix, and it follows that there is a mismatch between the two segments at that relative offset within the respective segments. If one segment is a proper prefix of the other, over the specified ranges, then the returned offset is the smallest range, and it follows that the relative offset is only valid for the segment with the larger range. Otherwise, there is no mismatch and <code>-1</code> is returned.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>srcSegment</code> - the source segment.</dd> <dd>
<code>srcFromOffset</code> - the offset (inclusive) of the first byte in the source segment to be tested.</dd> <dd>
<code>srcToOffset</code> - the offset (exclusive) of the last byte in the source segment to be tested.</dd> <dd>
<code>dstSegment</code> - the destination segment.</dd> <dd>
<code>dstFromOffset</code> - the offset (inclusive) of the first byte in the destination segment to be tested.</dd> <dd>
<code>dstToOffset</code> - the offset (exclusive) of the last byte in the destination segment to be tested.</dd> <dt>Returns:</dt> <dd>the relative offset, in bytes, of the first mismatch between the source and destination segments, otherwise -1 if no mismatch.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>srcSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>srcSegment.isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the <a href="#scope()">scope</a> associated with <code>dstSegment</code> is not <a href="memorysegment.scope#isAlive()">alive</a><sup><a href="memorysegment.scope#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup>.</dd> <dd>
<code><a href="../wrongthreadexception" title="class in java.lang">WrongThreadException</a></code> - if this method is called from a thread <code>T</code>, such that <code>dstSegment.isAccessibleBy(T) == false</code>.</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>srcFromOffset &lt; 0</code>, <code>srcToOffset &lt; srcFromOffset</code> or <code>srcToOffset &gt; srcSegment.byteSize()</code>
</dd> <dd>
<code><a href="../indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>dstFromOffset &lt; 0</code>, <code>dstToOffset &lt; dstFromOffset</code> or <code>dstToOffset &gt; dstSegment.byteSize()</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#mismatch(java.lang.foreign.MemorySegment)"><code>mismatch(MemorySegment)</code></a></li> <li><a href="../../util/arrays#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)"><code>Arrays.mismatch(Object[], int, int, Object[], int, int)</code></a></li> </ul> </dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/MemorySegment.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/MemorySegment.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
