
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Collectors - OpenJDK 21 - W3cubDocs</title>
  
  <meta name="description" content=" The following are examples of using the predefined collectors to perform common mutable reduction tasks&#58; ">
  <meta name="keywords" content="class, collectors, openjdk, openjdk~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~21/java.base/java/util/stream/collectors.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/openjdk~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~21/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<h1 title="Class Collectors" class="title">Class Collectors</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../../lang/object" title="class in java.lang">java.lang.Object</a> <div class="inheritance">java.util.stream.Collectors</div> </div> <section class="class-description" id="class-description">  <pre class="lang-java" data-language="java">public final class Collectors extends Object</pre> <div class="block">Implementations of <a href="collector" title="interface in java.util.stream"><code>Collector</code></a> that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc. <p>The following are examples of using the predefined collectors to perform common mutable reduction tasks: </p>
<pre class="lang-java" data-language="java"><code>
 // Accumulate names into a List
 List&lt;String&gt; list = people.stream()
   .map(Person::getName)
   .collect(Collectors.toList());

 // Accumulate names into a TreeSet
 Set&lt;String&gt; set = people.stream()
   .map(Person::getName)
   .collect(Collectors.toCollection(TreeSet::new));

 // Convert elements to strings and concatenate them, separated by commas
 String joined = things.stream()
   .map(Object::toString)
   .collect(Collectors.joining(", "));

 // Compute sum of salaries of employee
 int total = employees.stream()
   .collect(Collectors.summingInt(Employee::getSalary));

 // Group employees by department
 Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()
   .collect(Collectors.groupingBy(Employee::getDepartment));

 // Compute sum of salaries by department
 Map&lt;Department, Integer&gt; totalByDept = employees.stream()
   .collect(Collectors.groupingBy(Employee::getDepartment,
                                  Collectors.summingInt(Employee::getSalary)));

 // Partition students into passing and failing
 Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()
   .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));

 </code></pre>
</div> <dl class="notes"> <dt>Since:</dt> <dd>1.8</dd> </dl> </section> <section class="summary"> <section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                                                                                        <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../../lang/double" title="class in java.lang">Double</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#averagingDouble(java.util.function.ToDoubleFunction)" class="member-name-link">averagingDouble</a><wbr>(<a href="../function/todoublefunction" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the arithmetic mean of a double-valued function applied to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../../lang/double" title="class in java.lang">Double</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#averagingInt(java.util.function.ToIntFunction)" class="member-name-link">averagingInt</a><wbr>(<a href="../function/tointfunction" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the arithmetic mean of an integer-valued function applied to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../../lang/double" title="class in java.lang">Double</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#averagingLong(java.util.function.ToLongFunction)" class="member-name-link">averagingLong</a><wbr>(<a href="../function/tolongfunction" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the arithmetic mean of a long-valued function applied to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
A,<wbr>
R,<wbr>
RR&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>A,<wbr>RR&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#collectingAndThen(java.util.stream.Collector,java.util.function.Function)" class="member-name-link">collectingAndThen</a><wbr>(<a href="collector" title="interface in java.util.stream">Collector</a>&lt;T,<wbr>A,<wbr>R&gt; downstream,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;R,<wbr>RR&gt; finisher)</wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Adapts a <code>Collector</code> to perform an additional finishing transformation.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../../lang/long" title="class in java.lang">Long</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#counting()" class="member-name-link">counting</a>()</code></td>
<td> <div class="block">Returns a <code>Collector</code> accepting elements of type <code>T</code> that counts the number of input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
A,<wbr>
R&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>R&gt;</wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#filtering(java.util.function.Predicate,java.util.stream.Collector)" class="member-name-link">filtering</a><wbr>(<a href="../function/predicate" title="interface in java.util.function">Predicate</a>&lt;? super T&gt; predicate,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>A,<wbr>R&gt; downstream)</wbr></wbr></wbr></code></td>
<td> <div class="block">Adapts a <code>Collector</code> to one accepting elements of the same type <code>T</code> by applying the predicate to each input element and only accumulating if the predicate returns <code>true</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
U,<wbr>
A,<wbr>
R&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>R&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#flatMapping(java.util.function.Function,java.util.stream.Collector)" class="member-name-link">flatMapping</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends <a href="stream" title="interface in java.util.stream">Stream</a>&lt;? extends U&gt;&gt; mapper,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super U,<wbr>A,<wbr>R&gt; downstream)</wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a flat mapping function to each input element before accumulation.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr><a href="../list" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#groupingBy(java.util.function.Function)" class="member-name-link">groupingBy</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; classifier)</wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and returning the results in a <code>Map</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
D,<wbr>
A,<wbr>
M extends <a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr>
D&gt;&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>M&gt;</wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)" class="member-name-link">groupingBy</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; classifier,
 <a href="../function/supplier" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>A,<wbr>D&gt; downstream)</wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
A,<wbr>
D&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr>D&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)" class="member-name-link">groupingBy</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; classifier,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>A,<wbr>D&gt; downstream)</wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../concurrent/concurrentmap" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<wbr><a href="../list" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#groupingByConcurrent(java.util.function.Function)" class="member-name-link">groupingByConcurrent</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; classifier)</wbr></wbr></code></td>
<td> <div class="block">Returns a concurrent <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
A,<wbr>
D,<wbr>
M extends <a href="../concurrent/concurrentmap" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<wbr>
D&gt;&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>M&gt;</wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)" class="member-name-link">groupingByConcurrent</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; classifier,
 <a href="../function/supplier" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>A,<wbr>D&gt; downstream)</wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
A,<wbr>
D&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../concurrent/concurrentmap" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<wbr>D&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)" class="member-name-link">groupingByConcurrent</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; classifier,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>A,<wbr>D&gt; downstream)</wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</div> </td>
</tr>
<tr>
<td><code>static <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;<a href="../../lang/charsequence" title="interface in java.lang">CharSequence</a>,<wbr>?,<wbr><a href="../../lang/string" title="class in java.lang">String</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#joining()" class="member-name-link">joining</a>()</code></td>
<td> <div class="block">Returns a <code>Collector</code> that concatenates the input elements into a <code>String</code>, in encounter order.</div> </td>
</tr>
<tr>
<td><code>static <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;<a href="../../lang/charsequence" title="interface in java.lang">CharSequence</a>,<wbr>?,<wbr><a href="../../lang/string" title="class in java.lang">String</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#joining(java.lang.CharSequence)" class="member-name-link">joining</a><wbr>(<a href="../../lang/charsequence" title="interface in java.lang">CharSequence</a> delimiter)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, in encounter order.</div> </td>
</tr>
<tr>
<td><code>static <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;<a href="../../lang/charsequence" title="interface in java.lang">CharSequence</a>,<wbr>?,<wbr><a href="../../lang/string" title="class in java.lang">String</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)" class="member-name-link">joining</a><wbr>(<a href="../../lang/charsequence" title="interface in java.lang">CharSequence</a> delimiter,
 <a href="../../lang/charsequence" title="interface in java.lang">CharSequence</a> prefix,
 <a href="../../lang/charsequence" title="interface in java.lang">CharSequence</a> suffix)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
U,<wbr>
A,<wbr>
R&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>R&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#mapping(java.util.function.Function,java.util.stream.Collector)" class="member-name-link">mapping</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; mapper,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super U,<wbr>A,<wbr>R&gt; downstream)</wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a mapping function to each input element before accumulation.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../optional" title="class in java.util">Optional</a>&lt;T&gt;&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#maxBy(java.util.Comparator)" class="member-name-link">maxBy</a><wbr>(<a href="../comparator" title="interface in java.util">Comparator</a>&lt;? super T&gt; comparator)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the maximal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../optional" title="class in java.util">Optional</a>&lt;T&gt;&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#minBy(java.util.Comparator)" class="member-name-link">minBy</a><wbr>(<a href="../comparator" title="interface in java.util">Comparator</a>&lt;? super T&gt; comparator)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the minimal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;<a href="../../lang/boolean" title="class in java.lang">Boolean</a>,<wbr><a href="../list" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#partitioningBy(java.util.function.Predicate)" class="member-name-link">partitioningBy</a><wbr>(<a href="../function/predicate" title="interface in java.util.function">Predicate</a>&lt;? super T&gt; predicate)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, and organizes them into a <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
D,<wbr>
A&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;<a href="../../lang/boolean" title="class in java.lang">Boolean</a>,<wbr>D&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#partitioningBy(java.util.function.Predicate,java.util.stream.Collector)" class="member-name-link">partitioningBy</a><wbr>(<a href="../function/predicate" title="interface in java.util.function">Predicate</a>&lt;? super T&gt; predicate,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>A,<wbr>D&gt; downstream)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, reduces the values in each partition according to another <code>Collector</code>, and organizes them into a <code>Map&lt;Boolean, D&gt;</code> whose values are the result of the downstream reduction.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../optional" title="class in java.util">Optional</a>&lt;T&gt;&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#reducing(java.util.function.BinaryOperator)" class="member-name-link">reducing</a><wbr>(<a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>T&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#reducing(T,java.util.function.BinaryOperator)" class="member-name-link">reducing</a><wbr>(T identity,
 <a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code> using the provided identity.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
U&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>U&gt;</wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)" class="member-name-link">reducing</a><wbr>(U identity,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; mapper,
 <a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; op)</wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which performs a reduction of its input elements under a specified mapping function and <code>BinaryOperator</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../doublesummarystatistics" title="class in java.util">DoubleSummaryStatistics</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#summarizingDouble(java.util.function.ToDoubleFunction)" class="member-name-link">summarizingDouble</a><wbr>(<a href="../function/todoublefunction" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which applies an <code>double</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../intsummarystatistics" title="class in java.util">IntSummaryStatistics</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#summarizingInt(java.util.function.ToIntFunction)" class="member-name-link">summarizingInt</a><wbr>(<a href="../function/tointfunction" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which applies an <code>int</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../longsummarystatistics" title="class in java.util">LongSummaryStatistics</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#summarizingLong(java.util.function.ToLongFunction)" class="member-name-link">summarizingLong</a><wbr>(<a href="../function/tolongfunction" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> which applies an <code>long</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../../lang/double" title="class in java.lang">Double</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#summingDouble(java.util.function.ToDoubleFunction)" class="member-name-link">summingDouble</a><wbr>(<a href="../function/todoublefunction" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the sum of a double-valued function applied to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../../lang/integer" title="class in java.lang">Integer</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#summingInt(java.util.function.ToIntFunction)" class="member-name-link">summingInt</a><wbr>(<a href="../function/tointfunction" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the sum of an integer-valued function applied to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../../lang/long" title="class in java.lang">Long</a>&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#summingLong(java.util.function.ToLongFunction)" class="member-name-link">summingLong</a><wbr>(<a href="../function/tolongfunction" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that produces the sum of a long-valued function applied to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
R1,<wbr>
R2,<wbr>
R&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>R&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction)" class="member-name-link">teeing</a><wbr>(<a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>?,<wbr>R1&gt; downstream1,
 <a href="collector" title="interface in java.util.stream">Collector</a>&lt;? super T,<wbr>?,<wbr>R2&gt; downstream2,
 <a href="../function/bifunction" title="interface in java.util.function">BiFunction</a>&lt;? super R1,<wbr>? super R2,<wbr>R&gt; merger)</wbr></wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that is a composite of two downstream collectors.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
C extends <a href="../collection" title="interface in java.util">Collection</a>&lt;T&gt;&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>C&gt;</wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toCollection(java.util.function.Supplier)" class="member-name-link">toCollection</a><wbr>(<a href="../function/supplier" title="interface in java.util.function">Supplier</a>&lt;C&gt; collectionFactory)</wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into a new <code>Collection</code>, in encounter order.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../concurrent/concurrentmap" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<wbr>U&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)" class="member-name-link">toConcurrentMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../concurrent/concurrentmap" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<wbr>U&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)" class="member-name-link">toConcurrentMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper,
 <a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U,<wbr>
M extends <a href="../concurrent/concurrentmap" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<wbr>
U&gt;&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>M&gt;</wbr></wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)" class="member-name-link">toConcurrentMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper,
 <a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction,
 <a href="../function/supplier" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../list" title="interface in java.util">List</a>&lt;T&gt;&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#toList()" class="member-name-link">toList</a>()</code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into a new <code>List</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr>U&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toMap(java.util.function.Function,java.util.function.Function)" class="member-name-link">toMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr>U&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)" class="member-name-link">toMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper,
 <a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U,<wbr>
M extends <a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr>
U&gt;&gt;<br><a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr>M&gt;</wbr></wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)" class="member-name-link">toMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper,
 <a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction,
 <a href="../function/supplier" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../set" title="interface in java.util">Set</a>&lt;T&gt;&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#toSet()" class="member-name-link">toSet</a>()</code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into a new <code>Set</code>.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../list" title="interface in java.util">List</a>&lt;T&gt;&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#toUnmodifiableList()" class="member-name-link">toUnmodifiableList</a>()</code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../list#unmodifiable">unmodifiable List</a> in encounter order.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr>U&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function)" class="member-name-link">toUnmodifiableMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T,<wbr>
K,<wbr>
U&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../map" title="interface in java.util">Map</a>&lt;K,<wbr>U&gt;&gt;</wbr></wbr></wbr></wbr></wbr></wbr></code></td>
<td><code><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)" class="member-name-link">toUnmodifiableMap</a><wbr>(<a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends K&gt; keyMapper,
 <a href="../function/function" title="interface in java.util.function">Function</a>&lt;? super T,<wbr>? extends U&gt; valueMapper,
 <a href="../function/binaryoperator" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction)</wbr></wbr></wbr></code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements.</div> </td>
</tr>
<tr>
<td><code>static &lt;T&gt; <a href="collector" title="interface in java.util.stream">Collector</a><wbr>&lt;T,<wbr>?,<wbr><a href="../set" title="interface in java.util">Set</a>&lt;T&gt;&gt;</wbr></wbr></wbr></code></td>
<td><code><a href="#toUnmodifiableSet()" class="member-name-link">toUnmodifiableSet</a>()</code></td>
<td> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../set#unmodifiable">unmodifiable Set</a>.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../../lang/object" title="class in java.lang">Object</a>
</h3> <code><a href="../../lang/object#clone()">clone</a>, <a href="../../lang/object#equals(java.lang.Object)">equals</a>, <a href="../../lang/object#finalize()">finalize</a>, <a href="../../lang/object#getClass()">getClass</a>, <a href="../../lang/object#hashCode()">hashCode</a>, <a href="../../lang/object#notify()">notify</a>, <a href="../../lang/object#notifyAll()">notifyAll</a>, <a href="../../lang/object#toString()">toString</a>, <a href="../../lang/object#wait()">wait</a>, <a href="../../lang/object#wait(long)">wait</a>, <a href="../../lang/object#wait(long,int)">wait</a></code>
</div> </section> </section> <section class="details"> <section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="toCollection(java.util.function.Supplier)"> <h3>toCollection</h3> <pre class="lang-java" data-language="java">public static &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T,?,C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</pre> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into a new <code>Collection</code>, in encounter order. The <code>Collection</code> is created by the provided factory.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>C</code> - the type of the resulting <code>Collection</code>
</dd> <dt>Parameters:</dt> <dd>
<code>collectionFactory</code> - a supplier providing a new empty <code>Collection</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects all the input elements into a <code>Collection</code>, in encounter order</dd> </dl> </section><section class="detail" id="toList()"> <h3>toList</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,List&lt;T&gt;&gt; toList()</pre> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into a new <code>List</code>. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>List</code> returned; if more control over the returned <code>List</code> is required, use <a href="#toCollection(java.util.function.Supplier)"><code>toCollection(Supplier)</code></a>.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects all the input elements into a <code>List</code>, in encounter order</dd> </dl> </section><section class="detail" id="toUnmodifiableList()"> <h3>toUnmodifiableList</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,List&lt;T&gt;&gt; toUnmodifiableList()</pre> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../list#unmodifiable">unmodifiable List</a> in encounter order. The returned Collector disallows null values and will throw <code>NullPointerException</code> if it is presented with a null value.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../list#unmodifiable">unmodifiable List</a> in encounter order</dd> <dt>Since:</dt> <dd>10</dd> </dl> </section><section class="detail" id="toSet()"> <h3>toSet</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Set&lt;T&gt;&gt; toSet()</pre> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into a new <code>Set</code>. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Set</code> returned; if more control over the returned <code>Set</code> is required, use <a href="#toCollection(java.util.function.Supplier)"><code>toCollection(Supplier)</code></a>. <p>This is an <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects all the input elements into a <code>Set</code>
</dd> </dl> </section><section class="detail" id="toUnmodifiableSet()"> <h3>toUnmodifiableSet</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Set&lt;T&gt;&gt; toUnmodifiableSet()</pre> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../set#unmodifiable">unmodifiable Set</a>. The returned Collector disallows null values and will throw <code>NullPointerException</code> if it is presented with a null value. If the input contains duplicate elements, an arbitrary element of the duplicates is preserved. <p>This is an <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../set#unmodifiable">unmodifiable Set</a>
</dd> <dt>Since:</dt> <dd>10</dd> </dl> </section><section class="detail" id="joining()"> <h3>joining</h3> <pre class="lang-java" data-language="java">public static Collector&lt;CharSequence,?,String&gt; joining()</pre> <div class="block">Returns a <code>Collector</code> that concatenates the input elements into a <code>String</code>, in encounter order.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a <code>Collector</code> that concatenates the input elements into a <code>String</code>, in encounter order</dd> </dl> </section><section class="detail" id="joining(java.lang.CharSequence)"> <h3>joining</h3> <pre class="lang-java" data-language="java">public static Collector&lt;CharSequence,?,String&gt; joining(CharSequence delimiter)</pre> <div class="block">Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, in encounter order.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>delimiter</code> - the delimiter to be used between each element</dd> <dt>Returns:</dt> <dd>A <code>Collector</code> which concatenates CharSequence elements, separated by the specified delimiter, in encounter order</dd> </dl> </section><section class="detail" id="joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)"> <h3>joining</h3> <pre class="lang-java" data-language="java">public static Collector&lt;CharSequence,?,String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</pre> <div class="block">Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>delimiter</code> - the delimiter to be used between each element</dd> <dd>
<code>prefix</code> - the sequence of characters to be used at the beginning of the joined result</dd> <dd>
<code>suffix</code> - the sequence of characters to be used at the end of the joined result</dd> <dt>Returns:</dt> <dd>A <code>Collector</code> which concatenates CharSequence elements, separated by the specified delimiter, in encounter order</dd> </dl> </section><section class="detail" id="mapping(java.util.function.Function,java.util.stream.Collector)"> <h3>mapping</h3> <pre class="lang-java" data-language="java">public static &lt;T, U, A, R&gt; Collector&lt;T,?,R&gt; mapping(Function&lt;? super T,? extends U&gt; mapper, Collector&lt;? super U,A,R&gt; downstream)</pre> <div class="block">Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a mapping function to each input element before accumulation.</div> <dl class="notes"> <dt>API Note:</dt> <dd>The <code>mapping()</code> collectors are most useful when used in a multi-level reduction, such as downstream of a <code>groupingBy</code> or <code>partitioningBy</code>. For example, given a stream of <code>Person</code>, to accumulate the set of last names in each city: <pre class="lang-java" data-language="java"><code>
 Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                mapping(Person::getLastName,
                        toSet())));
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>U</code> - type of elements accepted by downstream collector</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of collector</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function to be applied to the input elements</dd> <dd>
<code>downstream</code> - a collector which will accept mapped values</dd> <dt>Returns:</dt> <dd>a collector which applies the mapping function to the input elements and provides the mapped results to the downstream collector</dd> </dl> </section><section class="detail" id="flatMapping(java.util.function.Function,java.util.stream.Collector)"> <h3>flatMapping</h3> <pre class="lang-java" data-language="java">public static &lt;T, U, A, R&gt; Collector&lt;T,?,R&gt; flatMapping(Function&lt;? super T,? extends Stream&lt;? extends U&gt;&gt; mapper, Collector&lt;? super U,A,R&gt; downstream)</pre> <div class="block">Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a flat mapping function to each input element before accumulation. The flat mapping function maps an input element to a <a href="stream" title="interface in java.util.stream"><code>stream</code></a> covering zero or more output elements that are then accumulated downstream. Each mapped stream is <a href="basestream#close()"><code>closed</code></a> after its contents have been placed downstream. (If a mapped stream is <code>null</code> an empty stream is used, instead.)</div> <dl class="notes"> <dt>API Note:</dt> <dd>The <code>flatMapping()</code> collectors are most useful when used in a multi-level reduction, such as downstream of a <code>groupingBy</code> or <code>partitioningBy</code>. For example, given a stream of <code>Order</code>, to accumulate the set of line items for each customer: <pre class="lang-java" data-language="java"><code>
 Map&lt;String, Set&lt;LineItem&gt;&gt; itemsByCustomerName
   = orders.stream().collect(
     groupingBy(Order::getCustomerName,
                flatMapping(order -&gt; order.getLineItems().stream(),
                            toSet())));
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>U</code> - type of elements accepted by downstream collector</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of collector</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function to be applied to the input elements, which returns a stream of results</dd> <dd>
<code>downstream</code> - a collector which will receive the elements of the stream returned by mapper</dd> <dt>Returns:</dt> <dd>a collector which applies the mapping function to the input elements and provides the flat mapped results to the downstream collector</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="filtering(java.util.function.Predicate,java.util.stream.Collector)"> <h3>filtering</h3> <pre class="lang-java" data-language="java">public static &lt;T, A, R&gt; Collector&lt;T,?,R&gt; filtering(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T,A,R&gt; downstream)</pre> <div class="block">Adapts a <code>Collector</code> to one accepting elements of the same type <code>T</code> by applying the predicate to each input element and only accumulating if the predicate returns <code>true</code>.</div> <dl class="notes"> <dt>API Note:</dt> <dd>The <code>filtering()</code> collectors are most useful when used in a multi-level reduction, such as downstream of a <code>groupingBy</code> or <code>partitioningBy</code>. For example, given a stream of <code>Employee</code>, to accumulate the employees in each department that have a salary above a certain threshold: <pre class="lang-java" data-language="java"><code>
 Map&lt;Department, Set&lt;Employee&gt;&gt; wellPaidEmployeesByDepartment
   = employees.stream().collect(
     groupingBy(Employee::getDepartment,
                filtering(e -&gt; e.getSalary() &gt; 2000,
                          toSet())));
 </code></pre> A filtering collector differs from a stream's <code>filter()</code> operation. In this example, suppose there are no employees whose salary is above the threshold in some department. Using a filtering collector as shown above would result in a mapping from that department to an empty <code>Set</code>. If a stream <code>filter()</code> operation were done instead, there would be no mapping for that department at all.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of collector</dd> <dt>Parameters:</dt> <dd>
<code>predicate</code> - a predicate to be applied to the input elements</dd> <dd>
<code>downstream</code> - a collector which will accept values that match the predicate</dd> <dt>Returns:</dt> <dd>a collector which applies the predicate to the input elements and provides matching elements to the downstream collector</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="collectingAndThen(java.util.stream.Collector,java.util.function.Function)"> <h3>collectingAndThen</h3> <pre class="lang-java" data-language="java">public static &lt;T, A, R, RR&gt; Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher)</pre> <div class="block">Adapts a <code>Collector</code> to perform an additional finishing transformation. For example, one could adapt the <a href="#toList()"><code>toList()</code></a> collector to always produce an immutable list with: <pre class="lang-java" data-language="java"><code>
 List&lt;String&gt; list = people.stream().collect(
   collectingAndThen(toList(),
                     Collections::unmodifiableList));
 </code></pre>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of the downstream collector</dd> <dd>
<code>RR</code> - result type of the resulting collector</dd> <dt>Parameters:</dt> <dd>
<code>downstream</code> - a collector</dd> <dd>
<code>finisher</code> - a function to be applied to the final result of the downstream collector</dd> <dt>Returns:</dt> <dd>a collector which performs the action of the downstream collector, followed by an additional finishing step</dd> </dl> </section><section class="detail" id="counting()"> <h3>counting</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Long&gt; counting()</pre> <div class="block">Returns a <code>Collector</code> accepting elements of type <code>T</code> that counts the number of input elements. If no elements are present, the result is 0.</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>This produces a result equivalent to: <pre class="lang-java" data-language="java"><code>
     reducing(0L, e -&gt; 1L, Long::sum)
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that counts the input elements</dd> </dl> </section><section class="detail" id="minBy(java.util.Comparator)"> <h3>minBy</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator)</pre> <div class="block">Returns a <code>Collector</code> that produces the minimal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>This produces a result equivalent to: <pre class="lang-java" data-language="java"><code>
     reducing(BinaryOperator.minBy(comparator))
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>comparator</code> - a <code>Comparator</code> for comparing elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the minimal value</dd> </dl> </section><section class="detail" id="maxBy(java.util.Comparator)"> <h3>maxBy</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator)</pre> <div class="block">Returns a <code>Collector</code> that produces the maximal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>This produces a result equivalent to: <pre class="lang-java" data-language="java"><code>
     reducing(BinaryOperator.maxBy(comparator))
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>comparator</code> - a <code>Comparator</code> for comparing elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the maximal value</dd> </dl> </section><section class="detail" id="summingInt(java.util.function.ToIntFunction)"> <h3>summingInt</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> that produces the sum of an integer-valued function applied to the input elements. If no elements are present, the result is 0.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be summed</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the sum of a derived property</dd> </dl> </section><section class="detail" id="summingLong(java.util.function.ToLongFunction)"> <h3>summingLong</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> that produces the sum of a long-valued function applied to the input elements. If no elements are present, the result is 0.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be summed</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the sum of a derived property</dd> </dl> </section><section class="detail" id="summingDouble(java.util.function.ToDoubleFunction)"> <h3>summingDouble</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> that produces the sum of a double-valued function applied to the input elements. If no elements are present, the result is 0. <p>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a <code>NaN</code> or the sum is at any point a <code>NaN</code> then the sum will be <code>NaN</code>.</p>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be summed</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the sum of a derived property</dd> </dl> </section><section class="detail" id="averagingInt(java.util.function.ToIntFunction)"> <h3>averagingInt</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> that produces the arithmetic mean of an integer-valued function applied to the input elements. If no elements are present, the result is 0.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be averaged</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the arithmetic mean of a derived property</dd> </dl> </section><section class="detail" id="averagingLong(java.util.function.ToLongFunction)"> <h3>averagingLong</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> that produces the arithmetic mean of a long-valued function applied to the input elements. If no elements are present, the result is 0.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be averaged</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the arithmetic mean of a derived property</dd> </dl> </section><section class="detail" id="averagingDouble(java.util.function.ToDoubleFunction)"> <h3>averagingDouble</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> that produces the arithmetic mean of a double-valued function applied to the input elements. If no elements are present, the result is 0. <p>The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a <code>NaN</code> or the sum is at any point a <code>NaN</code> then the average will be <code>NaN</code>.</p>
</div> <dl class="notes"> <dt>Implementation Note:</dt> <dd>The <code>double</code> format can represent all consecutive integers in the range -2<sup>53</sup> to 2<sup>53</sup>. If the pipeline has more than 2<sup>53</sup> values, the divisor in the average computation will saturate at 2<sup>53</sup>, leading to additional numerical errors.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be averaged</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the arithmetic mean of a derived property</dd> </dl> </section><section class="detail" id="reducing(T,java.util.function.BinaryOperator)"> <h3 id="reducing(java.lang.Object,java.util.function.BinaryOperator)">reducing</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</pre> <div class="block">Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code> using the provided identity.</div> <dl class="notes"> <dt>API Note:</dt> <dd>The <code>reducing()</code> collectors are most useful when used in a multi-level reduction, downstream of <code>groupingBy</code> or <code>partitioningBy</code>. To perform a simple reduction on a stream, use <a href="stream#reduce(T,java.util.function.BinaryOperator)"><code>Stream.reduce(Object, BinaryOperator)</code></a>} instead.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - element type for the input and output of the reduction</dd> <dt>Parameters:</dt> <dd>
<code>identity</code> - the identity value for the reduction (also, the value that is returned when there are no input elements)</dd> <dd>
<code>op</code> - a <code>BinaryOperator&lt;T&gt;</code> used to reduce the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which implements the reduction operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#reducing(java.util.function.BinaryOperator)"><code>reducing(BinaryOperator)</code></a></li> <li><a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"><code>reducing(Object, Function, BinaryOperator)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="reducing(java.util.function.BinaryOperator)"> <h3>reducing</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</pre> <div class="block">Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code>. The result is described as an <code>Optional&lt;T&gt;</code>.</div> <dl class="notes"> <dt>API Note:</dt> <dd>The <code>reducing()</code> collectors are most useful when used in a multi-level reduction, downstream of <code>groupingBy</code> or <code>partitioningBy</code>. To perform a simple reduction on a stream, use <a href="stream#reduce(java.util.function.BinaryOperator)"><code>Stream.reduce(BinaryOperator)</code></a> instead. <p>For example, given a stream of <code>Person</code>, to calculate tallest person in each city: </p>
<pre class="lang-java" data-language="java"><code>
 Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight);
 Map&lt;City, Optional&lt;Person&gt;&gt; tallestByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                reducing(BinaryOperator.maxBy(byHeight))));
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - element type for the input and output of the reduction</dd> <dt>Parameters:</dt> <dd>
<code>op</code> - a <code>BinaryOperator&lt;T&gt;</code> used to reduce the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which implements the reduction operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a></li> <li><a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"><code>reducing(Object, Function, BinaryOperator)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"> <h3 id="reducing(java.lang.Object,java.util.function.Function,java.util.function.BinaryOperator)">reducing</h3> <pre class="lang-java" data-language="java">public static &lt;T, U&gt; Collector&lt;T,?,U&gt; reducing(U identity, Function&lt;? super T,? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</pre> <div class="block">Returns a <code>Collector</code> which performs a reduction of its input elements under a specified mapping function and <code>BinaryOperator</code>. This is a generalization of <a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a> which allows a transformation of the elements before reduction.</div> <dl class="notes"> <dt>API Note:</dt> <dd>The <code>reducing()</code> collectors are most useful when used in a multi-level reduction, downstream of <code>groupingBy</code> or <code>partitioningBy</code>. To perform a simple map-reduce on a stream, use <a href="stream#map(java.util.function.Function)"><code>Stream.map(Function)</code></a> and <a href="stream#reduce(T,java.util.function.BinaryOperator)"><code>Stream.reduce(Object, BinaryOperator)</code></a> instead. <p>For example, given a stream of <code>Person</code>, to calculate the longest last name of residents in each city: </p>
<pre class="lang-java" data-language="java"><code>
 Comparator&lt;String&gt; byLength = Comparator.comparing(String::length);
 Map&lt;City, String&gt; longestLastNameByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                reducing("",
                         Person::getLastName,
                         BinaryOperator.maxBy(byLength))));
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>U</code> - the type of the mapped values</dd> <dt>Parameters:</dt> <dd>
<code>identity</code> - the identity value for the reduction (also, the value that is returned when there are no input elements)</dd> <dd>
<code>mapper</code> - a mapping function to apply to each input value</dd> <dd>
<code>op</code> - a <code>BinaryOperator&lt;U&gt;</code> used to reduce the mapped values</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the map-reduce operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a></li> <li><a href="#reducing(java.util.function.BinaryOperator)"><code>reducing(BinaryOperator)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="groupingBy(java.util.function.Function)"> <h3>groupingBy</h3> <pre class="lang-java" data-language="java">public static &lt;T, K&gt; Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T,? extends K&gt; classifier)</pre> <div class="block">Returns a <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and returning the results in a <code>Map</code>. <p>The classification function maps elements to some key type <code>K</code>. The collector produces a <code>Map&lt;K, List&lt;T&gt;&gt;</code> whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are <code>List</code>s containing the input elements which map to the associated key under the classification function. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> or <code>List</code> objects returned.</p>
</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>This produces a result similar to: <pre class="lang-java" data-language="java"><code>
     groupingBy(classifier, toList());
 </code></pre>
</dd> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting <code>Map</code> collector is not required, using <a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - the classifier function mapping input elements to keys</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the group-by operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a></li> <li><a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="groupingBy(java.util.function.Function,java.util.stream.Collector)"> <h3>groupingBy</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, A, D&gt; Collector&lt;T,?,Map&lt;K,D&gt;&gt; groupingBy(Function&lt;? super T,? extends K&gt; classifier, Collector&lt;? super T,A,D&gt; downstream)</pre> <div class="block">Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. <p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>Map&lt;K, D&gt;</code>. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned. </p>
<p>For example, to compute the set of last names of people in each city: </p>
<pre class="lang-java" data-language="java"><code>
 Map&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                mapping(Person::getLastName,
                        toSet())));
 </code></pre>
</div> <dl class="notes"> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a></li> <li><a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"> <h3>groupingBy</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T,?,M&gt; groupingBy(Function&lt;? super T,? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T,A,D&gt; downstream)</pre> <div class="block">Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. The <code>Map</code> produced by the Collector is created with the supplied factory function. <p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>Map&lt;K, D&gt;</code>. </p>
<p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p>
<pre class="lang-java" data-language="java"><code>
 Map&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                TreeMap::new,
                mapping(Person::getLastName,
                        toSet())));
 </code></pre>
</div> <dl class="notes"> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>M</code> - the type of the resulting <code>Map</code>
</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>Map</code> into which the results will be inserted</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a></li> <li><a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="groupingByConcurrent(java.util.function.Function)"> <h3>groupingByConcurrent</h3> <pre class="lang-java" data-language="java">public static &lt;T, K&gt; Collector&lt;T,?,ConcurrentMap&lt;K,List&lt;T&gt;&gt;&gt; groupingByConcurrent(Function&lt;? super T,? extends K&gt; classifier)</pre> <div class="block">Returns a concurrent <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function. <p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector. </p>
<p>The classification function maps elements to some key type <code>K</code>. The collector produces a <code>ConcurrentMap&lt;K, List&lt;T&gt;&gt;</code> whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are <code>List</code>s containing the input elements which map to the associated key under the classification function. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> or <code>List</code> objects returned, or of the thread-safety of the <code>List</code> objects returned.</p>
</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>This produces a result similar to: <pre class="lang-java" data-language="java"><code>
     groupingByConcurrent(classifier, toList());
 </code></pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> implementing the group-by operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"> <h3>groupingByConcurrent</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, A, D&gt; Collector&lt;T,?,ConcurrentMap&lt;K,D&gt;&gt; groupingByConcurrent(Function&lt;? super T,? extends K&gt; classifier, Collector&lt;? super T,A,D&gt; downstream)</pre> <div class="block">Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. <p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector. </p>
<p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>ConcurrentMap&lt;K, D&gt;</code>. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> returned. </p>
<p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p>
<pre class="lang-java" data-language="java"><code>
 ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingByConcurrent(Person::getCity,
                          mapping(Person::getLastName,
                                  toSet())));
 </code></pre>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"> <h3>groupingByConcurrent</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, A, D, M extends ConcurrentMap&lt;K, D&gt;&gt; Collector&lt;T,?,M&gt; groupingByConcurrent(Function&lt;? super T,? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T,A,D&gt; downstream)</pre> <div class="block">Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. The <code>ConcurrentMap</code> produced by the Collector is created with the supplied factory function. <p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector. </p>
<p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>ConcurrentMap&lt;K, D&gt;</code>. </p>
<p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p>
<pre class="lang-java" data-language="java"><code>
 ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingByConcurrent(Person::getCity,
                          ConcurrentSkipListMap::new,
                          mapping(Person::getLastName,
                                  toSet())));
 </code></pre>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dd>
<code>M</code> - the type of the resulting <code>ConcurrentMap</code>
</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>ConcurrentMap</code> into which the results will be inserted</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a></li> <li><a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a></li> <li><a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="partitioningBy(java.util.function.Predicate)"> <h3>partitioningBy</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,Map&lt;Boolean,List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)</pre> <div class="block">Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, and organizes them into a <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code>. The returned <code>Map</code> always contains mappings for both <code>false</code> and <code>true</code> keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> or <code>List</code> returned.</div> <dl class="notes"> <dt>API Note:</dt> <dd>If a partition has no elements, its value in the result Map will be an empty List.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>predicate</code> - a predicate used for classifying input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the partitioning operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#partitioningBy(java.util.function.Predicate,java.util.stream.Collector)"><code>partitioningBy(Predicate, Collector)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="partitioningBy(java.util.function.Predicate,java.util.stream.Collector)"> <h3>partitioningBy</h3> <pre class="lang-java" data-language="java">public static &lt;T, D, A&gt; Collector&lt;T,?,Map&lt;Boolean,D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T,A,D&gt; downstream)</pre> <div class="block">Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, reduces the values in each partition according to another <code>Collector</code>, and organizes them into a <code>Map&lt;Boolean, D&gt;</code> whose values are the result of the downstream reduction. <p> The returned <code>Map</code> always contains mappings for both <code>false</code> and <code>true</code> keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned.</p>
</div> <dl class="notes"> <dt>API Note:</dt> <dd>If a partition has no elements, its value in the result Map will be obtained by calling the downstream collector's supplier function and then applying the finisher function.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dt>Parameters:</dt> <dd>
<code>predicate</code> - a predicate used for classifying input elements</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the cascaded partitioning operation</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#partitioningBy(java.util.function.Predicate)"><code>partitioningBy(Predicate)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toMap(java.util.function.Function,java.util.function.Function)"> <h3>toMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U&gt; Collector&lt;T,?,Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper)</pre> <div class="block">Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), an <code>IllegalStateException</code> is thrown when the collection operation is performed. If the mapped keys might have duplicates, use <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a> instead. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned.</p>
</div> <dl class="notes"> <dt>API Note:</dt> <dd>It is common for either the key or the value to be the input elements. In this case, the utility method <a href="../function/function#identity()"><code>Function.identity()</code></a> may be helpful. For example, the following produces a <code>Map</code> mapping students to their grade point average: <pre class="lang-java" data-language="java"><code>
 Map&lt;Student, Double&gt; studentToGPA
   = students.stream().collect(
     toMap(Function.identity(),
           student -&gt; computeGPA(student)));
 </code></pre> And the following produces a <code>Map</code> mapping a unique identifier to students: <pre class="lang-java" data-language="java"><code>
 Map&lt;String, Student&gt; studentIdToStudent
   = students.stream().collect(
     toMap(Student::getId,
           Function.identity()));
 </code></pre>
</dd> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the <code>Map</code> in encounter order, using <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects elements into a <code>Map</code> whose keys and values are the result of applying mapping functions to the input elements</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a></li> <li><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a></li> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toUnmodifiableMap(java.util.function.Function,java.util.function.Function)"> <h3>toUnmodifiableMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U&gt; Collector&lt;T,?,Map&lt;K,U&gt;&gt; toUnmodifiableMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper)</pre> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), an <code>IllegalStateException</code> is thrown when the collection operation is performed. If the mapped keys might have duplicates, use <a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toUnmodifiableMap(Function, Function, BinaryOperator)</code></a> to handle merging of the values. </p>
<p>The returned Collector disallows null keys and values. If either mapping function returns null, <code>NullPointerException</code> will be thrown.</p>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys, must be non-null</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values, must be non-null</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if either keyMapper or valueMapper is null</dd> <dt>Since:</dt> <dd>10</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toUnmodifiableMap(Function, Function, BinaryOperator)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"> <h3>toMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U&gt; Collector&lt;T,?,Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</pre> <div class="block">Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned.</p>
</div> <dl class="notes"> <dt>API Note:</dt> <dd>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of <code>toMap</code> simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of <code>Person</code>, and you want to produce a "phone book" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a <code>Map</code> mapping names to a concatenated list of addresses: <pre class="lang-java" data-language="java"><code>
 Map&lt;String, String&gt; phoneBook
   = people.stream().collect(
     toMap(Person::getName,
           Person::getAddress,
           (s, a) -&gt; s + ", " + a));
 </code></pre>
</dd> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the <code>Map</code> in encounter order, using <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects elements into a <code>Map</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a></li> <li><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a></li> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"> <h3>toUnmodifiableMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U&gt; Collector&lt;T,?,Map&lt;K,U&gt;&gt; toUnmodifiableMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</pre> <div class="block">Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. </p>
<p>The returned Collector disallows null keys and values. If either mapping function returns null, <code>NullPointerException</code> will be thrown.</p>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys, must be non-null</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values, must be non-null</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>, must be non-null</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if the keyMapper, valueMapper, or mergeFunction is null</dd> <dt>Since:</dt> <dd>10</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function)"><code>toUnmodifiableMap(Function, Function)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"> <h3>toMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T,?,M&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapFactory)</pre> <div class="block">Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The <code>Map</code> is created by a provided supplier function.</p>
</div> <dl class="notes"> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the <code>Map</code> in encounter order, using <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dd>
<code>M</code> - the type of the resulting <code>Map</code>
</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>Map</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects elements into a <code>Map</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a></li> <li><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a></li> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toConcurrentMap(java.util.function.Function,java.util.function.Function)"> <h3>toConcurrentMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U&gt; Collector&lt;T,?,ConcurrentMap&lt;K,U&gt;&gt; toConcurrentMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper)</pre> <div class="block">Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), an <code>IllegalStateException</code> is thrown when the collection operation is performed. If the mapped keys may have duplicates, use <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> instead. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> returned.</p>
</div> <dl class="notes"> <dt>API Note:</dt> <dd>It is common for either the key or the value to be the input elements. In this case, the utility method <a href="../function/function#identity()"><code>Function.identity()</code></a> may be helpful. For example, the following produces a <code>ConcurrentMap</code> mapping students to their grade point average: <pre class="lang-java" data-language="java"><code>
 ConcurrentMap&lt;Student, Double&gt; studentToGPA
   = students.stream().collect(
     toConcurrentMap(Function.identity(),
                     student -&gt; computeGPA(student)));
 </code></pre> And the following produces a <code>ConcurrentMap</code> mapping a unique identifier to students: <pre class="lang-java" data-language="java"><code>
 ConcurrentMap&lt;String, Student&gt; studentIdToStudent
   = students.stream().collect(
     toConcurrentMap(Student::getId,
                     Function.identity()));
 </code></pre> <p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - the mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - the mapping function to produce values</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> which collects elements into a <code>ConcurrentMap</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to the input elements</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a></li> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a></li> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"> <h3>toConcurrentMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U&gt; Collector&lt;T,?,ConcurrentMap&lt;K,U&gt;&gt; toConcurrentMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</pre> <div class="block">Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> returned.</p>
</div> <dl class="notes"> <dt>API Note:</dt> <dd>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of <code>toConcurrentMap</code> simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of <code>Person</code>, and you want to produce a "phone book" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a <code>ConcurrentMap</code> mapping names to a concatenated list of addresses: <pre class="lang-java" data-language="java"><code>
 ConcurrentMap&lt;String, String&gt; phoneBook
   = people.stream().collect(
     toConcurrentMap(Person::getName,
                     Person::getAddress,
                     (s, a) -&gt; s + ", " + a));
 </code></pre> <p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> which collects elements into a <code>ConcurrentMap</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a></li> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a></li> <li><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"> <h3>toConcurrentMap</h3> <pre class="lang-java" data-language="java">public static &lt;T, K, U, M extends ConcurrentMap&lt;K, U&gt;&gt; Collector&lt;T,?,M&gt; toConcurrentMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapFactory)</pre> <div class="block">Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The <code>ConcurrentMap</code> is created by a provided supplier function. </p>
<p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dd>
<code>M</code> - the type of the resulting <code>ConcurrentMap</code>
</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>ConcurrentMap</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> which collects elements into a <code>ConcurrentMap</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a></li> <li><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a></li> <li><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="summarizingInt(java.util.function.ToIntFunction)"> <h3>summarizingInt</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> which applies an <code>int</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a mapping function to apply to each element</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the summary-statistics reduction</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#summarizingDouble(java.util.function.ToDoubleFunction)"><code>summarizingDouble(ToDoubleFunction)</code></a></li> <li><a href="#summarizingLong(java.util.function.ToLongFunction)"><code>summarizingLong(ToLongFunction)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="summarizingLong(java.util.function.ToLongFunction)"> <h3>summarizingLong</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> which applies an <code>long</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - the mapping function to apply to each element</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the summary-statistics reduction</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#summarizingDouble(java.util.function.ToDoubleFunction)"><code>summarizingDouble(ToDoubleFunction)</code></a></li> <li><a href="#summarizingInt(java.util.function.ToIntFunction)"><code>summarizingInt(ToIntFunction)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="summarizingDouble(java.util.function.ToDoubleFunction)"> <h3>summarizingDouble</h3> <pre class="lang-java" data-language="java">public static &lt;T&gt; Collector&lt;T,?,DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</pre> <div class="block">Returns a <code>Collector</code> which applies an <code>double</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a mapping function to apply to each element</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the summary-statistics reduction</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#summarizingLong(java.util.function.ToLongFunction)"><code>summarizingLong(ToLongFunction)</code></a></li> <li><a href="#summarizingInt(java.util.function.ToIntFunction)"><code>summarizingInt(ToIntFunction)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction)"> <h3>teeing</h3> <pre class="lang-java" data-language="java">public static &lt;T, R1, R2, R&gt; Collector&lt;T,?,R&gt; teeing(Collector&lt;? super T,?,R1&gt; downstream1, Collector&lt;? super T,?,R2&gt; downstream2, BiFunction&lt;? super R1,? super R2,R&gt; merger)</pre> <div class="block">Returns a <code>Collector</code> that is a composite of two downstream collectors. Every element passed to the resulting collector is processed by both downstream collectors, then their results are merged using the specified merge function into the final result. <p>The resulting collector functions do the following: </p>
<ul> <li>supplier: creates a result container that contains result containers obtained by calling each collector's supplier </li>
<li>accumulator: calls each collector's accumulator with its result container and the input element </li>
<li>combiner: calls each collector's combiner with two result containers </li>
<li>finisher: calls each collector's finisher with its result container, then calls the supplied merger and returns its result. </li>
</ul> <p>The resulting collector is <a href="collector.characteristics#UNORDERED"><code>Collector.Characteristics.UNORDERED</code></a> if both downstream collectors are unordered and <a href="collector.characteristics#CONCURRENT"><code>Collector.Characteristics.CONCURRENT</code></a> if both downstream collectors are concurrent.</p>
</div> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>R1</code> - the result type of the first collector</dd> <dd>
<code>R2</code> - the result type of the second collector</dd> <dd>
<code>R</code> - the final result type</dd> <dt>Parameters:</dt> <dd>
<code>downstream1</code> - the first downstream collector</dd> <dd>
<code>downstream2</code> - the second downstream collector</dd> <dd>
<code>merger</code> - the function which merges two results into the single one</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which aggregates the results of two supplied collectors.</dd> <dt>Since:</dt> <dd>12</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Collectors.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Collectors.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
