
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ThreadPoolExecutor - OpenJDK 21 - W3cubDocs</title>
  
  <meta name="description" content="Thread pools address two different problems&#58; they usually provide improved performance when executing large numbers of asynchronous tasks, due &hellip;">
  <meta name="keywords" content="class, threadpoolexecutor, openjdk, openjdk~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~21/java.base/java/util/concurrent/threadpoolexecutor.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/openjdk~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~21/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<h1 title="Class ThreadPoolExecutor" class="title">Class ThreadPoolExecutor</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../../lang/object" title="class in java.lang">java.lang.Object</a> <div class="inheritance">
<a href="abstractexecutorservice" title="class in java.util.concurrent">java.util.concurrent.AbstractExecutorService</a> <div class="inheritance">java.util.concurrent.ThreadPoolExecutor</div> </div> </div> <section class="class-description" id="class-description"> <dl class="notes"> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../../lang/autocloseable" title="interface in java.lang">AutoCloseable</a></code>, <code><a href="executor" title="interface in java.util.concurrent">Executor</a></code>, <code><a href="executorservice" title="interface in java.util.concurrent">ExecutorService</a></code>
</dd> </dl> <dl class="notes"> <dt>Direct Known Subclasses:</dt> <dd><code><a href="scheduledthreadpoolexecutor" title="class in java.util.concurrent">ScheduledThreadPoolExecutor</a></code></dd> </dl>  <pre class="lang-java" data-language="java">public class ThreadPoolExecutor extends AbstractExecutorService</pre> <div class="block">An <a href="executorservice" title="interface in java.util.concurrent"><code>ExecutorService</code></a> that executes each submitted task using one of possibly several pooled threads, normally configured using <a href="executors" title="class in java.util.concurrent"><code>Executors</code></a> factory methods. <p>Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks. Each <code>ThreadPoolExecutor</code> also maintains some basic statistics, such as the number of completed tasks. </p>
<p>To be useful across a wide range of contexts, this class provides many adjustable parameters and extensibility hooks. However, programmers are urged to use the more convenient <a href="executors" title="class in java.util.concurrent"><code>Executors</code></a> factory methods <a href="executors#newCachedThreadPool()"><code>Executors.newCachedThreadPool()</code></a> (unbounded thread pool, with automatic thread reclamation), <a href="executors#newFixedThreadPool(int)"><code>Executors.newFixedThreadPool(int)</code></a> (fixed size thread pool) and <a href="executors#newSingleThreadExecutor()"><code>Executors.newSingleThreadExecutor()</code></a> (single background thread), that preconfigure settings for the most common usage scenarios. Otherwise, use the following guide when manually configuring and tuning this class: </p>
<dl> <dt>Core and maximum pool sizes</dt> <dd>A <code>ThreadPoolExecutor</code> will automatically adjust the pool size (see <a href="#getPoolSize()"><code>getPoolSize()</code></a>) according to the bounds set by corePoolSize (see <a href="#getCorePoolSize()"><code>getCorePoolSize()</code></a>) and maximumPoolSize (see <a href="#getMaximumPoolSize()"><code>getMaximumPoolSize()</code></a>). When a new task is submitted in method <a href="#execute(java.lang.Runnable)"><code>execute(Runnable)</code></a>, if fewer than corePoolSize threads are running, a new thread is created to handle the request, even if other worker threads are idle. Else if fewer than maximumPoolSize threads are running, a new thread will be created to handle the request only if the queue is full. By setting corePoolSize and maximumPoolSize the same, you create a fixed-size thread pool. By setting maximumPoolSize to an essentially unbounded value such as <code>Integer.MAX_VALUE</code>, you allow the pool to accommodate an arbitrary number of concurrent tasks. Most typically, core and maximum pool sizes are set only upon construction, but they may also be changed dynamically using <a href="#setCorePoolSize(int)"><code>setCorePoolSize(int)</code></a> and <a href="#setMaximumPoolSize(int)"><code>setMaximumPoolSize(int)</code></a>. </dd> <dt>On-demand construction</dt> <dd>By default, even core threads are initially created and started only when new tasks arrive, but this can be overridden dynamically using method <a href="#prestartCoreThread()"><code>prestartCoreThread()</code></a> or <a href="#prestartAllCoreThreads()"><code>prestartAllCoreThreads()</code></a>. You probably want to prestart threads if you construct the pool with a non-empty queue. </dd> <dt>Creating new threads</dt> <dd>New threads are created using a <a href="threadfactory" title="interface in java.util.concurrent"><code>ThreadFactory</code></a>. If not otherwise specified, a <a href="executors#defaultThreadFactory()"><code>Executors.defaultThreadFactory()</code></a> is used, that creates threads to all be in the same <a href="../../lang/threadgroup" title="class in java.lang"><code>ThreadGroup</code></a> and with the same <code>NORM_PRIORITY</code> priority and non-daemon status. By supplying a different ThreadFactory, you can alter the thread's name, thread group, priority, daemon status, etc. If a <code>ThreadFactory</code> fails to create a thread when asked by returning null from <code>newThread</code>, the executor will continue, but might not be able to execute any tasks. Threads should possess the "modifyThread" <code>RuntimePermission</code>. If worker threads or other threads using the pool do not possess this permission, service may be degraded: configuration changes may not take effect in a timely manner, and a shutdown pool may remain in a state in which termination is possible but not completed.</dd> <dt>Keep-alive times</dt> <dd>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see <a href="#getKeepAliveTime(java.util.concurrent.TimeUnit)"><code>getKeepAliveTime(TimeUnit)</code></a>). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method <a href="#setKeepAliveTime(long,java.util.concurrent.TimeUnit)"><code>setKeepAliveTime(long, TimeUnit)</code></a>. Using a value of <code>Long.MAX_VALUE</code> <a href="timeunit#NANOSECONDS"><code>TimeUnit.NANOSECONDS</code></a> effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads, but method <a href="#allowCoreThreadTimeOut(boolean)"><code>allowCoreThreadTimeOut(boolean)</code></a> can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero. </dd> <dt>Queuing</dt> <dd>Any <a href="blockingqueue" title="interface in java.util.concurrent"><code>BlockingQueue</code></a> may be used to transfer and hold submitted tasks. The use of this queue interacts with pool sizing: <ul> <li>If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing. </li>
<li>If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread. </li>
<li>If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected. </li>
</ul> There are three general strategies for queuing: <ol> <li>
<em> Direct handoffs.</em> A good default choice for a work queue is a <a href="synchronousqueue" title="class in java.util.concurrent"><code>SynchronousQueue</code></a> that hands off tasks to threads without otherwise holding them. Here, an attempt to queue a task will fail if no threads are immediately available to run it, so a new thread will be constructed. This policy avoids lockups when handling sets of requests that might have internal dependencies. Direct handoffs generally require unbounded maximumPoolSizes to avoid rejection of new submitted tasks. This in turn admits the possibility of unbounded thread growth when commands continue to arrive on average faster than they can be processed. </li>
<li>
<em> Unbounded queues.</em> Using an unbounded queue (for example a <a href="linkedblockingqueue" title="class in java.util.concurrent"><code>LinkedBlockingQueue</code></a> without a predefined capacity) will cause new tasks to wait in the queue when all corePoolSize threads are busy. Thus, no more than corePoolSize threads will ever be created. (And the value of the maximumPoolSize therefore doesn't have any effect.) This may be appropriate when each task is completely independent of others, so tasks cannot affect each others execution; for example, in a web page server. While this style of queuing can be useful in smoothing out transient bursts of requests, it admits the possibility of unbounded work queue growth when commands continue to arrive on average faster than they can be processed. </li>
<li>
<em>Bounded queues.</em> A bounded queue (for example, an <a href="arrayblockingqueue" title="class in java.util.concurrent"><code>ArrayBlockingQueue</code></a>) helps prevent resource exhaustion when used with finite maximumPoolSizes, but can be more difficult to tune and control. Queue sizes and maximum pool sizes may be traded off for each other: Using large queues and small pools minimizes CPU usage, OS resources, and context-switching overhead, but can lead to artificially low throughput. If tasks frequently block (for example if they are I/O bound), a system may be able to schedule time for more threads than you otherwise allow. Use of small queues generally requires larger pool sizes, which keeps CPUs busier but may encounter unacceptable scheduling overhead, which also decreases throughput. </li>
</ol> </dd> <dt>Rejected tasks</dt> <dd>New tasks submitted in method <a href="#execute(java.lang.Runnable)"><code>execute(Runnable)</code></a> will be <em>rejected</em> when the Executor has been shut down, and also when the Executor uses finite bounds for both maximum threads and work queue capacity, and is saturated. In either case, the <code>execute</code> method invokes the <a href="rejectedexecutionhandler#rejectedExecution(java.lang.Runnable,java.util.concurrent.ThreadPoolExecutor)"><code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code></a> method of its <a href="rejectedexecutionhandler" title="interface in java.util.concurrent"><code>RejectedExecutionHandler</code></a>. Four predefined handler policies are provided: <ol> <li>In the default <a href="threadpoolexecutor.abortpolicy" title="class in java.util.concurrent"><code>ThreadPoolExecutor.AbortPolicy</code></a>, the handler throws a runtime <a href="rejectedexecutionexception" title="class in java.util.concurrent"><code>RejectedExecutionException</code></a> upon rejection. </li>
<li>In <a href="threadpoolexecutor.callerrunspolicy" title="class in java.util.concurrent"><code>ThreadPoolExecutor.CallerRunsPolicy</code></a>, the thread that invokes <code>execute</code> itself runs the task. This provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted. </li>
<li>In <a href="threadpoolexecutor.discardpolicy" title="class in java.util.concurrent"><code>ThreadPoolExecutor.DiscardPolicy</code></a>, a task that cannot be executed is simply dropped. This policy is designed only for those rare cases in which task completion is never relied upon. </li>
<li>In <a href="threadpoolexecutor.discardoldestpolicy" title="class in java.util.concurrent"><code>ThreadPoolExecutor.DiscardOldestPolicy</code></a>, if the executor is not shut down, the task at the head of the work queue is dropped, and then execution is retried (which can fail again, causing this to be repeated.) This policy is rarely acceptable. In nearly all cases, you should also cancel the task to cause an exception in any component waiting for its completion, and/or log the failure, as illustrated in <a href="threadpoolexecutor.discardoldestpolicy" title="class in java.util.concurrent"><code>ThreadPoolExecutor.DiscardOldestPolicy</code></a> documentation. </li>
</ol> It is possible to define and use other kinds of <a href="rejectedexecutionhandler" title="interface in java.util.concurrent"><code>RejectedExecutionHandler</code></a> classes. Doing so requires some care especially when policies are designed to work only under particular capacity or queuing policies. </dd> <dt>Hook methods</dt> <dd>This class provides <code>protected</code> overridable <a href="#beforeExecute(java.lang.Thread,java.lang.Runnable)"><code>beforeExecute(Thread, Runnable)</code></a> and <a href="#afterExecute(java.lang.Runnable,java.lang.Throwable)"><code>afterExecute(Runnable, Throwable)</code></a> methods that are called before and after execution of each task. These can be used to manipulate the execution environment; for example, reinitializing ThreadLocals, gathering statistics, or adding log entries. Additionally, method <a href="#terminated()"><code>terminated()</code></a> can be overridden to perform any special processing that needs to be done once the Executor has fully terminated. <p>If hook, callback, or BlockingQueue methods throw exceptions, internal worker threads may in turn fail, abruptly terminate, and possibly be replaced.</p>
</dd> <dt>Queue maintenance</dt> <dd>Method <a href="#getQueue()"><code>getQueue()</code></a> allows access to the work queue for purposes of monitoring and debugging. Use of this method for any other purpose is strongly discouraged. Two supplied methods, <a href="#remove(java.lang.Runnable)"><code>remove(Runnable)</code></a> and <a href="#purge()"><code>purge()</code></a> are available to assist in storage reclamation when large numbers of queued tasks become cancelled.</dd> <dt>Reclamation</dt> <dd>A pool that is no longer referenced in a program <em>AND</em> has no remaining threads may be reclaimed (garbage collected) without being explicitly shutdown. You can configure a pool to allow all unused threads to eventually die by setting appropriate keep-alive times, using a lower bound of zero core threads and/or setting <a href="#allowCoreThreadTimeOut(boolean)"><code>allowCoreThreadTimeOut(boolean)</code></a>. </dd> </dl> <p><b>Extension example.</b> Most extensions of this class override one or more of the protected hook methods. For example, here is a subclass that adds a simple pause/resume feature: </p>
<pre class="lang-java" data-language="java"> <code>
 class PausableThreadPoolExecutor extends ThreadPoolExecutor {
   private boolean isPaused;
   private ReentrantLock pauseLock = new ReentrantLock();
   private Condition unpaused = pauseLock.newCondition();

   public PausableThreadPoolExecutor(...) { super(...); }

   protected void beforeExecute(Thread t, Runnable r) {
     super.beforeExecute(t, r);
     pauseLock.lock();
     try {
       while (isPaused) unpaused.await();
     } catch (InterruptedException ie) {
       t.interrupt();
     } finally {
       pauseLock.unlock();
     }
   }

   public void pause() {
     pauseLock.lock();
     try {
       isPaused = true;
     } finally {
       pauseLock.unlock();
     }
   }

   public void resume() {
     pauseLock.lock();
     try {
       isPaused = false;
       unpaused.signalAll();
     } finally {
       pauseLock.unlock();
     }
   }
 }</code></pre>
</div> <dl class="notes"> <dt>Since:</dt> <dd>1.5</dd> </dl> </section> <section class="summary"> <section class="nested-class-summary" id="nested-class-summary"> <h2>Nested Class Summary</h2>  <table class="summary-table three-column-summary">                <tr>
<th>Modifier and Type</th>
<th>Class</th>
<th>Description</th>
</tr>
<tr>
<td><code>static class </code></td>
<td><code><a href="threadpoolexecutor.abortpolicy" class="type-name-link" title="class in java.util.concurrent">ThreadPoolExecutor.AbortPolicy</a></code></td>
<td> <div class="block">A handler for rejected tasks that throws a <a href="rejectedexecutionexception" title="class in java.util.concurrent"><code>RejectedExecutionException</code></a>.</div> </td>
</tr>
<tr>
<td><code>static class </code></td>
<td><code><a href="threadpoolexecutor.callerrunspolicy" class="type-name-link" title="class in java.util.concurrent">ThreadPoolExecutor.CallerRunsPolicy</a></code></td>
<td> <div class="block">A handler for rejected tasks that runs the rejected task directly in the calling thread of the <code>execute</code> method, unless the executor has been shut down, in which case the task is discarded.</div> </td>
</tr>
<tr>
<td><code>static class </code></td>
<td><code><a href="threadpoolexecutor.discardoldestpolicy" class="type-name-link" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardOldestPolicy</a></code></td>
<td> <div class="block">A handler for rejected tasks that discards the oldest unhandled request and then retries <code>execute</code>, unless the executor is shut down, in which case the task is discarded.</div> </td>
</tr>
<tr>
<td><code>static class </code></td>
<td><code><a href="threadpoolexecutor.discardpolicy" class="type-name-link" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardPolicy</a></code></td>
<td> <div class="block">A handler for rejected tasks that silently discards the rejected task.</div> </td>
</tr>
</table> </section><section class="constructor-summary" id="constructor-summary"> <h2>Constructor Summary</h2>  <table class="summary-table two-column-summary">           <tr>
<th>Constructor</th>
<th>Description</th>
</tr>
<tr>
<td><code><a href="#%3Cinit%3E(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue)" class="member-name-link">ThreadPoolExecutor</a><wbr>(int corePoolSize,
 int maximumPoolSize,
 long keepAliveTime,
 <a href="timeunit" title="enum class in java.util.concurrent">TimeUnit</a> unit,
 <a href="blockingqueue" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../lang/runnable" title="interface in java.lang">Runnable</a>&gt; workQueue)</wbr></code></td>
<td> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters, the <a href="executors#defaultThreadFactory()">default thread factory</a> and the <a href="threadpoolexecutor.abortpolicy" title="class in java.util.concurrent">default rejected execution handler</a>.</div> </td>
</tr>
<tr>
<td><code><a href="#%3Cinit%3E(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.RejectedExecutionHandler)" class="member-name-link">ThreadPoolExecutor</a><wbr>(int corePoolSize,
 int maximumPoolSize,
 long keepAliveTime,
 <a href="timeunit" title="enum class in java.util.concurrent">TimeUnit</a> unit,
 <a href="blockingqueue" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../lang/runnable" title="interface in java.lang">Runnable</a>&gt; workQueue,
 <a href="rejectedexecutionhandler" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</wbr></code></td>
<td> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters and the <a href="executors#defaultThreadFactory()">default thread factory</a>.</div> </td>
</tr>
<tr>
<td><code><a href="#%3Cinit%3E(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory)" class="member-name-link">ThreadPoolExecutor</a><wbr>(int corePoolSize,
 int maximumPoolSize,
 long keepAliveTime,
 <a href="timeunit" title="enum class in java.util.concurrent">TimeUnit</a> unit,
 <a href="blockingqueue" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../lang/runnable" title="interface in java.lang">Runnable</a>&gt; workQueue,
 <a href="threadfactory" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</wbr></code></td>
<td> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters and the <a href="threadpoolexecutor.abortpolicy" title="class in java.util.concurrent">default rejected execution handler</a>.</div> </td>
</tr>
<tr>
<td><code><a href="#%3Cinit%3E(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory,java.util.concurrent.RejectedExecutionHandler)" class="member-name-link">ThreadPoolExecutor</a><wbr>(int corePoolSize,
 int maximumPoolSize,
 long keepAliveTime,
 <a href="timeunit" title="enum class in java.util.concurrent">TimeUnit</a> unit,
 <a href="blockingqueue" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../lang/runnable" title="interface in java.lang">Runnable</a>&gt; workQueue,
 <a href="threadfactory" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory,
 <a href="rejectedexecutionhandler" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</wbr></code></td>
<td> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters.</div> </td>
</tr>
</table> </section><section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                                                          <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>protected void</code></td>
<td><code><a href="#afterExecute(java.lang.Runnable,java.lang.Throwable)" class="member-name-link">afterExecute</a><wbr>(<a href="../../lang/runnable" title="interface in java.lang">Runnable</a> r,
 <a href="../../lang/throwable" title="class in java.lang">Throwable</a> t)</wbr></code></td>
<td> <div class="block">Method invoked upon completion of execution of the given Runnable.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#allowCoreThreadTimeOut(boolean)" class="member-name-link">allowCoreThreadTimeOut</a><wbr>(boolean value)</wbr></code></td>
<td> <div class="block">Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#allowsCoreThreadTimeOut()" class="member-name-link">allowsCoreThreadTimeOut</a>()</code></td>
<td> <div class="block">Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#awaitTermination(long,java.util.concurrent.TimeUnit)" class="member-name-link">awaitTermination</a><wbr>(long timeout,
 <a href="timeunit" title="enum class in java.util.concurrent">TimeUnit</a> unit)</wbr></code></td>
<td> <div class="block">Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.</div> </td>
</tr>
<tr>
<td><code>protected void</code></td>
<td><code><a href="#beforeExecute(java.lang.Thread,java.lang.Runnable)" class="member-name-link">beforeExecute</a><wbr>(<a href="../../lang/thread" title="class in java.lang">Thread</a> t,
 <a href="../../lang/runnable" title="interface in java.lang">Runnable</a> r)</wbr></code></td>
<td> <div class="block">Method invoked prior to executing the given Runnable in the given thread.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#execute(java.lang.Runnable)" class="member-name-link">execute</a><wbr>(<a href="../../lang/runnable" title="interface in java.lang">Runnable</a> command)</wbr></code></td>
<td> <div class="block">Executes the given task sometime in the future.</div> </td>
</tr>
<tr>
<td><code>protected void</code></td>
<td><code><a href="#finalize()" class="member-name-link">finalize</a>()</code></td>
<td> <div class="block">
<span class="deprecated-label">Deprecated, for removal: This API element is subject to removal in a future version.</span> <div class="deprecation-comment">Finalization has been deprecated for removal.</div> </div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#getActiveCount()" class="member-name-link">getActiveCount</a>()</code></td>
<td> <div class="block">Returns the approximate number of threads that are actively executing tasks.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#getCompletedTaskCount()" class="member-name-link">getCompletedTaskCount</a>()</code></td>
<td> <div class="block">Returns the approximate total number of tasks that have completed execution.</div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#getCorePoolSize()" class="member-name-link">getCorePoolSize</a>()</code></td>
<td> <div class="block">Returns the core number of threads.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#getKeepAliveTime(java.util.concurrent.TimeUnit)" class="member-name-link">getKeepAliveTime</a><wbr>(<a href="timeunit" title="enum class in java.util.concurrent">TimeUnit</a> unit)</wbr></code></td>
<td> <div class="block">Returns the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated.</div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#getLargestPoolSize()" class="member-name-link">getLargestPoolSize</a>()</code></td>
<td> <div class="block">Returns the largest number of threads that have ever simultaneously been in the pool.</div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#getMaximumPoolSize()" class="member-name-link">getMaximumPoolSize</a>()</code></td>
<td> <div class="block">Returns the maximum allowed number of threads.</div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#getPoolSize()" class="member-name-link">getPoolSize</a>()</code></td>
<td> <div class="block">Returns the current number of threads in the pool.</div> </td>
</tr>
<tr>
<td><code><a href="blockingqueue" title="interface in java.util.concurrent">BlockingQueue</a><wbr>&lt;<a href="../../lang/runnable" title="interface in java.lang">Runnable</a>&gt;</wbr></code></td>
<td><code><a href="#getQueue()" class="member-name-link">getQueue</a>()</code></td>
<td> <div class="block">Returns the task queue used by this executor.</div> </td>
</tr>
<tr>
<td><code><a href="rejectedexecutionhandler" title="interface in java.util.concurrent">RejectedExecutionHandler</a></code></td>
<td><code><a href="#getRejectedExecutionHandler()" class="member-name-link">getRejectedExecutionHandler</a>()</code></td>
<td> <div class="block">Returns the current handler for unexecutable tasks.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#getTaskCount()" class="member-name-link">getTaskCount</a>()</code></td>
<td> <div class="block">Returns the approximate total number of tasks that have ever been scheduled for execution.</div> </td>
</tr>
<tr>
<td><code><a href="threadfactory" title="interface in java.util.concurrent">ThreadFactory</a></code></td>
<td><code><a href="#getThreadFactory()" class="member-name-link">getThreadFactory</a>()</code></td>
<td> <div class="block">Returns the thread factory used to create new threads.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isShutdown()" class="member-name-link">isShutdown</a>()</code></td>
<td> <div class="block">Returns <code>true</code> if this executor has been shut down.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isTerminated()" class="member-name-link">isTerminated</a>()</code></td>
<td> <div class="block">Returns <code>true</code> if all tasks have completed following shut down.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isTerminating()" class="member-name-link">isTerminating</a>()</code></td>
<td> <div class="block">Returns true if this executor is in the process of terminating after <a href="#shutdown()"><code>shutdown()</code></a> or <a href="#shutdownNow()"><code>shutdownNow()</code></a> but has not completely terminated.</div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#prestartAllCoreThreads()" class="member-name-link">prestartAllCoreThreads</a>()</code></td>
<td> <div class="block">Starts all core threads, causing them to idly wait for work.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#prestartCoreThread()" class="member-name-link">prestartCoreThread</a>()</code></td>
<td> <div class="block">Starts a core thread, causing it to idly wait for work.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#purge()" class="member-name-link">purge</a>()</code></td>
<td> <div class="block">Tries to remove from the work queue all <a href="future" title="interface in java.util.concurrent"><code>Future</code></a> tasks that have been cancelled.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#remove(java.lang.Runnable)" class="member-name-link">remove</a><wbr>(<a href="../../lang/runnable" title="interface in java.lang">Runnable</a> task)</wbr></code></td>
<td> <div class="block">Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#setCorePoolSize(int)" class="member-name-link">setCorePoolSize</a><wbr>(int corePoolSize)</wbr></code></td>
<td> <div class="block">Sets the core number of threads.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#setKeepAliveTime(long,java.util.concurrent.TimeUnit)" class="member-name-link">setKeepAliveTime</a><wbr>(long time,
 <a href="timeunit" title="enum class in java.util.concurrent">TimeUnit</a> unit)</wbr></code></td>
<td> <div class="block">Sets the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#setMaximumPoolSize(int)" class="member-name-link">setMaximumPoolSize</a><wbr>(int maximumPoolSize)</wbr></code></td>
<td> <div class="block">Sets the maximum allowed number of threads.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)" class="member-name-link">setRejectedExecutionHandler</a><wbr>(<a href="rejectedexecutionhandler" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</wbr></code></td>
<td> <div class="block">Sets a new handler for unexecutable tasks.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#setThreadFactory(java.util.concurrent.ThreadFactory)" class="member-name-link">setThreadFactory</a><wbr>(<a href="threadfactory" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</wbr></code></td>
<td> <div class="block">Sets the thread factory used to create new threads.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#shutdown()" class="member-name-link">shutdown</a>()</code></td>
<td> <div class="block">Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted.</div> </td>
</tr>
<tr>
<td><code><a href="../list" title="interface in java.util">List</a><wbr>&lt;<a href="../../lang/runnable" title="interface in java.lang">Runnable</a>&gt;</wbr></code></td>
<td><code><a href="#shutdownNow()" class="member-name-link">shutdownNow</a>()</code></td>
<td> <div class="block">Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution.</div> </td>
</tr>
<tr>
<td><code>protected void</code></td>
<td><code><a href="#terminated()" class="member-name-link">terminated</a>()</code></td>
<td> <div class="block">Method invoked when the Executor has terminated.</div> </td>
</tr>
<tr>
<td><code><a href="../../lang/string" title="class in java.lang">String</a></code></td>
<td><code><a href="#toString()" class="member-name-link">toString</a>()</code></td>
<td> <div class="block">Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.util.concurrent.AbstractExecutorService">Methods declared in class java.util.concurrent.<a href="abstractexecutorservice" title="class in java.util.concurrent">AbstractExecutorService</a>
</h3> <code><a href="abstractexecutorservice#invokeAll(java.util.Collection)">invokeAll</a>, <a href="abstractexecutorservice#invokeAll(java.util.Collection,long,java.util.concurrent.TimeUnit)">invokeAll</a>, <a href="abstractexecutorservice#invokeAny(java.util.Collection)">invokeAny</a>, <a href="abstractexecutorservice#invokeAny(java.util.Collection,long,java.util.concurrent.TimeUnit)">invokeAny</a>, <a href="abstractexecutorservice#newTaskFor(java.lang.Runnable,T)">newTaskFor</a>, <a href="abstractexecutorservice#newTaskFor(java.util.concurrent.Callable)">newTaskFor</a>, <a href="abstractexecutorservice#submit(java.lang.Runnable)">submit</a>, <a href="abstractexecutorservice#submit(java.lang.Runnable,T)">submit</a>, <a href="abstractexecutorservice#submit(java.util.concurrent.Callable)">submit</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../../lang/object" title="class in java.lang">Object</a>
</h3> <code><a href="../../lang/object#clone()">clone</a>, <a href="../../lang/object#equals(java.lang.Object)">equals</a>, <a href="../../lang/object#getClass()">getClass</a>, <a href="../../lang/object#hashCode()">hashCode</a>, <a href="../../lang/object#notify()">notify</a>, <a href="../../lang/object#notifyAll()">notifyAll</a>, <a href="../../lang/object#wait()">wait</a>, <a href="../../lang/object#wait(long)">wait</a>, <a href="../../lang/object#wait(long,int)">wait</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.util.concurrent.ExecutorService">Methods declared in interface java.util.concurrent.<a href="executorservice" title="interface in java.util.concurrent">ExecutorService</a>
</h3> <code><a href="executorservice#close()">close</a></code>
</div> </section> </section> <section class="details"> <section class="constructor-details" id="constructor-detail"> <h2>Constructor Details</h2>  </section><section class="detail" id="&lt;init&gt;(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue)"> <h3>ThreadPoolExecutor</h3> <pre class="lang-java" data-language="java">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</pre> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters, the <a href="executors#defaultThreadFactory()">default thread factory</a> and the <a href="threadpoolexecutor.abortpolicy" title="class in java.util.concurrent">default rejected execution handler</a>. <p>It may be more convenient to use one of the <a href="executors" title="class in java.util.concurrent"><code>Executors</code></a> factory methods instead of this general purpose constructor.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>corePoolSize</code> - the number of threads to keep in the pool, even if they are idle, unless <code>allowCoreThreadTimeOut</code> is set</dd> <dd>
<code>maximumPoolSize</code> - the maximum number of threads to allow in the pool</dd> <dd>
<code>keepAliveTime</code> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</dd> <dd>
<code>unit</code> - the time unit for the <code>keepAliveTime</code> argument</dd> <dd>
<code>workQueue</code> - the queue to use for holding tasks before they are executed. This queue will hold only the <code>Runnable</code> tasks submitted by the <code>execute</code> method.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if one of the following holds:<br> <code>corePoolSize &lt; 0</code><br> <code>keepAliveTime &lt; 0</code><br> <code>maximumPoolSize &lt;= 0</code><br> <code>maximumPoolSize &lt; corePoolSize</code>
</dd> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>workQueue</code> is null</dd> </dl> </section><section class="detail" id="&lt;init&gt;(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory)"> <h3>ThreadPoolExecutor</h3> <pre class="lang-java" data-language="java">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</pre> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters and the <a href="threadpoolexecutor.abortpolicy" title="class in java.util.concurrent">default rejected execution handler</a>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>corePoolSize</code> - the number of threads to keep in the pool, even if they are idle, unless <code>allowCoreThreadTimeOut</code> is set</dd> <dd>
<code>maximumPoolSize</code> - the maximum number of threads to allow in the pool</dd> <dd>
<code>keepAliveTime</code> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</dd> <dd>
<code>unit</code> - the time unit for the <code>keepAliveTime</code> argument</dd> <dd>
<code>workQueue</code> - the queue to use for holding tasks before they are executed. This queue will hold only the <code>Runnable</code> tasks submitted by the <code>execute</code> method.</dd> <dd>
<code>threadFactory</code> - the factory to use when the executor creates a new thread</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if one of the following holds:<br> <code>corePoolSize &lt; 0</code><br> <code>keepAliveTime &lt; 0</code><br> <code>maximumPoolSize &lt;= 0</code><br> <code>maximumPoolSize &lt; corePoolSize</code>
</dd> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>workQueue</code> or <code>threadFactory</code> is null</dd> </dl> </section><section class="detail" id="&lt;init&gt;(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.RejectedExecutionHandler)"> <h3>ThreadPoolExecutor</h3> <pre class="lang-java" data-language="java">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</pre> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters and the <a href="executors#defaultThreadFactory()">default thread factory</a>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>corePoolSize</code> - the number of threads to keep in the pool, even if they are idle, unless <code>allowCoreThreadTimeOut</code> is set</dd> <dd>
<code>maximumPoolSize</code> - the maximum number of threads to allow in the pool</dd> <dd>
<code>keepAliveTime</code> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</dd> <dd>
<code>unit</code> - the time unit for the <code>keepAliveTime</code> argument</dd> <dd>
<code>workQueue</code> - the queue to use for holding tasks before they are executed. This queue will hold only the <code>Runnable</code> tasks submitted by the <code>execute</code> method.</dd> <dd>
<code>handler</code> - the handler to use when execution is blocked because the thread bounds and queue capacities are reached</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if one of the following holds:<br> <code>corePoolSize &lt; 0</code><br> <code>keepAliveTime &lt; 0</code><br> <code>maximumPoolSize &lt;= 0</code><br> <code>maximumPoolSize &lt; corePoolSize</code>
</dd> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>workQueue</code> or <code>handler</code> is null</dd> </dl> </section><section class="detail" id="&lt;init&gt;(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory,java.util.concurrent.RejectedExecutionHandler)"> <h3>ThreadPoolExecutor</h3> <pre class="lang-java" data-language="java">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</pre> <div class="block">Creates a new <code>ThreadPoolExecutor</code> with the given initial parameters.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>corePoolSize</code> - the number of threads to keep in the pool, even if they are idle, unless <code>allowCoreThreadTimeOut</code> is set</dd> <dd>
<code>maximumPoolSize</code> - the maximum number of threads to allow in the pool</dd> <dd>
<code>keepAliveTime</code> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</dd> <dd>
<code>unit</code> - the time unit for the <code>keepAliveTime</code> argument</dd> <dd>
<code>workQueue</code> - the queue to use for holding tasks before they are executed. This queue will hold only the <code>Runnable</code> tasks submitted by the <code>execute</code> method.</dd> <dd>
<code>threadFactory</code> - the factory to use when the executor creates a new thread</dd> <dd>
<code>handler</code> - the handler to use when execution is blocked because the thread bounds and queue capacities are reached</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if one of the following holds:<br> <code>corePoolSize &lt; 0</code><br> <code>keepAliveTime &lt; 0</code><br> <code>maximumPoolSize &lt;= 0</code><br> <code>maximumPoolSize &lt; corePoolSize</code>
</dd> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>workQueue</code> or <code>threadFactory</code> or <code>handler</code> is null</dd> </dl> </section><section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="execute(java.lang.Runnable)"> <h3>execute</h3> <pre class="lang-java" data-language="java">public void execute(Runnable command)</pre> <div class="block">Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current <a href="rejectedexecutionhandler" title="interface in java.util.concurrent"><code>RejectedExecutionHandler</code></a>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>command</code> - the task to execute</dd> <dt>Throws:</dt> <dd>
<code><a href="rejectedexecutionexception" title="class in java.util.concurrent">RejectedExecutionException</a></code> - at discretion of <code>RejectedExecutionHandler</code>, if the task cannot be accepted for execution</dd> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>command</code> is null</dd> </dl> </section><section class="detail" id="shutdown()"> <h3>shutdown</h3> <pre class="lang-java" data-language="java">public void shutdown()</pre> <div class="block">Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. <p>This method does not wait for previously submitted tasks to complete execution. Use <a href="#awaitTermination(long,java.util.concurrent.TimeUnit)"><code>awaitTermination</code></a> to do that.</p>
</div> <dl class="notes"> <dt>Throws:</dt> <dd>
<code><a href="../../lang/securityexception" title="class in java.lang">SecurityException</a></code> - if a security manager exists and shutting down this ExecutorService may manipulate threads that the caller is not permitted to modify because it does not hold <a href="../../lang/runtimepermission" title="class in java.lang"><code>RuntimePermission</code></a><code>("modifyThread")</code>, or the security manager's <code>checkAccess</code> method denies access.</dd> </dl> </section><section class="detail" id="shutdownNow()"> <h3>shutdownNow</h3> <pre class="lang-java" data-language="java">public List&lt;Runnable&gt; shutdownNow()</pre> <div class="block">Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. These tasks are drained (removed) from the task queue upon return from this method. <p>This method does not wait for actively executing tasks to terminate. Use <a href="#awaitTermination(long,java.util.concurrent.TimeUnit)"><code>awaitTermination</code></a> to do that. </p>
<p>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation interrupts tasks via <a href="../../lang/thread#interrupt()"><code>Thread.interrupt()</code></a>; any task that fails to respond to interrupts may never terminate.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>list of tasks that never commenced execution</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/securityexception" title="class in java.lang">SecurityException</a></code> - if a security manager exists and shutting down this ExecutorService may manipulate threads that the caller is not permitted to modify because it does not hold <a href="../../lang/runtimepermission" title="class in java.lang"><code>RuntimePermission</code></a><code>("modifyThread")</code>, or the security manager's <code>checkAccess</code> method denies access.</dd> </dl> </section><section class="detail" id="isShutdown()"> <h3>isShutdown</h3> <pre class="lang-java" data-language="java">public boolean isShutdown()</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="executorservice#isShutdown()">ExecutorService</a></code></span></div> <div class="block">Returns <code>true</code> if this executor has been shut down.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if this executor has been shut down</dd> </dl> </section><section class="detail" id="isTerminating()"> <h3>isTerminating</h3> <pre class="lang-java" data-language="java">public boolean isTerminating()</pre> <div class="block">Returns true if this executor is in the process of terminating after <a href="#shutdown()"><code>shutdown()</code></a> or <a href="#shutdownNow()"><code>shutdownNow()</code></a> but has not completely terminated. This method may be useful for debugging. A return of <code>true</code> reported a sufficient period after shutdown may indicate that submitted tasks have ignored or suppressed interruption, causing this executor not to properly terminate.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if terminating but not yet terminated</dd> </dl> </section><section class="detail" id="isTerminated()"> <h3>isTerminated</h3> <pre class="lang-java" data-language="java">public boolean isTerminated()</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="executorservice#isTerminated()">ExecutorService</a></code></span></div> <div class="block">Returns <code>true</code> if all tasks have completed following shut down. Note that <code>isTerminated</code> is never <code>true</code> unless either <code>shutdown</code> or <code>shutdownNow</code> was called first.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if all tasks have completed following shut down</dd> </dl> </section><section class="detail" id="awaitTermination(long,java.util.concurrent.TimeUnit)"> <h3>awaitTermination</h3> <pre class="lang-java" data-language="java">public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="executorservice#awaitTermination(long,java.util.concurrent.TimeUnit)">ExecutorService</a></code></span></div> <div class="block">Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>timeout</code> - the maximum time to wait</dd> <dd>
<code>unit</code> - the time unit of the timeout argument</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this executor terminated and <code>false</code> if the timeout elapsed before termination</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/interruptedexception" title="class in java.lang">InterruptedException</a></code> - if interrupted while waiting</dd> </dl> </section><section class="detail" id="finalize()"> <h3>finalize</h3> <pre class="lang-java" data-language="java">@Deprecated(since="9", forRemoval=true) protected void finalize()</pre> <div class="deprecation-block">
<span class="deprecated-label">Deprecated, for removal: This API element is subject to removal in a future version.</span> <div class="deprecation-comment">Finalization has been deprecated for removal. See <a href="../../lang/object#finalize()"><code>Object.finalize()</code></a> for background information and details about migration options.</div> </div> <div class="block"><span class="description-from-type-label">Description copied from class: <code><a href="../../lang/object#finalize()">Object</a></code></span></div> <div class="block">Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the <code>finalize</code> method to dispose of system resources or to perform other cleanup. <p> <b>When running in a Java virtual machine in which finalization has been disabled or removed, the garbage collector will never call <code>finalize()</code>. In a Java virtual machine in which finalization is enabled, the garbage collector might call <code>finalize</code> only after an indefinite delay.</b> </p>
<p> The general contract of <code>finalize</code> is that it is invoked if and when the Java virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The <code>finalize</code> method may take any action, including making this object available again to other threads; the usual purpose of <code>finalize</code>, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. </p>
<p> The <code>finalize</code> method of class <code>Object</code> performs no special action; it simply returns normally. Subclasses of <code>Object</code> may override this definition. </p>
<p> The Java programming language does not guarantee which thread will invoke the <code>finalize</code> method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. </p>
<p> After the <code>finalize</code> method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. </p>
<p> The <code>finalize</code> method is never invoked more than once by a Java virtual machine for any given object. </p>
<p> Any exception thrown by the <code>finalize</code> method causes the finalization of this object to be halted, but is otherwise ignored.</p>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../../lang/object#finalize()">finalize</a></code> in class <code><a href="../../lang/object" title="class in java.lang">Object</a></code>
</dd> <dt>Implementation Note:</dt> <dd>Previous versions of this class had a finalize method that shut down this executor, but in this version, finalize does nothing.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="../../lang/ref/weakreference" title="class in java.lang.ref"><code>WeakReference</code></a></li> <li><a href="../../lang/ref/phantomreference" title="class in java.lang.ref"><code>PhantomReference</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setThreadFactory(java.util.concurrent.ThreadFactory)"> <h3>setThreadFactory</h3> <pre class="lang-java" data-language="java">public void setThreadFactory(ThreadFactory threadFactory)</pre> <div class="block">Sets the thread factory used to create new threads.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>threadFactory</code> - the new thread factory</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if threadFactory is null</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#getThreadFactory()"><code>getThreadFactory()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getThreadFactory()"> <h3>getThreadFactory</h3> <pre class="lang-java" data-language="java">public ThreadFactory getThreadFactory()</pre> <div class="block">Returns the thread factory used to create new threads.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current thread factory</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setThreadFactory(java.util.concurrent.ThreadFactory)"><code>setThreadFactory(ThreadFactory)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"> <h3>setRejectedExecutionHandler</h3> <pre class="lang-java" data-language="java">public void setRejectedExecutionHandler(RejectedExecutionHandler handler)</pre> <div class="block">Sets a new handler for unexecutable tasks.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>handler</code> - the new handler</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if handler is null</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#getRejectedExecutionHandler()"><code>getRejectedExecutionHandler()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getRejectedExecutionHandler()"> <h3>getRejectedExecutionHandler</h3> <pre class="lang-java" data-language="java">public RejectedExecutionHandler getRejectedExecutionHandler()</pre> <div class="block">Returns the current handler for unexecutable tasks.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current handler</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><code>setRejectedExecutionHandler(RejectedExecutionHandler)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setCorePoolSize(int)"> <h3>setCorePoolSize</h3> <pre class="lang-java" data-language="java">public void setCorePoolSize(int corePoolSize)</pre> <div class="block">Sets the core number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle. If larger, new threads will, if needed, be started to execute any queued tasks.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>corePoolSize</code> - the new core size</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>corePoolSize &lt; 0</code> or <code>corePoolSize</code> is greater than the <a href="#getMaximumPoolSize()">maximum pool size</a>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#getCorePoolSize()"><code>getCorePoolSize()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getCorePoolSize()"> <h3>getCorePoolSize</h3> <pre class="lang-java" data-language="java">public int getCorePoolSize()</pre> <div class="block">Returns the core number of threads.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the core number of threads</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#setCorePoolSize(int)"><code>setCorePoolSize(int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="prestartCoreThread()"> <h3>prestartCoreThread</h3> <pre class="lang-java" data-language="java">public boolean prestartCoreThread()</pre> <div class="block">Starts a core thread, causing it to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed. This method will return <code>false</code> if all core threads have already been started.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if a thread was started</dd> </dl> </section><section class="detail" id="prestartAllCoreThreads()"> <h3>prestartAllCoreThreads</h3> <pre class="lang-java" data-language="java">public int prestartAllCoreThreads()</pre> <div class="block">Starts all core threads, causing them to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the number of threads started</dd> </dl> </section><section class="detail" id="allowsCoreThreadTimeOut()"> <h3>allowsCoreThreadTimeOut</h3> <pre class="lang-java" data-language="java">public boolean allowsCoreThreadTimeOut()</pre> <div class="block">Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive. When true, the same keep-alive policy applying to non-core threads applies also to core threads. When false (the default), core threads are never terminated due to lack of incoming tasks.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if core threads are allowed to time out, else <code>false</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="allowCoreThreadTimeOut(boolean)"> <h3>allowCoreThreadTimeOut</h3> <pre class="lang-java" data-language="java">public void allowCoreThreadTimeOut(boolean value)</pre> <div class="block">Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive. When false, core threads are never terminated due to lack of incoming tasks. When true, the same keep-alive policy applying to non-core threads applies also to core threads. To avoid continual thread replacement, the keep-alive time must be greater than zero when setting <code>true</code>. This method should in general be called before the pool is actively used.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>value</code> - <code>true</code> if should time out, else <code>false</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if value is <code>true</code> and the current keep-alive time is not greater than zero</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="setMaximumPoolSize(int)"> <h3>setMaximumPoolSize</h3> <pre class="lang-java" data-language="java">public void setMaximumPoolSize(int maximumPoolSize)</pre> <div class="block">Sets the maximum allowed number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>maximumPoolSize</code> - the new maximum</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the new maximum is less than or equal to zero, or less than the <a href="#getCorePoolSize()">core pool size</a>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#getMaximumPoolSize()"><code>getMaximumPoolSize()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getMaximumPoolSize()"> <h3>getMaximumPoolSize</h3> <pre class="lang-java" data-language="java">public int getMaximumPoolSize()</pre> <div class="block">Returns the maximum allowed number of threads.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the maximum allowed number of threads</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#setMaximumPoolSize(int)"><code>setMaximumPoolSize(int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setKeepAliveTime(long,java.util.concurrent.TimeUnit)"> <h3>setKeepAliveTime</h3> <pre class="lang-java" data-language="java">public void setKeepAliveTime(long time, TimeUnit unit)</pre> <div class="block">Sets the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated. Threads that wait this amount of time without processing a task will be terminated if there are more than the core number of threads currently in the pool, or if this pool <a href="#allowsCoreThreadTimeOut()">allows core thread timeout</a>. This overrides any value set in the constructor.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>time</code> - the time to wait. A time value of zero will cause excess threads to terminate immediately after executing tasks.</dd> <dd>
<code>unit</code> - the time unit of the <code>time</code> argument</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>time</code> less than zero or if <code>time</code> is zero and <code>allowsCoreThreadTimeOut</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#getKeepAliveTime(java.util.concurrent.TimeUnit)"><code>getKeepAliveTime(TimeUnit)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getKeepAliveTime(java.util.concurrent.TimeUnit)"> <h3>getKeepAliveTime</h3> <pre class="lang-java" data-language="java">public long getKeepAliveTime(TimeUnit unit)</pre> <div class="block">Returns the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated. Threads that wait this amount of time without processing a task will be terminated if there are more than the core number of threads currently in the pool, or if this pool <a href="#allowsCoreThreadTimeOut()">allows core thread timeout</a>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>unit</code> - the desired time unit of the result</dd> <dt>Returns:</dt> <dd>the time limit</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setKeepAliveTime(long,java.util.concurrent.TimeUnit)"><code>setKeepAliveTime(long, TimeUnit)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getQueue()"> <h3>getQueue</h3> <pre class="lang-java" data-language="java">public BlockingQueue&lt;Runnable&gt; getQueue()</pre> <div class="block">Returns the task queue used by this executor. Access to the task queue is intended primarily for debugging and monitoring. This queue may be in active use. Retrieving the task queue does not prevent queued tasks from executing.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the task queue</dd> </dl> </section><section class="detail" id="remove(java.lang.Runnable)"> <h3>remove</h3> <pre class="lang-java" data-language="java">public boolean remove(Runnable task)</pre> <div class="block">Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started. <p>This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using <code>submit</code> might be converted into a form that maintains <code>Future</code> status. However, in such cases, method <a href="#purge()"><code>purge()</code></a> may be used to remove those Futures that have been cancelled.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>task</code> - the task to remove</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the task was removed</dd> </dl> </section><section class="detail" id="purge()"> <h3>purge</h3> <pre class="lang-java" data-language="java">public void purge()</pre> <div class="block">Tries to remove from the work queue all <a href="future" title="interface in java.util.concurrent"><code>Future</code></a> tasks that have been cancelled. This method can be useful as a storage reclamation operation, that has no other impact on functionality. Cancelled tasks are never executed, but may accumulate in work queues until worker threads can actively remove them. Invoking this method instead tries to remove them now. However, this method may fail to remove tasks in the presence of interference by other threads.</div> </section><section class="detail" id="getPoolSize()"> <h3>getPoolSize</h3> <pre class="lang-java" data-language="java">public int getPoolSize()</pre> <div class="block">Returns the current number of threads in the pool.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the number of threads</dd> </dl> </section><section class="detail" id="getActiveCount()"> <h3>getActiveCount</h3> <pre class="lang-java" data-language="java">public int getActiveCount()</pre> <div class="block">Returns the approximate number of threads that are actively executing tasks.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the number of threads</dd> </dl> </section><section class="detail" id="getLargestPoolSize()"> <h3>getLargestPoolSize</h3> <pre class="lang-java" data-language="java">public int getLargestPoolSize()</pre> <div class="block">Returns the largest number of threads that have ever simultaneously been in the pool.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the number of threads</dd> </dl> </section><section class="detail" id="getTaskCount()"> <h3>getTaskCount</h3> <pre class="lang-java" data-language="java">public long getTaskCount()</pre> <div class="block">Returns the approximate total number of tasks that have ever been scheduled for execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the number of tasks</dd> </dl> </section><section class="detail" id="getCompletedTaskCount()"> <h3>getCompletedTaskCount</h3> <pre class="lang-java" data-language="java">public long getCompletedTaskCount()</pre> <div class="block">Returns the approximate total number of tasks that have completed execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the number of tasks</dd> </dl> </section><section class="detail" id="toString()"> <h3>toString</h3> <pre class="lang-java" data-language="java">public String toString()</pre> <div class="block">Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../../lang/object#toString()">toString</a></code> in class <code><a href="../../lang/object" title="class in java.lang">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a string identifying this pool, as well as its state</dd> </dl> </section><section class="detail" id="beforeExecute(java.lang.Thread,java.lang.Runnable)"> <h3>beforeExecute</h3> <pre class="lang-java" data-language="java">protected void beforeExecute(Thread t, Runnable r)</pre> <div class="block">Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread <code>t</code> that will execute task <code>r</code>, and may be used to re-initialize ThreadLocals, or to perform logging. <p>This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke <code>super.beforeExecute</code> at the end of this method.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>t</code> - the thread that will run task <code>r</code>
</dd> <dd>
<code>r</code> - the task that will be executed</dd> </dl> </section><section class="detail" id="afterExecute(java.lang.Runnable,java.lang.Throwable)"> <h3>afterExecute</h3> <pre class="lang-java" data-language="java">protected void afterExecute(Runnable r, Throwable t)</pre> <div class="block">Method invoked upon completion of execution of the given Runnable. This method is invoked by the thread that executed the task. If non-null, the Throwable is the uncaught <code>RuntimeException</code> or <code>Error</code> that caused execution to terminate abruptly. <p>This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke <code>super.afterExecute</code> at the beginning of this method. </p>
<p><b>Note:</b> When actions are enclosed in tasks (such as <a href="futuretask" title="class in java.util.concurrent"><code>FutureTask</code></a>) either explicitly or via methods such as <code>submit</code>, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are <em>not</em> passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted: </p>
<pre class="lang-java" data-language="java"> <code>
 class ExtendedExecutor extends ThreadPoolExecutor {
   // ...
   protected void afterExecute(Runnable r, Throwable t) {
     super.afterExecute(r, t);
     if (t == null
         &amp;&amp; r instanceof Future&lt;?&gt;
         &amp;&amp; ((Future&lt;?&gt;)r).isDone()) {
       try {
         Object result = ((Future&lt;?&gt;) r).get();
       } catch (CancellationException ce) {
         t = ce;
       } catch (ExecutionException ee) {
         t = ee.getCause();
       } catch (InterruptedException ie) {
         // ignore/reset
         Thread.currentThread().interrupt();
       }
     }
     if (t != null)
       System.out.println(t);
   }
 }</code></pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>r</code> - the runnable that has completed</dd> <dd>
<code>t</code> - the exception that caused termination, or null if execution completed normally</dd> </dl> </section><section class="detail" id="terminated()"> <h3>terminated</h3> <pre class="lang-java" data-language="java">protected void terminated()</pre> <div class="block">Method invoked when the Executor has terminated. Default implementation does nothing. Note: To properly nest multiple overridings, subclasses should generally invoke <code>super.terminated</code> within this method.</div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ThreadPoolExecutor.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ThreadPoolExecutor.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
