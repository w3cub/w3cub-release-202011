
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>CountedCompleter - OpenJDK 21 - W3cubDocs</title>
  
  <meta name="description" content="A concrete CountedCompleter class must define method compute(), that should in most cases (as illustrated below), invoke tryComplete() once before &hellip;">
  <meta name="keywords" content="class, countedcompleter, t, openjdk, openjdk~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~21/java.base/java/util/concurrent/countedcompleter.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/openjdk~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~21/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<h1 title="Class CountedCompleter" class="title">Class CountedCompleter&lt;T&gt;</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../../lang/object" title="class in java.lang">java.lang.Object</a> <div class="inheritance">
<a href="forkjointask" title="class in java.util.concurrent">java.util.concurrent.ForkJoinTask</a>&lt;T&gt; <div class="inheritance">java.util.concurrent.CountedCompleter&lt;T&gt;</div> </div> </div> <section class="class-description" id="class-description"> <dl class="notes"> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the result of the completer</dd> </dl> <dl class="notes"> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../../io/serializable" title="interface in java.io">Serializable</a></code>, <code><a href="future" title="interface in java.util.concurrent">Future</a>&lt;T&gt;</code>
</dd> </dl>  <pre class="lang-java" data-language="java">public abstract class CountedCompleter&lt;T&gt; extends ForkJoinTask&lt;T&gt;</pre> <div class="block">A <a href="forkjointask" title="class in java.util.concurrent"><code>ForkJoinTask</code></a> with a completion action performed when triggered and there are no remaining pending actions. CountedCompleters are in general more robust in the presence of subtask stalls and blockage than are other forms of ForkJoinTasks, but are less intuitive to program. Uses of CountedCompleter are similar to those of other completion based components (such as <a href="../../nio/channels/completionhandler" title="interface in java.nio.channels"><code>CompletionHandler</code></a>) except that multiple <em>pending</em> completions may be necessary to trigger the completion action <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>, not just one. Unless initialized otherwise, the <a href="#getPendingCount()">pending count</a> starts at zero, but may be (atomically) changed using methods <a href="#setPendingCount(int)"><code>setPendingCount(int)</code></a>, <a href="#addToPendingCount(int)"><code>addToPendingCount(int)</code></a>, and <a href="#compareAndSetPendingCount(int,int)"><code>compareAndSetPendingCount(int, int)</code></a>. Upon invocation of <a href="#tryComplete()"><code>tryComplete()</code></a>, if the pending action count is nonzero, it is decremented; otherwise, the completion action is performed, and if this completer itself has a completer, the process is continued with its completer. As is the case with related synchronization components such as <a href="phaser" title="class in java.util.concurrent"><code>Phaser</code></a> and <a href="semaphore" title="class in java.util.concurrent"><code>Semaphore</code></a>, these methods affect only internal counts; they do not establish any further internal bookkeeping. In particular, the identities of pending tasks are not maintained. As illustrated below, you can create subclasses that do record some or all pending tasks or their results when needed. As illustrated below, utility methods supporting customization of completion traversals are also provided. However, because CountedCompleters provide only basic synchronization mechanisms, it may be useful to create further abstract subclasses that maintain linkages, fields, and additional support methods appropriate for a set of related usages. <p>A concrete CountedCompleter class must define method <a href="#compute()"><code>compute()</code></a>, that should in most cases (as illustrated below), invoke <code>tryComplete()</code> once before returning. The class may also optionally override method <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> to perform an action upon normal completion, and method <a href="#onExceptionalCompletion(java.lang.Throwable,java.util.concurrent.CountedCompleter)"><code>onExceptionalCompletion(Throwable, CountedCompleter)</code></a> to perform an action upon any exception. </p>
<p>CountedCompleters most often do not bear results, in which case they are normally declared as <code>CountedCompleter&lt;Void&gt;</code>, and will always return <code>null</code> as a result value. In other cases, you should override method <a href="#getRawResult()"><code>getRawResult()</code></a> to provide a result from <code>join(), invoke()</code>, and related methods. In general, this method should return the value of a field (or a function of one or more fields) of the CountedCompleter object that holds the result upon completion. Method <a href="#setRawResult(T)"><code>setRawResult(T)</code></a> by default plays no role in CountedCompleters. It is possible, but rarely applicable, to override this method to maintain other objects or fields holding result data. </p>
<p>A CountedCompleter that does not itself have a completer (i.e., one for which <a href="#getCompleter()"><code>getCompleter()</code></a> returns <code>null</code>) can be used as a regular ForkJoinTask with this added functionality. However, any completer that in turn has another completer serves only as an internal helper for other computations, so its own task status (as reported in methods such as <a href="forkjointask#isDone()"><code>ForkJoinTask.isDone()</code></a>) is arbitrary; this status changes only upon explicit invocations of <a href="#complete(T)"><code>complete(T)</code></a>, <a href="forkjointask#cancel(boolean)"><code>ForkJoinTask.cancel(boolean)</code></a>, <a href="forkjointask#completeExceptionally(java.lang.Throwable)"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a> or upon exceptional completion of method <code>compute</code>. Upon any exceptional completion, the exception may be relayed to a task's completer (and its completer, and so on), if one exists and it has not otherwise already completed. Similarly, cancelling an internal CountedCompleter has only a local effect on that completer, so is not often useful. </p>
<p><b>Sample Usages.</b> </p>
<p><b>Parallel recursive decomposition.</b> CountedCompleters may be arranged in trees similar to those often used with <a href="recursiveaction" title="class in java.util.concurrent"><code>RecursiveAction</code></a>s, although the constructions involved in setting them up typically vary. Here, the completer of each task is its parent in the computation tree. Even though they entail a bit more bookkeeping, CountedCompleters may be better choices when applying a possibly time-consuming operation (that cannot be further subdivided) to each element of an array or collection; especially when the operation takes a significantly different amount of time to complete for some elements than others, either because of intrinsic variation (for example I/O) or auxiliary effects such as garbage collection. Because CountedCompleters provide their own continuations, other tasks need not block waiting to perform them. </p>
<p>For example, here is an initial version of a utility method that uses divide-by-two recursive decomposition to divide work into single pieces (leaf tasks). Even when work is split into individual calls, tree-based techniques are usually preferable to directly forking leaf tasks, because they reduce inter-thread communication and improve load balancing. In the recursive case, the second of each pair of subtasks to finish triggers completion of their parent (because no result combination is performed, the default no-op implementation of method <code>onCompletion</code> is not overridden). The utility method sets up the root task and invokes it (here, implicitly using the <a href="forkjoinpool#commonPool()"><code>ForkJoinPool.commonPool()</code></a>). It is straightforward and reliable (but not optimal) to always set the pending count to the number of child tasks and call <code>
 tryComplete()</code> immediately before returning. </p>
<pre class="lang-java" data-language="java"> <code>
 public static &lt;E&gt; void forEach(E[] array, Consumer&lt;E&gt; action) {
   class Task extends CountedCompleter&lt;Void&gt; {
     final int lo, hi;
     Task(Task parent, int lo, int hi) {
       super(parent); this.lo = lo; this.hi = hi;
     }

     public void compute() {
       if (hi - lo &gt;= 2) {
         int mid = (lo + hi) &gt;&gt;&gt; 1;
         // must set pending count before fork
         setPendingCount(2);
         new Task(this, mid, hi).fork(); // right child
         new Task(this, lo, mid).fork(); // left child
       }
       else if (hi &gt; lo)
         action.accept(array[lo]);
       tryComplete();
     }
   }
   new Task(null, 0, array.length).invoke();
 }</code></pre> This design can be improved by noticing that in the recursive case, the task has nothing to do after forking its right task, so can directly invoke its left task before returning. (This is an analog of tail recursion removal.) Also, when the last action in a task is to fork or invoke a subtask (a "tail call"), the call to <code>
 tryComplete()</code> can be optimized away, at the cost of making the pending count look "off by one". <pre class="lang-java" data-language="java"> <code>
     public void compute() {
       if (hi - lo &gt;= 2) {
         int mid = (lo + hi) &gt;&gt;&gt; 1;
         setPendingCount(1); // looks off by one, but correct!
         new Task(this, mid, hi).fork(); // right child
         new Task(this, lo, mid).compute(); // direct invoke
       } else {
         if (hi &gt; lo)
           action.accept(array[lo]);
         tryComplete();
       }
     }</code></pre> As a further optimization, notice that the left task need not even exist. Instead of creating a new one, we can continue using the original task, and add a pending count for each fork. Additionally, because no task in this tree implements an <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> method, <code>tryComplete</code> can be replaced with <a href="#propagateCompletion()"><code>propagateCompletion()</code></a>. <pre class="lang-java" data-language="java"> <code>
     public void compute() {
       int n = hi - lo;
       for (; n &gt;= 2; n /= 2) {
         addToPendingCount(1);
         new Task(this, lo + n/2, lo + n).fork();
       }
       if (n &gt; 0)
         action.accept(array[lo]);
       propagateCompletion();
     }</code></pre> When pending counts can be precomputed, they can be established in the constructor: <pre class="lang-java" data-language="java"> <code>
 public static &lt;E&gt; void forEach(E[] array, Consumer&lt;E&gt; action) {
   class Task extends CountedCompleter&lt;Void&gt; {
     final int lo, hi;
     Task(Task parent, int lo, int hi) {
       super(parent, 31 - Integer.numberOfLeadingZeros(hi - lo));
       this.lo = lo; this.hi = hi;
     }

     public void compute() {
       for (int n = hi - lo; n &gt;= 2; n /= 2)
         new Task(this, lo + n/2, lo + n).fork();
       action.accept(array[lo]);
       propagateCompletion();
     }
   }
   if (array.length &gt; 0)
     new Task(null, 0, array.length).invoke();
 }</code></pre> Additional optimizations of such classes might entail specializing classes for leaf steps, subdividing by say, four, instead of two per iteration, and using an adaptive threshold instead of always subdividing down to single elements. <p><b>Searching.</b> A tree of CountedCompleters can search for a value or property in different parts of a data structure, and report a result in an <a href="atomic/atomicreference" title="class in java.util.concurrent.atomic"><code>AtomicReference</code></a> as soon as one is found. The others can poll the result to avoid unnecessary work. (You could additionally <a href="forkjointask#cancel(boolean)">cancel</a> other tasks, but it is usually simpler and more efficient to just let them notice that the result is set and if so skip further processing.) Illustrating again with an array using full partitioning (again, in practice, leaf tasks will almost always process more than one element): </p>
<pre class="lang-java" data-language="java"> <code>
 class Searcher&lt;E&gt; extends CountedCompleter&lt;E&gt; {
   final E[] array; final AtomicReference&lt;E&gt; result; final int lo, hi;
   Searcher(CountedCompleter&lt;?&gt; p, E[] array, AtomicReference&lt;E&gt; result, int lo, int hi) {
     super(p);
     this.array = array; this.result = result; this.lo = lo; this.hi = hi;
   }
   public E getRawResult() { return result.get(); }
   public void compute() { // similar to ForEach version 3
     int l = lo, h = hi;
     while (result.get() == null &amp;&amp; h &gt;= l) {
       if (h - l &gt;= 2) {
         int mid = (l + h) &gt;&gt;&gt; 1;
         addToPendingCount(1);
         new Searcher(this, array, result, mid, h).fork();
         h = mid;
       }
       else {
         E x = array[l];
         if (matches(x) &amp;&amp; result.compareAndSet(null, x))
           quietlyCompleteRoot(); // root task is now joinable
         break;
       }
     }
     tryComplete(); // normally complete whether or not found
   }
   boolean matches(E e) { ... } // return true if found

   public static &lt;E&gt; E search(E[] array) {
       return new Searcher&lt;E&gt;(null, array, new AtomicReference&lt;E&gt;(), 0, array.length).invoke();
   }
 }</code></pre> In this example, as well as others in which tasks have no other effects except to <code>compareAndSet</code> a common result, the trailing unconditional invocation of <code>tryComplete</code> could be made conditional (<code>if (result.get() == null) tryComplete();</code>) because no further bookkeeping is required to manage completions once the root task completes. <p><b>Recording subtasks.</b> CountedCompleter tasks that combine results of multiple subtasks usually need to access these results in method <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>. As illustrated in the following class (that performs a simplified form of map-reduce where mappings and reductions are all of type <code>E</code>), one way to do this in divide and conquer designs is to have each subtask record its sibling, so that it can be accessed in method <code>onCompletion</code>. This technique applies to reductions in which the order of combining left and right results does not matter; ordered reductions require explicit left/right designations. Variants of other streamlinings seen in the above examples may also apply. </p>
<pre class="lang-java" data-language="java"> <code>
 class MyMapper&lt;E&gt; { E apply(E v) {  ...  } }
 class MyReducer&lt;E&gt; { E apply(E x, E y) {  ...  } }
 class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; {
   final E[] array; final MyMapper&lt;E&gt; mapper;
   final MyReducer&lt;E&gt; reducer; final int lo, hi;
   MapReducer&lt;E&gt; sibling;
   E result;
   MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
              MyReducer&lt;E&gt; reducer, int lo, int hi) {
     super(p);
     this.array = array; this.mapper = mapper;
     this.reducer = reducer; this.lo = lo; this.hi = hi;
   }
   public void compute() {
     if (hi - lo &gt;= 2) {
       int mid = (lo + hi) &gt;&gt;&gt; 1;
       MapReducer&lt;E&gt; left = new MapReducer(this, array, mapper, reducer, lo, mid);
       MapReducer&lt;E&gt; right = new MapReducer(this, array, mapper, reducer, mid, hi);
       left.sibling = right;
       right.sibling = left;
       setPendingCount(1); // only right is pending
       right.fork();
       left.compute();     // directly execute left
     }
     else {
       if (hi &gt; lo)
           result = mapper.apply(array[lo]);
       tryComplete();
     }
   }
   public void onCompletion(CountedCompleter&lt;?&gt; caller) {
     if (caller != this) {
       MapReducer&lt;E&gt; child = (MapReducer&lt;E&gt;)caller;
       MapReducer&lt;E&gt; sib = child.sibling;
       if (sib == null || sib.result == null)
         result = child.result;
       else
         result = reducer.apply(child.result, sib.result);
     }
   }
   public E getRawResult() { return result; }

   public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
     return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                              0, array.length).invoke();
   }
 }</code></pre> Here, method <code>onCompletion</code> takes a form common to many completion designs that combine results. This callback-style method is triggered once per task, in either of the two different contexts in which the pending count is, or becomes, zero: (1) by a task itself, if its pending count is zero upon invocation of <code>
 tryComplete</code>, or (2) by any of its subtasks when they complete and decrement the pending count to zero. The <code>caller</code> argument distinguishes cases. Most often, when the caller is <code>this</code>, no action is necessary. Otherwise the caller argument can be used (usually via a cast) to supply a value (and/or links to other values) to be combined. Assuming proper use of pending counts, the actions inside <code>onCompletion</code> occur (once) upon completion of a task and its subtasks. No additional synchronization is required within this method to ensure thread safety of accesses to fields of this task or other completed tasks. <p><b>Completion Traversals.</b> If using <code>onCompletion</code> to process completions is inapplicable or inconvenient, you can use methods <a href="#firstComplete()"><code>firstComplete()</code></a> and <a href="#nextComplete()"><code>nextComplete()</code></a> to create custom traversals. For example, to define a MapReducer that only splits out right-hand tasks in the form of the third ForEach example, the completions must cooperatively reduce along unexhausted subtask links, which can be done as follows: </p>
<pre class="lang-java" data-language="java"> <code>
 class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; { // version 2
   final E[] array; final MyMapper&lt;E&gt; mapper;
   final MyReducer&lt;E&gt; reducer; final int lo, hi;
   MapReducer&lt;E&gt; forks, next; // record subtask forks in list
   E result;
   MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
              MyReducer&lt;E&gt; reducer, int lo, int hi, MapReducer&lt;E&gt; next) {
     super(p);
     this.array = array; this.mapper = mapper;
     this.reducer = reducer; this.lo = lo; this.hi = hi;
     this.next = next;
   }
   public void compute() {
     int l = lo, h = hi;
     while (h - l &gt;= 2) {
       int mid = (l + h) &gt;&gt;&gt; 1;
       addToPendingCount(1);
       (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();
       h = mid;
     }
     if (h &gt; l)
       result = mapper.apply(array[l]);
     // process completions by reducing along and advancing subtask links
     for (CountedCompleter&lt;?&gt; c = firstComplete(); c != null; c = c.nextComplete()) {
       for (MapReducer t = (MapReducer)c, s = t.forks; s != null; s = t.forks = s.next)
         t.result = reducer.apply(t.result, s.result);
     }
   }
   public E getRawResult() { return result; }

   public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
     return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                              0, array.length, null).invoke();
   }
 }</code></pre> <p><b>Triggers.</b> Some CountedCompleters are themselves never forked, but instead serve as bits of plumbing in other designs; including those in which the completion of one or more async tasks triggers another async task. For example: </p>
<pre class="lang-java" data-language="java"> <code>
 class HeaderBuilder extends CountedCompleter&lt;...&gt; { ... }
 class BodyBuilder extends CountedCompleter&lt;...&gt; { ... }
 class PacketSender extends CountedCompleter&lt;...&gt; {
   PacketSender(...) { super(null, 1); ... } // trigger on second completion
   public void compute() { } // never called
   public void onCompletion(CountedCompleter&lt;?&gt; caller) { sendPacket(); }
 }
 // sample use:
 PacketSender p = new PacketSender();
 new HeaderBuilder(p, ...).fork();
 new BodyBuilder(p, ...).fork();</code></pre>
</div> <dl class="notes"> <dt>Since:</dt> <dd>1.8</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/serialized-form.html#java.util.concurrent.CountedCompleter">Serialized Form</a></li> </ul> </dd> </dl> </section> <section class="summary"> <section class="nested-class-summary" id="nested-class-summary"> <h2>Nested Class Summary</h2> <div class="inherited-list"> <h2 id="nested-classes-inherited-from-class-java.util.concurrent.Future">Nested classes/interfaces declared in interface java.util.concurrent.<a href="future" title="interface in java.util.concurrent">Future</a>
</h2> <code><a href="future.state" title="enum class in java.util.concurrent">Future.State</a></code>
</div> </section><section class="constructor-summary" id="constructor-summary"> <h2>Constructor Summary</h2>  <table class="summary-table three-column-summary">     <div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">CountedCompleter</a>()</code></div>   <div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(java.util.concurrent.CountedCompleter)" class="member-name-link">CountedCompleter</a><wbr>(<a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt; completer)</wbr></code></div>   <div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(java.util.concurrent.CountedCompleter,int)" class="member-name-link">CountedCompleter</a><wbr>(<a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt; completer,
 int initialPendingCount)</wbr></code></div>  <tr>
<th>Modifier</th>
<th>Constructor</th>
<th>Description</th>
</tr>
<tr>
<td><code>protected </code></td>
<td> <div class="block">Creates a new CountedCompleter with no completer and an initial pending count of zero.</div> </td>
</tr>
<tr>
<td><code>protected </code></td>
<td> <div class="block">Creates a new CountedCompleter with the given completer and an initial pending count of zero.</div> </td>
</tr>
<tr>
<td><code>protected </code></td>
<td> <div class="block">Creates a new CountedCompleter with the given completer and initial pending count.</div> </td>
</tr>
</table> </section><section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#addToPendingCount(int)" class="member-name-link">addToPendingCount</a><wbr>(int delta)</wbr></code></td>
<td> <div class="block">Adds (atomically) the given value to the pending count.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#compareAndSetPendingCount(int,int)" class="member-name-link">compareAndSetPendingCount</a><wbr>(int expected,
 int count)</wbr></code></td>
<td> <div class="block">Sets (atomically) the pending count to the given count only if it currently holds the given expected value.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#complete(T)" class="member-name-link">complete</a><wbr>(<a href="countedcompleter" title="type parameter in CountedCompleter">T</a> rawResult)</wbr></code></td>
<td> <div class="block">Regardless of pending count, invokes <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>, marks this task as complete and further triggers <a href="#tryComplete()"><code>tryComplete()</code></a> on this task's completer, if one exists.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#compute()" class="member-name-link">compute</a>()</code></td>
<td> <div class="block">The main computation performed by this task.</div> </td>
</tr>
<tr>
<td><code>final int</code></td>
<td><code><a href="#decrementPendingCountUnlessZero()" class="member-name-link">decrementPendingCountUnlessZero</a>()</code></td>
<td> <div class="block">If the pending count is nonzero, (atomically) decrements it.</div> </td>
</tr>
<tr>
<td><code>protected final boolean</code></td>
<td><code><a href="#exec()" class="member-name-link">exec</a>()</code></td>
<td> <div class="block">Implements execution conventions for CountedCompleters.</div> </td>
</tr>
<tr>
<td><code>final <a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a><wbr>&lt;?&gt;</wbr></code></td>
<td><code><a href="#firstComplete()" class="member-name-link">firstComplete</a>()</code></td>
<td> <div class="block">If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns <code>null</code>.</div> </td>
</tr>
<tr>
<td><code>final <a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a><wbr>&lt;?&gt;</wbr></code></td>
<td><code><a href="#getCompleter()" class="member-name-link">getCompleter</a>()</code></td>
<td> <div class="block">Returns the completer established in this task's constructor, or <code>null</code> if none.</div> </td>
</tr>
<tr>
<td><code>final int</code></td>
<td><code><a href="#getPendingCount()" class="member-name-link">getPendingCount</a>()</code></td>
<td> <div class="block">Returns the current pending count.</div> </td>
</tr>
<tr>
<td><code><a href="countedcompleter" title="type parameter in CountedCompleter">T</a></code></td>
<td><code><a href="#getRawResult()" class="member-name-link">getRawResult</a>()</code></td>
<td> <div class="block">Returns the result of the computation.</div> </td>
</tr>
<tr>
<td><code>final <a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a><wbr>&lt;?&gt;</wbr></code></td>
<td><code><a href="#getRoot()" class="member-name-link">getRoot</a>()</code></td>
<td> <div class="block">Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#helpComplete(int)" class="member-name-link">helpComplete</a><wbr>(int maxTasks)</wbr></code></td>
<td> <div class="block">If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.</div> </td>
</tr>
<tr>
<td><code>final <a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a><wbr>&lt;?&gt;</wbr></code></td>
<td><code><a href="#nextComplete()" class="member-name-link">nextComplete</a>()</code></td>
<td> <div class="block">If this task does not have a completer, invokes <a href="forkjointask#quietlyComplete()"><code>ForkJoinTask.quietlyComplete()</code></a> and returns <code>null</code>.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#onCompletion(java.util.concurrent.CountedCompleter)" class="member-name-link">onCompletion</a><wbr>(<a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt; caller)</wbr></code></td>
<td> <div class="block">Performs an action when method <a href="#tryComplete()"><code>tryComplete()</code></a> is invoked and the pending count is zero, or when the unconditional method <a href="#complete(T)"><code>complete(T)</code></a> is invoked.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#onExceptionalCompletion(java.lang.Throwable,java.util.concurrent.CountedCompleter)" class="member-name-link">onExceptionalCompletion</a><wbr>(<a href="../../lang/throwable" title="class in java.lang">Throwable</a> ex,
 <a href="countedcompleter" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt; caller)</wbr></code></td>
<td> <div class="block">Performs an action when method <a href="forkjointask#completeExceptionally(java.lang.Throwable)"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a> is invoked or method <a href="#compute()"><code>compute()</code></a> throws an exception, and this task has not already otherwise completed normally.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#propagateCompletion()" class="member-name-link">propagateCompletion</a>()</code></td>
<td> <div class="block">Equivalent to <a href="#tryComplete()"><code>tryComplete()</code></a> but does not invoke <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#quietlyCompleteRoot()" class="member-name-link">quietlyCompleteRoot</a>()</code></td>
<td> <div class="block">Equivalent to <code>getRoot().quietlyComplete()</code>.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#setPendingCount(int)" class="member-name-link">setPendingCount</a><wbr>(int count)</wbr></code></td>
<td> <div class="block">Sets the pending count to the given value.</div> </td>
</tr>
<tr>
<td><code>protected void</code></td>
<td><code><a href="#setRawResult(T)" class="member-name-link">setRawResult</a><wbr>(<a href="countedcompleter" title="type parameter in CountedCompleter">T</a> t)</wbr></code></td>
<td> <div class="block">A method that result-bearing CountedCompleters may optionally use to help maintain result data.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#tryComplete()" class="member-name-link">tryComplete</a>()</code></td>
<td> <div class="block">If the pending count is nonzero, decrements the count; otherwise invokes <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.util.concurrent.ForkJoinTask">Methods declared in class java.util.concurrent.<a href="forkjointask" title="class in java.util.concurrent">ForkJoinTask</a>
</h3> <code><a href="forkjointask#adapt(java.lang.Runnable)">adapt</a>, <a href="forkjointask#adapt(java.lang.Runnable,T)">adapt</a>, <a href="forkjointask#adapt(java.util.concurrent.Callable)">adapt</a>, <a href="forkjointask#adaptInterruptible(java.util.concurrent.Callable)">adaptInterruptible</a>, <a href="forkjointask#cancel(boolean)">cancel</a>, <a href="forkjointask#compareAndSetForkJoinTaskTag(short,short)">compareAndSetForkJoinTaskTag</a>, <a href="forkjointask#completeExceptionally(java.lang.Throwable)">completeExceptionally</a>, <a href="forkjointask#fork()">fork</a>, <a href="forkjointask#get()">get</a>, <a href="forkjointask#get(long,java.util.concurrent.TimeUnit)">get</a>, <a href="forkjointask#getException()">getException</a>, <a href="forkjointask#getForkJoinTaskTag()">getForkJoinTaskTag</a>, <a href="forkjointask#getPool()">getPool</a>, <a href="forkjointask#getQueuedTaskCount()">getQueuedTaskCount</a>, <a href="forkjointask#getSurplusQueuedTaskCount()">getSurplusQueuedTaskCount</a>, <a href="forkjointask#helpQuiesce()">helpQuiesce</a>, <a href="forkjointask#inForkJoinPool()">inForkJoinPool</a>, <a href="forkjointask#invoke()">invoke</a>, <a href="forkjointask#invokeAll(java.util.Collection)">invokeAll</a>, <a href="forkjointask#invokeAll(java.util.concurrent.ForkJoinTask...)">invokeAll</a>, <a href="forkjointask#invokeAll(java.util.concurrent.ForkJoinTask,java.util.concurrent.ForkJoinTask)">invokeAll</a>, <a href="forkjointask#isCancelled()">isCancelled</a>, <a href="forkjointask#isCompletedAbnormally()">isCompletedAbnormally</a>, <a href="forkjointask#isCompletedNormally()">isCompletedNormally</a>, <a href="forkjointask#isDone()">isDone</a>, <a href="forkjointask#join()">join</a>, <a href="forkjointask#peekNextLocalTask()">peekNextLocalTask</a>, <a href="forkjointask#pollNextLocalTask()">pollNextLocalTask</a>, <a href="forkjointask#pollSubmission()">pollSubmission</a>, <a href="forkjointask#pollTask()">pollTask</a>, <a href="forkjointask#quietlyComplete()">quietlyComplete</a>, <a href="forkjointask#quietlyInvoke()">quietlyInvoke</a>, <a href="forkjointask#quietlyJoin()">quietlyJoin</a>, <a href="forkjointask#quietlyJoin(long,java.util.concurrent.TimeUnit)">quietlyJoin</a>, <a href="forkjointask#quietlyJoinUninterruptibly(long,java.util.concurrent.TimeUnit)">quietlyJoinUninterruptibly</a>, <a href="forkjointask#reinitialize()">reinitialize</a>, <a href="forkjointask#setForkJoinTaskTag(short)">setForkJoinTaskTag</a>, <a href="forkjointask#tryUnfork()">tryUnfork</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../../lang/object" title="class in java.lang">Object</a>
</h3> <code><a href="../../lang/object#clone()">clone</a>, <a href="../../lang/object#equals(java.lang.Object)">equals</a>, <a href="../../lang/object#finalize()">finalize</a>, <a href="../../lang/object#getClass()">getClass</a>, <a href="../../lang/object#hashCode()">hashCode</a>, <a href="../../lang/object#notify()">notify</a>, <a href="../../lang/object#notifyAll()">notifyAll</a>, <a href="../../lang/object#toString()">toString</a>, <a href="../../lang/object#wait()">wait</a>, <a href="../../lang/object#wait(long)">wait</a>, <a href="../../lang/object#wait(long,int)">wait</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.util.concurrent.Future">Methods declared in interface java.util.concurrent.<a href="future" title="interface in java.util.concurrent">Future</a>
</h3> <code><a href="future#exceptionNow()">exceptionNow</a>, <a href="future#resultNow()">resultNow</a>, <a href="future#state()">state</a></code>
</div> </section> </section> <section class="details"> <section class="constructor-details" id="constructor-detail"> <h2>Constructor Details</h2>  </section><section class="detail" id="&lt;init&gt;(java.util.concurrent.CountedCompleter,int)"> <h3>CountedCompleter</h3> <pre class="lang-java" data-language="java">protected CountedCompleter(CountedCompleter&lt;?&gt; completer, int initialPendingCount)</pre> <div class="block">Creates a new CountedCompleter with the given completer and initial pending count.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>completer</code> - this task's completer, or <code>null</code> if none</dd> <dd>
<code>initialPendingCount</code> - the initial pending count</dd> </dl> </section><section class="detail" id="&lt;init&gt;(java.util.concurrent.CountedCompleter)"> <h3>CountedCompleter</h3> <pre class="lang-java" data-language="java">protected CountedCompleter(CountedCompleter&lt;?&gt; completer)</pre> <div class="block">Creates a new CountedCompleter with the given completer and an initial pending count of zero.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>completer</code> - this task's completer, or <code>null</code> if none</dd> </dl> </section><section class="detail" id="&lt;init&gt;()"> <h3>CountedCompleter</h3> <pre class="lang-java" data-language="java">protected CountedCompleter()</pre> <div class="block">Creates a new CountedCompleter with no completer and an initial pending count of zero.</div> </section><section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="compute()"> <h3>compute</h3> <pre class="lang-java" data-language="java">public abstract void compute()</pre> <div class="block">The main computation performed by this task.</div> </section><section class="detail" id="onCompletion(java.util.concurrent.CountedCompleter)"> <h3>onCompletion</h3> <pre class="lang-java" data-language="java">public void onCompletion(CountedCompleter&lt;?&gt; caller)</pre> <div class="block">Performs an action when method <a href="#tryComplete()"><code>tryComplete()</code></a> is invoked and the pending count is zero, or when the unconditional method <a href="#complete(T)"><code>complete(T)</code></a> is invoked. By default, this method does nothing. You can distinguish cases by checking the identity of the given caller argument. If not equal to <code>
 this</code>, then it is typically a subtask that may contain results (and/or links to other results) to combine.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>caller</code> - the task invoking this method (which may be this task itself)</dd> </dl> </section><section class="detail" id="onExceptionalCompletion(java.lang.Throwable,java.util.concurrent.CountedCompleter)"> <h3>onExceptionalCompletion</h3> <pre class="lang-java" data-language="java">public boolean onExceptionalCompletion(Throwable ex, CountedCompleter&lt;?&gt; caller)</pre> <div class="block">Performs an action when method <a href="forkjointask#completeExceptionally(java.lang.Throwable)"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a> is invoked or method <a href="#compute()"><code>compute()</code></a> throws an exception, and this task has not already otherwise completed normally. On entry to this method, this task <a href="forkjointask#isCompletedAbnormally()"><code>ForkJoinTask.isCompletedAbnormally()</code></a>. The return value of this method controls further propagation: If <code>true</code> and this task has a completer that has not completed, then that completer is also completed exceptionally, with the same exception as this completer. The default implementation of this method does nothing except return <code>true</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>ex</code> - the exception</dd> <dd>
<code>caller</code> - the task invoking this method (which may be this task itself)</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this exception should be propagated to this task's completer, if one exists</dd> </dl> </section><section class="detail" id="getCompleter()"> <h3>getCompleter</h3> <pre class="lang-java" data-language="java">public final CountedCompleter&lt;?&gt; getCompleter()</pre> <div class="block">Returns the completer established in this task's constructor, or <code>null</code> if none.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the completer</dd> </dl> </section><section class="detail" id="getPendingCount()"> <h3>getPendingCount</h3> <pre class="lang-java" data-language="java">public final int getPendingCount()</pre> <div class="block">Returns the current pending count.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current pending count</dd> </dl> </section><section class="detail" id="setPendingCount(int)"> <h3>setPendingCount</h3> <pre class="lang-java" data-language="java">public final void setPendingCount(int count)</pre> <div class="block">Sets the pending count to the given value.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>count</code> - the count</dd> </dl> </section><section class="detail" id="addToPendingCount(int)"> <h3>addToPendingCount</h3> <pre class="lang-java" data-language="java">public final void addToPendingCount(int delta)</pre> <div class="block">Adds (atomically) the given value to the pending count.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>delta</code> - the value to add</dd> </dl> </section><section class="detail" id="compareAndSetPendingCount(int,int)"> <h3>compareAndSetPendingCount</h3> <pre class="lang-java" data-language="java">public final boolean compareAndSetPendingCount(int expected, int count)</pre> <div class="block">Sets (atomically) the pending count to the given count only if it currently holds the given expected value.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>expected</code> - the expected value</dd> <dd>
<code>count</code> - the new value</dd> <dt>Returns:</dt> <dd>
<code>true</code> if successful</dd> </dl> </section><section class="detail" id="decrementPendingCountUnlessZero()"> <h3>decrementPendingCountUnlessZero</h3> <pre class="lang-java" data-language="java">public final int decrementPendingCountUnlessZero()</pre> <div class="block">If the pending count is nonzero, (atomically) decrements it.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the initial (undecremented) pending count holding on entry to this method</dd> </dl> </section><section class="detail" id="getRoot()"> <h3>getRoot</h3> <pre class="lang-java" data-language="java">public final CountedCompleter&lt;?&gt; getRoot()</pre> <div class="block">Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the root of the current computation</dd> </dl> </section><section class="detail" id="tryComplete()"> <h3>tryComplete</h3> <pre class="lang-java" data-language="java">public final void tryComplete()</pre> <div class="block">If the pending count is nonzero, decrements the count; otherwise invokes <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</div> </section><section class="detail" id="propagateCompletion()"> <h3>propagateCompletion</h3> <pre class="lang-java" data-language="java">public final void propagateCompletion()</pre> <div class="block">Equivalent to <a href="#tryComplete()"><code>tryComplete()</code></a> but does not invoke <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete. This method may be useful in cases where <code>onCompletion</code> should not, or need not, be invoked for each completer in a computation.</div> </section><section class="detail" id="complete(T)"> <h3 id="complete(java.lang.Object)">complete</h3> <pre class="lang-java" data-language="java">public void complete(T rawResult)</pre> <div class="block">Regardless of pending count, invokes <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>, marks this task as complete and further triggers <a href="#tryComplete()"><code>tryComplete()</code></a> on this task's completer, if one exists. The given rawResult is used as an argument to <a href="#setRawResult(T)"><code>setRawResult(T)</code></a> before invoking <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> or marking this task as complete; its value is meaningful only for classes overriding <code>setRawResult</code>. This method does not modify the pending count. <p>This method may be useful when forcing completion as soon as any one (versus all) of several subtask results are obtained. However, in the common (and recommended) case in which <code>
 setRawResult</code> is not overridden, this effect can be obtained more simply using <a href="#quietlyCompleteRoot()"><code>quietlyCompleteRoot()</code></a>.</p>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="forkjointask#complete(V)">complete</a></code> in class <code><a href="forkjointask" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="countedcompleter" title="type parameter in CountedCompleter">T</a>&gt;</code>
</dd> <dt>Parameters:</dt> <dd>
<code>rawResult</code> - the raw result</dd> </dl> </section><section class="detail" id="firstComplete()"> <h3>firstComplete</h3> <pre class="lang-java" data-language="java">public final CountedCompleter&lt;?&gt; firstComplete()</pre> <div class="block">If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns <code>null</code>. This method is designed to be used with <a href="#nextComplete()"><code>nextComplete()</code></a> in completion traversal loops.</div> <dl class="notes"> <dt>Returns:</dt> <dd>this task, if pending count was zero, else <code>null</code>
</dd> </dl> </section><section class="detail" id="nextComplete()"> <h3>nextComplete</h3> <pre class="lang-java" data-language="java">public final CountedCompleter&lt;?&gt; nextComplete()</pre> <div class="block">If this task does not have a completer, invokes <a href="forkjointask#quietlyComplete()"><code>ForkJoinTask.quietlyComplete()</code></a> and returns <code>null</code>. Or, if the completer's pending count is non-zero, decrements that pending count and returns <code>null</code>. Otherwise, returns the completer. This method can be used as part of a completion traversal loop for homogeneous task hierarchies: <pre class="lang-java" data-language="java"> <code>
 for (CountedCompleter&lt;?&gt; c = firstComplete();
      c != null;
      c = c.nextComplete()) {
   // ... process c ...
 }</code></pre>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>the completer, or <code>null</code> if none</dd> </dl> </section><section class="detail" id="quietlyCompleteRoot()"> <h3>quietlyCompleteRoot</h3> <pre class="lang-java" data-language="java">public final void quietlyCompleteRoot()</pre> <div class="block">Equivalent to <code>getRoot().quietlyComplete()</code>.</div> </section><section class="detail" id="helpComplete(int)"> <h3>helpComplete</h3> <pre class="lang-java" data-language="java">public final void helpComplete(int maxTasks)</pre> <div class="block">If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>maxTasks</code> - the maximum number of tasks to process. If less than or equal to zero, then no tasks are processed.</dd> </dl> </section><section class="detail" id="exec()"> <h3>exec</h3> <pre class="lang-java" data-language="java">protected final boolean exec()</pre> <div class="block">Implements execution conventions for CountedCompleters.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="forkjointask#exec()">exec</a></code> in class <code><a href="forkjointask" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="countedcompleter" title="type parameter in CountedCompleter">T</a>&gt;</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this task is known to have completed normally</dd> </dl> </section><section class="detail" id="getRawResult()"> <h3>getRawResult</h3> <pre class="lang-java" data-language="java">public T getRawResult()</pre> <div class="block">Returns the result of the computation. By default, returns <code>null</code>, which is appropriate for <code>Void</code> actions, but in other cases should be overridden, almost always to return a field or function of a field that holds the result upon completion.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="forkjointask#getRawResult()">getRawResult</a></code> in class <code><a href="forkjointask" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="countedcompleter" title="type parameter in CountedCompleter">T</a>&gt;</code>
</dd> <dt>Returns:</dt> <dd>the result of the computation</dd> </dl> </section><section class="detail" id="setRawResult(T)"> <h3 id="setRawResult(java.lang.Object)">setRawResult</h3> <pre class="lang-java" data-language="java">protected void setRawResult(T t)</pre> <div class="block">A method that result-bearing CountedCompleters may optionally use to help maintain result data. By default, does nothing. Overrides are not recommended. However, if this method is overridden to update existing objects or fields, then it must in general be defined to be thread-safe.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="forkjointask#setRawResult(V)">setRawResult</a></code> in class <code><a href="forkjointask" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="countedcompleter" title="type parameter in CountedCompleter">T</a>&gt;</code>
</dd> <dt>Parameters:</dt> <dd>
<code>t</code> - the value</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/CountedCompleter.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/CountedCompleter.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
