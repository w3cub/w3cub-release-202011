
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Path2D - OpenJDK 21 - W3cubDocs</title>
  
  <meta name="description" content="Use Path2D.Float when dealing with data that can be represented and used with floating point precision. Use Path2D.Double for data that requires the &hellip;">
  <meta name="keywords" content="class, path, d, openjdk, openjdk~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~21/java.desktop/java/awt/geom/path2d.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/openjdk~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~21/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<h1 title="Class Path2D" class="title">Class Path2D</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../../../../java.base/java/lang/object" title="class in java.lang">java.lang.Object</a> <div class="inheritance">java.awt.geom.Path2D</div> </div> <section class="class-description" id="class-description"> <dl class="notes"> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../shape" title="interface in java.awt">Shape</a></code>, <code><a href="../../../../java.base/java/lang/cloneable" title="interface in java.lang">Cloneable</a></code>
</dd> </dl> <dl class="notes"> <dt>Direct Known Subclasses:</dt> <dd>
<code><a href="path2d.double" title="class in java.awt.geom">Path2D.Double</a></code>, <code><a href="path2d.float" title="class in java.awt.geom">Path2D.Float</a></code>
</dd> </dl>  <pre class="lang-java" data-language="java">public abstract sealed class Path2D extends Object implements Shape, Cloneable permits Path2D.Double, Path2D.Float</pre> <div class="block">The <code>Path2D</code> class provides a simple, yet flexible shape which represents an arbitrary geometric path. It can fully represent any path which can be iterated by the <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> interface including all of its segment types and winding rules and it implements all of the basic hit testing methods of the <a href="../shape" title="interface in java.awt"><code>Shape</code></a> interface. <p> Use <a href="path2d.float" title="class in java.awt.geom"><code>Path2D.Float</code></a> when dealing with data that can be represented and used with floating point precision. Use <a href="path2d.double" title="class in java.awt.geom"><code>Path2D.Double</code></a> for data that requires the accuracy or range of double precision. </p>
<p> <code>Path2D</code> provides exactly those facilities required for basic construction and management of a geometric path and implementation of the above interfaces with little added interpretation. If it is useful to manipulate the interiors of closed geometric shapes beyond simple hit testing then the <a href="area" title="class in java.awt.geom"><code>Area</code></a> class provides additional capabilities specifically targeted at closed figures. While both classes nominally implement the <code>Shape</code> interface, they differ in purpose and together they provide two useful views of a geometric shape where <code>Path2D</code> deals primarily with a trajectory formed by path segments and <code>Area</code> deals more with interpretation and manipulation of enclosed regions of 2D geometric space. </p>
<p> The <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> interface has more detailed descriptions of the types of segments that make up a path and the winding rules that control how to determine which regions are inside or outside the path.</p>
</div> <dl class="notes">
<dt>Sealed Class Hierarchy Graph:</dt>
<dd><a class="sealed-graph" href="https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D-sealed-graph.svg"><img style="vertical-align:top" alt="Sealed class hierarchy graph for Path2D" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuMzguMCAoMjAxNDA0MTMuMjA0MSkKIC0tPgo8IS0tIFRpdGxlOiBHIFBhZ2VzOiAxIC0tPgo8c3ZnIHdpZHRoPSIxODRwdCIgaGVpZ2h0PSIyMTdwdCIKIHZpZXdCb3g9IjAuMDAgMC4wMCAxODQuMDAgMjE3LjAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KPGcgaWQ9ImdyYXBoMCIgY2xhc3M9ImdyYXBoIiB0cmFuc2Zvcm09InNjYWxlKDEgMSkgcm90YXRlKDApIHRyYW5zbGF0ZSg0IDIxMykiPgo8dGl0bGU+RzwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IndoaXRlIiBzdHJva2U9Im5vbmUiIHBvaW50cz0iLTQsNCAtNCwtMjEzIDE4MCwtMjEzIDE4MCw0IC00LDQiLz4KPCEtLSBqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGUgLS0+CjxnIGlkPSJub2RlMSIgY2xhc3M9Im5vZGUiPjx0aXRsZT5qYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGU8L3RpdGxlPgo8ZyBpZD0iYV9ub2RlMSI+PGEgeGxpbms6aHJlZj0iLi4vLi4vLi4vamF2YS9hd3QvZ2VvbS9Eb3VibGUuaHRtbCIgeGxpbms6dGl0bGU9ImphdmEuYXd0Lmdlb20uUGF0aDJELkRvdWJsZSI+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjEzOSIgeT0iLTEwMS40IiBmb250LWZhbWlseT0iRGVqYVZ1U2FucyIgZm9udC1zaXplPSIxMi4wMCIgZmlsbD0iI2U3NmYwMCI+RG91YmxlPC90ZXh0Pgo8L2E+CjwvZz4KPC9nPgo8IS0tIGphdmEuYXd0Lmdlb20uUGF0aDJEIC0tPgo8ZyBpZD0ibm9kZTIiIGNsYXNzPSJub2RlIj48dGl0bGU+amF2YS5hd3QuZ2VvbS5QYXRoMkQ8L3RpdGxlPgo8ZyBpZD0iYV9ub2RlMiI+PGEgeGxpbms6aHJlZj0iLi4vLi4vLi4vamF2YS9hd3QvZ2VvbS9QYXRoMkQuaHRtbCIgeGxpbms6dGl0bGU9ImphdmEuYXd0Lmdlb20uUGF0aDJEIj4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iODciIHk9Ii0xODUuNCIgZm9udC1mYW1pbHk9IkRlamFWdVNhbnMiIGZvbnQtc2l6ZT0iMTIuMDAiIGZpbGw9IiNlNzZmMDAiPlBhdGgyRDwvdGV4dD4KPC9hPgo8L2c+CjwvZz4KPCEtLSBqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGUmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRCAtLT4KPGcgaWQ9ImVkZ2UxIiBjbGFzcz0iZWRnZSI+PHRpdGxlPmphdmEuYXd0Lmdlb20uUGF0aDJELkRvdWJsZSYjNDU7Jmd0O2phdmEuYXd0Lmdlb20uUGF0aDJEPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjOTk5OTk5IiBzdHJva2Utd2lkdGg9IjIiIGQ9Ik0xMjYuNDEyLC0xMjUuMzVDMTE5Ljk2MSwtMTM1LjUyMyAxMTEuOTkzLC0xNDguMDg4IDEwNC45MTMsLTE1OS4yNTIiLz4KPHBvbHlnb24gZmlsbD0iIzk5OTk5OSIgc3Ryb2tlPSIjOTk5OTk5IiBzdHJva2Utd2lkdGg9IjIiIHBvaW50cz0iOTkuNDcxOCwtMTY3LjgzMyAxMDEuMDI3LC0xNTYuOTc4IDEwMS43MjcsLTE2My4zNDMgMTA0LjQwNSwtMTU5LjEyIDEwNC44MjcsLTE1OS4zODggMTA1LjI1LC0xNTkuNjU2IDEwMi41NzIsLTE2My44NzggMTA4LjYyOCwtMTYxLjc5OCA5OS40NzE4LC0xNjcuODMzIDk5LjQ3MTgsLTE2Ny44MzMiLz4KPC9nPgo8IS0tIG9wZW4gbm9kZSAjMCAtLT4KPGcgaWQ9Im5vZGUzIiBjbGFzcz0ibm9kZSI+PHRpdGxlPm9wZW4gbm9kZSAjMDwvdGl0bGU+CjxnIGlkPSJhX25vZGUzIj48YSB4bGluazp0aXRsZT0iTm9uJiM0NTtzZWFsZWQgSGllcmFyY2h5Ij4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIxMjAiIHk9Ii0xOC40IiBmb250LWZhbWlseT0iRGVqYVZ1U2FucyIgZm9udC1zdHlsZT0iaXRhbGljIiBmb250LXNpemU9IjEyLjAwIiBmaWxsPSIjZTc2ZjAwIj4mbHQ7YW55Jmd0OzwvdGV4dD4KPC9hPgo8L2c+CjwvZz4KPCEtLSBvcGVuIG5vZGUgIzAmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGUgLS0+CjxnIGlkPSJlZGdlMiIgY2xhc3M9ImVkZ2UiPjx0aXRsZT5vcGVuIG5vZGUgIzAmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGU8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM5OTk5OTkiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWRhc2hhcnJheT0iNSwyIiBkPSJNMTQwLjUxNiwtNDEuMzQ5OUMxNDAuMjgsLTUxLjAxOTIgMTM5Ljk5MSwtNjIuODQ5OCAxMzkuNzMsLTczLjU4NDMiLz4KPHBvbHlnb24gZmlsbD0iIzk5OTk5OSIgc3Ryb2tlPSIjOTk5OTk5IiBzdHJva2Utd2lkdGg9IjIiIHBvaW50cz0iMTM5LjQ4LC04My44MzI5IDEzNS4yMjUsLTczLjcyNjEgMTM5LjEwMiwtNzguODIyMiAxMzkuMjI0LC03My44MjM3IDEzOS43MjQsLTczLjgzNTkgMTQwLjIyMywtNzMuODQ4MSAxNDAuMTAxLC03OC44NDY2IDE0NC4yMjIsLTczLjk0NTYgMTM5LjQ4LC04My44MzI5IDEzOS40OCwtODMuODMyOSIvPgo8L2c+CjwhLS0gamF2YS5hd3QuZ2VvbS5QYXRoMkQuRmxvYXQgLS0+CjxnIGlkPSJub2RlNCIgY2xhc3M9Im5vZGUiPjx0aXRsZT5qYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdDwvdGl0bGU+CjxnIGlkPSJhX25vZGU0Ij48YSB4bGluazpocmVmPSIuLi8uLi8uLi9qYXZhL2F3dC9nZW9tL0Zsb2F0Lmh0bWwiIHhsaW5rOnRpdGxlPSJqYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdCI+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjM2IiB5PSItMTAxLjQiIGZvbnQtZmFtaWx5PSJEZWphVnVTYW5zIiBmb250LXNpemU9IjEyLjAwIiBmaWxsPSIjZTc2ZjAwIj5GbG9hdDwvdGV4dD4KPC9hPgo8L2c+CjwvZz4KPCEtLSBqYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdCYjNDU7Jmd0O2phdmEuYXd0Lmdlb20uUGF0aDJEIC0tPgo8ZyBpZD0iZWRnZTMiIGNsYXNzPSJlZGdlIj48dGl0bGU+amF2YS5hd3QuZ2VvbS5QYXRoMkQuRmxvYXQmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRDwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzk5OTk5OSIgc3Ryb2tlLXdpZHRoPSIyIiBkPSJNNDguMzQ1NywtMTI1LjM1QzU0LjY3MjgsLTEzNS41MjMgNjIuNDg3NywtMTQ4LjA4OCA2OS40MzEzLC0xNTkuMjUyIi8+Cjxwb2x5Z29uIGZpbGw9IiM5OTk5OTkiIHN0cm9rZT0iIzk5OTk5OSIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludHM9Ijc0Ljc2OCwtMTY3LjgzMyA2NS42NjU0LC0xNjEuNzE4IDcxLjcwMjcsLTE2My44NTEgNjkuMDYyLC0xNTkuNjA1IDY5LjQ4NjYsLTE1OS4zNDEgNjkuOTExMiwtMTU5LjA3NyA3Mi41NTE5LC0xNjMuMzIzIDczLjMwNzgsLTE1Ni45NjUgNzQuNzY4LC0xNjcuODMzIDc0Ljc2OCwtMTY3LjgzMyIvPgo8L2c+CjwhLS0gb3BlbiBub2RlICMxIC0tPgo8ZyBpZD0ibm9kZTUiIGNsYXNzPSJub2RlIj48dGl0bGU+b3BlbiBub2RlICMxPC90aXRsZT4KPGcgaWQ9ImFfbm9kZTUiPjxhIHhsaW5rOnRpdGxlPSJOb24mIzQ1O3NlYWxlZCBIaWVyYXJjaHkiPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9IjE0IiB5PSItMTguNCIgZm9udC1mYW1pbHk9IkRlamFWdVNhbnMiIGZvbnQtc3R5bGU9Iml0YWxpYyIgZm9udC1zaXplPSIxMi4wMCIgZmlsbD0iI2U3NmYwMCI+Jmx0O2FueSZndDs8L3RleHQ+CjwvYT4KPC9nPgo8L2c+CjwhLS0gb3BlbiBub2RlICMxJiM0NTsmZ3Q7amF2YS5hd3QuZ2VvbS5QYXRoMkQuRmxvYXQgLS0+CjxnIGlkPSJlZGdlNCIgY2xhc3M9ImVkZ2UiPjx0aXRsZT5vcGVuIG5vZGUgIzEmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdDwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzk5OTk5OSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtZGFzaGFycmF5PSI1LDIiIGQ9Ik0zNS4yNDIxLC00MS4zNDk5QzM1LjM2LC01MS4wMTkyIDM1LjUwNDMsLTYyLjg0OTggMzUuNjM1MiwtNzMuNTg0MyIvPgo8cG9seWdvbiBmaWxsPSIjOTk5OTk5IiBzdHJva2U9IiM5OTk5OTkiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRzPSIzNS43NjAyLC04My44MzI5IDMxLjEzODUsLTczLjg4ODUgMzUuMTk5MiwtNzguODM5NCAzNS4xMzgyLC03My44Mzk3IDM1LjYzODEsLTczLjgzMzYgMzYuMTM4MSwtNzMuODI3NSAzNi4xOTkxLC03OC44MjcyIDQwLjEzNzgsLTczLjc3ODcgMzUuNzYwMiwtODMuODMyOSAzNS43NjAyLC04My44MzI5Ii8+CjwvZz4KPC9nPgo8L3N2Zz4K" height="100"><span><img style="border: solid lightgray 1px; vertical-align:top" alt="Sealed class hierarchy graph for Path2D" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuMzguMCAoMjAxNDA0MTMuMjA0MSkKIC0tPgo8IS0tIFRpdGxlOiBHIFBhZ2VzOiAxIC0tPgo8c3ZnIHdpZHRoPSIxODRwdCIgaGVpZ2h0PSIyMTdwdCIKIHZpZXdCb3g9IjAuMDAgMC4wMCAxODQuMDAgMjE3LjAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KPGcgaWQ9ImdyYXBoMCIgY2xhc3M9ImdyYXBoIiB0cmFuc2Zvcm09InNjYWxlKDEgMSkgcm90YXRlKDApIHRyYW5zbGF0ZSg0IDIxMykiPgo8dGl0bGU+RzwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IndoaXRlIiBzdHJva2U9Im5vbmUiIHBvaW50cz0iLTQsNCAtNCwtMjEzIDE4MCwtMjEzIDE4MCw0IC00LDQiLz4KPCEtLSBqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGUgLS0+CjxnIGlkPSJub2RlMSIgY2xhc3M9Im5vZGUiPjx0aXRsZT5qYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGU8L3RpdGxlPgo8ZyBpZD0iYV9ub2RlMSI+PGEgeGxpbms6aHJlZj0iLi4vLi4vLi4vamF2YS9hd3QvZ2VvbS9Eb3VibGUuaHRtbCIgeGxpbms6dGl0bGU9ImphdmEuYXd0Lmdlb20uUGF0aDJELkRvdWJsZSI+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjEzOSIgeT0iLTEwMS40IiBmb250LWZhbWlseT0iRGVqYVZ1U2FucyIgZm9udC1zaXplPSIxMi4wMCIgZmlsbD0iI2U3NmYwMCI+RG91YmxlPC90ZXh0Pgo8L2E+CjwvZz4KPC9nPgo8IS0tIGphdmEuYXd0Lmdlb20uUGF0aDJEIC0tPgo8ZyBpZD0ibm9kZTIiIGNsYXNzPSJub2RlIj48dGl0bGU+amF2YS5hd3QuZ2VvbS5QYXRoMkQ8L3RpdGxlPgo8ZyBpZD0iYV9ub2RlMiI+PGEgeGxpbms6aHJlZj0iLi4vLi4vLi4vamF2YS9hd3QvZ2VvbS9QYXRoMkQuaHRtbCIgeGxpbms6dGl0bGU9ImphdmEuYXd0Lmdlb20uUGF0aDJEIj4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iODciIHk9Ii0xODUuNCIgZm9udC1mYW1pbHk9IkRlamFWdVNhbnMiIGZvbnQtc2l6ZT0iMTIuMDAiIGZpbGw9IiNlNzZmMDAiPlBhdGgyRDwvdGV4dD4KPC9hPgo8L2c+CjwvZz4KPCEtLSBqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGUmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRCAtLT4KPGcgaWQ9ImVkZ2UxIiBjbGFzcz0iZWRnZSI+PHRpdGxlPmphdmEuYXd0Lmdlb20uUGF0aDJELkRvdWJsZSYjNDU7Jmd0O2phdmEuYXd0Lmdlb20uUGF0aDJEPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjOTk5OTk5IiBzdHJva2Utd2lkdGg9IjIiIGQ9Ik0xMjYuNDEyLC0xMjUuMzVDMTE5Ljk2MSwtMTM1LjUyMyAxMTEuOTkzLC0xNDguMDg4IDEwNC45MTMsLTE1OS4yNTIiLz4KPHBvbHlnb24gZmlsbD0iIzk5OTk5OSIgc3Ryb2tlPSIjOTk5OTk5IiBzdHJva2Utd2lkdGg9IjIiIHBvaW50cz0iOTkuNDcxOCwtMTY3LjgzMyAxMDEuMDI3LC0xNTYuOTc4IDEwMS43MjcsLTE2My4zNDMgMTA0LjQwNSwtMTU5LjEyIDEwNC44MjcsLTE1OS4zODggMTA1LjI1LC0xNTkuNjU2IDEwMi41NzIsLTE2My44NzggMTA4LjYyOCwtMTYxLjc5OCA5OS40NzE4LC0xNjcuODMzIDk5LjQ3MTgsLTE2Ny44MzMiLz4KPC9nPgo8IS0tIG9wZW4gbm9kZSAjMCAtLT4KPGcgaWQ9Im5vZGUzIiBjbGFzcz0ibm9kZSI+PHRpdGxlPm9wZW4gbm9kZSAjMDwvdGl0bGU+CjxnIGlkPSJhX25vZGUzIj48YSB4bGluazp0aXRsZT0iTm9uJiM0NTtzZWFsZWQgSGllcmFyY2h5Ij4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIxMjAiIHk9Ii0xOC40IiBmb250LWZhbWlseT0iRGVqYVZ1U2FucyIgZm9udC1zdHlsZT0iaXRhbGljIiBmb250LXNpemU9IjEyLjAwIiBmaWxsPSIjZTc2ZjAwIj4mbHQ7YW55Jmd0OzwvdGV4dD4KPC9hPgo8L2c+CjwvZz4KPCEtLSBvcGVuIG5vZGUgIzAmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGUgLS0+CjxnIGlkPSJlZGdlMiIgY2xhc3M9ImVkZ2UiPjx0aXRsZT5vcGVuIG5vZGUgIzAmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRC5Eb3VibGU8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM5OTk5OTkiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWRhc2hhcnJheT0iNSwyIiBkPSJNMTQwLjUxNiwtNDEuMzQ5OUMxNDAuMjgsLTUxLjAxOTIgMTM5Ljk5MSwtNjIuODQ5OCAxMzkuNzMsLTczLjU4NDMiLz4KPHBvbHlnb24gZmlsbD0iIzk5OTk5OSIgc3Ryb2tlPSIjOTk5OTk5IiBzdHJva2Utd2lkdGg9IjIiIHBvaW50cz0iMTM5LjQ4LC04My44MzI5IDEzNS4yMjUsLTczLjcyNjEgMTM5LjEwMiwtNzguODIyMiAxMzkuMjI0LC03My44MjM3IDEzOS43MjQsLTczLjgzNTkgMTQwLjIyMywtNzMuODQ4MSAxNDAuMTAxLC03OC44NDY2IDE0NC4yMjIsLTczLjk0NTYgMTM5LjQ4LC04My44MzI5IDEzOS40OCwtODMuODMyOSIvPgo8L2c+CjwhLS0gamF2YS5hd3QuZ2VvbS5QYXRoMkQuRmxvYXQgLS0+CjxnIGlkPSJub2RlNCIgY2xhc3M9Im5vZGUiPjx0aXRsZT5qYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdDwvdGl0bGU+CjxnIGlkPSJhX25vZGU0Ij48YSB4bGluazpocmVmPSIuLi8uLi8uLi9qYXZhL2F3dC9nZW9tL0Zsb2F0Lmh0bWwiIHhsaW5rOnRpdGxlPSJqYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdCI+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjM2IiB5PSItMTAxLjQiIGZvbnQtZmFtaWx5PSJEZWphVnVTYW5zIiBmb250LXNpemU9IjEyLjAwIiBmaWxsPSIjZTc2ZjAwIj5GbG9hdDwvdGV4dD4KPC9hPgo8L2c+CjwvZz4KPCEtLSBqYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdCYjNDU7Jmd0O2phdmEuYXd0Lmdlb20uUGF0aDJEIC0tPgo8ZyBpZD0iZWRnZTMiIGNsYXNzPSJlZGdlIj48dGl0bGU+amF2YS5hd3QuZ2VvbS5QYXRoMkQuRmxvYXQmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRDwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzk5OTk5OSIgc3Ryb2tlLXdpZHRoPSIyIiBkPSJNNDguMzQ1NywtMTI1LjM1QzU0LjY3MjgsLTEzNS41MjMgNjIuNDg3NywtMTQ4LjA4OCA2OS40MzEzLC0xNTkuMjUyIi8+Cjxwb2x5Z29uIGZpbGw9IiM5OTk5OTkiIHN0cm9rZT0iIzk5OTk5OSIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludHM9Ijc0Ljc2OCwtMTY3LjgzMyA2NS42NjU0LC0xNjEuNzE4IDcxLjcwMjcsLTE2My44NTEgNjkuMDYyLC0xNTkuNjA1IDY5LjQ4NjYsLTE1OS4zNDEgNjkuOTExMiwtMTU5LjA3NyA3Mi41NTE5LC0xNjMuMzIzIDczLjMwNzgsLTE1Ni45NjUgNzQuNzY4LC0xNjcuODMzIDc0Ljc2OCwtMTY3LjgzMyIvPgo8L2c+CjwhLS0gb3BlbiBub2RlICMxIC0tPgo8ZyBpZD0ibm9kZTUiIGNsYXNzPSJub2RlIj48dGl0bGU+b3BlbiBub2RlICMxPC90aXRsZT4KPGcgaWQ9ImFfbm9kZTUiPjxhIHhsaW5rOnRpdGxlPSJOb24mIzQ1O3NlYWxlZCBIaWVyYXJjaHkiPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9IjE0IiB5PSItMTguNCIgZm9udC1mYW1pbHk9IkRlamFWdVNhbnMiIGZvbnQtc3R5bGU9Iml0YWxpYyIgZm9udC1zaXplPSIxMi4wMCIgZmlsbD0iI2U3NmYwMCI+Jmx0O2FueSZndDs8L3RleHQ+CjwvYT4KPC9nPgo8L2c+CjwhLS0gb3BlbiBub2RlICMxJiM0NTsmZ3Q7amF2YS5hd3QuZ2VvbS5QYXRoMkQuRmxvYXQgLS0+CjxnIGlkPSJlZGdlNCIgY2xhc3M9ImVkZ2UiPjx0aXRsZT5vcGVuIG5vZGUgIzEmIzQ1OyZndDtqYXZhLmF3dC5nZW9tLlBhdGgyRC5GbG9hdDwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzk5OTk5OSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtZGFzaGFycmF5PSI1LDIiIGQ9Ik0zNS4yNDIxLC00MS4zNDk5QzM1LjM2LC01MS4wMTkyIDM1LjUwNDMsLTYyLjg0OTggMzUuNjM1MiwtNzMuNTg0MyIvPgo8cG9seWdvbiBmaWxsPSIjOTk5OTk5IiBzdHJva2U9IiM5OTk5OTkiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRzPSIzNS43NjAyLC04My44MzI5IDMxLjEzODUsLTczLjg4ODUgMzUuMTk5MiwtNzguODM5NCAzNS4xMzgyLC03My44Mzk3IDM1LjYzODEsLTczLjgzMzYgMzYuMTM4MSwtNzMuODI3NSAzNi4xOTkxLC03OC44MjcyIDQwLjEzNzgsLTczLjc3ODcgMzUuNzYwMiwtODMuODMyOSAzNS43NjAyLC04My44MzI5Ii8+CjwvZz4KPC9nPgo8L3N2Zz4K"></span></a></dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section> <section class="summary"> <section class="nested-class-summary" id="nested-class-summary"> <h2>Nested Class Summary</h2>  <table class="summary-table three-column-summary">          <tr>
<th>Modifier and Type</th>
<th>Class</th>
<th>Description</th>
</tr>
<tr>
<td><code>static class </code></td>
<td><code><a href="path2d.double" class="type-name-link" title="class in java.awt.geom">Path2D.Double</a></code></td>
<td> <div class="block">The <code>Double</code> class defines a geometric path with coordinates stored in double precision floating point.</div> </td>
</tr>
<tr>
<td><code>static class </code></td>
<td><code><a href="path2d.float" class="type-name-link" title="class in java.awt.geom">Path2D.Float</a></code></td>
<td> <div class="block">The <code>Float</code> class defines a geometric path with coordinates stored in single precision floating point.</div> </td>
</tr>
</table> </section><section class="field-summary" id="field-summary"> <h2>Field Summary</h2>  <table class="summary-table three-column-summary">          <tr>
<th>Modifier and Type</th>
<th>Field</th>
<th>Description</th>
</tr>
<tr>
<td><code>static final int</code></td>
<td><code><a href="#WIND_EVEN_ODD" class="member-name-link">WIND_EVEN_ODD</a></code></td>
<td> <div class="block">An even-odd winding rule for determining the interior of a path.</div> </td>
</tr>
<tr>
<td><code>static final int</code></td>
<td><code><a href="#WIND_NON_ZERO" class="member-name-link">WIND_NON_ZERO</a></code></td>
<td> <div class="block">A non-zero winding rule for determining the interior of a path.</div> </td>
</tr>
</table> </section><section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                                           <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#append(java.awt.geom.PathIterator,boolean)" class="member-name-link">append</a><wbr>(<a href="pathiterator" title="interface in java.awt.geom">PathIterator</a> pi,
 boolean connect)</wbr></code></td>
<td> <div class="block">Appends the geometry of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> object to the path, possibly connecting the new geometry to the existing path segments with a line segment.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#append(java.awt.Shape,boolean)" class="member-name-link">append</a><wbr>(<a href="../shape" title="interface in java.awt">Shape</a> s,
 boolean connect)</wbr></code></td>
<td> <div class="block">Appends the geometry of the specified <code>Shape</code> object to the path, possibly connecting the new geometry to the existing path segments with a line segment.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a></code></td>
<td><code><a href="#clone()" class="member-name-link">clone</a>()</code></td>
<td> <div class="block">Creates a new object of the same class as this object.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#closePath()" class="member-name-link">closePath</a>()</code></td>
<td> <div class="block">Closes the current subpath by drawing a straight line back to the coordinates of the last <code>moveTo</code>.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#contains(double,double)" class="member-name-link">contains</a><wbr>(double x,
 double y)</wbr></code></td>
<td> <div class="block">Tests if the specified coordinates are inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness">definition of insideness</a>.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#contains(double,double,double,double)" class="member-name-link">contains</a><wbr>(double x,
 double y,
 double w,
 double h)</wbr></code></td>
<td> <div class="block">Tests if the interior of the <code>Shape</code> entirely contains the specified rectangular area.</div> </td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code><a href="#contains(java.awt.geom.PathIterator,double,double)" class="member-name-link">contains</a><wbr>(<a href="pathiterator" title="interface in java.awt.geom">PathIterator</a> pi,
 double x,
 double y)</wbr></code></td>
<td> <div class="block">Tests if the specified coordinates are inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>.</div> </td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code><a href="#contains(java.awt.geom.PathIterator,double,double,double,double)" class="member-name-link">contains</a><wbr>(<a href="pathiterator" title="interface in java.awt.geom">PathIterator</a> pi,
 double x,
 double y,
 double w,
 double h)</wbr></code></td>
<td> <div class="block">Tests if the specified rectangular area is entirely inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>.</div> </td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code><a href="#contains(java.awt.geom.PathIterator,java.awt.geom.Point2D)" class="member-name-link">contains</a><wbr>(<a href="pathiterator" title="interface in java.awt.geom">PathIterator</a> pi,
 <a href="point2d" title="class in java.awt.geom">Point2D</a> p)</wbr></code></td>
<td> <div class="block">Tests if the specified <a href="point2d" title="class in java.awt.geom"><code>Point2D</code></a> is inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>.</div> </td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code><a href="#contains(java.awt.geom.PathIterator,java.awt.geom.Rectangle2D)" class="member-name-link">contains</a><wbr>(<a href="pathiterator" title="interface in java.awt.geom">PathIterator</a> pi,
 <a href="rectangle2d" title="class in java.awt.geom">Rectangle2D</a> r)</wbr></code></td>
<td> <div class="block">Tests if the specified <a href="rectangle2d" title="class in java.awt.geom"><code>Rectangle2D</code></a> is entirely inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#contains(java.awt.geom.Point2D)" class="member-name-link">contains</a><wbr>(<a href="point2d" title="class in java.awt.geom">Point2D</a> p)</wbr></code></td>
<td> <div class="block">Tests if a specified <a href="point2d" title="class in java.awt.geom"><code>Point2D</code></a> is inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness"> definition of insideness</a>.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#contains(java.awt.geom.Rectangle2D)" class="member-name-link">contains</a><wbr>(<a href="rectangle2d" title="class in java.awt.geom">Rectangle2D</a> r)</wbr></code></td>
<td> <div class="block">Tests if the interior of the <code>Shape</code> entirely contains the specified <code>Rectangle2D</code>.</div> </td>
</tr>
<tr>
<td><code>final <a href="../shape" title="interface in java.awt">Shape</a></code></td>
<td><code><a href="#createTransformedShape(java.awt.geom.AffineTransform)" class="member-name-link">createTransformedShape</a><wbr>(<a href="affinetransform" title="class in java.awt.geom">AffineTransform</a> at)</wbr></code></td>
<td> <div class="block">Returns a new <code>Shape</code> representing a transformed version of this <code>Path2D</code>.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#curveTo(double,double,double,double,double,double)" class="member-name-link">curveTo</a><wbr>(double x1,
 double y1,
 double x2,
 double y2,
 double x3,
 double y3)</wbr></code></td>
<td> <div class="block">Adds a curved segment, defined by three new points, to the path by drawing a Bézier curve that intersects both the current coordinates and the specified coordinates <code>(x3,y3)</code>, using the specified points <code>(x1,y1)</code> and <code>(x2,y2)</code> as Bézier control points.</div> </td>
</tr>
<tr>
<td><code>final <a href="../rectangle" title="class in java.awt">Rectangle</a></code></td>
<td><code><a href="#getBounds()" class="member-name-link">getBounds</a>()</code></td>
<td> <div class="block">Returns an integer <a href="../rectangle" title="class in java.awt"><code>Rectangle</code></a> that completely encloses the <code>Shape</code>.</div> </td>
</tr>
<tr>
<td><code>final <a href="point2d" title="class in java.awt.geom">Point2D</a></code></td>
<td><code><a href="#getCurrentPoint()" class="member-name-link">getCurrentPoint</a>()</code></td>
<td> <div class="block">Returns the coordinates most recently added to the end of the path as a <a href="point2d" title="class in java.awt.geom"><code>Point2D</code></a> object.</div> </td>
</tr>
<tr>
<td><code>final <a href="pathiterator" title="interface in java.awt.geom">PathIterator</a></code></td>
<td><code><a href="#getPathIterator(java.awt.geom.AffineTransform,double)" class="member-name-link">getPathIterator</a><wbr>(<a href="affinetransform" title="class in java.awt.geom">AffineTransform</a> at,
 double flatness)</wbr></code></td>
<td> <div class="block">Returns an iterator object that iterates along the <code>Shape</code> boundary and provides access to a flattened view of the <code>Shape</code> outline geometry.</div> </td>
</tr>
<tr>
<td><code>final int</code></td>
<td><code><a href="#getWindingRule()" class="member-name-link">getWindingRule</a>()</code></td>
<td> <div class="block">Returns the fill style winding rule.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#intersects(double,double,double,double)" class="member-name-link">intersects</a><wbr>(double x,
 double y,
 double w,
 double h)</wbr></code></td>
<td> <div class="block">Tests if the interior of the <code>Shape</code> intersects the interior of a specified rectangular area.</div> </td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code><a href="#intersects(java.awt.geom.PathIterator,double,double,double,double)" class="member-name-link">intersects</a><wbr>(<a href="pathiterator" title="interface in java.awt.geom">PathIterator</a> pi,
 double x,
 double y,
 double w,
 double h)</wbr></code></td>
<td> <div class="block">Tests if the interior of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> intersects the interior of a specified set of rectangular coordinates.</div> </td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code><a href="#intersects(java.awt.geom.PathIterator,java.awt.geom.Rectangle2D)" class="member-name-link">intersects</a><wbr>(<a href="pathiterator" title="interface in java.awt.geom">PathIterator</a> pi,
 <a href="rectangle2d" title="class in java.awt.geom">Rectangle2D</a> r)</wbr></code></td>
<td> <div class="block">Tests if the interior of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> intersects the interior of a specified <a href="rectangle2d" title="class in java.awt.geom"><code>Rectangle2D</code></a>.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#intersects(java.awt.geom.Rectangle2D)" class="member-name-link">intersects</a><wbr>(<a href="rectangle2d" title="class in java.awt.geom">Rectangle2D</a> r)</wbr></code></td>
<td> <div class="block">Tests if the interior of the <code>Shape</code> intersects the interior of a specified <code>Rectangle2D</code>.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#lineTo(double,double)" class="member-name-link">lineTo</a><wbr>(double x,
 double y)</wbr></code></td>
<td> <div class="block">Adds a point to the path by drawing a straight line from the current coordinates to the new specified coordinates specified in double precision.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#moveTo(double,double)" class="member-name-link">moveTo</a><wbr>(double x,
 double y)</wbr></code></td>
<td> <div class="block">Adds a point to the path by moving to the specified coordinates specified in double precision.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#quadTo(double,double,double,double)" class="member-name-link">quadTo</a><wbr>(double x1,
 double y1,
 double x2,
 double y2)</wbr></code></td>
<td> <div class="block">Adds a curved segment, defined by two new points, to the path by drawing a Quadratic curve that intersects both the current coordinates and the specified coordinates <code>(x2,y2)</code>, using the specified point <code>(x1,y1)</code> as a quadratic parametric control point.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#reset()" class="member-name-link">reset</a>()</code></td>
<td> <div class="block">Resets the path to empty.</div> </td>
</tr>
<tr>
<td><code>final void</code></td>
<td><code><a href="#setWindingRule(int)" class="member-name-link">setWindingRule</a><wbr>(int rule)</wbr></code></td>
<td> <div class="block">Sets the winding rule for this path to the specified value.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#transform(java.awt.geom.AffineTransform)" class="member-name-link">transform</a><wbr>(<a href="affinetransform" title="class in java.awt.geom">AffineTransform</a> at)</wbr></code></td>
<td> <div class="block">Transforms the geometry of this path using the specified <a href="affinetransform" title="class in java.awt.geom"><code>AffineTransform</code></a>.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#trimToSize()" class="member-name-link">trimToSize</a>()</code></td>
<td> <div class="block">Trims the capacity of this Path2D instance to its current size.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a>
</h3> <code><a href="../../../../java.base/java/lang/object#equals(java.lang.Object)">equals</a>, <a href="../../../../java.base/java/lang/object#finalize()">finalize</a>, <a href="../../../../java.base/java/lang/object#getClass()">getClass</a>, <a href="../../../../java.base/java/lang/object#hashCode()">hashCode</a>, <a href="../../../../java.base/java/lang/object#notify()">notify</a>, <a href="../../../../java.base/java/lang/object#notifyAll()">notifyAll</a>, <a href="../../../../java.base/java/lang/object#toString()">toString</a>, <a href="../../../../java.base/java/lang/object#wait()">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long)">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long,int)">wait</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.awt.Shape">Methods declared in interface java.awt.<a href="../shape" title="interface in java.awt">Shape</a>
</h3> <code><a href="../shape#getBounds2D()">getBounds2D</a>, <a href="../shape#getPathIterator(java.awt.geom.AffineTransform)">getPathIterator</a></code>
</div> </section> </section> <section class="details"> <section class="field-details" id="field-detail"> <h2>Field Details</h2>  </section><section class="detail" id="WIND_EVEN_ODD"> <h3>WIND_EVEN_ODD</h3> <pre class="lang-java" data-language="java">public static final int WIND_EVEN_ODD</pre> <div class="block">An even-odd winding rule for determining the interior of a path.</div> <dl class="notes"> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="pathiterator#WIND_EVEN_ODD"><code>PathIterator.WIND_EVEN_ODD</code></a></li> <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/constant-values.html#java.awt.geom.Path2D.WIND_EVEN_ODD">Constant Field Values</a></li> </ul> </dd> </dl> </section><section class="detail" id="WIND_NON_ZERO"> <h3>WIND_NON_ZERO</h3> <pre class="lang-java" data-language="java">public static final int WIND_NON_ZERO</pre> <div class="block">A non-zero winding rule for determining the interior of a path.</div> <dl class="notes"> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="pathiterator#WIND_NON_ZERO"><code>PathIterator.WIND_NON_ZERO</code></a></li> <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/constant-values.html#java.awt.geom.Path2D.WIND_NON_ZERO">Constant Field Values</a></li> </ul> </dd> </dl> </section><section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="moveTo(double,double)"> <h3>moveTo</h3> <pre class="lang-java" data-language="java">public abstract void moveTo(double x, double y)</pre> <div class="block">Adds a point to the path by moving to the specified coordinates specified in double precision.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>x</code> - the specified X coordinate</dd> <dd>
<code>y</code> - the specified Y coordinate</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="lineTo(double,double)"> <h3>lineTo</h3> <pre class="lang-java" data-language="java">public abstract void lineTo(double x, double y)</pre> <div class="block">Adds a point to the path by drawing a straight line from the current coordinates to the new specified coordinates specified in double precision.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>x</code> - the specified X coordinate</dd> <dd>
<code>y</code> - the specified Y coordinate</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="quadTo(double,double,double,double)"> <h3>quadTo</h3> <pre class="lang-java" data-language="java">public abstract void quadTo(double x1, double y1, double x2, double y2)</pre> <div class="block">Adds a curved segment, defined by two new points, to the path by drawing a Quadratic curve that intersects both the current coordinates and the specified coordinates <code>(x2,y2)</code>, using the specified point <code>(x1,y1)</code> as a quadratic parametric control point. All coordinates are specified in double precision.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>x1</code> - the X coordinate of the quadratic control point</dd> <dd>
<code>y1</code> - the Y coordinate of the quadratic control point</dd> <dd>
<code>x2</code> - the X coordinate of the final end point</dd> <dd>
<code>y2</code> - the Y coordinate of the final end point</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="curveTo(double,double,double,double,double,double)"> <h3>curveTo</h3> <pre class="lang-java" data-language="java">public abstract void curveTo(double x1, double y1, double x2, double y2, double x3, double y3)</pre> <div class="block">Adds a curved segment, defined by three new points, to the path by drawing a Bézier curve that intersects both the current coordinates and the specified coordinates <code>(x3,y3)</code>, using the specified points <code>(x1,y1)</code> and <code>(x2,y2)</code> as Bézier control points. All coordinates are specified in double precision.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>x1</code> - the X coordinate of the first Bézier control point</dd> <dd>
<code>y1</code> - the Y coordinate of the first Bézier control point</dd> <dd>
<code>x2</code> - the X coordinate of the second Bézier control point</dd> <dd>
<code>y2</code> - the Y coordinate of the second Bézier control point</dd> <dd>
<code>x3</code> - the X coordinate of the final end point</dd> <dd>
<code>y3</code> - the Y coordinate of the final end point</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="closePath()"> <h3>closePath</h3> <pre class="lang-java" data-language="java">public final void closePath()</pre> <div class="block">Closes the current subpath by drawing a straight line back to the coordinates of the last <code>moveTo</code>. If the path is already closed then this method has no effect.</div> <dl class="notes"> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="append(java.awt.Shape,boolean)"> <h3>append</h3> <pre class="lang-java" data-language="java">public final void append(Shape s, boolean connect)</pre> <div class="block">Appends the geometry of the specified <code>Shape</code> object to the path, possibly connecting the new geometry to the existing path segments with a line segment. If the <code>connect</code> parameter is <code>true</code> and the path is not empty then any initial <code>moveTo</code> in the geometry of the appended <code>Shape</code> is turned into a <code>lineTo</code> segment. If the destination coordinates of such a connecting <code>lineTo</code> segment match the ending coordinates of a currently open subpath then the segment is omitted as superfluous. The winding rule of the specified <code>Shape</code> is ignored and the appended geometry is governed by the winding rule specified for this path.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> whose geometry is appended to this path</dd> <dd>
<code>connect</code> - a boolean to control whether or not to turn an initial <code>moveTo</code> segment into a <code>lineTo</code> segment to connect the new geometry to the existing path</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="append(java.awt.geom.PathIterator,boolean)"> <h3>append</h3> <pre class="lang-java" data-language="java">public abstract void append(PathIterator pi, boolean connect)</pre> <div class="block">Appends the geometry of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> object to the path, possibly connecting the new geometry to the existing path segments with a line segment. If the <code>connect</code> parameter is <code>true</code> and the path is not empty then any initial <code>moveTo</code> in the geometry of the appended <code>Shape</code> is turned into a <code>lineTo</code> segment. If the destination coordinates of such a connecting <code>lineTo</code> segment match the ending coordinates of a currently open subpath then the segment is omitted as superfluous. The winding rule of the specified <code>Shape</code> is ignored and the appended geometry is governed by the winding rule specified for this path.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>pi</code> - the <code>PathIterator</code> whose geometry is appended to this path</dd> <dd>
<code>connect</code> - a boolean to control whether or not to turn an initial <code>moveTo</code> segment into a <code>lineTo</code> segment to connect the new geometry to the existing path</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="getWindingRule()"> <h3>getWindingRule</h3> <pre class="lang-java" data-language="java">public final int getWindingRule()</pre> <div class="block">Returns the fill style winding rule.</div> <dl class="notes"> <dt>Returns:</dt> <dd>an integer representing the current winding rule.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#WIND_EVEN_ODD"><code>WIND_EVEN_ODD</code></a></li> <li><a href="#WIND_NON_ZERO"><code>WIND_NON_ZERO</code></a></li> <li><a href="#setWindingRule(int)"><code>setWindingRule(int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setWindingRule(int)"> <h3>setWindingRule</h3> <pre class="lang-java" data-language="java">public final void setWindingRule(int rule)</pre> <div class="block">Sets the winding rule for this path to the specified value.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>rule</code> - an integer representing the specified winding rule</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>rule</code> is not either <a href="#WIND_EVEN_ODD"><code>WIND_EVEN_ODD</code></a> or <a href="#WIND_NON_ZERO"><code>WIND_NON_ZERO</code></a>
</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#getWindingRule()"><code>getWindingRule()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getCurrentPoint()"> <h3>getCurrentPoint</h3> <pre class="lang-java" data-language="java">public final Point2D getCurrentPoint()</pre> <div class="block">Returns the coordinates most recently added to the end of the path as a <a href="point2d" title="class in java.awt.geom"><code>Point2D</code></a> object.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a <code>Point2D</code> object containing the ending coordinates of the path or <code>null</code> if there are no points in the path.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="reset()"> <h3>reset</h3> <pre class="lang-java" data-language="java">public final void reset()</pre> <div class="block">Resets the path to empty. The append position is set back to the beginning of the path and all coordinates and point types are forgotten.</div> <dl class="notes"> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="transform(java.awt.geom.AffineTransform)"> <h3>transform</h3> <pre class="lang-java" data-language="java">public abstract void transform(AffineTransform at)</pre> <div class="block">Transforms the geometry of this path using the specified <a href="affinetransform" title="class in java.awt.geom"><code>AffineTransform</code></a>. The geometry is transformed in place, which permanently changes the boundary defined by this object.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>at</code> - the <code>AffineTransform</code> used to transform the area</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="createTransformedShape(java.awt.geom.AffineTransform)"> <h3>createTransformedShape</h3> <pre class="lang-java" data-language="java">public final Shape createTransformedShape(AffineTransform at)</pre> <div class="block">Returns a new <code>Shape</code> representing a transformed version of this <code>Path2D</code>. Note that the exact type and coordinate precision of the return value is not specified for this method. The method will return a Shape that contains no less precision for the transformed geometry than this <code>Path2D</code> currently maintains, but it may contain no more precision either. If the tradeoff of precision vs. storage size in the result is important then the convenience constructors in the <a href="path2d.float#%3Cinit%3E(java.awt.Shape,java.awt.geom.AffineTransform)"><code>Path2D.Float</code></a> and <a href="path2d.double#%3Cinit%3E(java.awt.Shape,java.awt.geom.AffineTransform)"><code>Path2D.Double</code></a> subclasses should be used to make the choice explicit.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>at</code> - the <code>AffineTransform</code> used to transform a new <code>Shape</code>.</dd> <dt>Returns:</dt> <dd>a new <code>Shape</code>, transformed with the specified <code>AffineTransform</code>.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="getBounds()"> <h3>getBounds</h3> <pre class="lang-java" data-language="java">public final Rectangle getBounds()</pre> <div class="block">Returns an integer <a href="../rectangle" title="class in java.awt"><code>Rectangle</code></a> that completely encloses the <code>Shape</code>. Note that there is no guarantee that the returned <code>Rectangle</code> is the smallest bounding box that encloses the <code>Shape</code>, only that the <code>Shape</code> lies entirely within the indicated <code>Rectangle</code>. The returned <code>Rectangle</code> might also fail to completely enclose the <code>Shape</code> if the <code>Shape</code> overflows the limited range of the integer data type. The <code>getBounds2D</code> method generally returns a tighter bounding box due to its greater flexibility in representation. <p> Note that the <a href="../shape#def_insideness">definition of insideness</a> can lead to situations where points on the defining outline of the <code>shape</code> may not be considered contained in the returned <code>bounds</code> object, but only in cases where those points are also not considered contained in the original <code>shape</code>. </p> <p> If a <code>point</code> is inside the <code>shape</code> according to the <a href="../shape#contains(double,double)"><code>contains(point)</code></a> method, then it must be inside the returned <code>Rectangle</code> bounds object according to the <a href="../shape#contains(double,double)"><code>contains(point)</code></a> method of the <code>bounds</code>. Specifically: </p> <p> <code>shape.contains(x,y)</code> requires <code>bounds.contains(x,y)</code> </p> <p> If a <code>point</code> is not inside the <code>shape</code>, then it might still be contained in the <code>bounds</code> object: </p> <p> <code>bounds.contains(x,y)</code> does not imply <code>shape.contains(x,y)</code> </p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#getBounds()">getBounds</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Returns:</dt> <dd>an integer <code>Rectangle</code> that completely encloses the <code>Shape</code>.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="../shape#getBounds2D()"><code>Shape.getBounds2D()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="contains(java.awt.geom.PathIterator,double,double)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public static boolean contains(PathIterator pi, double x, double y)</pre> <div class="block">Tests if the specified coordinates are inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>. <p> This method provides a basic facility for implementors of the <a href="../shape" title="interface in java.awt"><code>Shape</code></a> interface to implement support for the <a href="../shape#contains(double,double)"><code>Shape.contains(double, double)</code></a> method.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>pi</code> - the specified <code>PathIterator</code>
</dd> <dd>
<code>x</code> - the specified X coordinate</dd> <dd>
<code>y</code> - the specified Y coordinate</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified coordinates are inside the specified <code>PathIterator</code>; <code>false</code> otherwise</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="contains(java.awt.geom.PathIterator,java.awt.geom.Point2D)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public static boolean contains(PathIterator pi, Point2D p)</pre> <div class="block">Tests if the specified <a href="point2d" title="class in java.awt.geom"><code>Point2D</code></a> is inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>. <p> This method provides a basic facility for implementors of the <a href="../shape" title="interface in java.awt"><code>Shape</code></a> interface to implement support for the <a href="../shape#contains(java.awt.geom.Point2D)"><code>Shape.contains(Point2D)</code></a> method.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>pi</code> - the specified <code>PathIterator</code>
</dd> <dd>
<code>p</code> - the specified <code>Point2D</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified coordinates are inside the specified <code>PathIterator</code>; <code>false</code> otherwise</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="contains(double,double)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public final boolean contains(double x, double y)</pre> <div class="block">Tests if the specified coordinates are inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness">definition of insideness</a>.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(double,double)">contains</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the specified X coordinate to be tested</dd> <dd>
<code>y</code> - the specified Y coordinate to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified coordinates are inside the <code>Shape</code> boundary; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="contains(java.awt.geom.Point2D)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public final boolean contains(Point2D p)</pre> <div class="block">Tests if a specified <a href="point2d" title="class in java.awt.geom"><code>Point2D</code></a> is inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness"> definition of insideness</a>.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(java.awt.geom.Point2D)">contains</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>p</code> - the specified <code>Point2D</code> to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified <code>Point2D</code> is inside the boundary of the <code>Shape</code>; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="contains(java.awt.geom.PathIterator,double,double,double,double)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public static boolean contains(PathIterator pi, double x, double y, double w, double h)</pre> <div class="block">Tests if the specified rectangular area is entirely inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>. <p> This method provides a basic facility for implementors of the <a href="../shape" title="interface in java.awt"><code>Shape</code></a> interface to implement support for the <a href="../shape#contains(double,double,double,double)"><code>Shape.contains(double, double, double, double)</code></a> method. </p>
<p> This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a <a href="#WIND_NON_ZERO"><code>WIND_NON_ZERO</code></a> winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>pi</code> - the specified <code>PathIterator</code>
</dd> <dd>
<code>x</code> - the specified X coordinate</dd> <dd>
<code>y</code> - the specified Y coordinate</dd> <dd>
<code>w</code> - the width of the specified rectangular area</dd> <dd>
<code>h</code> - the height of the specified rectangular area</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified <code>PathIterator</code> contains the specified rectangular area; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="contains(java.awt.geom.PathIterator,java.awt.geom.Rectangle2D)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public static boolean contains(PathIterator pi, Rectangle2D r)</pre> <div class="block">Tests if the specified <a href="rectangle2d" title="class in java.awt.geom"><code>Rectangle2D</code></a> is entirely inside the closed boundary of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a>. <p> This method provides a basic facility for implementors of the <a href="../shape" title="interface in java.awt"><code>Shape</code></a> interface to implement support for the <a href="../shape#contains(java.awt.geom.Rectangle2D)"><code>Shape.contains(Rectangle2D)</code></a> method. </p>
<p> This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a <a href="#WIND_NON_ZERO"><code>WIND_NON_ZERO</code></a> winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>pi</code> - the specified <code>PathIterator</code>
</dd> <dd>
<code>r</code> - a specified <code>Rectangle2D</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified <code>PathIterator</code> contains the specified <code>Rectangle2D</code>; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="contains(double,double,double,double)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public final boolean contains(double x, double y, double w, double h)</pre> <div class="block">Tests if the interior of the <code>Shape</code> entirely contains the specified rectangular area. All coordinates that lie inside the rectangular area must lie within the <code>Shape</code> for the entire rectangular area to be considered contained within the <code>Shape</code>. <p> The <code>Shape.contains()</code> method allows a <code>Shape</code> implementation to conservatively return <code>false</code> when: </p>
<ul> <li> the <code>intersect</code> method returns <code>true</code> and </li>
<li> the calculations to determine whether or not the <code>Shape</code> entirely contains the rectangular area are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>false</code> even though the <code>Shape</code> contains the rectangular area. The <a href="area" title="class in java.awt.geom"><code>Area</code></a> class performs more accurate geometric computations than most <code>Shape</code> objects and therefore can be used if a more precise answer is required. <p> This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a <a href="#WIND_NON_ZERO"><code>WIND_NON_ZERO</code></a> winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(double,double,double,double)">contains</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the X coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>y</code> - the Y coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>w</code> - the width of the specified rectangular area</dd> <dd>
<code>h</code> - the height of the specified rectangular area</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> entirely contains the specified rectangular area; <code>false</code> otherwise or, if the <code>Shape</code> contains the rectangular area and the <code>intersects</code> method returns <code>true</code> and the containment calculations would be too expensive to perform.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="area" title="class in java.awt.geom"><code>Area</code></a></li> <li><a href="../shape#intersects(double,double,double,double)"><code>Shape.intersects(double, double, double, double)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="contains(java.awt.geom.Rectangle2D)"> <h3>contains</h3> <pre class="lang-java" data-language="java">public final boolean contains(Rectangle2D r)</pre> <div class="block">Tests if the interior of the <code>Shape</code> entirely contains the specified <code>Rectangle2D</code>. The <code>Shape.contains()</code> method allows a <code>Shape</code> implementation to conservatively return <code>false</code> when: <ul> <li> the <code>intersect</code> method returns <code>true</code> and </li>
<li> the calculations to determine whether or not the <code>Shape</code> entirely contains the <code>Rectangle2D</code> are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>false</code> even though the <code>Shape</code> contains the <code>Rectangle2D</code>. The <a href="area" title="class in java.awt.geom"><code>Area</code></a> class performs more accurate geometric computations than most <code>Shape</code> objects and therefore can be used if a more precise answer is required. <p> This method object may conservatively return false in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such segments could lie entirely within the interior of the path if they are part of a path with a <a href="#WIND_NON_ZERO"><code>WIND_NON_ZERO</code></a> winding rule or if the segments are retraced in the reverse direction such that the two sets of segments cancel each other out without any exterior area falling between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(java.awt.geom.Rectangle2D)">contains</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>r</code> - The specified <code>Rectangle2D</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> entirely contains the <code>Rectangle2D</code>; <code>false</code> otherwise or, if the <code>Shape</code> contains the <code>Rectangle2D</code> and the <code>intersects</code> method returns <code>true</code> and the containment calculations would be too expensive to perform.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="../shape#contains(double,double,double,double)"><code>Shape.contains(double, double, double, double)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="intersects(java.awt.geom.PathIterator,double,double,double,double)"> <h3>intersects</h3> <pre class="lang-java" data-language="java">public static boolean intersects(PathIterator pi, double x, double y, double w, double h)</pre> <div class="block">Tests if the interior of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> intersects the interior of a specified set of rectangular coordinates. <p> This method provides a basic facility for implementors of the <a href="../shape" title="interface in java.awt"><code>Shape</code></a> interface to implement support for the <a href="../shape#intersects(double,double,double,double)"><code>Shape.intersects(double, double, double, double)</code></a> method. </p>
<p> This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>pi</code> - the specified <code>PathIterator</code>
</dd> <dd>
<code>x</code> - the specified X coordinate</dd> <dd>
<code>y</code> - the specified Y coordinate</dd> <dd>
<code>w</code> - the width of the specified rectangular coordinates</dd> <dd>
<code>h</code> - the height of the specified rectangular coordinates</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified <code>PathIterator</code> and the interior of the specified set of rectangular coordinates intersect each other; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="intersects(java.awt.geom.PathIterator,java.awt.geom.Rectangle2D)"> <h3>intersects</h3> <pre class="lang-java" data-language="java">public static boolean intersects(PathIterator pi, Rectangle2D r)</pre> <div class="block">Tests if the interior of the specified <a href="pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> intersects the interior of a specified <a href="rectangle2d" title="class in java.awt.geom"><code>Rectangle2D</code></a>. <p> This method provides a basic facility for implementors of the <a href="../shape" title="interface in java.awt"><code>Shape</code></a> interface to implement support for the <a href="../shape#intersects(java.awt.geom.Rectangle2D)"><code>Shape.intersects(Rectangle2D)</code></a> method. </p>
<p> This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>pi</code> - the specified <code>PathIterator</code>
</dd> <dd>
<code>r</code> - the specified <code>Rectangle2D</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified <code>PathIterator</code> and the interior of the specified <code>Rectangle2D</code> intersect each other; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="intersects(double,double,double,double)"> <h3>intersects</h3> <pre class="lang-java" data-language="java">public final boolean intersects(double x, double y, double w, double h)</pre> <div class="block">Tests if the interior of the <code>Shape</code> intersects the interior of a specified rectangular area. The rectangular area is considered to intersect the <code>Shape</code> if any point is contained in both the interior of the <code>Shape</code> and the specified rectangular area. <p> The <code>Shape.intersects()</code> method allows a <code>Shape</code> implementation to conservatively return <code>true</code> when: </p>
<ul> <li> there is a high probability that the rectangular area and the <code>Shape</code> intersect, but </li>
<li> the calculations to accurately determine this intersection are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>true</code> even though the rectangular area does not intersect the <code>Shape</code>. The <a href="area" title="class in java.awt.geom"><code>Area</code></a> class performs more accurate computations of geometric intersection than most <code>Shape</code> objects and therefore can be used if a more precise answer is required. <p> This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#intersects(double,double,double,double)">intersects</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the X coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>y</code> - the Y coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>w</code> - the width of the specified rectangular area</dd> <dd>
<code>h</code> - the height of the specified rectangular area</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> and the interior of the rectangular area intersect, or are both highly likely to intersect and intersection calculations would be too expensive to perform; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="area" title="class in java.awt.geom"><code>Area</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="intersects(java.awt.geom.Rectangle2D)"> <h3>intersects</h3> <pre class="lang-java" data-language="java">public final boolean intersects(Rectangle2D r)</pre> <div class="block">Tests if the interior of the <code>Shape</code> intersects the interior of a specified <code>Rectangle2D</code>. The <code>Shape.intersects()</code> method allows a <code>Shape</code> implementation to conservatively return <code>true</code> when: <ul> <li> there is a high probability that the <code>Rectangle2D</code> and the <code>Shape</code> intersect, but </li>
<li> the calculations to accurately determine this intersection are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>true</code> even though the <code>Rectangle2D</code> does not intersect the <code>Shape</code>. The <a href="area" title="class in java.awt.geom"><code>Area</code></a> class performs more accurate computations of geometric intersection than most <code>Shape</code> objects and therefore can be used if a more precise answer is required. <p> This method object may conservatively return true in cases where the specified rectangular area intersects a segment of the path, but that segment does not represent a boundary between the interior and exterior of the path. Such a case may occur if some set of segments of the path are retraced in the reverse direction such that the two sets of segments cancel each other out without any interior area between them. To determine whether segments represent true boundaries of the interior of the path would require extensive calculations involving all of the segments of the path and the winding rule and are thus beyond the scope of this implementation.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#intersects(java.awt.geom.Rectangle2D)">intersects</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>r</code> - the specified <code>Rectangle2D</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> and the interior of the specified <code>Rectangle2D</code> intersect, or are both highly likely to intersect and intersection calculations would be too expensive to perform; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="../shape#intersects(double,double,double,double)"><code>Shape.intersects(double, double, double, double)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getPathIterator(java.awt.geom.AffineTransform,double)"> <h3>getPathIterator</h3> <pre class="lang-java" data-language="java">public final PathIterator getPathIterator(AffineTransform at, double flatness)</pre> <div class="block">Returns an iterator object that iterates along the <code>Shape</code> boundary and provides access to a flattened view of the <code>Shape</code> outline geometry. <p> Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the iterator. </p>
<p> If an optional <code>AffineTransform</code> is specified, the coordinates returned in the iteration are transformed accordingly. </p>
<p> The amount of subdivision of the curved segments is controlled by the <code>flatness</code> parameter, which specifies the maximum distance that any point on the unflattened transformed curve can deviate from the returned flattened path segments. Note that a limit on the accuracy of the flattened path might be silently imposed, causing very small flattening parameters to be treated as larger values. This limit, if there is one, is defined by the particular implementation that is used. </p>
<p> Each call to this method returns a fresh <code>PathIterator</code> object that traverses the <code>Shape</code> object geometry independently from any other <code>PathIterator</code> objects in use at the same time. </p>
<p> It is recommended, but not guaranteed, that objects implementing the <code>Shape</code> interface isolate iterations that are in process from any changes that might occur to the original object's geometry during such iterations. </p>
<p> The iterator for this class is not multi-threaded safe, which means that this <code>Path2D</code> class does not guarantee that modifications to the geometry of this <code>Path2D</code> object do not affect any iterations of that geometry that are already in process.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../shape#getPathIterator(java.awt.geom.AffineTransform,double)">getPathIterator</a></code> in interface <code><a href="../shape" title="interface in java.awt">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>at</code> - an optional <code>AffineTransform</code> to be applied to the coordinates as they are returned in the iteration, or <code>null</code> if untransformed coordinates are desired</dd> <dd>
<code>flatness</code> - the maximum distance that the line segments used to approximate the curved segments are allowed to deviate from any point on the original curve</dd> <dt>Returns:</dt> <dd>a new <code>PathIterator</code> that independently traverses a flattened view of the geometry of the <code>Shape</code>.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl> </section><section class="detail" id="clone()"> <h3>clone</h3> <pre class="lang-java" data-language="java">public abstract Object clone()</pre> <div class="block">Creates a new object of the same class as this object.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../../../../java.base/java/lang/object#clone()">clone</a></code> in class <code><a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a clone of this instance.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/outofmemoryerror" title="class in java.lang">OutOfMemoryError</a></code> - if there is not enough memory.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="../../../../java.base/java/lang/cloneable" title="interface in java.lang"><code>Cloneable</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="trimToSize()"> <h3>trimToSize</h3> <pre class="lang-java" data-language="java">public abstract void trimToSize()</pre> <div class="block">Trims the capacity of this Path2D instance to its current size. An application can use this operation to minimize the storage of a path.</div> <dl class="notes"> <dt>Since:</dt> <dd>10</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
