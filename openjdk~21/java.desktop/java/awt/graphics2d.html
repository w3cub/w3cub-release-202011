
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Graphics2D - OpenJDK 21 - W3cubDocs</title>
  
  <meta name="description" content="Coordinates in device space usually refer to individual device pixels and are aligned on the infinitely thin gaps between these pixels. Some &hellip;">
  <meta name="keywords" content="class, graphics, d, openjdk, openjdk~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~21/java.desktop/java/awt/graphics2d.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/openjdk~21.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~21/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<h1 title="Class Graphics2D" class="title">Class Graphics2D</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../../../java.base/java/lang/object" title="class in java.lang">java.lang.Object</a> <div class="inheritance">
<a href="graphics" title="class in java.awt">java.awt.Graphics</a> <div class="inheritance">java.awt.Graphics2D</div> </div> </div> <section class="class-description" id="class-description">  <pre class="lang-java" data-language="java">public abstract class Graphics2D extends Graphics</pre> <div class="block">This <code>Graphics2D</code> class extends the <a href="graphics" title="class in java.awt"><code>Graphics</code></a> class to provide more sophisticated control over geometry, coordinate transformations, color management, and text layout. This is the fundamental class for rendering 2-dimensional shapes, text and images on the Java(tm) platform. <h2 id="coordinate-spaces-heading">Coordinate Spaces</h2> All coordinates passed to a <code>Graphics2D</code> object are specified in a device-independent coordinate system called User Space, which is used by applications. The <code>Graphics2D</code> object contains an <a href="geom/affinetransform" title="class in java.awt.geom"><code>AffineTransform</code></a> object as part of its rendering state that defines how to convert coordinates from user space to device-dependent coordinates in Device Space. <p> Coordinates in device space usually refer to individual device pixels and are aligned on the infinitely thin gaps between these pixels. Some <code>Graphics2D</code> objects can be used to capture rendering operations for storage into a graphics metafile for playback on a concrete device of unknown physical resolution at a later time. Since the resolution might not be known when the rendering operations are captured, the <code>Graphics2D Transform</code> is set up to transform user coordinates to a virtual device space that approximates the expected resolution of the target device. Further transformations might need to be applied at playback time if the estimate is incorrect. </p>
<p> Some of the operations performed by the rendering attribute objects occur in the device space, but all <code>Graphics2D</code> methods take user space coordinates. </p>
<p> Every <code>Graphics2D</code> object is associated with a target that defines where rendering takes place. A <a href="graphicsconfiguration" title="class in java.awt"><code>GraphicsConfiguration</code></a> object defines the characteristics of the rendering target, such as pixel format and resolution. The same rendering target is used throughout the life of a <code>Graphics2D</code> object. </p>
<p> When creating a <code>Graphics2D</code> object, the <code>GraphicsConfiguration</code> specifies the <a id="deftransform">default transform</a> for the target of the <code>Graphics2D</code> (a <a href="component" title="class in java.awt"><code>Component</code></a> or <a href="image" title="class in java.awt"><code>Image</code></a>). This default transform maps the user space coordinate system to screen and printer device coordinates such that the origin maps to the upper left hand corner of the target region of the device with increasing X coordinates extending to the right and increasing Y coordinates extending downward. The scaling of the default transform is set to identity for those devices that are close to 72 dpi, such as screen devices. The scaling of the default transform is set to approximately 72 user space coordinates per square inch for high resolution devices, such as printers. For image buffers, the default transform is the <code>Identity</code> transform. </p>
<h2 id="rendering-process-heading">Rendering Process</h2> The Rendering Process can be broken down into four phases that are controlled by the <code>Graphics2D</code> rendering attributes. The renderer can optimize many of these steps, either by caching the results for future calls, by collapsing multiple virtual steps into a single operation, or by recognizing various attributes as common simple cases that can be eliminated by modifying other parts of the operation. <p> The steps in the rendering process are: </p>
<ol> <li> Determine what to render. </li>
<li> Constrain the rendering operation to the current <code>Clip</code>. The <code>Clip</code> is specified by a <a href="shape" title="interface in java.awt"><code>Shape</code></a> in user space and is controlled by the program using the various clip manipulation methods of <code>Graphics</code> and <code>Graphics2D</code>. This <i>user clip</i> is transformed into device space by the current <code>Transform</code> and combined with the <i>device clip</i>, which is defined by the visibility of windows and device extents. The combination of the user clip and device clip defines the <i>composite clip</i>, which determines the final clipping region. The user clip is not modified by the rendering system to reflect the resulting composite clip. </li>
<li> Determine what colors to render. </li>
<li> Apply the colors to the destination drawing surface using the current <a href="composite" title="interface in java.awt"><code>Composite</code></a> attribute in the <code>Graphics2D</code> context. </li>
</ol> <br> The three types of rendering operations, along with details of each of their particular rendering processes are: <ol> <li> <b><a id="rendershape"><code>Shape</code> operations</a></b> <ol> <li> If the operation is a <code>draw(Shape)</code> operation, then the <a href="stroke#createStrokedShape(java.awt.Shape)"><code>createStrokedShape</code></a> method on the current <a href="stroke" title="interface in java.awt"><code>Stroke</code></a> attribute in the <code>Graphics2D</code> context is used to construct a new <code>Shape</code> object that contains the outline of the specified <code>Shape</code>. </li>
<li> The <code>Shape</code> is transformed from user space to device space using the current <code>Transform</code> in the <code>Graphics2D</code> context. </li>
<li> The outline of the <code>Shape</code> is extracted using the <a href="shape#getPathIterator(java.awt.geom.AffineTransform)"><code>getPathIterator</code></a> method of <code>Shape</code>, which returns a <a href="geom/pathiterator" title="interface in java.awt.geom"><code>PathIterator</code></a> object that iterates along the boundary of the <code>Shape</code>. </li>
<li> If the <code>Graphics2D</code> object cannot handle the curved segments that the <code>PathIterator</code> object returns then it can call the alternate <a href="shape#getPathIterator(java.awt.geom.AffineTransform,double)"><code>getPathIterator</code></a> method of <code>Shape</code>, which flattens the <code>Shape</code>. </li>
<li> The current <a href="paint" title="interface in java.awt"><code>Paint</code></a> in the <code>Graphics2D</code> context is queried for a <a href="paintcontext" title="interface in java.awt"><code>PaintContext</code></a>, which specifies the colors to render in device space. </li>
</ol> </li>
<li> <b><a id="rendertext">Text operations</a></b> <ol> <li> The following steps are used to determine the set of glyphs required to render the indicated <code>String</code>: <ol> <li> If the argument is a <code>String</code>, then the current <code>Font</code> in the <code>Graphics2D</code> context is asked to convert the Unicode characters in the <code>String</code> into a set of glyphs for presentation with whatever basic layout and shaping algorithms the font implements. </li>
<li> If the argument is an <a href="../../../java.base/java/text/attributedcharacteriterator" title="interface in java.text"><code>AttributedCharacterIterator</code></a>, the iterator is asked to convert itself to a <a href="font/textlayout" title="class in java.awt.font"><code>TextLayout</code></a> using its embedded font attributes. The <code>TextLayout</code> implements more sophisticated glyph layout algorithms that perform Unicode bi-directional layout adjustments automatically for multiple fonts of differing writing directions. </li>
<li> If the argument is a <a href="font/glyphvector" title="class in java.awt.font"><code>GlyphVector</code></a>, then the <code>GlyphVector</code> object already contains the appropriate font-specific glyph codes with explicit coordinates for the position of each glyph. </li>
</ol> </li>
<li> The current <code>Font</code> is queried to obtain outlines for the indicated glyphs. These outlines are treated as shapes in user space relative to the position of each glyph that was determined in step 1. </li>
<li> The character outlines are filled as indicated above under <a href="#rendershape"><code>Shape</code> operations</a>. </li>
<li> The current <code>Paint</code> is queried for a <code>PaintContext</code>, which specifies the colors to render in device space. </li>
</ol> </li>
<li> <b><a id="renderingimage"><code>Image</code> Operations</a></b> <ol> <li> The region of interest is defined by the bounding box of the source <code>Image</code>. This bounding box is specified in Image Space, which is the <code>Image</code> object's local coordinate system. </li>
<li> If an <code>AffineTransform</code> is passed to <a href="#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)"><code>drawImage(Image, AffineTransform, ImageObserver)</code></a>, the <code>AffineTransform</code> is used to transform the bounding box from image space to user space. If no <code>AffineTransform</code> is supplied, the bounding box is treated as if it is already in user space. </li>
<li> The bounding box of the source <code>Image</code> is transformed from user space into device space using the current <code>Transform</code>. Note that the result of transforming the bounding box does not necessarily result in a rectangular region in device space. </li>
<li> The <code>Image</code> object determines what colors to render, sampled according to the source to destination coordinate mapping specified by the current <code>Transform</code> and the optional image transform. </li>
</ol> </li>
</ol> <h2 id="default-rendering-attributes-heading">Default Rendering Attributes</h2> The default values for the <code>Graphics2D</code> rendering attributes are: <dl> <dt>
<i><code>Paint</code></i> </dt>
<dd>The color of the <code>Component</code>. </dd>
<dt>
<i><code>Font</code></i> </dt>
<dd>The <code>Font</code> of the <code>Component</code>. </dd>
<dt>
<i><code>Stroke</code></i> </dt>
<dd>A square pen with a linewidth of 1, no dashing, miter segment joins and square end caps. </dd>
<dt>
<i><code>Transform</code></i> </dt>
<dd>The <a href="graphicsconfiguration#getDefaultTransform()"><code>getDefaultTransform</code></a> for the <code>GraphicsConfiguration</code> of the <code>Component</code>. </dd>
<dt>
<i><code>Composite</code></i> </dt>
<dd>The <a href="alphacomposite#SRC_OVER"><code>AlphaComposite.SRC_OVER</code></a> rule. </dd>
<dt>
<i><code>Clip</code></i> </dt>
<dd>No rendering <code>Clip</code>, the output is clipped to the <code>Component</code>. </dd>
</dl> <h2 id="rendering-compatibility-issues-heading">Rendering Compatibility Issues</h2> The JDK(tm) 1.1 rendering model is based on a pixelization model that specifies that coordinates are infinitely thin, lying between the pixels. Drawing operations are performed using a one-pixel wide pen that fills the pixel below and to the right of the anchor point on the path. The JDK 1.1 rendering model is consistent with the capabilities of most of the existing class of platform renderers that need to resolve integer coordinates to a discrete pen that must fall completely on a specified number of pixels. <p> The Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers. A pen with a width of one pixel does not need to fall completely on pixel N as opposed to pixel N+1. The pen can fall partially on both pixels. It is not necessary to choose a bias direction for a wide pen since the blending that occurs along the pen traversal edges makes the sub-pixel position of the pen visible to the user. On the other hand, when antialiasing is turned off by setting the <a href="renderinghints#KEY_ANTIALIASING"><code>KEY_ANTIALIASING</code></a> hint key to the <a href="renderinghints#VALUE_ANTIALIAS_OFF"><code>VALUE_ANTIALIAS_OFF</code></a> hint value, the renderer might need to apply a bias to determine which pixel to modify when the pen is straddling a pixel boundary, such as when it is drawn along an integer coordinate in device space. While the capabilities of an antialiasing renderer make it no longer necessary for the rendering model to specify a bias for the pen, it is desirable for the antialiasing and non-antialiasing renderers to perform similarly for the common cases of drawing one-pixel wide horizontal and vertical lines on the screen. To ensure that turning on antialiasing by setting the <a href="renderinghints#KEY_ANTIALIASING"><code>KEY_ANTIALIASING</code></a> hint key to <a href="renderinghints#VALUE_ANTIALIAS_ON"><code>VALUE_ANTIALIAS_ON</code></a> does not cause such lines to suddenly become twice as wide and half as opaque, it is desirable to have the model specify a path for such lines so that they completely cover a particular set of pixels to help increase their crispness. </p>
<p> Java 2D API maintains compatibility with JDK 1.1 rendering behavior, such that legacy operations and existing renderer behavior is unchanged under Java 2D API. Legacy methods that map onto general <code>draw</code> and <code>fill</code> methods are defined, which clearly indicates how <code>Graphics2D</code> extends <code>Graphics</code> based on settings of <code>Stroke</code> and <code>Transform</code> attributes and rendering hints. The definition performs identically under default attribute settings. For example, the default <code>Stroke</code> is a <code>BasicStroke</code> with a width of 1 and no dashing and the default Transform for screen drawing is an Identity transform. </p>
<p> The following two rules provide predictable rendering behavior whether aliasing or antialiasing is being used. </p>
<ul> <li> Device coordinates are defined to be between device pixels which avoids any inconsistent results between aliased and antialiased rendering. If coordinates were defined to be at a pixel's center, some of the pixels covered by a shape, such as a rectangle, would only be half covered. With aliased rendering, the half covered pixels would either be rendered inside the shape or outside the shape. With anti-aliased rendering, the pixels on the entire edge of the shape would be half covered. On the other hand, since coordinates are defined to be between pixels, a shape like a rectangle would have no half covered pixels, whether or not it is rendered using antialiasing. </li>
<li> Lines and paths stroked using the <code>BasicStroke</code> object may be "normalized" to provide consistent rendering of the outlines when positioned at various points on the drawable and whether drawn with aliased or antialiased rendering. This normalization process is controlled by the <a href="renderinghints#KEY_STROKE_CONTROL"><code>KEY_STROKE_CONTROL</code></a> hint. The exact normalization algorithm is not specified, but the goals of this normalization are to ensure that lines are rendered with consistent visual appearance regardless of how they fall on the pixel grid and to promote more solid horizontal and vertical lines in antialiased mode so that they resemble their non-antialiased counterparts more closely. A typical normalization step might promote antialiased line endpoints to pixel centers to reduce the amount of blending or adjust the subpixel positioning of non-antialiased lines so that the floating point line widths round to even or odd pixel counts with equal likelihood. This process can move endpoints by up to half a pixel (usually towards positive infinity along both axes) to promote these consistent results. </li>
</ul> <p> The following definitions of general legacy methods perform identically to previously specified behavior under default attribute settings: </p>
<ul> <li> For <code>fill</code> operations, including <code>fillRect</code>, <code>fillRoundRect</code>, <code>fillOval</code>, <code>fillArc</code>, <code>fillPolygon</code>, and <code>clearRect</code>, <a href="#fill(java.awt.Shape)"><code>fill</code></a> can now be called with the desired <code>Shape</code>. For example, when filling a rectangle: <pre>
 fill(new Rectangle(x, y, w, h));
 </pre> is called. </li>
<li> Similarly, for draw operations, including <code>drawLine</code>, <code>drawRect</code>, <code>drawRoundRect</code>, <code>drawOval</code>, <code>drawArc</code>, <code>drawPolyline</code>, and <code>drawPolygon</code>, <a href="#draw(java.awt.Shape)"><code>draw</code></a> can now be called with the desired <code>Shape</code>. For example, when drawing a rectangle: <pre>
 draw(new Rectangle(x, y, w, h));
 </pre> is called. </li>
<li> The <code>draw3DRect</code> and <code>fill3DRect</code> methods were implemented in terms of the <code>drawLine</code> and <code>fillRect</code> methods in the <code>Graphics</code> class which would predicate their behavior upon the current <code>Stroke</code> and <code>Paint</code> objects in a <code>Graphics2D</code> context. This class overrides those implementations with versions that use the current <code>Color</code> exclusively, overriding the current <code>Paint</code> and which uses <code>fillRect</code> to describe the exact same behavior as the preexisting methods regardless of the setting of the current <code>Stroke</code>. </li>
</ul> The <code>Graphics</code> class defines only the <code>setColor</code> method to control the color to be painted. Since the Java 2D API extends the <code>Color</code> object to implement the new <code>Paint</code> interface, the existing <code>setColor</code> method is now a convenience method for setting the current <code>Paint</code> attribute to a <code>Color</code> object. <code>setColor(c)</code> is equivalent to <code>setPaint(c)</code>. <p> The <code>Graphics</code> class defines two methods for controlling how colors are applied to the destination. </p>
<ol> <li> The <code>setPaintMode</code> method is implemented as a convenience method to set the default <code>Composite</code>, equivalent to <code>setComposite(new AlphaComposite.SrcOver)</code>. </li>
<li> The <code>setXORMode(Color xorcolor)</code> method is implemented as a convenience method to set a special <code>Composite</code> object that ignores the <code>Alpha</code> components of source colors and sets the destination color to the value: <pre>
 dstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);
 </pre> </li>
</ol>
</div> <dl class="notes"> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="renderinghints" title="class in java.awt"><code>RenderingHints</code></a></li> </ul> </dd> </dl> </section> <section class="summary"> <section class="constructor-summary" id="constructor-summary"> <h2>Constructor Summary</h2>  <table class="summary-table three-column-summary">     <div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">Graphics2D</a>()</code></div>  <tr>
<th>Modifier</th>
<th>Constructor</th>
<th>Description</th>
</tr>
<tr>
<td><code>protected </code></td>
<td> <div class="block">Constructs a new <code>Graphics2D</code> object.</div> </td>
</tr>
</table> </section><section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                                                                         <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#addRenderingHints(java.util.Map)" class="member-name-link">addRenderingHints</a><wbr>(<a href="../../../java.base/java/util/map" title="interface in java.util">Map</a>&lt;?,<wbr>?&gt; hints)</wbr></wbr></code></td>
<td> <div class="block">Sets the values of an arbitrary number of preferences for the rendering algorithms.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#clip(java.awt.Shape)" class="member-name-link">clip</a><wbr>(<a href="shape" title="interface in java.awt">Shape</a> s)</wbr></code></td>
<td> <div class="block">Intersects the current <code>Clip</code> with the interior of the specified <code>Shape</code> and sets the <code>Clip</code> to the resulting intersection.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#draw(java.awt.Shape)" class="member-name-link">draw</a><wbr>(<a href="shape" title="interface in java.awt">Shape</a> s)</wbr></code></td>
<td> <div class="block">Strokes the outline of a <code>Shape</code> using the settings of the current <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#draw3DRect(int,int,int,int,boolean)" class="member-name-link">draw3DRect</a><wbr>(int x,
 int y,
 int width,
 int height,
 boolean raised)</wbr></code></td>
<td> <div class="block">Draws a 3-D highlighted outline of the specified rectangle.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawGlyphVector(java.awt.font.GlyphVector,float,float)" class="member-name-link">drawGlyphVector</a><wbr>(<a href="font/glyphvector" title="class in java.awt.font">GlyphVector</a> g,
 float x,
 float y)</wbr></code></td>
<td> <div class="block">Renders the text of the specified <a href="font/glyphvector" title="class in java.awt.font"><code>GlyphVector</code></a> using the <code>Graphics2D</code> context's rendering attributes.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)" class="member-name-link">drawImage</a><wbr>(<a href="image/bufferedimage" title="class in java.awt.image">BufferedImage</a> img,
 <a href="image/bufferedimageop" title="interface in java.awt.image">BufferedImageOp</a> op,
 int x,
 int y)</wbr></code></td>
<td> <div class="block">Renders a <code>BufferedImage</code> that is filtered with a <a href="image/bufferedimageop" title="interface in java.awt.image"><code>BufferedImageOp</code></a>.</div> </td>
</tr>
<tr>
<td><code>abstract boolean</code></td>
<td><code><a href="#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)" class="member-name-link">drawImage</a><wbr>(<a href="image" title="class in java.awt">Image</a> img,
 <a href="geom/affinetransform" title="class in java.awt.geom">AffineTransform</a> xform,
 <a href="image/imageobserver" title="interface in java.awt.image">ImageObserver</a> obs)</wbr></code></td>
<td> <div class="block">Renders an image, applying a transform from image space into user space before drawing.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform)" class="member-name-link">drawRenderableImage</a><wbr>(<a href="image/renderable/renderableimage" title="interface in java.awt.image.renderable">RenderableImage</a> img,
 <a href="geom/affinetransform" title="class in java.awt.geom">AffineTransform</a> xform)</wbr></code></td>
<td> <div class="block">Renders a <a href="image/renderable/renderableimage" title="interface in java.awt.image.renderable"><code>RenderableImage</code></a>, applying a transform from image space into user space before drawing.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform)" class="member-name-link">drawRenderedImage</a><wbr>(<a href="image/renderedimage" title="interface in java.awt.image">RenderedImage</a> img,
 <a href="geom/affinetransform" title="class in java.awt.geom">AffineTransform</a> xform)</wbr></code></td>
<td> <div class="block">Renders a <a href="image/renderedimage" title="interface in java.awt.image"><code>RenderedImage</code></a>, applying a transform from image space into user space before drawing.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawString(java.lang.String,float,float)" class="member-name-link">drawString</a><wbr>(<a href="../../../java.base/java/lang/string" title="class in java.lang">String</a> str,
 float x,
 float y)</wbr></code></td>
<td> <div class="block">Renders the text specified by the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawString(java.lang.String,int,int)" class="member-name-link">drawString</a><wbr>(<a href="../../../java.base/java/lang/string" title="class in java.lang">String</a> str,
 int x,
 int y)</wbr></code></td>
<td> <div class="block">Renders the text of the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawString(java.text.AttributedCharacterIterator,float,float)" class="member-name-link">drawString</a><wbr>(<a href="../../../java.base/java/text/attributedcharacteriterator" title="interface in java.text">AttributedCharacterIterator</a> iterator,
 float x,
 float y)</wbr></code></td>
<td> <div class="block">Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute" title="class in java.awt.font"><code>TextAttribute</code></a> class.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#drawString(java.text.AttributedCharacterIterator,int,int)" class="member-name-link">drawString</a><wbr>(<a href="../../../java.base/java/text/attributedcharacteriterator" title="interface in java.text">AttributedCharacterIterator</a> iterator,
 int x,
 int y)</wbr></code></td>
<td> <div class="block">Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute" title="class in java.awt.font"><code>TextAttribute</code></a> class.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#fill(java.awt.Shape)" class="member-name-link">fill</a><wbr>(<a href="shape" title="interface in java.awt">Shape</a> s)</wbr></code></td>
<td> <div class="block">Fills the interior of a <code>Shape</code> using the settings of the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#fill3DRect(int,int,int,int,boolean)" class="member-name-link">fill3DRect</a><wbr>(int x,
 int y,
 int width,
 int height,
 boolean raised)</wbr></code></td>
<td> <div class="block">Paints a 3-D highlighted rectangle filled with the current color.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="color" title="class in java.awt">Color</a></code></td>
<td><code><a href="#getBackground()" class="member-name-link">getBackground</a>()</code></td>
<td> <div class="block">Returns the background color used for clearing a region.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="composite" title="interface in java.awt">Composite</a></code></td>
<td><code><a href="#getComposite()" class="member-name-link">getComposite</a>()</code></td>
<td> <div class="block">Returns the current <code>Composite</code> in the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="graphicsconfiguration" title="class in java.awt">GraphicsConfiguration</a></code></td>
<td><code><a href="#getDeviceConfiguration()" class="member-name-link">getDeviceConfiguration</a>()</code></td>
<td> <div class="block">Returns the device configuration associated with this <code>Graphics2D</code>.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="font/fontrendercontext" title="class in java.awt.font">FontRenderContext</a></code></td>
<td><code><a href="#getFontRenderContext()" class="member-name-link">getFontRenderContext</a>()</code></td>
<td> <div class="block">Get the rendering context of the <code>Font</code> within this <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="paint" title="interface in java.awt">Paint</a></code></td>
<td><code><a href="#getPaint()" class="member-name-link">getPaint</a>()</code></td>
<td> <div class="block">Returns the current <code>Paint</code> of the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="../../../java.base/java/lang/object" title="class in java.lang">Object</a></code></td>
<td><code><a href="#getRenderingHint(java.awt.RenderingHints.Key)" class="member-name-link">getRenderingHint</a><wbr>(<a href="renderinghints.key" title="class in java.awt">RenderingHints.Key</a> hintKey)</wbr></code></td>
<td> <div class="block">Returns the value of a single preference for the rendering algorithms.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="renderinghints" title="class in java.awt">RenderingHints</a></code></td>
<td><code><a href="#getRenderingHints()" class="member-name-link">getRenderingHints</a>()</code></td>
<td> <div class="block">Gets the preferences for the rendering algorithms.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="stroke" title="interface in java.awt">Stroke</a></code></td>
<td><code><a href="#getStroke()" class="member-name-link">getStroke</a>()</code></td>
<td> <div class="block">Returns the current <code>Stroke</code> in the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="geom/affinetransform" title="class in java.awt.geom">AffineTransform</a></code></td>
<td><code><a href="#getTransform()" class="member-name-link">getTransform</a>()</code></td>
<td> <div class="block">Returns a copy of the current <code>Transform</code> in the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract boolean</code></td>
<td><code><a href="#hit(java.awt.Rectangle,java.awt.Shape,boolean)" class="member-name-link">hit</a><wbr>(<a href="rectangle" title="class in java.awt">Rectangle</a> rect,
 <a href="shape" title="interface in java.awt">Shape</a> s,
 boolean onStroke)</wbr></code></td>
<td> <div class="block">Checks whether or not the specified <code>Shape</code> intersects the specified <a href="rectangle" title="class in java.awt"><code>Rectangle</code></a>, which is in device space.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#rotate(double)" class="member-name-link">rotate</a><wbr>(double theta)</wbr></code></td>
<td> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a rotation transform.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#rotate(double,double,double)" class="member-name-link">rotate</a><wbr>(double theta,
 double x,
 double y)</wbr></code></td>
<td> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a translated rotation transform.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#scale(double,double)" class="member-name-link">scale</a><wbr>(double sx,
 double sy)</wbr></code></td>
<td> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a scaling transformation Subsequent rendering is resized according to the specified scaling factors relative to the previous scaling.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#setBackground(java.awt.Color)" class="member-name-link">setBackground</a><wbr>(<a href="color" title="class in java.awt">Color</a> color)</wbr></code></td>
<td> <div class="block">Sets the background color for the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#setComposite(java.awt.Composite)" class="member-name-link">setComposite</a><wbr>(<a href="composite" title="interface in java.awt">Composite</a> comp)</wbr></code></td>
<td> <div class="block">Sets the <code>Composite</code> for the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#setPaint(java.awt.Paint)" class="member-name-link">setPaint</a><wbr>(<a href="paint" title="interface in java.awt">Paint</a> paint)</wbr></code></td>
<td> <div class="block">Sets the <code>Paint</code> attribute for the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#setRenderingHint(java.awt.RenderingHints.Key,java.lang.Object)" class="member-name-link">setRenderingHint</a><wbr>(<a href="renderinghints.key" title="class in java.awt">RenderingHints.Key</a> hintKey,
 <a href="../../../java.base/java/lang/object" title="class in java.lang">Object</a> hintValue)</wbr></code></td>
<td> <div class="block">Sets the value of a single preference for the rendering algorithms.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#setRenderingHints(java.util.Map)" class="member-name-link">setRenderingHints</a><wbr>(<a href="../../../java.base/java/util/map" title="interface in java.util">Map</a>&lt;?,<wbr>?&gt; hints)</wbr></wbr></code></td>
<td> <div class="block">Replaces the values of all preferences for the rendering algorithms with the specified <code>hints</code>.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#setStroke(java.awt.Stroke)" class="member-name-link">setStroke</a><wbr>(<a href="stroke" title="interface in java.awt">Stroke</a> s)</wbr></code></td>
<td> <div class="block">Sets the <code>Stroke</code> for the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#setTransform(java.awt.geom.AffineTransform)" class="member-name-link">setTransform</a><wbr>(<a href="geom/affinetransform" title="class in java.awt.geom">AffineTransform</a> Tx)</wbr></code></td>
<td> <div class="block">Overwrites the Transform in the <code>Graphics2D</code> context.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#shear(double,double)" class="member-name-link">shear</a><wbr>(double shx,
 double shy)</wbr></code></td>
<td> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a shearing transform.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#transform(java.awt.geom.AffineTransform)" class="member-name-link">transform</a><wbr>(<a href="geom/affinetransform" title="class in java.awt.geom">AffineTransform</a> Tx)</wbr></code></td>
<td> <div class="block">Composes an <code>AffineTransform</code> object with the <code>Transform</code> in this <code>Graphics2D</code> according to the rule last-specified-first-applied.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#translate(double,double)" class="member-name-link">translate</a><wbr>(double tx,
 double ty)</wbr></code></td>
<td> <div class="block">Concatenates the current <code>Graphics2D Transform</code> with a translation transform.</div> </td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code><a href="#translate(int,int)" class="member-name-link">translate</a><wbr>(int x,
 int y)</wbr></code></td>
<td> <div class="block">Translates the origin of the <code>Graphics2D</code> context to the point (<i>x</i>, <i>y</i>) in the current coordinate system.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.awt.Graphics">Methods declared in class java.awt.<a href="graphics" title="class in java.awt">Graphics</a>
</h3> <code><a href="graphics#clearRect(int,int,int,int)">clearRect</a>, <a href="graphics#clipRect(int,int,int,int)">clipRect</a>, <a href="graphics#copyArea(int,int,int,int,int,int)">copyArea</a>, <a href="graphics#create()">create</a>, <a href="graphics#create(int,int,int,int)">create</a>, <a href="graphics#dispose()">dispose</a>, <a href="graphics#drawArc(int,int,int,int,int,int)">drawArc</a>, <a href="graphics#drawBytes(byte%5B%5D,int,int,int,int)">drawBytes</a>, <a href="graphics#drawChars(char%5B%5D,int,int,int,int)">drawChars</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawLine(int,int,int,int)">drawLine</a>, <a href="graphics#drawOval(int,int,int,int)">drawOval</a>, <a href="graphics#drawPolygon(int%5B%5D,int%5B%5D,int)">drawPolygon</a>, <a href="graphics#drawPolygon(java.awt.Polygon)">drawPolygon</a>, <a href="graphics#drawPolyline(int%5B%5D,int%5B%5D,int)">drawPolyline</a>, <a href="graphics#drawRect(int,int,int,int)">drawRect</a>, <a href="graphics#drawRoundRect(int,int,int,int,int,int)">drawRoundRect</a>, <a href="graphics#fillArc(int,int,int,int,int,int)">fillArc</a>, <a href="graphics#fillOval(int,int,int,int)">fillOval</a>, <a href="graphics#fillPolygon(int%5B%5D,int%5B%5D,int)">fillPolygon</a>, <a href="graphics#fillPolygon(java.awt.Polygon)">fillPolygon</a>, <a href="graphics#fillRect(int,int,int,int)">fillRect</a>, <a href="graphics#fillRoundRect(int,int,int,int,int,int)">fillRoundRect</a>, <a href="graphics#finalize()">finalize</a>, <a href="graphics#getClip()">getClip</a>, <a href="graphics#getClipBounds()">getClipBounds</a>, <a href="graphics#getClipBounds(java.awt.Rectangle)">getClipBounds</a>, <a href="graphics#getClipRect()">getClipRect</a>, <a href="graphics#getColor()">getColor</a>, <a href="graphics#getFont()">getFont</a>, <a href="graphics#getFontMetrics()">getFontMetrics</a>, <a href="graphics#getFontMetrics(java.awt.Font)">getFontMetrics</a>, <a href="graphics#hitClip(int,int,int,int)">hitClip</a>, <a href="graphics#setClip(int,int,int,int)">setClip</a>, <a href="graphics#setClip(java.awt.Shape)">setClip</a>, <a href="graphics#setColor(java.awt.Color)">setColor</a>, <a href="graphics#setFont(java.awt.Font)">setFont</a>, <a href="graphics#setPaintMode()">setPaintMode</a>, <a href="graphics#setXORMode(java.awt.Color)">setXORMode</a>, <a href="graphics#toString()">toString</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../../../java.base/java/lang/object" title="class in java.lang">Object</a>
</h3> <code><a href="../../../java.base/java/lang/object#clone()">clone</a>, <a href="../../../java.base/java/lang/object#equals(java.lang.Object)">equals</a>, <a href="../../../java.base/java/lang/object#getClass()">getClass</a>, <a href="../../../java.base/java/lang/object#hashCode()">hashCode</a>, <a href="../../../java.base/java/lang/object#notify()">notify</a>, <a href="../../../java.base/java/lang/object#notifyAll()">notifyAll</a>, <a href="../../../java.base/java/lang/object#wait()">wait</a>, <a href="../../../java.base/java/lang/object#wait(long)">wait</a>, <a href="../../../java.base/java/lang/object#wait(long,int)">wait</a></code>
</div> </section> </section> <section class="details"> <section class="constructor-details" id="constructor-detail"> <h2>Constructor Details</h2>  </section><section class="detail" id="&lt;init&gt;()"> <h3>Graphics2D</h3> <pre class="lang-java" data-language="java">protected Graphics2D()</pre> <div class="block">Constructs a new <code>Graphics2D</code> object. Since <code>Graphics2D</code> is an abstract class, and since it must be customized by subclasses for different output devices, <code>Graphics2D</code> objects cannot be created directly. Instead, <code>Graphics2D</code> objects must be obtained from another <code>Graphics2D</code> object, created by a <code>Component</code>, or obtained from images such as <a href="image/bufferedimage" title="class in java.awt.image"><code>BufferedImage</code></a> objects.</div> <dl class="notes"> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="component#getGraphics()"><code>Component.getGraphics()</code></a></li> <li><a href="graphics#create()"><code>Graphics.create()</code></a></li> </ul> </dd> </dl> </section><section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="draw3DRect(int,int,int,int,boolean)"> <h3>draw3DRect</h3> <pre class="lang-java" data-language="java">public void draw3DRect(int x, int y, int width, int height, boolean raised)</pre> <div class="block">Draws a 3-D highlighted outline of the specified rectangle. The edges of the rectangle are highlighted so that they appear to be beveled and lit from the upper left corner. <p> The colors used for the highlighting effect are determined based on the current color. The resulting rectangle covers an area that is <code>width + 1</code> pixels wide by <code>height + 1</code> pixels tall. This method uses the current <code>Color</code> exclusively and ignores the current <code>Paint</code>.</p>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="graphics#draw3DRect(int,int,int,int,boolean)">draw3DRect</a></code> in class <code><a href="graphics" title="class in java.awt">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the x coordinate of the rectangle to be drawn.</dd> <dd>
<code>y</code> - the y coordinate of the rectangle to be drawn.</dd> <dd>
<code>width</code> - the width of the rectangle to be drawn.</dd> <dd>
<code>height</code> - the height of the rectangle to be drawn.</dd> <dd>
<code>raised</code> - a boolean that determines whether the rectangle appears to be raised above the surface or sunk into the surface.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="graphics#fill3DRect(int,int,int,int,boolean)"><code>Graphics.fill3DRect(int, int, int, int, boolean)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="fill3DRect(int,int,int,int,boolean)"> <h3>fill3DRect</h3> <pre class="lang-java" data-language="java">public void fill3DRect(int x, int y, int width, int height, boolean raised)</pre> <div class="block">Paints a 3-D highlighted rectangle filled with the current color. The edges of the rectangle are highlighted so that it appears as if the edges were beveled and lit from the upper left corner. The colors used for the highlighting effect and for filling are determined from the current <code>Color</code>. This method uses the current <code>Color</code> exclusively and ignores the current <code>Paint</code>.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="graphics#fill3DRect(int,int,int,int,boolean)">fill3DRect</a></code> in class <code><a href="graphics" title="class in java.awt">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the x coordinate of the rectangle to be filled.</dd> <dd>
<code>y</code> - the y coordinate of the rectangle to be filled.</dd> <dd>
<code>width</code> - the width of the rectangle to be filled.</dd> <dd>
<code>height</code> - the height of the rectangle to be filled.</dd> <dd>
<code>raised</code> - a boolean value that determines whether the rectangle appears to be raised above the surface or etched into the surface.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="graphics#draw3DRect(int,int,int,int,boolean)"><code>Graphics.draw3DRect(int, int, int, int, boolean)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="draw(java.awt.Shape)"> <h3>draw</h3> <pre class="lang-java" data-language="java">public abstract void draw(Shape s)</pre> <div class="block">Strokes the outline of a <code>Shape</code> using the settings of the current <code>Graphics2D</code> context. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, <code>Composite</code> and <code>Stroke</code> attributes.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> to be rendered</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setStroke(java.awt.Stroke)"><code>setStroke(java.awt.Stroke)</code></a></li> <li><a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a></li> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)"> <h3>drawImage</h3> <pre class="lang-java" data-language="java">public abstract boolean drawImage(Image img, AffineTransform xform, ImageObserver obs)</pre> <div class="block">Renders an image, applying a transform from image space into user space before drawing. The transformation from user space into device space is done with the current <code>Transform</code> in the <code>Graphics2D</code>. The specified transformation is applied to the image before the transform attribute in the <code>Graphics2D</code> context is applied. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, and <code>Composite</code> attributes. Note that no rendering is done if the specified transform is noninvertible.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>img</code> - the specified image to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>xform</code> - the transformation from image space into user space</dd> <dd>
<code>obs</code> - the <a href="image/imageobserver" title="interface in java.awt.image"><code>ImageObserver</code></a> to be notified as more of the <code>Image</code> is converted</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the <code>Image</code> is fully loaded and completely rendered, or if it's null; <code>false</code> if the <code>Image</code> is still being loaded.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)"> <h3>drawImage</h3> <pre class="lang-java" data-language="java">public abstract void drawImage(BufferedImage img, BufferedImageOp op, int x, int y)</pre> <div class="block">Renders a <code>BufferedImage</code> that is filtered with a <a href="image/bufferedimageop" title="interface in java.awt.image"><code>BufferedImageOp</code></a>. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code> and <code>Composite</code> attributes. This is equivalent to: <pre>
 img1 = op.filter(img, null);
 drawImage(img1, new AffineTransform(1f,0f,0f,1f,x,y), null);
 </pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>img</code> - the specified <code>BufferedImage</code> to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>op</code> - the filter to be applied to the image before rendering</dd> <dd>
<code>x</code> - the x coordinate of the location in user space where the upper left corner of the image is rendered</dd> <dd>
<code>y</code> - the y coordinate of the location in user space where the upper left corner of the image is rendered</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform)"> <h3>drawRenderedImage</h3> <pre class="lang-java" data-language="java">public abstract void drawRenderedImage(RenderedImage img, AffineTransform xform)</pre> <div class="block">Renders a <a href="image/renderedimage" title="interface in java.awt.image"><code>RenderedImage</code></a>, applying a transform from image space into user space before drawing. The transformation from user space into device space is done with the current <code>Transform</code> in the <code>Graphics2D</code>. The specified transformation is applied to the image before the transform attribute in the <code>Graphics2D</code> context is applied. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, and <code>Composite</code> attributes. Note that no rendering is done if the specified transform is noninvertible.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>img</code> - the image to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>xform</code> - the transformation from image space into user space</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform)"> <h3>drawRenderableImage</h3> <pre class="lang-java" data-language="java">public abstract void drawRenderableImage(RenderableImage img, AffineTransform xform)</pre> <div class="block">Renders a <a href="image/renderable/renderableimage" title="interface in java.awt.image.renderable"><code>RenderableImage</code></a>, applying a transform from image space into user space before drawing. The transformation from user space into device space is done with the current <code>Transform</code> in the <code>Graphics2D</code>. The specified transformation is applied to the image before the transform attribute in the <code>Graphics2D</code> context is applied. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, and <code>Composite</code> attributes. Note that no rendering is done if the specified transform is noninvertible. <p> Rendering hints set on the <code>Graphics2D</code> object might be used in rendering the <code>RenderableImage</code>. If explicit control is required over specific hints recognized by a specific <code>RenderableImage</code>, or if knowledge of which hints are used is required, then a <code>RenderedImage</code> should be obtained directly from the <code>RenderableImage</code> and rendered using <a href="#drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform)"><code>drawRenderedImage</code></a>.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>img</code> - the image to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>xform</code> - the transformation from image space into user space</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> <li><a href="#drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform)"><code>drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawString(java.lang.String,int,int)"> <h3>drawString</h3> <pre class="lang-java" data-language="java">public abstract void drawString(String str, int x, int y)</pre> <div class="block">Renders the text of the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context. The baseline of the first character is at position (<i>x</i>, <i>y</i>) in the User Space. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, <code>Font</code> and <code>Composite</code> attributes. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="graphics#drawString(java.lang.String,int,int)">drawString</a></code> in class <code><a href="graphics" title="class in java.awt">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>str</code> - the string to be rendered</dd> <dd>
<code>x</code> - the x coordinate of the location where the <code>String</code> should be rendered</dd> <dd>
<code>y</code> - the y coordinate of the location where the <code>String</code> should be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>str</code> is <code>null</code>
</dd> <dt>Since:</dt> <dd>1.0</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="graphics#drawBytes(byte%5B%5D,int,int,int,int)"><code>Graphics.drawBytes(byte[], int, int, int, int)</code></a></li> <li><a href="graphics#drawChars(char%5B%5D,int,int,int,int)"><code>Graphics.drawChars(char[], int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawString(java.lang.String,float,float)"> <h3>drawString</h3> <pre class="lang-java" data-language="java">public abstract void drawString(String str, float x, float y)</pre> <div class="block">Renders the text specified by the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context. The baseline of the first character is at position (<i>x</i>, <i>y</i>) in the User Space. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, <code>Font</code> and <code>Composite</code> attributes. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>str</code> - the <code>String</code> to be rendered</dd> <dd>
<code>x</code> - the x coordinate of the location where the <code>String</code> should be rendered</dd> <dd>
<code>y</code> - the y coordinate of the location where the <code>String</code> should be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>str</code> is <code>null</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a></li> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> <li><a href="graphics#setFont(java.awt.Font)"><code>Graphics.setFont(java.awt.Font)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawString(java.text.AttributedCharacterIterator,int,int)"> <h3>drawString</h3> <pre class="lang-java" data-language="java">public abstract void drawString(AttributedCharacterIterator iterator, int x, int y)</pre> <div class="block">Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute" title="class in java.awt.font"><code>TextAttribute</code></a> class. <p> The baseline of the first character is at position (<i>x</i>, <i>y</i>) in User Space. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="graphics#drawString(java.text.AttributedCharacterIterator,int,int)">drawString</a></code> in class <code><a href="graphics" title="class in java.awt">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>iterator</code> - the iterator whose text is to be rendered</dd> <dd>
<code>x</code> - the x coordinate where the iterator's text is to be rendered</dd> <dd>
<code>y</code> - the y coordinate where the iterator's text is to be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>iterator</code> is <code>null</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a></li> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawString(java.text.AttributedCharacterIterator,float,float)"> <h3>drawString</h3> <pre class="lang-java" data-language="java">public abstract void drawString(AttributedCharacterIterator iterator, float x, float y)</pre> <div class="block">Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute" title="class in java.awt.font"><code>TextAttribute</code></a> class. <p> The baseline of the first character is at position (<i>x</i>, <i>y</i>) in User Space. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>iterator</code> - the iterator whose text is to be rendered</dd> <dd>
<code>x</code> - the x coordinate where the iterator's text is to be rendered</dd> <dd>
<code>y</code> - the y coordinate where the iterator's text is to be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>iterator</code> is <code>null</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a></li> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="drawGlyphVector(java.awt.font.GlyphVector,float,float)"> <h3>drawGlyphVector</h3> <pre class="lang-java" data-language="java">public abstract void drawGlyphVector(GlyphVector g, float x, float y)</pre> <div class="block">Renders the text of the specified <a href="font/glyphvector" title="class in java.awt.font"><code>GlyphVector</code></a> using the <code>Graphics2D</code> context's rendering attributes. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, and <code>Composite</code> attributes. The <code>GlyphVector</code> specifies individual glyphs from a <a href="font" title="class in java.awt"><code>Font</code></a>. The <code>GlyphVector</code> can also contain the glyph positions. This is the fastest way to render a set of characters to the screen.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>g</code> - the <code>GlyphVector</code> to be rendered</dd> <dd>
<code>x</code> - the x position in User Space where the glyphs should be rendered</dd> <dd>
<code>y</code> - the y position in User Space where the glyphs should be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>g</code> is <code>null</code>.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="font#createGlyphVector(java.awt.font.FontRenderContext,java.lang.String)"><code>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</code></a></li> <li><a href="font/glyphvector" title="class in java.awt.font"><code>GlyphVector</code></a></li> <li><a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a></li> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="fill(java.awt.Shape)"> <h3>fill</h3> <pre class="lang-java" data-language="java">public abstract void fill(Shape s)</pre> <div class="block">Fills the interior of a <code>Shape</code> using the settings of the <code>Graphics2D</code> context. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, and <code>Composite</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> to be filled</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a></li> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> <li><a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="hit(java.awt.Rectangle,java.awt.Shape,boolean)"> <h3>hit</h3> <pre class="lang-java" data-language="java">public abstract boolean hit(Rectangle rect, Shape s, boolean onStroke)</pre> <div class="block">Checks whether or not the specified <code>Shape</code> intersects the specified <a href="rectangle" title="class in java.awt"><code>Rectangle</code></a>, which is in device space. If <code>onStroke</code> is false, this method checks whether or not the interior of the specified <code>Shape</code> intersects the specified <code>Rectangle</code>. If <code>onStroke</code> is <code>true</code>, this method checks whether or not the <code>Stroke</code> of the specified <code>Shape</code> outline intersects the specified <code>Rectangle</code>. The rendering attributes taken into account include the <code>Clip</code>, <code>Transform</code>, and <code>Stroke</code> attributes.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>rect</code> - the area in device space to check for a hit</dd> <dd>
<code>s</code> - the <code>Shape</code> to check for a hit</dd> <dd>
<code>onStroke</code> - flag used to choose between testing the stroked or the filled shape. If the flag is <code>true</code>, the <code>Stroke</code> outline is tested. If the flag is <code>false</code>, the filled <code>Shape</code> is tested.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if there is a hit; <code>false</code> otherwise.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setStroke(java.awt.Stroke)"><code>setStroke(java.awt.Stroke)</code></a></li> <li><a href="#fill(java.awt.Shape)"><code>fill(java.awt.Shape)</code></a></li> <li><a href="#draw(java.awt.Shape)"><code>draw(java.awt.Shape)</code></a></li> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a></li> <li><a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getDeviceConfiguration()"> <h3>getDeviceConfiguration</h3> <pre class="lang-java" data-language="java">public abstract GraphicsConfiguration getDeviceConfiguration()</pre> <div class="block">Returns the device configuration associated with this <code>Graphics2D</code>.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the device configuration of this <code>Graphics2D</code>.</dd> </dl> </section><section class="detail" id="setComposite(java.awt.Composite)"> <h3>setComposite</h3> <pre class="lang-java" data-language="java">public abstract void setComposite(Composite comp)</pre> <div class="block">Sets the <code>Composite</code> for the <code>Graphics2D</code> context. The <code>Composite</code> is used in all drawing methods such as <code>drawImage</code>, <code>drawString</code>, <code>draw</code>, and <code>fill</code>. It specifies how new pixels are to be combined with the existing pixels on the graphics device during the rendering process. <p>If this <code>Graphics2D</code> context is drawing to a <code>Component</code> on the display screen and the <code>Composite</code> is a custom object rather than an instance of the <code>AlphaComposite</code> class, and if there is a security manager, its <code>checkPermission</code> method is called with an <code>AWTPermission("readDisplayPixels")</code> permission.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>comp</code> - the <code>Composite</code> object to be used for rendering</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/securityexception" title="class in java.lang">SecurityException</a></code> - if a custom <code>Composite</code> object is being used to render to the screen and a security manager is set and its <code>checkPermission</code> method does not allow the operation.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="graphics#setXORMode(java.awt.Color)"><code>Graphics.setXORMode(java.awt.Color)</code></a></li> <li><a href="graphics#setPaintMode()"><code>Graphics.setPaintMode()</code></a></li> <li><a href="#getComposite()"><code>getComposite()</code></a></li> <li><a href="alphacomposite" title="class in java.awt"><code>AlphaComposite</code></a></li> <li><a href="../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)"><code>SecurityManager.checkPermission(java.security.Permission)</code></a></li> <li><a href="awtpermission" title="class in java.awt"><code>AWTPermission</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setPaint(java.awt.Paint)"> <h3>setPaint</h3> <pre class="lang-java" data-language="java">public abstract void setPaint(Paint paint)</pre> <div class="block">Sets the <code>Paint</code> attribute for the <code>Graphics2D</code> context. Calling this method with a <code>null Paint</code> object does not have any effect on the current <code>Paint</code> attribute of this <code>Graphics2D</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>paint</code> - the <code>Paint</code> object to be used to generate color during the rendering process, or <code>null</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> <li><a href="#getPaint()"><code>getPaint()</code></a></li> <li><a href="gradientpaint" title="class in java.awt"><code>GradientPaint</code></a></li> <li><a href="texturepaint" title="class in java.awt"><code>TexturePaint</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setStroke(java.awt.Stroke)"> <h3>setStroke</h3> <pre class="lang-java" data-language="java">public abstract void setStroke(Stroke s)</pre> <div class="block">Sets the <code>Stroke</code> for the <code>Graphics2D</code> context.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Stroke</code> object to be used to stroke a <code>Shape</code> during the rendering process</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="basicstroke" title="class in java.awt"><code>BasicStroke</code></a></li> <li><a href="#getStroke()"><code>getStroke()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setRenderingHint(java.awt.RenderingHints.Key,java.lang.Object)"> <h3>setRenderingHint</h3> <pre class="lang-java" data-language="java">public abstract void setRenderingHint(RenderingHints.Key hintKey, Object hintValue)</pre> <div class="block">Sets the value of a single preference for the rendering algorithms. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>hintKey</code> - the key of the hint to be set.</dd> <dd>
<code>hintValue</code> - the value indicating preferences for the specified hint category.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#getRenderingHint(java.awt.RenderingHints.Key)"><code>getRenderingHint(RenderingHints.Key)</code></a></li> <li><a href="renderinghints" title="class in java.awt"><code>RenderingHints</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getRenderingHint(java.awt.RenderingHints.Key)"> <h3>getRenderingHint</h3> <pre class="lang-java" data-language="java">public abstract Object getRenderingHint(RenderingHints.Key hintKey)</pre> <div class="block">Returns the value of a single preference for the rendering algorithms. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>hintKey</code> - the key corresponding to the hint to get.</dd> <dt>Returns:</dt> <dd>an object representing the value for the specified hint key. Some of the keys and their associated values are defined in the <code>RenderingHints</code> class.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="renderinghints" title="class in java.awt"><code>RenderingHints</code></a></li> <li><a href="#setRenderingHint(java.awt.RenderingHints.Key,java.lang.Object)"><code>setRenderingHint(RenderingHints.Key, Object)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setRenderingHints(java.util.Map)"> <h3>setRenderingHints</h3> <pre class="lang-java" data-language="java">public abstract void setRenderingHints(Map&lt;?,?&gt; hints)</pre> <div class="block">Replaces the values of all preferences for the rendering algorithms with the specified <code>hints</code>. The existing values for all rendering hints are discarded and the new set of known hints and values are initialized from the specified <a href="../../../java.base/java/util/map" title="interface in java.util"><code>Map</code></a> object. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>hints</code> - the rendering hints to be set</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#getRenderingHints()"><code>getRenderingHints()</code></a></li> <li><a href="renderinghints" title="class in java.awt"><code>RenderingHints</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="addRenderingHints(java.util.Map)"> <h3>addRenderingHints</h3> <pre class="lang-java" data-language="java">public abstract void addRenderingHints(Map&lt;?,?&gt; hints)</pre> <div class="block">Sets the values of an arbitrary number of preferences for the rendering algorithms. Only values for the rendering hints that are present in the specified <code>Map</code> object are modified. All other preferences not present in the specified object are left unmodified. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>hints</code> - the rendering hints to be set</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="renderinghints" title="class in java.awt"><code>RenderingHints</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getRenderingHints()"> <h3>getRenderingHints</h3> <pre class="lang-java" data-language="java">public abstract RenderingHints getRenderingHints()</pre> <div class="block">Gets the preferences for the rendering algorithms. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Returns all of the hint key/value pairs that were ever specified in one operation. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a reference to an instance of <code>RenderingHints</code> that contains the current preferences.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="renderinghints" title="class in java.awt"><code>RenderingHints</code></a></li> <li><a href="#setRenderingHints(java.util.Map)"><code>setRenderingHints(Map)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="translate(int,int)"> <h3>translate</h3> <pre class="lang-java" data-language="java">public abstract void translate(int x, int y)</pre> <div class="block">Translates the origin of the <code>Graphics2D</code> context to the point (<i>x</i>, <i>y</i>) in the current coordinate system. Modifies the <code>Graphics2D</code> context so that its new origin corresponds to the point (<i>x</i>, <i>y</i>) in the <code>Graphics2D</code> context's former coordinate system. All coordinates used in subsequent rendering operations on this graphics context are relative to this new origin.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="graphics#translate(int,int)">translate</a></code> in class <code><a href="graphics" title="class in java.awt">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the specified x coordinate</dd> <dd>
<code>y</code> - the specified y coordinate</dd> <dt>Since:</dt> <dd>1.0</dd> </dl> </section><section class="detail" id="translate(double,double)"> <h3>translate</h3> <pre class="lang-java" data-language="java">public abstract void translate(double tx, double ty)</pre> <div class="block">Concatenates the current <code>Graphics2D Transform</code> with a translation transform. Subsequent rendering is translated by the specified distance relative to the previous position. This is equivalent to calling transform(T), where T is an <code>AffineTransform</code> represented by the following matrix: <pre>
          [   1    0    tx  ]
          [   0    1    ty  ]
          [   0    0    1   ]
 </pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>tx</code> - the distance to translate along the x-axis</dd> <dd>
<code>ty</code> - the distance to translate along the y-axis</dd> </dl> </section><section class="detail" id="rotate(double)"> <h3>rotate</h3> <pre class="lang-java" data-language="java">public abstract void rotate(double theta)</pre> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a rotation transform. Subsequent rendering is rotated by the specified radians relative to the previous origin. This is equivalent to calling <code>transform(R)</code>, where R is an <code>AffineTransform</code> represented by the following matrix: <pre>
          [   cos(theta)    -sin(theta)    0   ]
          [   sin(theta)     cos(theta)    0   ]
          [       0              0         1   ]
 </pre> Rotating with a positive angle theta rotates points on the positive x axis toward the positive y axis.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>theta</code> - the angle of rotation in radians</dd> </dl> </section><section class="detail" id="rotate(double,double,double)"> <h3>rotate</h3> <pre class="lang-java" data-language="java">public abstract void rotate(double theta, double x, double y)</pre> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a translated rotation transform. Subsequent rendering is transformed by a transform which is constructed by translating to the specified location, rotating by the specified radians, and translating back by the same amount as the original translation. This is equivalent to the following sequence of calls: <pre>
          translate(x, y);
          rotate(theta);
          translate(-x, -y);
 </pre> Rotating with a positive angle theta rotates points on the positive x axis toward the positive y axis.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>theta</code> - the angle of rotation in radians</dd> <dd>
<code>x</code> - the x coordinate of the origin of the rotation</dd> <dd>
<code>y</code> - the y coordinate of the origin of the rotation</dd> </dl> </section><section class="detail" id="scale(double,double)"> <h3>scale</h3> <pre class="lang-java" data-language="java">public abstract void scale(double sx, double sy)</pre> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a scaling transformation Subsequent rendering is resized according to the specified scaling factors relative to the previous scaling. This is equivalent to calling <code>transform(S)</code>, where S is an <code>AffineTransform</code> represented by the following matrix: <pre>
          [   sx   0    0   ]
          [   0    sy   0   ]
          [   0    0    1   ]
 </pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>sx</code> - the amount by which X coordinates in subsequent rendering operations are multiplied relative to previous rendering operations.</dd> <dd>
<code>sy</code> - the amount by which Y coordinates in subsequent rendering operations are multiplied relative to previous rendering operations.</dd> </dl> </section><section class="detail" id="shear(double,double)"> <h3>shear</h3> <pre class="lang-java" data-language="java">public abstract void shear(double shx, double shy)</pre> <div class="block">Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a shearing transform. Subsequent renderings are sheared by the specified multiplier relative to the previous position. This is equivalent to calling <code>transform(SH)</code>, where SH is an <code>AffineTransform</code> represented by the following matrix: <pre>
          [   1   shx   0   ]
          [  shy   1    0   ]
          [   0    0    1   ]
 </pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>shx</code> - the multiplier by which coordinates are shifted in the positive X axis direction as a function of their Y coordinate</dd> <dd>
<code>shy</code> - the multiplier by which coordinates are shifted in the positive Y axis direction as a function of their X coordinate</dd> </dl> </section><section class="detail" id="transform(java.awt.geom.AffineTransform)"> <h3>transform</h3> <pre class="lang-java" data-language="java">public abstract void transform(AffineTransform Tx)</pre> <div class="block">Composes an <code>AffineTransform</code> object with the <code>Transform</code> in this <code>Graphics2D</code> according to the rule last-specified-first-applied. If the current <code>Transform</code> is Cx, the result of composition with Tx is a new <code>Transform</code> Cx'. Cx' becomes the current <code>Transform</code> for this <code>Graphics2D</code>. Transforming a point p by the updated <code>Transform</code> Cx' is equivalent to first transforming p by Tx and then transforming the result by the original <code>Transform</code> Cx. In other words, Cx'(p) = Cx(Tx(p)). A copy of the Tx is made, if necessary, so further modifications to Tx do not affect rendering.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>Tx</code> - the <code>AffineTransform</code> object to be composed with the current <code>Transform</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="geom/affinetransform" title="class in java.awt.geom"><code>AffineTransform</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setTransform(java.awt.geom.AffineTransform)"> <h3>setTransform</h3> <pre class="lang-java" data-language="java">public abstract void setTransform(AffineTransform Tx)</pre> <div class="block">Overwrites the Transform in the <code>Graphics2D</code> context. WARNING: This method should <b>never</b> be used to apply a new coordinate transform on top of an existing transform because the <code>Graphics2D</code> might already have a transform that is needed for other purposes, such as rendering Swing components or applying a scaling transformation to adjust for the resolution of a printer. <p>To add a coordinate transform, use the <code>transform</code>, <code>rotate</code>, <code>scale</code>, or <code>shear</code> methods. The <code>setTransform</code> method is intended only for restoring the original <code>Graphics2D</code> transform after rendering, as shown in this example: </p>
<pre>
 // Get the current transform
 AffineTransform saveAT = g2.getTransform();
 // Perform transformation
 g2d.transform(...);
 // Render
 g2d.draw(...);
 // Restore original transform
 g2d.setTransform(saveAT);
 </pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>Tx</code> - the <code>AffineTransform</code> that was retrieved from the <code>getTransform</code> method</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#getTransform()"><code>getTransform()</code></a></li> <li><a href="geom/affinetransform" title="class in java.awt.geom"><code>AffineTransform</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getTransform()"> <h3>getTransform</h3> <pre class="lang-java" data-language="java">public abstract AffineTransform getTransform()</pre> <div class="block">Returns a copy of the current <code>Transform</code> in the <code>Graphics2D</code> context.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current <code>AffineTransform</code> in the <code>Graphics2D</code> context.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a></li> <li><a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getPaint()"> <h3>getPaint</h3> <pre class="lang-java" data-language="java">public abstract Paint getPaint()</pre> <div class="block">Returns the current <code>Paint</code> of the <code>Graphics2D</code> context.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current <code>Graphics2D Paint</code>, which defines a color or pattern.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a></li> <li><a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getComposite()"> <h3>getComposite</h3> <pre class="lang-java" data-language="java">public abstract Composite getComposite()</pre> <div class="block">Returns the current <code>Composite</code> in the <code>Graphics2D</code> context.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current <code>Graphics2D Composite</code>, which defines a compositing style.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setBackground(java.awt.Color)"> <h3>setBackground</h3> <pre class="lang-java" data-language="java">public abstract void setBackground(Color color)</pre> <div class="block">Sets the background color for the <code>Graphics2D</code> context. The background color is used for clearing a region. When a <code>Graphics2D</code> is constructed for a <code>Component</code>, the background color is inherited from the <code>Component</code>. Setting the background color in the <code>Graphics2D</code> context only affects the subsequent <code>clearRect</code> calls and not the background color of the <code>Component</code>. To change the background of the <code>Component</code>, use appropriate methods of the <code>Component</code>.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>color</code> - the background color that is used in subsequent calls to <code>clearRect</code>
</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="#getBackground()"><code>getBackground()</code></a></li> <li><a href="graphics#clearRect(int,int,int,int)"><code>Graphics.clearRect(int, int, int, int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getBackground()"> <h3>getBackground</h3> <pre class="lang-java" data-language="java">public abstract Color getBackground()</pre> <div class="block">Returns the background color used for clearing a region.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current <code>Graphics2D Color</code>, which defines the background color.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#setBackground(java.awt.Color)"><code>setBackground(java.awt.Color)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="getStroke()"> <h3>getStroke</h3> <pre class="lang-java" data-language="java">public abstract Stroke getStroke()</pre> <div class="block">Returns the current <code>Stroke</code> in the <code>Graphics2D</code> context.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the current <code>Graphics2D Stroke</code>, which defines the line style.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="#setStroke(java.awt.Stroke)"><code>setStroke(java.awt.Stroke)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="clip(java.awt.Shape)"> <h3>clip</h3> <pre class="lang-java" data-language="java">public abstract void clip(Shape s)</pre> <div class="block">Intersects the current <code>Clip</code> with the interior of the specified <code>Shape</code> and sets the <code>Clip</code> to the resulting intersection. The specified <code>Shape</code> is transformed with the current <code>Graphics2D</code> <code>Transform</code> before being intersected with the current <code>Clip</code>. This method is used to make the current <code>Clip</code> smaller. To make the <code>Clip</code> larger, use <code>setClip</code>. <p>The <i>user clip</i> modified by this method is independent of the clipping associated with device bounds and visibility. If no clip has previously been set, or if the clip has been cleared using <a href="graphics#setClip(java.awt.Shape)"><code>setClip</code></a> with a <code>null</code> argument, the specified <code>Shape</code> becomes the new user clip. </p>
<p>Since this method intersects the specified shape with the current clip, it will throw <code>NullPointerException</code> for a <code>null</code> shape unless the user clip is also <code>null</code>. So calling this method with a <code>null</code> argument is not recommended.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> to be intersected with the current <code>Clip</code>. This method updates the current <code>Clip</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if <code>s</code> is <code>null</code> and a user clip is currently set.</dd> </dl> </section><section class="detail" id="getFontRenderContext()"> <h3>getFontRenderContext</h3> <pre class="lang-java" data-language="java">public abstract FontRenderContext getFontRenderContext()</pre> <div class="block">Get the rendering context of the <code>Font</code> within this <code>Graphics2D</code> context. The <a href="font/fontrendercontext" title="class in java.awt.font"><code>FontRenderContext</code></a> encapsulates application hints such as anti-aliasing and fractional metrics, as well as target device specific information such as dots-per-inch. This information should be provided by the application when using objects that perform typographical formatting, such as <code>Font</code> and <code>TextLayout</code>. This information should also be provided by applications that perform their own layout and need accurate measurements of various characteristics of glyphs such as advance and line height when various rendering hints have been applied to the text rendering.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a reference to an instance of FontRenderContext.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="font/fontrendercontext" title="class in java.awt.font"><code>FontRenderContext</code></a></li> <li><a href="font#createGlyphVector(java.awt.font.FontRenderContext,java.lang.String)"><code>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</code></a></li> <li><a href="font/textlayout" title="class in java.awt.font"><code>TextLayout</code></a></li> </ul> </dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
