
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Api - Scala 2.13 Reflection - W3cubDocs</title>
  
  <meta name="description" content=" EXPERIMENTAL ">
  <meta name="keywords" content="package, scala, reflect, api, reflection, scala~2.13_reflection">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scala~2.13_reflection/scala/reflect/api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/scala~2.13_reflection.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scala~2.13_reflection/" class="_nav-link" title="" style="margin-left:0;">Scala 2.13 Reflection</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _scala">
				
				
<h1>Package scala.reflect.api</h1>
<h2 id="signature">
<span class="modifier_kind"> <span class="kind">package</span></span> <span class="symbol"><span class="name">api</span></span>
</h2>
<div id="comment" class="fullcommenttop">
<div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>The Scala Reflection API (located in scala-reflect.jar).</p>
<p>In Scala 2.10.0, the Scala Reflection API and its implementation have an "experimental" status. This means that the API and the docs are not complete and can be changed in binary- and source-incompatible manner in 2.10.1. This also means that the implementation has some known issues.</p>
<p>The following types are the backbone of the Scala Reflection API, and serve as a good starting point for information about Scala Reflection:</p>
<ul>
<li><a href="symbols" name="scala.reflect.api.Symbols" id="scala.reflect.api.Symbols" class="extype">scala.reflect.api.Symbols</a></li>
<li><a href="types" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a></li>
<li><a href="mirrors" name="scala.reflect.api.Mirrors" id="scala.reflect.api.Mirrors" class="extype">scala.reflect.api.Mirrors</a></li>
<li><a href="universe" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a></li>
</ul>
<p> For more information about Scala Reflection, see the <a href="http://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a> </p>
</div>
<dl class="attributes block">
<dt>Source</dt>
<dd><a href="https://github.com/scala/scala/tree/v2.13.0/src/reflect/scala/reflect/api/package.scala#L52" target="_blank">package.scala</a></dd>
<dt>Linear Supertypes</dt>
<dd>
<a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a>, <span name="scala.Any" class="extype">Any</span>
</dd>
</dl>

</div>
<div id="template"><div id="allMembers"><div id="types" class="types members">
<h2>Type Members</h2>
<h3 id="scala.reflect.api.Annotations">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="annotations" title="EXPERIMENTAL"><span class="name">Annotations</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> This trait provides annotation support for the reflection API.</p>
<p> In Scala, annotations belong to one of the two categories:</p>
<ul>

<i>Java annotations</i>: annotations on definitions produced by the Java compiler, i.e., subtypes of <span name="java.lang.annotation.Annotation" class="extype">java.lang.annotation.Annotation</span> attached to program definitions.
<i>Scala annotations</i>: annotations on definitions or types produced by the Scala compiler.</ul>
<p> When a Scala annotation that inherits from <span name="scala.annotation.StaticAnnotation" class="extype">scala.annotation.StaticAnnotation</span> is compiled, it is stored as special attributes in the corresponding classfile, and not as a Java annotation. Note that subclassing just <span name="scala.annotation.Annotation" class="extype">scala.annotation.Annotation</span> is not enough to have the corresponding metadata persisted for runtime reflection.</p>
<p> Both Java and Scala annotations are represented as typed trees carrying constructor invocations corresponding to the annotation. For instance, the annotation in <code>@ann(1, 2) class C</code> is represented as <code>q"@new ann(1, 2)"</code>.</p>
<p> Unlike Java reflection, Scala reflection does not support evaluation of constructor invocations stored in annotations into underlying objects. For instance it's impossible to go from <code>@ann(1, 2) class C</code> to <code>ann(1, 2)</code>, so one has to analyze trees representing annotation arguments to manually extract corresponding values. Towards that end, arguments of an annotation can be obtained via <code>annotation.tree.children.tail</code>.</p>
<p> For more information about <code>Annotation</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html" target="_blank">Reflection Guide: Annotations, Names, Scopes, and More</a> </p>
</div></div>
<h3 id="scala.reflect.api.Constants">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="constants" title="EXPERIMENTAL"><span class="name">Constants</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> According to the section 6.24 "Constant Expressions" of the Scala language specification, certain expressions (dubbed <i>constant expressions</i>) can be evaluated by the Scala compiler at compile-time.</p>
<p> <a href="constants%24constant" name="scala.reflect.api.Constants.Constant" id="scala.reflect.api.Constants.Constant" class="extype">scala.reflect.api.Constants#Constant</a> instances represent certain kinds of these expressions (with values stored in the <code>value</code> field and its strongly-typed views named <code>booleanValue</code>, <code>intValue</code> etc.), namely:</p>
<ol class="decimal">
Literals of primitive value classes (bytes, shorts, ints, longs, floats, doubles, chars, booleans and voids).String literals.References to classes (typically constructed with <span name="scala.Predef#classOf" class="extype">scala.Predef#classOf</span>).References to enumeration values.</ol>
<p> Such constants are used to represent literals in abstract syntax trees (the <a href="trees%24literal" name="scala.reflect.api.Trees.Literal" id="scala.reflect.api.Trees.Literal" class="extype">scala.reflect.api.Trees#Literal</a> node) and literal arguments for Java class file annotations (the <span name="scala.reflect.api.Annotations#LiteralArgument" class="extype">scala.reflect.api.Annotations#LiteralArgument</span> class).</p>
<h5> Example </h5>
<p> The <code>value</code> field deserves some explanation. Primitive and string values are represented as themselves, whereas references to classes and enums are a bit roundabout.</p>
<p> Class references are represented as instances of <a href="types%24type" name="scala.reflect.api.Types.Type" id="scala.reflect.api.Types.Type" class="extype">scala.reflect.api.Types#Type</a> (because when the Scala compiler processes a class reference, the underlying runtime class might not yet have been compiled). To convert such a reference to a runtime class, one should use the <code>runtimeClass</code> method of a mirror such as <a href="mirrors%24runtimemirror" name="scala.reflect.api.Mirrors.RuntimeMirror" id="scala.reflect.api.Mirrors.RuntimeMirror" class="extype">scala.reflect.api.Mirrors#RuntimeMirror</a> (the simplest way to get such a mirror is using <a href="../runtime/index#currentMirror:scala.reflect.runtime.package.universe.Mirror" name="scala.reflect.runtime#currentMirror" id="scala.reflect.runtime#currentMirror" class="extmbr">scala.reflect.runtime.package#currentMirror</a>).</p>
<p> Enumeration value references are represented as instances of <a href="symbols%24symbol" name="scala.reflect.api.Symbols.Symbol" id="scala.reflect.api.Symbols.Symbol" class="extype">scala.reflect.api.Symbols#Symbol</a>, which on JVM point to methods that return underlying enum values. To inspect an underlying enumeration or to get runtime value of a reference to an enum, one should use a <a href="mirrors%24runtimemirror" name="scala.reflect.api.Mirrors.RuntimeMirror" id="scala.reflect.api.Mirrors.RuntimeMirror" class="extype">scala.reflect.api.Mirrors#RuntimeMirror</a> (the simplest way to get such a mirror is again <a href="../runtime/index#currentMirror:scala.reflect.runtime.package.universe.Mirror" name="scala.reflect.runtime#currentMirror" id="scala.reflect.runtime#currentMirror" class="extmbr">scala.reflect.runtime.package#currentMirror</a>).</p>
<pre data-language="scala">enum JavaSimpleEnumeration { FOO, BAR }

import java.lang.annotation.*;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface JavaSimpleAnnotation {
  Class&lt;?&gt; classRef();
  JavaSimpleEnumeration enumRef();
}

@JavaSimpleAnnotation(
  classRef = JavaAnnottee.class,
  enumRef = JavaSimpleEnumeration.BAR
)
public class JavaAnnottee {}</pre>
<pre data-language="scala">import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror =&gt; cm}

object Test extends App {
  val jann = typeOf[JavaAnnottee].typeSymbol.annotations(0).javaArgs
  def jarg(name: String) = jann(TermName(name)).asInstanceOf[LiteralArgument].value

  val classRef = jarg("classRef").typeValue
  println(showRaw(classRef))             // TypeRef(ThisType(&lt;empty&gt;), JavaAnnottee, List())
  println(cm.runtimeClass(classRef))     // class JavaAnnottee

  val enumRef = jarg("enumRef").symbolValue
  println(enumRef)                       // value BAR

  val siblings = enumRef.owner.info.decls
  val enumValues = siblings.filter(sym =&gt; sym.isVal &amp;&amp; sym.isPublic)
  println(enumValues)                    // Scope{
                                         //   final val FOO: JavaSimpleEnumeration;
                                         //   final val BAR: JavaSimpleEnumeration
                                         // }

  // doesn't work because of https://github.com/scala/bug/issues/6459
  // val enumValue = mirror.reflectField(enumRef.asTerm).get
  val enumClass = cm.runtimeClass(enumRef.owner.asClass)
  val enumValue = enumClass.getDeclaredField(enumRef.name.toString).get(null)
  println(enumValue)                     // BAR
}</pre>
</div></div>
<h3 id="scala.reflect.api.Exprs">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="exprs" title="EXPERIMENTAL"><span class="name">Exprs</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>A trait that defines strongly-typed tree wrappers and operations on them for use in Scala Reflection.</p>
<p> <code>Expr</code> wraps an abstract syntax tree (<a href="trees%24tree" name="scala.reflect.api.Trees.Tree" id="scala.reflect.api.Trees.Tree" class="extype">scala.reflect.api.Trees#Tree</a>) and tags it with its type (<a href="types%24type" name="scala.reflect.api.Types.Type" id="scala.reflect.api.Types.Type" class="extype">scala.reflect.api.Types#Type</a>).</p>
<p> Usually <code>Expr</code>s are created via <a href="universe#reify%5BT%5D(expr:T):Universe.this.Expr%5BT%5D" name="scala.reflect.api.Universe#reify" id="scala.reflect.api.Universe#reify" class="extmbr">scala.reflect.api.Universe#reify</a>, in which case a compiler produces a <a href="treecreator" name="scala.reflect.api.TreeCreator" id="scala.reflect.api.TreeCreator" class="extype">scala.reflect.api.TreeCreator</a> for the provided expression and also creates a complementary <a href="typetags%24weaktypetag" name="scala.reflect.api.TypeTags.WeakTypeTag" id="scala.reflect.api.TypeTags.WeakTypeTag" class="extype">scala.reflect.api.TypeTags#WeakTypeTag</a> that corresponds to the type of that expression.</p>
<p><code>Expr</code>s can also be created manually via the <code>Expr</code> companion object, but then the burden of providing a <code>TreeCreator</code> lies on the programmer. Compile-time reflection via macros, as described in <a href="../macros/aliases" name="scala.reflect.macros.Aliases" id="scala.reflect.macros.Aliases" class="extype">scala.reflect.macros.Aliases</a>, provides an easier way to instantiate exprs manually. Manual creation, however, is very rarely needed when working with runtime reflection.</p>
<p> <code>Expr</code> can be migrated from one mirror to another by using the <code>in</code> method. Migration means that all symbolic references to classes/objects/packages in the expression are re-resolved within the new mirror (typically using that mirror's classloader). The default universe of an <code>Expr</code> is typically <a href="../runtime/index#universe:scala.reflect.api.JavaUniverse" name="scala.reflect.runtime#universe" id="scala.reflect.runtime#universe" class="extmbr">scala.reflect.runtime#universe</a>, the default mirror is typically <a href="../runtime/index#currentMirror:scala.reflect.runtime.package.universe.Mirror" name="scala.reflect.runtime#currentMirror" id="scala.reflect.runtime#currentMirror" class="extmbr">scala.reflect.runtime#currentMirror</a>. </p>
</div></div>
<h3 id="scala.reflect.api.FlagSets">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="flagsets" title="EXPERIMENTAL"><span class="name">FlagSets</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>The trait that defines flag sets and operations on them.</p>
<p><code>Flag</code>s are used to provide modifiers for abstract syntax trees that represent definitions via the <code>flags</code> field of <a href="#" name="scala.reflect.api.Trees.Modifiers" id="scala.reflect.api.Trees.Modifiers" class="extmbr">scala.reflect.api.Trees#Modifiers</a>. Trees that accept modifiers are:</p>
<ul>

<b><a href="trees%24classdef" name="scala.reflect.api.Trees.ClassDef" id="scala.reflect.api.Trees.ClassDef" class="extype">scala.reflect.api.Trees#ClassDef</a></b>. Classes and traits.
<b><a href="trees%24moduledef" name="scala.reflect.api.Trees.ModuleDef" id="scala.reflect.api.Trees.ModuleDef" class="extype">scala.reflect.api.Trees#ModuleDef</a></b>. Objects.
<b><a href="trees%24valdef" name="scala.reflect.api.Trees.ValDef" id="scala.reflect.api.Trees.ValDef" class="extype">scala.reflect.api.Trees#ValDef</a></b>. Vals, vars, parameters and self-type annotations.
<b><a href="trees%24defdef" name="scala.reflect.api.Trees.DefDef" id="scala.reflect.api.Trees.DefDef" class="extype">scala.reflect.api.Trees#DefDef</a></b>. Methods and constructors.
<b><a href="trees%24typedef" name="scala.reflect.api.Trees.TypeDef" id="scala.reflect.api.Trees.TypeDef" class="extype">scala.reflect.api.Trees#TypeDef</a></b>. Type aliases, abstract type members and type parameters.</ul>
<p>For example, to create a class named <code>C</code> one would write something like:</p>
<pre data-language="scala">ClassDef(Modifiers(NoFlags), TypeName("C"), Nil, ...)</pre>
<p>Here, the flag set is empty.</p>
<p>To make <code>C</code> private, one would write something like:</p>
<pre data-language="scala">ClassDef(Modifiers(PRIVATE), TypeName("C"), Nil, ...)</pre>
<p>Flags can also be combined with the vertical bar operator (<code>|</code>). For example, a private final class is written something like:</p>
<pre data-language="scala">ClassDef(Modifiers(PRIVATE | FINAL), TypeName("C"), Nil, ...)</pre>
<p>The list of all available flags is defined in <a href="flagsets%24flagvalues" name="scala.reflect.api.FlagSets.FlagValues" id="scala.reflect.api.FlagSets.FlagValues" class="extype">scala.reflect.api.FlagSets#FlagValues</a>, available via <a href="flagsets#Flag:FlagSets.this.FlagValues" name="scala.reflect.api.FlagSets#Flag" id="scala.reflect.api.FlagSets#Flag" class="extmbr">scala.reflect.api.FlagSets#Flag</a>. (Typically one writes a wildcard import for this, e.g. <code>import scala.reflect.runtime.universe.Flag._</code>).</p>
<p>Definition trees are compiled down to symbols, so flags on modifiers of these trees are transformed into flags on the resulting symbols. Unlike trees, symbols don't expose flags, but rather provide <code>isXXX</code> test methods (e.g. <code>isFinal</code> can be used to test finality). These test methods might require an upcast with <code>asTerm</code>, <code>asType</code> or <code>asClass</code> as some flags only make sense for certain kinds of symbols.</p>
<p><i>Of Note:</i> This part of the Reflection API is being considered as a candidate for redesign. It is quite possible that in future releases of the reflection API, flag sets could be replaced with something else.</p>
<p>For more details about <code>FlagSet</code>s and other aspects of Scala reflection, see the <a href="http://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a> </p>
</div></div>
<h3 id="scala.reflect.api.ImplicitTags">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="implicittags" title="Tags which preserve the identity of abstract types in the face of erasure."><span class="name">ImplicitTags</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt"><p>Tags which preserve the identity of abstract types in the face of erasure. Can be used for pattern matching, instance tests, serialization and the like.</p></div></div>
<h3 id="scala.reflect.api.Internals">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="internals" title="EXPERIMENTAL"><span class="name">Internals</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> This trait assembles APIs occasionally necessary for performing low-level operations on reflection artifacts. See <a href="internals%24internalapi" name="scala.reflect.api.Internals.InternalApi" id="scala.reflect.api.Internals.InternalApi" class="extype">Internals#InternalApi</a> for more information about nature, usefulness and compatibility guarantees of these APIs. </p>
</div></div>
<h3 id="scala.reflect.api.JavaUniverse">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="javauniverse" title="EXPERIMENTAL"><span class="name">JavaUniverse</span></a><span class="result"> extends <a href="universe" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">Universe</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> A refinement of <a href="universe" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a> for runtime reflection using JVM classloaders.</p>
<p> This refinement equips mirrors with reflection capabilities for the JVM. <code>JavaMirror</code> can convert Scala reflection artifacts (symbols and types) into Java reflection artifacts (classes) and vice versa. It can also perform reflective invocations (getting/setting field values, calling methods, etc).</p>
<p> See the <a href="http://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a> for details on how to use runtime reflection. </p>
</div></div>
<h3 id="scala.reflect.api.Liftables">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="liftables" title=""><span class="name">Liftables</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <h3 id="scala.reflect.api.Mirror">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class </span></span><span class="symbol"><a href="mirror" title="EXPERIMENTAL"><span class="name">Mirror</span></a><span class="tparams">[<span name="U">U &lt;: <a href="universe" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">Universe</a> with <span name="scala.Singleton" class="extype">Singleton</span></span>]</span><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>The base class for all mirrors.</p>
<p>See <a href="mirrors" name="scala.reflect.api.Mirrors" id="scala.reflect.api.Mirrors" class="extype">scala.reflect.api.Mirrors</a> or <span name="docs.scala-lang.org/overviews/reflection/overview.html" class="extype">Reflection Guide</span> for a complete overview of <code>Mirror</code>s. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>the type of the universe this mirror belongs to.</p></dd>
</dl>
</div>
<h3 id="scala.reflect.api.Mirrors">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="mirrors" title="EXPERIMENTAL"><span class="name">Mirrors</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>This trait provides support for Mirrors in the Scala Reflection API.</p>
<p><code>Mirror</code>s are a central part of Scala Reflection. All information provided by reflection is made accessible through <code>Mirror</code>s. Depending on the type of information to be obtained, or the reflective action to be taken, different flavors of mirrors must be used. "Classloader" mirrors can be used to obtain representations of types and members. From a classloader <code>Mirror</code>, it's possible to obtain more specialized "invoker" <code>Mirror</code>s (the most commonly-used mirrors), which implement reflective invocations, such as method/constructor calls and field accesses.</p>
<p>The two flavors of mirrors:</p>
<ul>

<b>“Classloader” mirrors</b>. These mirrors translate names to symbols (via methods <code>staticClass</code>/<code>staticModule</code>/<code>staticPackage</code>).
<b>"Invoker” mirrors</b>. These mirrors implement reflective invocations (via methods <code>MethodMirror.apply</code>, <code>FieldMirror.get</code>, etc). These "invoker" mirrors are the types of mirrors that are most commonly used.</ul>
<h5> Compile-time Mirrors </h5>
<p>Compile-time <code>Mirror</code>s make use of only classloader <code>Mirror</code>s to load <code>Symbol</code>s by name.</p>
<p>The entry point to classloader <code>Mirror</code>s is via <a href="../macros/blackbox/context#mirror:Context.this.universe.Mirror" name="scala.reflect.macros.blackbox.Context#mirror" id="scala.reflect.macros.blackbox.Context#mirror" class="extmbr">scala.reflect.macros.blackbox.Context#mirror</a> or <a href="../macros/whitebox/context#mirror:Context.this.universe.Mirror" name="scala.reflect.macros.whitebox.Context#mirror" id="scala.reflect.macros.whitebox.Context#mirror" class="extmbr">scala.reflect.macros.whitebox.Context#mirror</a>. Typical methods which use classloader <code>Mirror</code>s include <a href="#" name="scala.reflect.api.Mirror#staticClass" id="scala.reflect.api.Mirror#staticClass" class="extmbr">scala.reflect.api.Mirror#staticClass</a>, <a href="#" name="scala.reflect.api.Mirror#staticModule" id="scala.reflect.api.Mirror#staticModule" class="extmbr">scala.reflect.api.Mirror#staticModule</a>, and <a href="#" name="scala.reflect.api.Mirror#staticPackage" id="scala.reflect.api.Mirror#staticPackage" class="extmbr">scala.reflect.api.Mirror#staticPackage</a>. For example:</p>
<pre data-language="scala">import scala.reflect.macros.blackbox.Context

case class Location(filename: String, line: Int, column: Int)

object Macros {
  def currentLocation: Location = macro impl

  def impl(c: Context): c.Expr[Location] = {
    import c.universe._
    val pos = c.macroApplication.pos
    val clsLocation = c.mirror.staticModule("Location") // get symbol of "Location" object
    c.Expr(Apply(Ident(clsLocation), List(Literal(Constant(pos.source.path)), Literal(Constant(pos.line)), Literal(Constant(pos.column)))))
  }
}</pre>
<p><i>Of Note:</i> There are several high-level alternatives that one can use to avoid having to manually lookup symbols. For example, <code>typeOf[Location.type].termSymbol</code> (or <code>typeOf[Location].typeSymbol</code> if we needed a <code>ClassSymbol</code>), which are type safe since we don’t have to use <code>String</code>s to lookup the <code>Symbol</code>.</p>
<h5> Runtime Mirrors </h5>
<p>Runtime <code>Mirror</code>s make use of both classloader and invoker <code>Mirror</code>s.</p>
<p>The entry point to <code>Mirror</code>s for use at runtime is via <code>ru.runtimeMirror(&lt;classloader&gt;)</code>, where <code>ru</code> is <a href="../runtime/index#universe:scala.reflect.api.JavaUniverse" name="scala.reflect.runtime#universe" id="scala.reflect.runtime#universe" class="extmbr">scala.reflect.runtime.universe</a>.</p>
<p>The result of a <a href="javauniverse#runtimeMirror(cl:ClassLoader):JavaUniverse.this.Mirror" name="scala.reflect.api.JavaUniverse#runtimeMirror" id="scala.reflect.api.JavaUniverse#runtimeMirror" class="extmbr">scala.reflect.api.JavaUniverse#runtimeMirror</a> call is a classloader mirror, of type <a href="mirrors%24reflectivemirror" name="scala.reflect.api.Mirrors.ReflectiveMirror" id="scala.reflect.api.Mirrors.ReflectiveMirror" class="extype">scala.reflect.api.Mirrors#ReflectiveMirror</a>, which can load symbols by names as discussed above (in the “Compile-time” section).</p>
<p>A classloader mirror can create invoker mirrors, which include: <a href="mirrors%24instancemirror" name="scala.reflect.api.Mirrors.InstanceMirror" id="scala.reflect.api.Mirrors.InstanceMirror" class="extype">scala.reflect.api.Mirrors#InstanceMirror</a>, <a href="mirrors%24methodmirror" name="scala.reflect.api.Mirrors.MethodMirror" id="scala.reflect.api.Mirrors.MethodMirror" class="extype">scala.reflect.api.Mirrors#MethodMirror</a>, <a href="mirrors%24fieldmirror" name="scala.reflect.api.Mirrors.FieldMirror" id="scala.reflect.api.Mirrors.FieldMirror" class="extype">scala.reflect.api.Mirrors#FieldMirror</a>, <a href="mirrors%24classmirror" name="scala.reflect.api.Mirrors.ClassMirror" id="scala.reflect.api.Mirrors.ClassMirror" class="extype">scala.reflect.api.Mirrors#ClassMirror</a> and <a href="mirrors%24modulemirror" name="scala.reflect.api.Mirrors.ModuleMirror" id="scala.reflect.api.Mirrors.ModuleMirror" class="extype">scala.reflect.api.Mirrors#ModuleMirror</a>.</p>
<p>Examples of how these two types of <code>Mirror</code>s interact are available below.</p>
<h5> Types of Mirrors, Their Use Cases &amp; Examples </h5>
<p><b><a href="mirrors%24reflectivemirror" name="scala.reflect.api.Mirrors.ReflectiveMirror" id="scala.reflect.api.Mirrors.ReflectiveMirror" class="extype">scala.reflect.api.Mirrors#ReflectiveMirror</a></b>. Used for loading <code>Symbol</code>s by name, and as an entry point into invoker mirrors. Entry point: <code>val m = ru.runtimeMirror(&lt;classloader&gt;)</code>. Example:</p>
<pre data-language="scala">scala&gt; val ru = scala.reflect.runtime.universe
ru: scala.reflect.api.JavaUniverse = ...

scala&gt; val m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...</pre>
<p><b><a href="mirrors%24instancemirror" name="scala.reflect.api.Mirrors.InstanceMirror" id="scala.reflect.api.Mirrors.InstanceMirror" class="extype">scala.reflect.api.Mirrors#InstanceMirror</a></b>. Used for creating invoker <code>Mirror</code>s for methods and fields and for inner classes and inner objects (modules). Entry point: <code>val im = m.reflect(&lt;value&gt;)</code>. Example:</p>
<pre data-language="scala">scala&gt; class C { def x = 2 }
defined class C

scala&gt; val im = m.reflect(new C)
im: reflect.runtime.universe.InstanceMirror = instance mirror for C@3442299e</pre>
<p><b><a href="mirrors%24methodmirror" name="scala.reflect.api.Mirrors.MethodMirror" id="scala.reflect.api.Mirrors.MethodMirror" class="extype">scala.reflect.api.Mirrors#MethodMirror</a></b>. Used for invoking instance methods (Scala only has instance methods-- methods of objects are instance methods of object instances, obtainable via <code>ModuleMirror.instance</code>). Entry point: <code>val mm = im.reflectMethod(&lt;method symbol&gt;)</code>. Example:</p>
<pre data-language="scala">scala&gt; val methodX = typeOf[C].decl(TermName("x")).asMethod
methodX: reflect.runtime.universe.MethodSymbol = method x

scala&gt; val mm = im.reflectMethod(methodX)
mm: reflect.runtime.universe.MethodMirror = method mirror for C.x: scala.Int (bound to C@3442299e)

scala&gt; mm()
res0: Any = 2</pre>
<p><b><a href="mirrors%24fieldmirror" name="scala.reflect.api.Mirrors.FieldMirror" id="scala.reflect.api.Mirrors.FieldMirror" class="extype">scala.reflect.api.Mirrors#FieldMirror</a></b>. Used for getting/setting instance fields (Scala only has instance fields-- fields of objects are instance methods of object instances obtainable via ModuleMirror.instance). Entry point: <code>val fm = im.reflectMethod(&lt;field or accessor symbol&gt;)</code>. Example:</p>
<pre data-language="scala">scala&gt; class C { val x = 2; val y = 3 }
defined class C

scala&gt; val m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...

scala&gt; val im = m.reflect(new C)
im: reflect.runtime.universe.InstanceMirror = instance mirror for C@5f0c8ac1

scala&gt; val fieldX = typeOf[C].decl(TermName("x")).asTerm.accessed.asTerm
fieldX: reflect.runtime.universe.TermSymbol = value x
scala&gt; val fmX = im.reflectField(fieldX)
fmX: reflect.runtime.universe.FieldMirror = field mirror for C.x (bound to C@5f0c8ac1)

scala&gt; fmX.get
res0: Any = 2

scala&gt; fmX.set(3) // NOTE: can set an underlying value of an immutable field!

scala&gt; val fieldY = typeOf[C].decl(TermName("y")).asTerm.accessed.asTerm
fieldY: reflect.runtime.universe.TermSymbol = variable y

scala&gt; val fmY = im.reflectField(fieldY)
fmY: reflect.runtime.universe.FieldMirror = field mirror for C.y (bound to C@5f0c8ac1)

scala&gt; fmY.get
res1: Any = 3

scala&gt; fmY.set(4)

scala&gt; fmY.get
res2: Any = 4</pre>
<p><b><a href="mirrors%24classmirror" name="scala.reflect.api.Mirrors.ClassMirror" id="scala.reflect.api.Mirrors.ClassMirror" class="extype">scala.reflect.api.Mirrors#ClassMirror</a></b>. Used for creating invoker mirrors for constructors. Entry points: for <i>static classes</i> <code>val cm1 = m.reflectClass(&lt;class symbol&gt;)</code>, for <i>inner classes</i> <code>val mm2 = im.reflectClass(&lt;class symbol&gt;)</code>. Example:</p>
<pre data-language="scala">scala&gt; case class C(x: Int)
defined class C

scala&gt; val m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...

scala&gt; val classC = typeOf[C].typeSymbol.asClass

classC: reflect.runtime.universe.Symbol = class C

scala&gt; val cm = m.reflectClass(classC)
cm: reflect.runtime.universe.ClassMirror = class mirror for C (bound to null)

scala&gt; val ctorC = typeOf[C].decl(ru.nme.CONSTRUCTOR).asMethod
ctorC: reflect.runtime.universe.MethodSymbol = constructor C

scala&gt; val ctorm = cm.reflectConstructor(ctorC)
ctorm: reflect.runtime.universe.MethodMirror = constructor mirror for C.&lt;init&gt;(x: scala.Int): C (bound to null)

scala&gt; ctorm(2)
res0: Any = C(2)</pre>
<p><b><a href="mirrors%24modulemirror" name="scala.reflect.api.Mirrors.ModuleMirror" id="scala.reflect.api.Mirrors.ModuleMirror" class="extype">scala.reflect.api.Mirrors#ModuleMirror</a></b>. Used for getting singleton instances of objects. Entry points: for <i>static objects (modules)</i> <code>val mm1 = m.reflectModule(&lt;module symbol&gt;)</code>, for <i>inner objects (modules)</i> <code>val mm2 = im.reflectModule(&lt;module symbol&gt;)</code>. Example:</p>
<pre data-language="scala">scala&gt; object C { def x = 2 }
defined module C

scala&gt; val m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...

scala&gt; val objectC = typeOf[C.type].termSymbol.asModule
objectC: reflect.runtime.universe.ModuleSymbol = object C

scala&gt; val mm = m.reflectModule(objectC)
mm: reflect.runtime.universe.ModuleMirror = module mirror for C (bound to null)

scala&gt; val obj = mm.instance
obj: Any = C$@1005ec04</pre>
<p>For more information about <code>Mirrors</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/environment-universes-mirrors.html" target="_blank">Reflection Guide: Mirrors</a> </p>
</div></div>
<h3 id="scala.reflect.api.Names">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="names" title="EXPERIMENTAL"><span class="name">Names</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>This trait defines <code>Name</code>s in Scala Reflection, and operations on them.</p>
<p> Names are simple wrappers for strings. <a href="#" name="scala.reflect.api.Names.Name" id="scala.reflect.api.Names.Name" class="extmbr">Name</a> has two subtypes <a href="#" name="scala.reflect.api.Names.TermName" id="scala.reflect.api.Names.TermName" class="extmbr">TermName</a> and <a href="#" name="scala.reflect.api.Names.TypeName" id="scala.reflect.api.Names.TypeName" class="extmbr">TypeName</a> which distinguish names of terms (like objects or members) and types. A term and a type of the same name can co-exist in an object.</p>
<p> To search for the <code>map</code> method (which is a term) declared in the <code>List</code> class, one can do:</p>
<pre data-language="scala">scala&gt; typeOf[List[_]].member(TermName("map"))
res0: reflect.runtime.universe.Symbol = method map</pre>
<p> To search for a type member, one can follow the same procedure, using <code>TypeName</code> instead.</p>
<p> For more information about creating and using <code>Name</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html" target="_blank">Reflection Guide: Annotations, Names, Scopes, and More</a> </p>
</div></div>
<h3 id="scala.reflect.api.Position">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="position" title="EXPERIMENTAL"><span class="name">Position</span></a><span class="result"> extends <a href="../macros/attachments" name="scala.reflect.macros.Attachments" id="scala.reflect.macros.Attachments" class="extype">Attachments</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> Position tracks the origin of <a href="symbols%24symbol" name="scala.reflect.api.Symbols.Symbol" id="scala.reflect.api.Symbols.Symbol" class="extype">symbols</a> and <a href="trees%24tree" name="scala.reflect.api.Trees.Tree" id="scala.reflect.api.Trees.Tree" class="extype">tree nodes</a>. They are commonly used when displaying warnings and errors, to indicate the incorrect point in the program.</p>
<p> Every non-empty position refers to a SourceFile and three character offsets within it: start, end, and point. The point is where the ^ belongs when issuing an error message, usually a Name. A range position can be designated as transparent, which excuses it from maintaining the invariants to follow. If a transparent position has opaque children, those are considered as if they were the direct children of the transparent position's parent.</p>
<p> Note: some of these invariants actually apply to the trees which carry the positions, but they are phrased as if the positions themselves were the parent/children for conciseness.</p>
<p> Invariant 1: in a focused/offset position, start == point == end Invariant 2: in a range position, start &lt;= point &lt; end Invariant 3: an offset position never has a child with a range position Invariant 4: every range position child of a range position parent is contained within its parent Invariant 5: opaque range position siblings overlap at most at a single point</p>
<p> The following tests are useful on positions:</p>
<p> pos.isDefined true if position is not an UndefinedPosition (those being NoPosition and FakePos) pos.isRange true if position is a range (opaque or transparent) which implies start &lt; end pos.isOpaqueRange true if position is an opaque range</p>
<p> The following accessor methods are provided - an exception will be thrown if point/start/end are attempted on an UndefinedPosition.</p>
<p> pos.source The source file of the position, or NoSourceFile if unavailable pos.point The offset of the point pos.start The (inclusive) start offset, or the point of an offset position pos.end The (exclusive) end offset, or the point of an offset position</p>
<p> The following conversion methods are often used:</p>
<p> pos.focus Converts a range position to an offset position focused on the point pos.makeTransparent Convert an opaque range into a transparent range</p>
<p> For more information about <code>Position</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html" target="_blank">Reflection Guide: Annotations, Names, Scopes, and More</a> </p>
</div></div>
<h3 id="scala.reflect.api.Positions">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="positions" title="EXPERIMENTAL"><span class="name">Positions</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>This trait defines the concept of positions and operations on them. </p>
</div>
<dl class="attributes block">
<dt>See also</dt>
<dd><span class="cmt"><p><a href="position" name="scala.reflect.api.Position" id="scala.reflect.api.Position" class="extype">scala.reflect.api.Position</a></p></span></dd>
</dl>
</div>
<h3 id="scala.reflect.api.Printers">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="printers" title="EXPERIMENTAL"><span class="name">Printers</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>Utilities for nicely printing <a href="trees" name="scala.reflect.api.Trees" id="scala.reflect.api.Trees" class="extype">scala.reflect.api.Trees</a> and <a href="types" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a>.</p>
<h5> Printing Trees </h5>
<p>The method <code>show</code> displays the "prettified" representation of reflection artifacts. This representation provides one with the desugared Java representation of Scala code. For example:</p>
<pre data-language="scala">scala&gt; import scala.reflect.runtime.universe._
import scala.reflect.runtime.universe._

scala&gt; def tree = reify{ final class C { def x = 2 } }.tree
tree: reflect.runtime.universe.Tree

scala&gt; show(tree)
res0: String =
{
  final class C extends AnyRef {
    def &lt;init&gt;() = {
      super.&lt;init&gt;();
      ()
    };
    def x = 2
  };
  ()
}</pre>
<p>The method <code>showRaw</code> displays internal structure of a given reflection object as a Scala abstract syntax tree (AST), the representation that the Scala typechecker operates on.</p>
<p>Note, that while this representation appears to generate correct trees that one might think would be possible to use in a macro implementation, this is not usually the case. Symbols aren't fully represented (only their names are). Thus, this method is best-suited for use simply inspecting ASTs given some valid Scala code.</p>
<pre data-language="scala">scala&gt; showRaw(tree)
res1: String = Block(List(
  ClassDef(Modifiers(FINAL), TypeName("C"), List(), Template(
    List(Ident(TypeName("AnyRef"))),
    noSelfType,
    List(
      DefDef(Modifiers(), nme.CONSTRUCTOR, List(), List(List()), TypeTree(),
        Block(List(
          Apply(Select(Super(This(tpnme.EMPTY), tpnme.EMPTY), nme.CONSTRUCTOR), List())),
          Literal(Constant(())))),
      DefDef(Modifiers(), TermName("x"), List(), List(), TypeTree(),
        Literal(Constant(2))))))),
  Literal(Constant(())))</pre>
<p>The method <code>showRaw</code> can also print <a href="types" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a> next to the artifacts being inspected</p>
<pre data-language="scala">scala&gt; import scala.tools.reflect.ToolBox // requires scala-compiler.jar
import scala.tools.reflect.ToolBox

scala&gt; import scala.reflect.runtime.{currentMirror =&gt; cm}
import scala.reflect.runtime.{currentMirror=&gt;cm}

scala&gt; showRaw(cm.mkToolBox().typecheck(tree), printTypes = true)
res2: String = Block[1](List(
  ClassDef[2](Modifiers(FINAL), TypeName("C"), List(), Template[3](
    List(Ident[4](TypeName("AnyRef"))),
    noSelfType,
    List(
      DefDef[2](Modifiers(), nme.CONSTRUCTOR, List(), List(List()), TypeTree[3](),
        Block[1](List(
          Apply[4](Select[5](Super[6](This[3](TypeName("C")), tpnme.EMPTY), ...))),
          Literal[1](Constant(())))),
      DefDef[2](Modifiers(), TermName("x"), List(), List(), TypeTree[7](),
        Literal[8](Constant(2))))))),
  Literal[1](Constant(())))
[1] TypeRef(ThisType(scala), scala.Unit, List())
[2] NoType
[3] TypeRef(NoPrefix, TypeName("C"), List())
[4] TypeRef(ThisType(java.lang), java.lang.Object, List())
[5] MethodType(List(), TypeRef(ThisType(java.lang), java.lang.Object, List()))
[6] SuperType(ThisType(TypeName("C")), TypeRef(... java.lang.Object ...))
[7] TypeRef(ThisType(scala), scala.Int, List())
[8] ConstantType(Constant(2))</pre>
<h5> Printing Types </h5>
<p>The method <code>show</code></p>
<pre data-language="scala">scala&gt; import scala.reflect.runtime.universe._
import scala.reflect.runtime.universe._

scala&gt; def tpe = typeOf[{ def x: Int; val y: List[Int] }]
tpe: reflect.runtime.universe.Type

scala&gt; show(tpe)
res0: String = scala.AnyRef{def x: Int; val y: scala.List[Int]}</pre>
<p>Like the method <code>showRaw</code> for <a href="trees" name="scala.reflect.api.Trees" id="scala.reflect.api.Trees" class="extype">scala.reflect.api.Trees</a>, <code>showRaw</code> for <a href="types" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a> provides a visualization of the Scala AST operated on by the Scala typechecker.</p>
<pre data-language="scala">// showRaw has already been discussed above
scala&gt; showRaw(tpe)
res1: String = RefinedType(
  List(TypeRef(ThisType(scala), TypeName("AnyRef"), List())),
  Scope(
    TermName("x"),
    TermName("y")))</pre>
<p><code>printIds</code> and/or <code>printKinds</code> can additionally be supplied as arguments in a call to <code>showRaw</code> which additionally shows the unique identifiers of symbols.</p>
<pre data-language="scala">scala&gt; showRaw(tpe, printIds = true, printKinds = true)
res2: String = RefinedType(
  List(TypeRef(ThisType(scala#2043#PK), TypeName("AnyRef")#691#TPE, List())),
  Scope(
    TermName("x")#2540#METH,
    TermName("y")#2541#GET))</pre>
<p>For more details about <code>Printer</code>s and other aspects of Scala reflection, see the <a href="http://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a> </p>
</div></div>
<h3 id="scala.reflect.api.Quasiquotes">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="quasiquotes" title=""><span class="name">Quasiquotes</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <h3 id="scala.reflect.api.Scopes">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="scopes" title="EXPERIMENTAL"><span class="name">Scopes</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>This trait provides support for scopes in the reflection API.</p>
<p>A scope object generally maps names to symbols available in a corresponding lexical scope. Scopes can be nested. The base type exposed to the reflection API, however, only exposes a minimal interface, representing a scope as an iterable of symbols.</p>
<p>For rare occasions when it is necessary to create a scope manually, e.g., to populate members of <a href="types%24refinedtype" name="scala.reflect.api.Types.RefinedType" id="scala.reflect.api.Types.RefinedType" class="extype">scala.reflect.api.Types#RefinedType</a>, there is the <code>newScopeWith</code> function.</p>
<p>Additional functionality is exposed in member scopes that are returned by <code>members</code> and <code>decls</code> defined in <a href="types%24typeapi" name="scala.reflect.api.Types.TypeApi" id="scala.reflect.api.Types.TypeApi" class="extype">scala.reflect.api.Types#TypeApi</a>. Such scopes support the <code>sorted</code> method, which sorts members in declaration order. </p>
</div></div>
<h3 id="scala.reflect.api.StandardDefinitions">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="standarddefinitions" title="EXPERIMENTAL"><span class="name">StandardDefinitions</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>All Scala standard symbols and types.</p>
<p>These standard definitions can accessed to using <code>definitions</code>. They're typically imported with a wildcard import, <code>import definitions._</code>, and are listed in <a href="standarddefinitions%24definitionsapi" name="scala.reflect.api.StandardDefinitions.DefinitionsApi" id="scala.reflect.api.StandardDefinitions.DefinitionsApi" class="extype">scala.reflect.api.StandardDefinitions#DefinitionsApi</a>. </p>
</div></div>
<h3 id="scala.reflect.api.StandardLiftables">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="standardliftables" title=""><span class="name">StandardLiftables</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <h3 id="scala.reflect.api.StandardNames">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="standardnames" title="EXPERIMENTAL"><span class="name">StandardNames</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> Standard names are names that are essential to creating trees or to reflecting Scala artifacts. For example, <code>CONSTRUCTOR</code> (aka <code>&lt;init&gt;</code> on JVM) is necessary to create and invoke constructors.</p>
<p> These standard names can be referred to using <a href="standardnames#nme:StandardNames.this.TermNamesApi" name="scala.reflect.api.StandardNames#nme" id="scala.reflect.api.StandardNames#nme" class="extmbr"><code>nme</code></a> for term names and <a href="standardnames#tpnme:StandardNames.this.TypeNamesApi" name="scala.reflect.api.StandardNames#tpnme" id="scala.reflect.api.StandardNames#tpnme" class="extmbr"><code>tpnme</code></a> for type names </p>
</div>
<dl class="attributes block">
<dt>See also</dt>
<dd><span class="cmt"><p><a href="names" name="scala.reflect.api.Names" id="scala.reflect.api.Names" class="extype">Names</a> The API for names in Scala reflection.</p></span></dd>
</dl>
</div>
<h3 id="scala.reflect.api.Symbols">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="symbols" title="EXPERIMENTAL"><span class="name">Symbols</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> This trait defines symbols and operations on them.</p>
<p> Symbols are used to establish bindings between a name and the entity it refers to, such as a class or a method. Anything you define and can give a name to in Scala has an associated symbol.</p>
<p> Symbols contain all available information about the declaration of an entity (class/object/trait etc.) or a member (vals/vars/defs etc.), and as such are an integral abstraction central to both runtime reflection and macros.</p>
<p> A symbol can provide a wealth of information ranging from the basic <code>name</code> method available on all symbols to other, more involved, concepts such as getting the <code>baseClasses</code> from <code>ClassSymbol</code>. Other common use cases of symbols include inspecting members' signatures, getting type parameters of a class, getting the parameter type of a method or finding out the type of a field.</p>
<p> Example usage of runtime reflection; getting a method's type signature:</p>
<pre data-language="scala">scala&gt; import scala.reflect.runtime.universe._
import scala.reflect.runtime.universe._

scala&gt; class C[T] { def test[U](x: T)(y: U): Int = ??? }
defined class C

scala&gt; val test = typeOf[C[Int]].member(TermName("test")).asMethod
test: reflect.runtime.universe.MethodSymbol = method test

scala&gt; test.info
res0: reflect.runtime.universe.Type = [U](x: T)(y: U)scala.Int</pre>
<p> Symbols are organized in a hierarchy. For example, a symbol that represents a parameter of a method is owned by the corresponding method symbol, a method symbol is owned by its enclosing class, a class is owned by a containing package and so on.</p>
<p> Certain types of tree nodes, such as <a href="trees%24ident" name="scala.reflect.api.Trees.Ident" id="scala.reflect.api.Trees.Ident" class="extype">Ident</a> (references to identifiers) and <a href="trees%24select" name="scala.reflect.api.Trees.Select" id="scala.reflect.api.Trees.Select" class="extype">Select</a> (references to members) expose method <a href="trees%24symtreeapi#symbol:Trees.this.Symbol" name="scala.reflect.api.Trees.SymTreeApi#symbol" id="scala.reflect.api.Trees.SymTreeApi#symbol" class="extmbr"><code>symbol</code></a> to obtain the symbol that represents their declaration. During the typechecking phase, the compiler looks up the symbol based on the name and scope and sets the <a href="trees%24symtreeapi#symbol:Trees.this.Symbol" name="scala.reflect.api.Trees.SymTreeApi#symbol" id="scala.reflect.api.Trees.SymTreeApi#symbol" class="extmbr"><code>symbol</code> field</a> of tree nodes.</p>
<p> For more information about <code>Symbol</code> usage and attached intricacies, see the <a href="http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">Reflection Guide: Symbols</a> </p>
</div></div>
<h3 id="scala.reflect.api.TreeCreator">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class </span></span><span class="symbol"><a href="treecreator" title="A mirror-aware factory for trees."><span class="name">TreeCreator</span></a><span class="result"> extends <a href="../../index#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>A mirror-aware factory for trees.</p>
<p>This class is used internally by Scala Reflection, and is not recommended for use in client code. </p>
</div></div>
<h3 id="scala.reflect.api.Trees">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="trees" title="EXPERIMENTAL"><span class="name">Trees</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p>This trait defines the node types used in Scala abstract syntax trees (AST) and operations on them.</p>
<p>Trees are the basis for Scala's abstract syntax that is used to represent programs. They are also called abstract syntax trees and commonly abbreviated as ASTs.</p>
<p>In Scala reflection, APIs that produce or use <code>Tree</code>s are:</p>
<ul>

<b>Annotations</b> which use trees to represent their arguments, exposed in <span name="scala.reflect.api.Annotations#scalaArgs" class="extype">Annotation.scalaArgs</span>.
<b><a href="universe#reify%5BT%5D(expr:T):Universe.this.Expr%5BT%5D" name="scala.reflect.api.Universe#reify" id="scala.reflect.api.Universe#reify" class="extmbr">reify</a></b>, a special method on <a href="universe" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a> that takes an expression and returns an AST which represents the expression.
<b>Macros and runtime compilation with toolboxes</b> which both use trees as their program representation medium.</ul>
<p> Trees are immutable, except for three fields <a href="trees%24treeapi#pos:Trees.this.Position" name="scala.reflect.api.Trees.TreeApi#pos" id="scala.reflect.api.Trees.TreeApi#pos" class="extmbr">pos</a>, <a href="trees%24treeapi#symbol:Trees.this.Symbol" name="scala.reflect.api.Trees.TreeApi#symbol" id="scala.reflect.api.Trees.TreeApi#symbol" class="extmbr">symbol</a>, and <a href="trees%24treeapi#tpe:Trees.this.Type" name="scala.reflect.api.Trees.TreeApi#tpe" id="scala.reflect.api.Trees.TreeApi#tpe" class="extmbr">tpe</a>, which are assigned when a tree is typechecked to attribute it with the information gathered by the typechecker.</p>
<h5> Examples </h5>
<p> The following creates an AST representing a literal 5 in Scala source code:</p>
<pre data-language="scala">Literal(Constant(5))</pre>
<p> The following creates an AST representing <code>print("Hello World")</code>:</p>
<pre data-language="scala">Apply(Select(Select(This(TypeName("scala")), TermName("Predef")), TermName("print")), List(Literal(Constant("Hello World"))))</pre>
<p> The following creates an AST from a literal 5, and then uses <code>showRaw</code> to print it in a readable format.</p>
<pre data-language="scala">import scala.reflect.runtime.universe.{ reify, showRaw }
print( showRaw( reify{5}.tree ) )` // prints Literal(Constant(5))</pre>
<p> For more information about <code>Tree</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">Reflection Guide: Symbols, Trees, Types</a>. </p>
</div></div>
<h3 id="scala.reflect.api.TypeCreator">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class </span></span><span class="symbol"><a href="typecreator" title="A mirror-aware factory for types."><span class="name">TypeCreator</span></a><span class="result"> extends <a href="../../index#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p>A mirror-aware factory for types.</p>
<p>This class is used internally by Scala Reflection, and is not recommended for use in client code. </p>
</div></div>
<h3 id="scala.reflect.api.TypeTags">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="typetags" title="A TypeTag[T] encapsulates the runtime type representation of some type T."><span class="name">TypeTags</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>A <code>TypeTag[T]</code> encapsulates the runtime type representation of some type <code>T</code>. Like <span name="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</span>, the prime use case of <code>TypeTag</code>s is to give access to erased types. However, <code>TypeTag</code>s should be considered to be a richer replacement of the pre-2.10 notion of a <span name="scala.reflect.Manifest" class="extype">Manifest</span>, that are, in addition, fully integrated with Scala reflection.</p>
<p>There exist three different types of <code>TypeTags</code>:</p>
<ul>

<a href="typetags%24typetag" name="scala.reflect.api.TypeTags.TypeTag" id="scala.reflect.api.TypeTags.TypeTag" class="extype">scala.reflect.api.TypeTags#TypeTag</a>. <br>A full type descriptor of a Scala type. For example, a <code>TypeTag[List[String]]</code> contains all type information, in this case, of type <code>scala.List[String]</code>.
<span name="scala.reflect.ClassTag" class="extype">scala.reflect.ClassTag</span>. <br>A partial type descriptor of a Scala type. For example, a <code>ClassTag[List[String]]</code> contains only the erased class type information, in this case, of type <code>scala.collection.immutable.List</code>. <code>ClassTag</code>s provide access only to the runtime class of a type. Analogous to <a href="../index#ClassManifest%5BT%5D=scala.reflect.ClassTag%5BT%5D" name="scala.reflect.ClassManifest" id="scala.reflect.ClassManifest" class="extmbr">scala.reflect.ClassManifest</a>
<a href="typetags%24weaktypetag" name="scala.reflect.api.TypeTags.WeakTypeTag" id="scala.reflect.api.TypeTags.WeakTypeTag" class="extype">scala.reflect.api.TypeTags#WeakTypeTag</a>. <br>A type descriptor for abstract types (see description below).</ul>
<p>Like <span name="scala.reflect.Manifest" class="extype">Manifest</span>s, <code>TypeTag</code>s are always generated by the compiler, and can be obtained in three ways:</p>
<h5> #1 Via the methods <a href="typetags#typeTag%5BT%5D(implicitttag:TypeTags.this.TypeTag%5BT%5D):TypeTags.this.TypeTag%5BT%5D" name="scala.reflect.api.TypeTags#typeTag" id="scala.reflect.api.TypeTags#typeTag" class="extmbr">typeTag</a>, <a href="../index#classTag%5BT%5D(implicitctag:scala.reflect.ClassTag%5BT%5D):scala.reflect.ClassTag%5BT%5D" name="scala.reflect#classTag" id="scala.reflect#classTag" class="extmbr">classTag</a>, or <a href="typetags#weakTypeTag%5BT%5D(implicitattag:TypeTags.this.WeakTypeTag%5BT%5D):TypeTags.this.WeakTypeTag%5BT%5D" name="scala.reflect.api.TypeTags#weakTypeTag" id="scala.reflect.api.TypeTags#weakTypeTag" class="extmbr">weakTypeTag</a> </h5>
<p>For example:</p>
<pre data-language="scala">import scala.reflect.runtime.universe._
val tt = typeTag[Int]

import scala.reflect._
val ct = classTag[String]</pre>
<p>Each of these methods constructs a <code>TypeTag[T]</code> or <code>ClassTag[T]</code> for the given type argument <code>T</code>.</p>
<h5> #2 Using an implicit parameter of type <code>TypeTag[T]</code>, <code>ClassTag[T]</code>, or <code>WeakTypeTag[T]</code>
</h5>
<p>For example:</p>
<pre data-language="scala">import scala.reflect.runtime.universe._

def paramInfo[T](x: T)(implicit tag: TypeTag[T]): Unit = {
  val targs = tag.tpe match { case TypeRef(_, _, args) =&gt; args }
  println(s"type of $x has type arguments $targs")
}

scala&gt; paramInfo(42)
type of 42 has type arguments List()

scala&gt; paramInfo(List(1, 2))
type of List(1, 2) has type arguments List(Int)</pre>
<h5> #3 Context bound of a type parameter </h5>
<p>...on methods or classes. The above example can be implemented as follows:</p>
<pre data-language="scala">import scala.reflect.runtime.universe._

def paramInfo[T: TypeTag](x: T): Unit = {
  val targs = typeOf[T] match { case TypeRef(_, _, args) =&gt; args }
  println(s"type of $x has type arguments $targs")
}

scala&gt; paramInfo(42)
type of 42 has type arguments List()

scala&gt; paramInfo(List(1, 2))
type of List(1, 2) has type arguments List(Int)</pre>
<h5> <code>WeakTypeTag</code>s </h5>
<p><code>WeakTypeTag[T]</code> generalizes <code>TypeTag[T]</code>. Unlike a regular <code>TypeTag</code>, components of its type representation can be references to type parameters or abstract types. However, <code>WeakTypeTag[T]</code> tries to be as concrete as possible, i.e. if type tags are available for the referenced type arguments or abstract types, they are used to embed the concrete types into the <code>WeakTypeTag[T]</code>.</p>
<p>Continuing the example above:</p>
<pre data-language="scala">def weakParamInfo[T](x: T)(implicit tag: WeakTypeTag[T]): Unit = {
  val targs = tag.tpe match { case TypeRef(_, _, args) =&gt; args }
  println(s"type of $x has type arguments $targs")
}

scala&gt; def foo[T] = weakParamInfo(List[T]())
foo: [T]=&gt; Unit

scala&gt; foo[Int]
type of List() has type arguments List(T)</pre>
<h5> TypeTags and Manifests </h5>
<p><code>TypeTag</code>s correspond loosely to the pre-2.10 notion of <span name="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</span>s. While <span name="scala.reflect.ClassTag" class="extype">scala.reflect.ClassTag</span> corresponds to <a href="../index#ClassManifest%5BT%5D=scala.reflect.ClassTag%5BT%5D" name="scala.reflect.ClassManifest" id="scala.reflect.ClassManifest" class="extmbr">scala.reflect.ClassManifest</a> and <a href="typetags%24typetag" name="scala.reflect.api.TypeTags.TypeTag" id="scala.reflect.api.TypeTags.TypeTag" class="extype">scala.reflect.api.TypeTags#TypeTag</a> mostly corresponds to <span name="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</span>, other pre-2.10 <code>Manifest</code> types do not have a direct correspondence with a 2.10 "<code>Tag</code>" type.</p>
<ul>

<b><span name="scala.reflect.OptManifest" class="extype">scala.reflect.OptManifest</span> is not supported.</b> <br>This is because <code>Tag</code>s can reify arbitrary types, so they are always available. -
<b>There is no equivalent for <span name="scala.reflect.AnyValManifest" class="extype">scala.reflect.AnyValManifest</span>.</b> <br>Instead, one can compare their <code>Tag</code> with one of the base <code>Tag</code>s (defined in the corresponding companion objects) in order to find out whether or not it represents a primitive value class. Additionally, it's possible to simply use <code>&lt;tag&gt;.tpe.typeSymbol.isPrimitiveValueClass</code>.
<b>There are no replacement for factory methods defined in the <code>Manifest</code> companion objects</b>. <br>Instead, one could generate corresponding types using the reflection APIs provided by Java (for classes) and Scala (for types).
<b>Certain manifest operations(i.e., &lt;:&lt;, &gt;:&gt; and typeArguments) are not supported.</b> <br>Instead, one could use the reflection APIs provided by Java (for classes) and Scala (for types).</ul>
<p>In Scala 2.10, <a href="../index#ClassManifest%5BT%5D=scala.reflect.ClassTag%5BT%5D" name="scala.reflect.ClassManifest" id="scala.reflect.ClassManifest" class="extmbr">scala.reflect.ClassManifest</a>s are deprecated, and it is planned to deprecate <span name="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</span> in favor of <code>TypeTag</code>s and <code>ClassTag</code>s in an upcoming point release. Thus, it is advisable to migrate any <code>Manifest</code>-based APIs to use <code>Tag</code>s.</p>
<p>For more information about <code>TypeTag</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/typetags-manifests.html" target="_blank">Reflection Guide: TypeTags</a> </p>
</div>
<dl class="attributes block">
<dt>See also</dt>
<dd><span class="cmt"><p><span name="scala.reflect.ClassTag" class="extype">scala.reflect.ClassTag</span>, <a href="typetags%24typetag" name="scala.reflect.api.TypeTags.TypeTag" id="scala.reflect.api.TypeTags.TypeTag" class="extype">scala.reflect.api.TypeTags#TypeTag</a>, <a href="typetags%24weaktypetag" name="scala.reflect.api.TypeTags.WeakTypeTag" id="scala.reflect.api.TypeTags.WeakTypeTag" class="extype">scala.reflect.api.TypeTags#WeakTypeTag</a></p></span></dd>
</dl>
</div>
<h3 id="scala.reflect.api.Types">
<span class="modifier_kind"> <span class="kind">trait </span></span><span class="symbol"><a href="types" title="EXPERIMENTAL"><span class="name">Types</span></a><span class="result"> extends <a href="../../index#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p> A trait that defines types and operations on them.</p>
<p> Type instances represent information about the type of a corresponding symbol. This includes its members (methods, fields, type parameters, nested classes, traits, etc.) either declared directly or inherited, its base types, its erasure and so on. Types also provide operations to test for type conformance or equivalence or for widening.</p>
<p> To instantiate a type, most of the time, the <a href="typetags#typeOf%5BT%5D(implicitttag:TypeTags.this.TypeTag%5BT%5D):TypeTags.this.Type" name="scala.reflect.api.TypeTags#typeOf" id="scala.reflect.api.TypeTags#typeOf" class="extmbr">scala.reflect.api.TypeTags#typeOf</a> method can be used. It takes a type argument and produces a <code>Type</code> instance which represents that argument. For example:</p>
<pre data-language="scala">scala&gt; typeOf[List[Int]]
res0: reflect.runtime.universe.Type = scala.List[Int]</pre>
<p> In this example, a <a href="types%24typeref" name="scala.reflect.api.Types.TypeRef" id="scala.reflect.api.Types.TypeRef" class="extype">scala.reflect.api.Types#TypeRef</a> is returned, which corresponds to the type constructor <code>List</code> applied to the type argument <code>Int</code>.</p>
<p> In the case of a generic type, you can also combine it with other types using <a href="types#appliedType(sym:Types.this.Symbol,args:Types.this.Type*):Types.this.Type" name="scala.reflect.api.Types#appliedType" id="scala.reflect.api.Types#appliedType" class="extmbr">scala.reflect.api.Types#appliedType</a>. For example:</p>
<pre data-language="scala">scala&gt; val intType = typeOf[Int]
intType: reflect.runtime.universe.Type = Int

scala&gt; val listType = typeOf[List[_]]
listType: reflect.runtime.universe.Type = List[_]

scala&gt; appliedType(listType.typeConstructor, intType)
res0: reflect.runtime.universe.Type = List[Int]</pre>
<p> <i>Note:</i> Method <code>typeOf</code> does not work for types with type parameters, such as <code>typeOf[List[A]]</code> where <code>A</code> is a type parameter. In this case, use <a href="typetags#weakTypeOf%5BT%5D(implicitattag:TypeTags.this.WeakTypeTag%5BT%5D):TypeTags.this.Type" name="scala.reflect.api.TypeTags#weakTypeOf" id="scala.reflect.api.TypeTags#weakTypeOf" class="extmbr">scala.reflect.api.TypeTags#weakTypeOf</a> instead.</p>
<p> For other ways to instantiate types, see the <a href="http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">corresponding section of the Reflection Guide</a>.</p>
<h5> Common Operations on Types </h5>
<p> Types are typically used for type conformance tests or are queried for declarations of members or inner types.</p>
<ul>

<b>Subtyping Relationships</b> can be tested using <code>&lt;:&lt;</code> and <code>weak_&lt;:&lt;</code>.
<b>Type Equality</b> can be checked with <code>=:=</code>. It's important to note that <code>==</code> should not be used to compare types for equality-- <code>==</code> can't check for type equality in the presence of type aliases, while <code>=:=</code> can.</ul>
<p> Types can be queried for members and declarations by using the <code>members</code> and <code>declarations</code> methods (along with their singular counterparts <code>member</code> and <code>declaration</code>), which provide the list of definitions associated with that type. For example, to look up the <code>map</code> method of <code>List</code>, one can do:</p>
<pre data-language="scala">scala&gt; typeOf[List[_]].member(TermName("map"))
res1: reflect.runtime.universe.Symbol = method map</pre>
<p>For more information about <code>Type</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">Reflection Guide: Symbols, Trees, and Types</a> </p>
</div></div>
<h3 id="scala.reflect.api.Universe">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class </span></span><span class="symbol"><a href="universe" title="EXPERIMENTAL"><span class="name">Universe</span></a><span class="result"> extends <a href="symbols" name="scala.reflect.api.Symbols" id="scala.reflect.api.Symbols" class="extype">Symbols</a> with <a href="types" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">Types</a> with <a href="flagsets" name="scala.reflect.api.FlagSets" id="scala.reflect.api.FlagSets" class="extype">FlagSets</a> with <a href="scopes" name="scala.reflect.api.Scopes" id="scala.reflect.api.Scopes" class="extype">Scopes</a> with <a href="names" name="scala.reflect.api.Names" id="scala.reflect.api.Names" class="extype">Names</a> with <a href="trees" name="scala.reflect.api.Trees" id="scala.reflect.api.Trees" class="extype">Trees</a> with <a href="constants" name="scala.reflect.api.Constants" id="scala.reflect.api.Constants" class="extype">Constants</a> with <a href="annotations" name="scala.reflect.api.Annotations" id="scala.reflect.api.Annotations" class="extype">Annotations</a> with <a href="positions" name="scala.reflect.api.Positions" id="scala.reflect.api.Positions" class="extype">Positions</a> with <a href="exprs" name="scala.reflect.api.Exprs" id="scala.reflect.api.Exprs" class="extype">Exprs</a> with <a href="typetags" name="scala.reflect.api.TypeTags" id="scala.reflect.api.TypeTags" class="extype">TypeTags</a> with <a href="implicittags" name="scala.reflect.api.ImplicitTags" id="scala.reflect.api.ImplicitTags" class="extype">ImplicitTags</a> with <a href="standarddefinitions" name="scala.reflect.api.StandardDefinitions" id="scala.reflect.api.StandardDefinitions" class="extype">StandardDefinitions</a> with <a href="standardnames" name="scala.reflect.api.StandardNames" id="scala.reflect.api.StandardNames" class="extype">StandardNames</a> with <a href="standardliftables" name="scala.reflect.api.StandardLiftables" id="scala.reflect.api.StandardLiftables" class="extype">StandardLiftables</a> with <a href="mirrors" name="scala.reflect.api.Mirrors" id="scala.reflect.api.Mirrors" class="extype">Mirrors</a> with <a href="printers" name="scala.reflect.api.Printers" id="scala.reflect.api.Printers" class="extype">Printers</a> with <a href="liftables" name="scala.reflect.api.Liftables" id="scala.reflect.api.Liftables" class="extype">Liftables</a> with <a href="quasiquotes" name="scala.reflect.api.Quasiquotes" id="scala.reflect.api.Quasiquotes" class="extype">Quasiquotes</a> with <a href="internals" name="scala.reflect.api.Internals" id="scala.reflect.api.Internals" class="extype">Internals</a></span></span>
</h3>
   <div class="fullcomment"><div class="comment cmt">
<p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p>
<p><code>Universe</code> provides a complete set of reflection operations which make it possible for one to reflectively inspect Scala type relations, such as membership or subtyping.</p>
<p><a href="universe" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a> has two specialized sub-universes for different scenarios. <a href="javauniverse" name="scala.reflect.api.JavaUniverse" id="scala.reflect.api.JavaUniverse" class="extype">scala.reflect.api.JavaUniverse</a> adds operations that link symbols and types to the underlying classes and runtime values of a JVM instance-- this can be thought of as the <code>Universe</code> that should be used for all typical use-cases of Scala reflection. <a href="../macros/universe" name="scala.reflect.macros.Universe" id="scala.reflect.macros.Universe" class="extype">scala.reflect.macros.Universe</a> adds operations which allow macros to access selected compiler data structures and operations-- this type of <code>Universe</code> should only ever exist within the implementation of a Scala macro.</p>
<p><code>Universe</code> can be thought of as the entry point to Scala reflection. It mixes-in, and thus provides an interface to the following main types:</p>
<ul>

<a href="types%24type" name="scala.reflect.api.Types.Type" id="scala.reflect.api.Types.Type" class="extype">Types</a> represent types
<a href="symbols%24symbol" name="scala.reflect.api.Symbols.Symbol" id="scala.reflect.api.Symbols.Symbol" class="extype">Symbols</a> represent definitions
<a href="trees%24tree" name="scala.reflect.api.Trees.Tree" id="scala.reflect.api.Trees.Tree" class="extype">Trees</a> represent abstract syntax trees
<a href="#" name="scala.reflect.api.Names.Name" id="scala.reflect.api.Names.Name" class="extmbr">Names</a> represent term and type names
<a href="annotations%24annotation" name="scala.reflect.api.Annotations.Annotation" id="scala.reflect.api.Annotations.Annotation" class="extype">Annotations</a> represent annotations
<a href="#" name="scala.reflect.api.Positions.Position" id="scala.reflect.api.Positions.Position" class="extmbr">Positions</a> represent source positions of tree nodes
<a href="flagsets%24flagset" name="scala.reflect.api.FlagSets.FlagSet" id="scala.reflect.api.FlagSets.FlagSet" class="extype">FlagSet</a> represent sets of flags that apply to symbols and definition trees
<a href="constants%24constant" name="scala.reflect.api.Constants.Constant" id="scala.reflect.api.Constants.Constant" class="extype">Constants</a> represent compile-time constants.</ul>
<p>To obtain a <code>Universe</code> to use with Scala runtime reflection, simply make sure to use or import <code>scala.reflect.runtime.universe._</code></p>
<pre data-language="scala">scala&gt; import scala.reflect.runtime.universe._
import scala.reflect.runtime.universe._

scala&gt; typeOf[List[Int]]
res0: reflect.runtime.universe.Type = scala.List[Int]

scala&gt; typeOf[Either[String, Int]]
res1: reflect.runtime.universe.Type = scala.Either[String,Int]</pre>
<p>To obtain a <code>Universe</code> for use within a Scala macro, use <a href="../macros/blackbox/context#universe:scala.reflect.macros.Universe" name="scala.reflect.macros.blackbox.Context#universe" id="scala.reflect.macros.blackbox.Context#universe" class="extmbr">scala.reflect.macros.blackbox.Context#universe</a>. or <a href="../macros/whitebox/context#universe:scala.reflect.macros.Universe" name="scala.reflect.macros.whitebox.Context#universe" id="scala.reflect.macros.whitebox.Context#universe" class="extmbr">scala.reflect.macros.whitebox.Context#universe</a>. For example:</p>
<pre data-language="scala">def printf(format: String, params: Any*): Unit = macro impl
def impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = {
  import c.universe._
  ...
}</pre>
<p>For more information about <code>Universe</code>s, see the <a href="http://docs.scala-lang.org/overviews/reflection/environment-universes-mirrors.html" target="_blank">Reflection Guide: Universes</a> </p>
</div></div>
</div></div></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002-2019 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.scala-lang.org/api/2.13.0/scala-reflect/scala/reflect/api/index.html" class="_attribution-link">https://www.scala-lang.org/api/2.13.0/scala-reflect/scala/reflect/api/index.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
