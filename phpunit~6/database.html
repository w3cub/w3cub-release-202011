
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Database Testing - PHPUnit 6 - W3cubDocs</title>
  
  <meta name="description" content="Many beginner and intermediate unit testing examples in any programming language suggest that it is perfectly easy to test your application&#39;s &hellip;">
  <meta name="keywords" content="database, testing, phpunit, phpunit~6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/phpunit~6/database.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/phpunit~6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phpunit~6/" class="_nav-link" title="" style="margin-left:0;">PHPUnit 6</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _phpunit">
				
				
<h1 class="title" id="database">Database Testing</h1>
<p> Many beginner and intermediate unit testing examples in any programming language suggest that it is perfectly easy to test your application's logic with simple tests. For database-centric applications this is far away from the reality. Start using WordPress, TYPO3 or Symfony with Doctrine or Propel, for example, and you will easily experience considerable problems with PHPUnit: just because the database is so tightly coupled to these libraries. </p>
<div class="alert alert-info"><p> Make sure you have the PHP extension <code class="literal">pdo</code> and database specific extensions such as <code class="literal">pdo_mysql</code> installed. Otherwise the examples shown below will not work. </p></div>
<p> You probably know this scenario from your daily work and projects, where you want to put your fresh or experienced PHPUnit skills to work and get stuck by one of the following problems: </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p> The method you want to test executes a rather large JOIN operation and uses the data to calculate some important results. </p></li>
<li class="listitem"><p> Your business logic performs a mix of SELECT, INSERT, UPDATE and DELETE statements. </p></li>
<li class="listitem"><p> You need to setup test data in (possibly much) more than two tables to get reasonable initial data for the methods you want to test. </p></li>
</ol></div>
<p> The DbUnit extension considerably simplifies the setup of a database for testing purposes and allows you to verify the contents of a database after performing a series of operations. </p>
<h2 class="title" id="database.supported-vendors-for-database-testing">Supported Vendors for Database Testing</h2>
<p> DbUnit currently supports MySQL, PostgreSQL, Oracle and SQLite. Through <a class="ulink" href="http://framework.zend.com" target="_top">Zend Framework</a> or <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a> integrations it has access to other database systems such as IBM DB2 or Microsoft SQL Server. </p>
<h2 class="title" id="database.difficulties-in-database-testing">Difficulties in Database Testing</h2>
<p> There is a good reason why all the examples on unit testing do not include interactions with the database: these kind of tests are both complex to setup and maintain. While testing against your database you need to take care of the following variables: </p>
<div class="itemizedlist"><ul class="itemizedlist">
<li class="listitem"><p> The database schema and tables </p></li>
<li class="listitem"><p> Inserting the rows required for the test into these tables </p></li>
<li class="listitem"><p> Verifying the state of the database after your test has run </p></li>
<li class="listitem"><p> Cleanup the database for each new test </p></li>
</ul></div>
<p> Because many database APIs such as PDO, MySQLi or OCI8 are cumbersome to use and verbose in writing doing these steps manually is an absolute nightmare. </p>
<p> Test code should be as short and precise as possible for several reasons: </p>
<div class="itemizedlist"><ul class="itemizedlist">
<li class="listitem"><p> You do not want to modify considerable amount of test code for little changes in your production code. </p></li>
<li class="listitem"><p> You want to be able to read and understand the test code easily, even months after writing it. </p></li>
</ul></div>
<p> Additionally you have to realize that the database is essentially a global input variable to your code. Two tests in your test suite could run against the same database, possibly reusing data multiple times. Failures in one test can easily affect the result of the following tests making your testing experience very difficult. The previously mentioned cleanup step is of major importance to solve the <span class="quote">“<span class="quote">database is a global input</span>”</span> problem. </p>
<p> DbUnit helps to simplify all these problems with database testing in an elegant way. </p>
<p> What PHPUnit cannot help you with is the fact that database tests are very slow compared to tests not using the database. Depending on how large the interactions with your database are your tests could run a considerable amount of time. However, if you keep the amount of data used for each test small and try to test as much code using non-database tests you can easily get away in under a minute even for large test suites. </p>
<p> The <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2 project</a>'s test suite, for example, currently has a test suite of about 1000 tests where nearly half of them accesses the database and still runs in 15 seconds against a MySQL database on a standard desktop computer. </p>
<h2 class="title" id="database.the-four-stages-of-a-database-test">The four stages of a database test</h2>
<p> In his book on xUnit Test Patterns Gerard Meszaros lists the four stages of a unit-test: </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p> Set up fixture </p></li>
<li class="listitem"><p> Exercise System Under Test </p></li>
<li class="listitem"><p> Verify outcome </p></li>
<li class="listitem"><p> Teardown </p></li>
</ol></div>
<div class="blockquote"><blockquote class="blockquote">
<p> <span class="strong"><strong>What is a Fixture?</strong></span> </p>
<p> A fixture describes the initial state your application and database are in when you execute a test. </p>
</blockquote></div>
<p> Testing the database requires you to hook into at least the setup and teardown to clean-up and write the required fixture data into your tables. However, the database extension has good reason to revert the four stages in a database test to resemble the following workflow that is executed for each single test: </p>
<h3 class="title" id="database.clean-up-database">1. Clean-Up Database</h3>
<p> Since there is always a first test that runs against the database you do not know exactly if there is already data in the tables. PHPUnit will execute a TRUNCATE against all the tables you specified to reset their status to empty. </p>
<h3 class="title" id="database.set-up-fixture">2. Set up fixture</h3>
<p> PHPUnit will then iterate over all the fixture rows specified and insert them into their respective tables. </p>
<h3 class="title" id="database.run-test-verify-outcome-and-teardown">3–5. Run Test, Verify outcome and Teardown</h3>
<p> After the database is reset and loaded with its initial state the actual test is executed by PHPUnit. This part of the test code does not require awareness of the Database Extension at all, you can go on and test whatever you like with your code. </p>
<p> In your test use a special assertion called <code class="literal">assertDataSetsEqual()</code> for verification purposes, however, this is entirely optional. This feature will be explained in the section <span class="quote">“<span class="quote">Database Assertions</span>”</span>. </p>
<h2 class="title" id="database.configuration-of-a-phpunit-database-testcase">Configuration of a PHPUnit Database TestCase</h2>
<p> Usually when using PHPUnit your testcases would extend the <code class="literal">PHPUnit\Framework\TestCase</code> class in the following way: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    public function testCalculate()
    {
        $this-&gt;assertEquals(2, 1 + 1);
    }
}
?&gt;</pre>
<p> If you want to test code that works with the Database Extension the setup is a bit more complex and you have to extend a different abstract TestCase requiring you to implement two abstract methods <code class="literal">getConnection()</code> and <code class="literal">getDataSet()</code>: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this-&gt;createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this-&gt;createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
?&gt;</pre>
<h3 class="title" id="database.implementing-getconnection">Implementing getConnection()</h3>
<p> To allow the clean-up and fixture loading functionalities to work the PHPUnit Database Extension requires access to a database connection abstracted across vendors through the PDO library. It is important to note that your application does not need to be based on PDO to use PHPUnit's database extension, the connection is merely used for the clean-up and fixture setup. </p>
<p> In the previous example we create an in-memory Sqlite connection and pass it to the <code class="literal">createDefaultDBConnection</code> method which wraps the PDO instance and the second parameter (the database-name) in a very simple abstraction layer for database connections of the type <code class="literal">PHPUnit_Extensions_Database_DB_IDatabaseConnection</code>. </p>
<p> The section <span class="quote">“<span class="quote">Using the Database Connection</span>”</span> explains the API of this interface and how you can make the best use of it. </p>
<h3 class="title" id="database.implementing-getdataset">Implementing getDataSet()</h3>
<p> The <code class="literal">getDataSet()</code> method defines how the initial state of the database should look before each test is executed. The state of a database is abstracted through the concepts DataSet and DataTable both being represented by the interfaces <code class="literal">PHPUnit_Extensions_Database_DataSet_IDataSet</code> and <code class="literal">PHPUnit_Extensions_Database_DataSet_IDataTable</code>. The next section will describe in detail how these concepts work and what the benefits are for using them in database testing. </p>
<p> For the implementation we only need to know that the <code class="literal">getDataSet()</code> method is called once during <code class="literal">setUp()</code> to retrieve the fixture data-set and insert it into the database. In the example we are using a factory method <code class="literal">createFlatXMLDataSet($filename)</code> that represents a data-set through an XML representation. </p>
<h3 class="title" id="database.what-about-the-database-schema-ddl">What about the Database Schema (DDL)?</h3>
<p> PHPUnit assumes that the database schema with all its tables, triggers, sequences and views is created before a test is run. This means you as developer have to make sure that the database is correctly setup before running the suite. </p>
<p> There are several means to achieve this pre-condition to database testing. </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p> If you are using a persistent database (not Sqlite Memory) you can easily setup the database once with tools such as phpMyAdmin for MySQL and re-use the database for every test-run. </p></li>
<li class="listitem"><p> If you are using libraries such as <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a> or <a class="ulink" href="http://www.propelorm.org/" target="_top">Propel</a> you can use their APIs to create the database schema you need once before you run the tests. You can utilize <a class="ulink" href="textui" target="_top">PHPUnit's Bootstrap and Configuration</a> capabilities to execute this code whenever your tests are run. </p></li>
</ol></div>
<h3 class="title" id="database.tip-use-your-own-abstract-database-testcase">Tip: Use your own Abstract Database TestCase</h3>
<p> From the previous implementation example you can easily see that <code class="literal">getConnection()</code> method is pretty static and could be re-used in different database test-cases. Additionally to keep performance of your tests good and database overhead low you can refactor the code a little bit to get a generic abstract test case for your application, which still allows you to specify a different data-fixture for each test case: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class MyApp_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this-&gt;conn;
    }
}
?&gt;</pre>
<p> This has the database connection hardcoded in the PDO connection though. PHPUnit has another awesome feature that could make this testcase even more generic. If you use the <a class="ulink" href="appendixes.configuration#appendixes.configuration.php-ini-constants-variables" target="_top">XML Configuration</a> you could make the database connection configurable per test-run. First let's create a <span class="quote">“<span class="quote">phpunit.xml</span>”</span> file in our tests/ directory of the application that looks like: </p>
<pre class="screen">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;phpunit&gt;
    &lt;php&gt;
        &lt;var name="DB_DSN" value="mysql:dbname=myguestbook;host=localhost" /&gt;
        &lt;var name="DB_USER" value="user" /&gt;
        &lt;var name="DB_PASSWD" value="passwd" /&gt;
        &lt;var name="DB_DBNAME" value="myguestbook" /&gt;
    &lt;/php&gt;
&lt;/phpunit&gt;
</pre>
<p> We can now modify our test-case to look like: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class Generic_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this-&gt;conn;
    }
}
?&gt;</pre>
<p> We can now run the database test suite using different configurations from the command-line interface: </p>
<pre class="screen">user@desktop&gt; phpunit --configuration developer-a.xml MyTests/
user@desktop&gt; phpunit --configuration developer-b.xml MyTests/</pre>
<p> The possibility to run the database tests against different database targets easily is very important if you are developing on the development machine. If several developers run the database tests against the same database connection you can easily experience test-failures because of race-conditions. </p>
<h2 class="title" id="database.understanding-datasets-and-datatables">Understanding DataSets and DataTables</h2>
<p> A central concept of PHPUnit's Database Extension are DataSets and DataTables. You should try to understand this simple concept to master database testing with PHPUnit. The DataSet and DataTable are an abstraction layer around your database tables, rows and columns. A simple API hides the underlying database contents in an object structure, which can also be implemented by other non-database sources. </p>
<p> This abstraction is necessary to compare the actual contents of a database against the expected contents. Expectations can be represented as XML, YAML, CSV files or PHP array for example. The DataSet and DataTable interfaces enable the comparison of these conceptually different sources, emulating relational database storage in a semantically similar approach. </p>
<p> A workflow for database assertions in your tests then consists of three simple steps: </p>
<div class="itemizedlist"><ul class="itemizedlist">
<li class="listitem"><p> Specify one or more tables in your database by table name (actual dataset) </p></li>
<li class="listitem"><p> Specify the expected dataset in your preferred format (YAML, XML, ..) </p></li>
<li class="listitem"><p> Assert that both dataset representations equal each other. </p></li>
</ul></div>
<p> Assertions are not the only use-case for the DataSet and DataTable in PHPUnit's Database Extension. As shown in the previous section they also describe the initial contents of a database. You are forced to define a fixture dataset by the Database TestCase, which is then used to: </p>
<div class="itemizedlist"><ul class="itemizedlist">
<li class="listitem"><p> Delete all the rows from the tables specified in the dataset. </p></li>
<li class="listitem"><p> Write all the rows in the data-tables into the database. </p></li>
</ul></div>
<h3 class="title" id="database.available-implementations">Available Implementations</h3>
<p> There are three different types of datasets/datatables: </p>
<div class="itemizedlist"><ul class="itemizedlist">
<li class="listitem"><p> File-Based DataSets and DataTables </p></li>
<li class="listitem"><p> Query-Based DataSet and DataTable </p></li>
<li class="listitem"><p> Filter and Composition DataSets and DataTables </p></li>
</ul></div>
<p> The file-based datasets and tables are generally used for the initial fixture and to describe the expected state of the database. </p>
<h4 class="title" id="database.flat-xml-dataset">Flat XML DataSet</h4>
<p> The most common dataset is called Flat XML. It is a very simple xml format where a tag inside the root node <code class="literal">&lt;dataset&gt;</code> represents exactly one row in the database. The tags name equals the table to insert the row into and an attribute represents the column. An example for a simple guestbook application could look like this: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre>
<p> This is obviously easy to write. Here <code class="literal">&lt;guestbook&gt;</code> is the table name where two rows are inserted into each with four columns <span class="quote">“<span class="quote">id</span>”</span>, <span class="quote">“<span class="quote">content</span>”</span>, <span class="quote">“<span class="quote">user</span>”</span> and <span class="quote">“<span class="quote">created</span>”</span> with their respective values. </p>
<p> However, this simplicity comes at a cost. </p>
<p> From the previous example it isn't obvious how you would specify an empty table. You can insert a tag with no attributes with the name of the empty table. A flat xml file for an empty guestbook table would then look like: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook /&gt;
&lt;/dataset&gt;
</pre>
<p> The handling of NULL values with the flat xml dataset is tedious. A NULL value is different than an empty string value in almost any database (Oracle being an exception), something that is difficult to describe in the flat xml format. You can represent a NULL's value by omitting the attribute from the row specification. If our guestbook would allow anonymous entries represented by a NULL value in the user column, a hypothetical state of the guestbook table could look like: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre>
<p> In this case the second entry is posted anonymously. However, this leads to a serious problem with column recognition. During dataset equality assertions each dataset has to specify what columns a table holds. If an attribute is NULL for all the rows of a data-table, how would the Database Extension know that the column should be part of the table? </p>
<p> The flat xml dataset makes a crucial assumption now, defining that the attributes on the first defined row of a table define the columns of this table. In the previous example this would mean <span class="quote">“<span class="quote">id</span>”</span>, <span class="quote">“<span class="quote">content</span>”</span>, <span class="quote">“<span class="quote">user</span>”</span> and <span class="quote">“<span class="quote">created</span>”</span> are columns of the guestbook table. For the second row where <span class="quote">“<span class="quote">user</span>”</span> is not defined a NULL would be inserted into the database. </p>
<p> When the first guestbook entry is deleted from the dataset only <span class="quote">“<span class="quote">id</span>”</span>, <span class="quote">“<span class="quote">content</span>”</span> and <span class="quote">“<span class="quote">created</span>”</span> would be columns of the guestbook table, since <span class="quote">“<span class="quote">user</span>”</span> is not specified. </p>
<p> To use the Flat XML dataset effectively when NULL values are relevant the first row of each table must not contain any NULL value and only successive rows are allowed to omit attributes. This can be awkward, since the order of the rows is a relevant factor for database assertions. </p>
<p> In turn, if you specify only a subset of the table columns in the Flat XML dataset all the omitted values are set to their default values. This will lead to errors if one of the omitted columns is defined as <span class="quote">“<span class="quote">NOT NULL DEFAULT NULL</span>”</span>. </p>
<p> In conclusion I can only advise using the Flat XML datasets if you do not need NULL values. </p>
<p> You can create a flat xml dataset instance from within your Database TestCase by calling the <code class="literal">createFlatXmlDataSet($filename)</code> method: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
?&gt;</pre>
<h4 class="title" id="database.xml-dataset">XML DataSet</h4>
<p> There is another more structured XML dataset, which is a bit more verbose to write but avoids the NULL problems of the Flat XML dataset. Inside the root node <code class="literal">&lt;dataset&gt;</code> you can specify <code class="literal">&lt;table&gt;</code>, <code class="literal">&lt;column&gt;</code>, <code class="literal">&lt;row&gt;</code>, <code class="literal">&lt;value&gt;</code> and <code class="literal">&lt;null /&gt;</code> tags. An equivalent dataset to the previously defined Guestbook Flat XML looks like: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;table name="guestbook"&gt;
        &lt;column&gt;id&lt;/column&gt;
        &lt;column&gt;content&lt;/column&gt;
        &lt;column&gt;user&lt;/column&gt;
        &lt;column&gt;created&lt;/column&gt;
        &lt;row&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;Hello buddy!&lt;/value&gt;
            &lt;value&gt;joe&lt;/value&gt;
            &lt;value&gt;2010-04-24 17:15:23&lt;/value&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;value&gt;2&lt;/value&gt;
            &lt;value&gt;I like it!&lt;/value&gt;
            &lt;null /&gt;
            &lt;value&gt;2010-04-26 12:14:20&lt;/value&gt;
        &lt;/row&gt;
    &lt;/table&gt;
&lt;/dataset&gt;
</pre>
<p> Any defined <code class="literal">&lt;table&gt;</code> has a name and requires a definition of all the columns with their names. It can contain zero or any positive number of nested <code class="literal">&lt;row&gt;</code> elements. Defining no <code class="literal">&lt;row&gt;</code> element means the table is empty. The <code class="literal">&lt;value&gt;</code> and <code class="literal">&lt;null /&gt;</code> tags have to be specified in the order of the previously given <code class="literal">&lt;column&gt;</code> elements. The <code class="literal">&lt;null /&gt;</code> tag obviously means that the value is NULL. </p>
<p> You can create a xml dataset instance from within your Database TestCase by calling the <code class="literal">createXmlDataSet($filename)</code> method: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createXMLDataSet('myXmlFixture.xml');
    }
}
?&gt;</pre>
<h4 class="title" id="database.mysql-xml-dataset">MySQL XML DataSet</h4>
<p> This new XML format is specific to the <a class="ulink" href="http://www.mysql.com" target="_top">MySQL database server</a>. Support for it was added in PHPUnit 3.5. Files in this format can be generated using the <a class="ulink" href="http://dev.mysql.com/doc/refman/5.0/en/mysqldump.html" target="_top"><code class="literal">mysqldump</code></a> utility. Unlike CSV datasets, which <code class="literal">mysqldump</code> also supports, a single file in this XML format can contain data for multiple tables. You can create a file in this format by invoking <code class="literal">mysqldump</code> like so: </p>
<pre class="screen">mysqldump --xml -t -u [username] --password=[password] [database] &gt; /path/to/file.xml</pre>
<p> This file can be used in your Database TestCase by calling the <code class="literal">createMySQLXMLDataSet($filename)</code> method: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createMySQLXMLDataSet('/path/to/file.xml');
    }
}
?&gt;</pre>
<h4 class="title" id="database.yaml-dataset">YAML DataSet</h4>
<p> Alternatively, you can use YAML dataset for the guestbook example: </p>
<pre class="screen">
guestbook:
  -
    id: 1
    content: "Hello buddy!"
    user: "joe"
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: "I like it!"
    user:
    created: 2010-04-26 12:14:20
</pre>
<p> This is simple, convient AND it solves the NULL issue that the similar Flat XML dataset has. A NULL in YAML is just the column name without no value specified. An empty string is specified as <code class="literal">column1: ""</code>. </p>
<p> The YAML Dataset has no factory method on the Database TestCase currently, so you have to instantiate it manually: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\YamlDataSet;

class YamlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new YamlDataSet(dirname(__FILE__)."/_files/guestbook.yml");
    }
}
?&gt;</pre>
<h4 class="title" id="database.csv-dataset">CSV DataSet</h4>
<p> Another file-based dataset is based on CSV files. Each table of the dataset is represented as a single CSV file. For our guestbook example we would define a guestbook-table.csv file: </p>
<pre class="screen">
id,content,user,created
1,"Hello buddy!","joe","2010-04-24 17:15:23"
2,"I like it!","nancy","2010-04-26 12:14:20"
</pre>
<p> While this is very convenient for editing with Excel or OpenOffice, you cannot specify NULL values with the CSV dataset. An empty column will lead to the database default empty value being inserted into the column. </p>
<p> You can create a CSV DataSet by calling: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\CsvDataSet;

class CsvGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        $dataSet = new CsvDataSet();
        $dataSet-&gt;addTable('guestbook', dirname(__FILE__)."/_files/guestbook.csv");
        return $dataSet;
    }
}
?&gt;</pre>
<h4 class="title" id="database.array-dataset">Array DataSet</h4>
<p> There is no Array based DataSet in PHPUnit's Database Extension (yet), but we can implement our own easily. Our guestbook example should look like: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ArrayGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new MyApp_DbUnit_ArrayDataSet(
            [
                'guestbook' =&gt; [
                    [
                        'id' =&gt; 1,
                        'content' =&gt; 'Hello buddy!',
                        'user' =&gt; 'joe',
                        'created' =&gt; '2010-04-24 17:15:23'
                    ],
                    [
                        'id' =&gt; 2,
                        'content' =&gt; 'I like it!',
                        'user' =&gt; null,
                        'created' =&gt; '2010-04-26 12:14:20'
                    ],
                ],
            ]
        );
    }
}
?&gt;</pre>
<p> A PHP DataSet has obvious advantages over all the other file-based datasets: </p>
<div class="itemizedlist"><ul class="itemizedlist">
<li class="listitem"><p> PHP Arrays can obviously handle <code class="literal">NULL</code> values. </p></li>
<li class="listitem"><p> You won't need additional files for assertions and can specify them directly in the TestCase. </p></li>
</ul></div>
<p> For this dataset like the Flat XML, CSV and YAML DataSets the keys of the first specified row define the table's column names, in the previous case this would be <span class="quote">“<span class="quote">id</span>”</span>, <span class="quote">“<span class="quote">content</span>”</span>, <span class="quote">“<span class="quote">user</span>”</span> and <span class="quote">“<span class="quote">created</span>”</span>. </p>
<p> The implementation for this Array DataSet is simple and straightforward: </p>
<pre class="programlisting" data-language="php">&lt;?php
class MyApp_DbUnit_ArrayDataSet extends PHPUnit_Extensions_Database_DataSet_AbstractDataSet
{
    /**
     * @var array
     */
    protected $tables = [];

    /**
     * @param array $data
     */
    public function __construct(array $data)
    {
        foreach ($data AS $tableName =&gt; $rows) {
            $columns = [];
            if (isset($rows[0])) {
                $columns = array_keys($rows[0]);
            }

            $metaData = new PHPUnit_Extensions_Database_DataSet_DefaultTableMetaData($tableName, $columns);
            $table = new PHPUnit_Extensions_Database_DataSet_DefaultTable($metaData);

            foreach ($rows AS $row) {
                $table-&gt;addRow($row);
            }
            $this-&gt;tables[$tableName] = $table;
        }
    }

    protected function createIterator($reverse = false)
    {
        return new PHPUnit_Extensions_Database_DataSet_DefaultTableIterator($this-&gt;tables, $reverse);
    }

    public function getTable($tableName)
    {
        if (!isset($this-&gt;tables[$tableName])) {
            throw new InvalidArgumentException("$tableName is not a table in the current database.");
        }

        return $this-&gt;tables[$tableName];
    }
}
?&gt;</pre>
<h4 class="title" id="database.query-sql-dataset">Query (SQL) DataSet</h4>
<p> For database assertions you do not only need the file-based datasets but also a Query/SQL based Dataset that contains the actual contents of the database. This is where the Query DataSet shines: </p>
<pre class="programlisting" data-language="php">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook');
?&gt;</pre>
<p> Adding a table just by name is an implicit way to define the data-table with the following query: </p>
<pre class="programlisting" data-language="php">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT * FROM guestbook');
?&gt;</pre>
<p> You can make use of this by specifying arbitrary queries for your tables, for example restricting rows, column or adding <code class="literal">ORDER BY</code> clauses: </p>
<pre class="programlisting" data-language="php">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
?&gt;</pre>
<p> The section on Database Assertions will show some more details on how to make use of the Query DataSet. </p>
<h4 class="title" id="database.database-db-dataset">Database (DB) Dataset</h4>
<p> Accessing the Test Connection you can automatically create a DataSet that consists of all the tables with their content in the database specified as second parameter to the Connections Factory method. </p>
<p> You can either create a dataset for the complete database as shown in <code class="literal">testGuestbook()</code>, or restrict it to a set of specified table names with a whitelist as shown in <code class="literal">testFilteredGuestbook()</code> method. </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MySqlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $user = 'my_user';
        $password = 'my_password';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this-&gt;createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet($tableNames);
        // ...
    }
}
?&gt;</pre>
<h4 class="title" id="database.replacement-dataset">Replacement DataSet</h4>
<p> I have been talking about NULL problems with the Flat XML and CSV DataSet, but there is a slightly complicated workaround to get both types of datasets working with NULLs. </p>
<p> The Replacement DataSet is a decorator for an existing dataset and allows you to replace values in any column of the dataset by another replacement value. To get our guestbook example working with NULL values we specify the file like: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre>
<p> We then wrap the Flat XML DataSet into a Replacement DataSet: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ReplacementTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds = $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds-&gt;addFullReplacement('##NULL##', null);
        return $rds;
    }
}
?&gt;</pre>
<h4 class="title" id="database.dataset-filter">DataSet Filter</h4>
<p> If you have a large fixture file you can use the DataSet Filter for white- and blacklisting of tables and columns that should be contained in a sub-dataset. This is especially handy in combination with the DB DataSet to filter the columns of the datasets. </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetFilterTest extends TestCase
{
    use TestCaseTrait;

    public function testIncludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addIncludeTables(['guestbook']);
        $filterDataSet-&gt;setIncludeColumnsForTable('guestbook', ['id', 'content']);
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addExcludeTables(['foo', 'bar', 'baz']); // only keep the guestbook table!
        $filterDataSet-&gt;setExcludeColumnsForTable('guestbook', ['user', 'created']);
        // ..
    }
}
?&gt;</pre>
<div class="blockquote"><blockquote class="blockquote"><p> <span class="strong"><strong>NOTE</strong></span> You cannot use both exclude and include column filtering on the same table, only on different ones. Plus it is only possible to either white- or blacklist tables, not both of them. </p></blockquote></div>
<h4 class="title" id="database.composite-dataset">Composite DataSet</h4>
<p> The composite DataSet is very useful for aggregating several already existing datasets into a single dataset. When several datasets contain the same table the rows are appended in the specified order. For example if we have two datasets <span class="emphasis"><em>fixture1.xml</em></span>: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
&lt;/dataset&gt;
</pre>
<p> and <span class="emphasis"><em>fixture2.xml</em></span>: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre>
<p> Using the Composite DataSet we can aggregate both fixture files: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class CompositeTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds1 = $this-&gt;createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this-&gt;createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs-&gt;addDataSet($ds1);
        $compositeDs-&gt;addDataSet($ds2);

        return $compositeDs;
    }
}
?&gt;</pre>
<h3 class="title" id="database.beware-of-foreign-keys">Beware of Foreign Keys</h3>
<p> During Fixture SetUp PHPUnit's Database Extension inserts the rows into the database in the order they are specified in your fixture. If your database schema uses foreign keys this means you have to specify the tables in an order that does not cause foreign key constraints to fail. </p>
<h3 class="title" id="database.implementing-your-own-datasetsdatatables">Implementing your own DataSets/DataTables</h3>
<p> To understand the internals of DataSets and DataTables, lets have a look at the interface of a DataSet. You can skip this part if you do not plan to implement your own DataSet or DataTable. </p>
<pre class="programlisting" data-language="php">&lt;?php
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
?&gt;</pre>
<p> The public interface is used internally by the <code class="literal">assertDataSetsEqual()</code> assertion on the Database TestCase to check for dataset quality. From the <code class="literal">IteratorAggregate</code> interface the IDataSet inherits the <code class="literal">getIterator()</code> method to iterate over all tables of the dataset. The reverse iterator allows PHPUnit to truncate tables opposite the order they were created to satisfy foreign key constraints. </p>
<p> Depending on the implementation different approaches are taken to add table instances to a dataset. For example, tables are added internally during construction from the source file in all file-based datasets such as <code class="literal">YamlDataSet</code>, <code class="literal">XmlDataSet</code> or <code class="literal">FlatXmlDataSet</code>. </p>
<p> A table is also represented by the following interface: </p>
<pre class="programlisting" data-language="php">&lt;?php
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
?&gt;</pre>
<p> Except the <code class="literal">getTableMetaData()</code> method it is pretty self-explainatory. The used methods are all required for the different assertions of the Database Extension that are explained in the next chapter. The <code class="literal">getTableMetaData()</code> method has to return an implementation of the <code class="literal">PHPUnit_Extensions_Database_DataSet_ITableMetaData</code> interface, which describes the structure of the table. It holds information on: </p>
<div class="itemizedlist"><ul class="itemizedlist">
<li class="listitem"><p> The table name </p></li>
<li class="listitem"><p> An array of column-names of the table, ordered by their appearance in the result-set. </p></li>
<li class="listitem"><p> An array of the primary-key columns. </p></li>
</ul></div>
<p> This interface also has an assertion that checks if two instances of Table Metadata equal each other, which is used by the data-set equality assertion. </p>
<h2 class="title" id="database.the-connection-api">The Connection API</h2>
<p> There are three interesting methods on the Connection interface which has to be returned from the <code class="literal">getConnection()</code> method on the Database TestCase: </p>
<pre class="programlisting" data-language="php">&lt;?php
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
?&gt;</pre>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p> The <code class="literal">createDataSet()</code> method creates a Database (DB) DataSet as described in the DataSet implementations section. </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSet()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
    }
}
?&gt;</pre>
</li>
<li class="listitem">
<p> The <code class="literal">createQueryTable()</code> method can be used to create instances of a QueryTable, give them a result name and SQL query. This is a handy method when it comes to result/table assertions as will be shown in the next section on the Database Assertions API. </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateQueryTable()
    {
        $tableNames = ['guestbook'];
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable('guestbook', 'SELECT * FROM guestbook');
    }
}
?&gt;</pre>
</li>
<li class="listitem">
<p> The <code class="literal">getRowCount()</code> method is a convienent way to access the number of rows in a table, optionally filtered by an additional where clause. This can be used with a simple equality assertion: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testGetRowCount()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'));
    }
}
?&gt;</pre>
</li>
</ol></div>
<h2 class="title" id="database.database-assertions-api">Database Assertions API</h2>
<p> For a testing tool the Database Extension surely provides some assertions that you can use to verify the current state of the database, tables and the row-count of tables. This section describes this functionality in detail: </p>
<h3 class="title" id="database.asserting-the-row-count-of-a-table">Asserting the Row-Count of a Table</h3>
<p> It is often helpful to check if a table contains a specific amount of rows. You can easily achieve this without additional glue code using the Connection API. Say we wanted to check that after insertion of a row into our guestbook we not only have the two initial entries that have accompanied us in all the previous examples, but a third one: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), "Pre-Condition");

        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry("suzy", "Hello world!");

        $this-&gt;assertEquals(3, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), "Inserting failed");
    }
}
?&gt;</pre>
<h3 class="title" id="database.asserting-the-state-of-a-table">Asserting the State of a Table</h3>
<p> The previous assertion is helpful, but we surely want to check the actual contents of the table to verify that all the values were written into the correct columns. This can be achieved by a table assertion. </p>
<p> For this we would define a Query Table instance which derives its content from a table name and SQL query and compare it to a File/Array Based Data Set: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry("suzy", "Hello world!");

        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet("expectedBook.xml")
                              -&gt;getTable("guestbook");
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
?&gt;</pre>
<p> Now we have to write the <span class="emphasis"><em>expectedBook.xml</em></span> Flat XML file for this assertion: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" /&gt;
    &lt;guestbook id="3" content="Hello world!" user="suzy" created="2010-05-01 21:47:08" /&gt;
&lt;/dataset&gt;
</pre>
<p> This assertion would only pass on exactly one second of the universe though, on <span class="emphasis"><em>2010–05–01 21:47:08</em></span>. Dates pose a special problem to database testing and we can circumvent the failure by omitting the <span class="quote">“<span class="quote">created</span>”</span> column from the assertion. </p>
<p> The adjusted <span class="emphasis"><em>expectedBook.xml</em></span> Flat XML file would probably have to look like the following to make the assertion pass: </p>
<pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" /&gt;
    &lt;guestbook id="3" content="Hello world!" user="suzy" /&gt;
&lt;/dataset&gt;
</pre>
<p> We have to fix up the Query Table call: </p>
<pre class="programlisting" data-language="php">&lt;?php
$queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
?&gt;</pre>
<h3 class="title" id="database.asserting-the-result-of-a-query">Asserting the Result of a Query</h3>
<p> You can also assert the result of complex queries with the Query Table approach, just specify a result name with a query and compare it to a dataset: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ComplexQueryTest extends TestCase
{
    use TestCaseTrait;

    public function testComplexQuery()
    {
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet("complexQueryAssertion.xml")
                              -&gt;getTable("myComplexQuery");
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
?&gt;</pre>
<h3 class="title" id="database.asserting-the-state-of-multiple-tables">Asserting the State of Multiple Tables</h3>
<p> For sure you can assert the state of multiple tables at once and compare a query dataset against a file based dataset. There are two different ways for DataSet assertions. </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p> You can use the Database (DB) DataSet from the Connection and compare it to a File-Based DataSet. </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSetAssertion()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet(['guestbook']);
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');
        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?&gt;</pre>
</li>
<li class="listitem">
<p> You can construct the DataSet on your own: </p>
<pre class="programlisting" data-language="php">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testManualDataSetAssertion()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_QueryDataSet();
        $dataSet-&gt;addTable('guestbook', 'SELECT id, content, user FROM guestbook'); // additional tables
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');

        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?&gt;</pre>
</li>
</ol></div>
<h2 class="title" id="database.frequently-asked-questions">Frequently Asked Questions</h2>
<h3 class="title" id="database.will-phpunit-re-create-the-database-schema-for-each-test">Will PHPUnit (re-)create the database schema for each test?</h3>
<p> No, PHPUnit requires all database objects to be available when the suite is started. The Database, tables, sequences, triggers and views have to be created before you run the test suite. </p>
<p> <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a> or <a class="ulink" href="http://www.ezcomponents.org" target="_top">eZ Components</a> have powerful tools that allow you to create the database schema from pre-defined datastructures. However, these have to be hooked into the PHPUnit extension to allow an automatic database re-creation before the complete test-suite is run. </p>
<p> Since each test completely cleans the database you are not even required to re-create the database for each test-run. A permanently available database works perfectly. </p>
<h3 class="title" id="database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">Am I required to use PDO in my application for the Database Extension to work?</h3>
<p> No, PDO is only required for the fixture clean- and set-up and for assertions. You can use whatever database abstraction you want inside your own code. </p>
<h3 class="title" id="database.what-can-i-do-when-i-get-a-too-much-connections-error">What can I do, when I get a “Too much Connections” Error?</h3>
<p> If you do not cache the PDO instance that is created from the TestCase <code class="literal">getConnection()</code> method the number of connections to the database is increasing by one or more with each database test. With default configuration MySql only allows 100 concurrent connections other vendors also have maximum connection limits. </p>
<p> The SubSection <span class="quote">“<span class="quote">Use your own Abstract Database TestCase</span>”</span> shows how you can prevent this error from happening by using a single cached PDO instance in all your tests. </p>
<h3 class="title" id="database.how-to-handle-null-with-flat-xml-csv-datasets">How to handle NULL with Flat XML / CSV Datasets?</h3>
<p> Do not do this. Instead, you should use either the XML or the YAML DataSets. </p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2005–2017 Sebastian Bergmann<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>
    <a href="https://phpunit.de/manual/6.5/en/database.html" class="_attribution-link">https://phpunit.de/manual/6.5/en/database.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
