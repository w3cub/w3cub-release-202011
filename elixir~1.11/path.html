
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Path - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" This module provides conveniences for manipulating or retrieving file system paths. ">
  <meta name="keywords" content="path, summary, types, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/path.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Path   </h1> <section id="moduledoc"> <p>This module provides conveniences for manipulating or retrieving file system paths.</p>
<p>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</p>
<p>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like <a href="#wildcard/2"><code class="inline">wildcard/2</code></a> and <a href="#expand/1"><code class="inline">expand/1</code></a>).</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/1">absname(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the given path to an absolute one. Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/2">absname(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/1">basename(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/2">basename(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dirname/1">dirname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the directory component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/1">expand(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the path to an absolute one and expands any <code class="inline">.</code> and <code class="inline">..</code> characters and a leading <code class="inline">~</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/2">expand(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#extname/1">extname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the extension of the last component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/1">join(list)</a> </dt> <dd class="summary-synopsis"><p>Joins a list of paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/2">join(left, right)</a> </dt> <dd class="summary-synopsis"><p>Joins two paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative/1">relative(name)</a> </dt> <dd class="summary-synopsis"><p>Forces the path to be a relative path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to/2">relative_to(path, from)</a> </dt> <dd class="summary-synopsis"><p>Returns the given <code class="inline">path</code> relative to the given <code class="inline">from</code> path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to_cwd/1">relative_to_cwd(path)</a> </dt> <dd class="summary-synopsis"><p>Convenience to get the path relative to the current working directory.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/1">rootname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/2">rootname(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/1">split(path)</a> </dt> <dd class="summary-synopsis"><p>Splits the path into a list at the path separator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#type/1">type(name)</a> </dt> <dd class="summary-synopsis"><p>Returns the path type.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#wildcard/2">wildcard(glob, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: IO.chardata()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="absname/1">absname(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">absname(t()) :: binary()</pre> </div> <p>Converts the given path to an absolute one. Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p>
<h4 id="absname/1-examples" class="section-heading">  Examples </h4> <h3 id="absname/1-unix-like-operating-systems" class="section-heading">  Unix-like operating systems </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "/usr/local/foo"

Path.absname("../x")
#=&gt; "/usr/local/../x"</pre>
<h3 id="absname/1-windows" class="section-heading">  Windows </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "D:/usr/local/foo"

Path.absname("../x")
#=&gt; "D:/usr/local/../x"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="absname/2">absname(path, relative_to)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">absname(t(), t()) :: binary()</pre> </div> <p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p>
<p>If <code class="inline">path</code> is already an absolute path, <code class="inline">relative_to</code> is ignored. See also <a href="#relative_to/2"><code class="inline">relative_to/2</code></a>.</p>
<p>Unlike <a href="#expand/2"><code class="inline">expand/2</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p>
<h4 id="absname/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.absname("foo", "bar")
"bar/foo"

iex&gt; Path.absname("../x", "bar")
"bar/../x"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/1">basename(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">basename(t()) :: binary()</pre> </div> <p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p>
<h4 id="basename/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.basename("foo")
"foo"

iex&gt; Path.basename("foo/bar")
"bar"

iex&gt; Path.basename("/")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/2">basename(path, extension)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">basename(t(), t()) :: binary()</pre> </div> <p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="basename/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.basename("~/foo/bar.ex", ".ex")
"bar"

iex&gt; Path.basename("~/foo/bar.exs", ".ex")
"bar.exs"

iex&gt; Path.basename("~/foo/bar.old.ex", ".ex")
"bar.old"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dirname/1">dirname(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">dirname(t()) :: binary()</pre> </div> <p>Returns the directory component of <code class="inline">path</code>.</p>
<h4 id="dirname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.dirname("/foo/bar.ex")
"/foo"

iex&gt; Path.dirname("/foo/bar/baz.ex")
"/foo/bar"

iex&gt; Path.dirname("/foo/bar/")
"/foo/bar"

iex&gt; Path.dirname("bar.ex")
"."</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/1">expand(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">expand(t()) :: binary()</pre> </div> <p>Converts the path to an absolute one and expands any <code class="inline">.</code> and <code class="inline">..</code> characters and a leading <code class="inline">~</code>.</p>
<h4 id="expand/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Path.expand("/foo/bar/../baz")
#=&gt; "/foo/baz"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/2">expand(path, relative_to)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">expand(t(), t()) :: binary()</pre> </div> <p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p>
<p>If the path is already an absolute path, <code class="inline">relative_to</code> is ignored.</p>
<p>Note that this function treats a <code class="inline">path</code> with a leading <code class="inline">~</code> as an absolute one.</p>
<p>The second argument is first expanded to an absolute path.</p>
<h4 id="expand/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming that the absolute path to baz is /quux/baz
Path.expand("foo/bar/../bar", "baz")
#=&gt; "/quux/baz/foo/bar"

Path.expand("foo/bar/../bar", "/baz")
#=&gt; "/baz/foo/bar"

Path.expand("/foo/bar/../bar", "/baz")
#=&gt; "/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="extname/1">extname(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">extname(t()) :: binary()</pre> </div> <p>Returns the extension of the last component of <code class="inline">path</code>.</p>
<h4 id="extname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.extname("foo.erl")
".erl"

iex&gt; Path.extname("~/foo/bar")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/1">join(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">join([t(), ...]) :: binary()</pre> </div> <p>Joins a list of paths.</p>
<p>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</p>
<h4 id="join/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.join(["~", "foo"])
"~/foo"

iex&gt; Path.join(["foo"])
"foo"

iex&gt; Path.join(["/", "foo", "bar/"])
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/2">join(left, right)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">join(t(), t()) :: binary()</pre> </div> <p>Joins two paths.</p>
<p>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</p>
<h4 id="join/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.join("foo", "bar")
"foo/bar"

iex&gt; Path.join("/foo", "/bar/")
"/foo/bar"</pre>
<p>The functions in this module support chardata, so giving a list will treat it as a single entity:</p>
<pre data-language="elixir">iex&gt; Path.join("foo", ["bar", "fiz"])
"foo/barfiz"

iex&gt; Path.join(["foo", "bar"], "fiz")
"foobar/fiz"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative/1">relative(name)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">relative(t()) :: binary()</pre> </div> <p>Forces the path to be a relative path.</p>
<h4 id="relative/1-examples" class="section-heading">  Examples </h4> <h3 id="relative/1-unix-like-operating-systems" class="section-heading">  Unix-like operating systems </h3> <pre data-language="elixir">Path.relative("/usr/local/bin")   #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("../usr/local/bin") #=&gt; "../usr/local/bin"</pre>
<h3 id="relative/1-windows" class="section-heading">  Windows </h3> <pre data-language="elixir">Path.relative("D:/usr/local/bin") #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("D:bar.ex")         #=&gt; "bar.ex"
Path.relative("/bar/foo.ex")      #=&gt; "bar/foo.ex"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative_to/2">relative_to(path, from)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">relative_to(t(), t()) :: binary()</pre> </div> <p>Returns the given <code class="inline">path</code> relative to the given <code class="inline">from</code> path.</p>
<p>In other words, this function tries to strip the <code class="inline">from</code> prefix from <code class="inline">path</code>.</p>
<p>This function does not query the file system, so it assumes no symlinks between the paths.</p>
<p>In case a direct relative path cannot be found, it returns the original path.</p>
<h4 id="relative_to/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.relative_to("/usr/local/foo", "/usr/local")
"foo"

iex&gt; Path.relative_to("/usr/local/foo", "/")
"usr/local/foo"

iex&gt; Path.relative_to("/usr/local/foo", "/etc")
"/usr/local/foo"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative_to_cwd/1">relative_to_cwd(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">relative_to_cwd(t()) :: binary()</pre> </div> <p>Convenience to get the path relative to the current working directory.</p>
<p>If, for some reason, the current working directory cannot be retrieved, this function returns the given <code class="inline">path</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/1">rootname(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">rootname(t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<h4 id="rootname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.ex")
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/2">rootname(path, extension)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">rootname(t(), t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="rootname/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar.erl", ".erl")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.erl", ".ex")
"/foo/bar.erl"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/1">split(path)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split(t()) :: [binary()]</pre> </div> <p>Splits the path into a list at the path separator.</p>
<p>If an empty string is given, returns an empty list.</p>
<p>On Windows, path is split on both "\" and "/" separators and the driver letter, if there is one, is always returned in lowercase.</p>
<h4 id="split/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.split("")
[]

iex&gt; Path.split("foo")
["foo"]

iex&gt; Path.split("/foo/bar")
["/", "foo", "bar"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="type/1">type(name)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">type(t()) :: :absolute | :relative | :volumerelative</pre> </div> <p>Returns the path type.</p>
<h4 id="type/1-examples" class="section-heading">  Examples </h4> <h3 id="type/1-unix-like-operating-systems" class="section-heading">  Unix-like operating systems </h3> <pre data-language="elixir">Path.type("/")                #=&gt; :absolute
Path.type("/usr/local/bin")   #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("../usr/local/bin") #=&gt; :relative
Path.type("~/file")           #=&gt; :relative</pre>
<h3 id="type/1-windows" class="section-heading">  Windows </h3> <pre data-language="elixir">Path.type("D:/usr/local/bin") #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("D:bar.ex")         #=&gt; :volumerelative
Path.type("/bar/foo.ex")      #=&gt; :volumerelative</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="wildcard/2">wildcard(glob, opts \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">wildcard(t(), keyword()) :: [binary()]</pre> </div> <p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p>
<p>The wildcard looks like an ordinary path, except that the following "wildcard characters" are interpreted in a special way:</p>
<ul>
<li><p><code class="inline">?</code> - matches one character.</p></li>
<li><p><code class="inline">*</code> - matches any number of characters up to the end of the filename, the next dot, or the next slash.</p></li>
<li><p><code class="inline">**</code> - two adjacent <code class="inline">*</code>'s used as a single pattern will match all files and zero or more directories and subdirectories.</p></li>
<li><p><code class="inline">[char1,char2,...]</code> - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
<li><p><code class="inline">{item1,item2,...}</code> - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
</ul>
<p>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: <code class="inline">"a"</code> will not match <code class="inline">"A"</code>.</p>
<p>Directory separators must always be written as <code class="inline">/</code>, even on Windows. You may call <a href="#expand/1"><code class="inline">Path.expand/1</code></a> to normalize the path before invoking this function.</p>
<p>By default, the patterns <code class="inline">*</code> and <code class="inline">?</code> do not match files starting with a dot <code class="inline">.</code>. See the <code class="inline">:match_dot</code> option in the "Options" section below.</p>
<h4 id="wildcard/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:match_dot</code> - (boolean) if <code class="inline">false</code>, the special wildcard characters <code class="inline">*</code> and <code class="inline">?</code> will not match files starting with a dot (<code class="inline">.</code>). If <code class="inline">true</code>, files starting with a <code class="inline">.</code> will not be treated specially. Defaults to <code class="inline">false</code>.</li></ul>
<h4 id="wildcard/2-examples" class="section-heading">  Examples </h4> <p>Imagine you have a directory called <code class="inline">projects</code> with three Elixir projects inside of it: <code class="inline">elixir</code>, <code class="inline">ex_doc</code>, and <code class="inline">plug</code>. You can find all <code class="inline">.beam</code> files inside the <code class="inline">ebin</code> directory of each project as follows:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.beam")</pre>
<p>If you want to search for both <code class="inline">.beam</code> and <code class="inline">.app</code> files, you could do:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.{beam,app}")</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    Â© 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.11.2/Path.html" class="_attribution-link">https://hexdocs.pm/elixir/1.11.2/Path.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
