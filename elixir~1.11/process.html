
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Process - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" Conveniences for working with processes and the process dictionary. ">
  <meta name="keywords" content="process, summary, types, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/process.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/elixir~1.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Process   </h1> <section id="moduledoc"> <p>Conveniences for working with processes and the process dictionary.</p>
<p>Besides the functions available in this module, the <a href="https://hexdocs.pm/elixir/Kernel.html"><code class="inline">Kernel</code></a> module exposes and auto-imports some basic functionality related to processes available through the following functions:</p>
<ul>
<li>
<a href="https://hexdocs.pm/elixir/Kernel.html#spawn/1"><code class="inline">Kernel.spawn/1</code></a> and <a href="https://hexdocs.pm/elixir/Kernel.html#spawn/3"><code class="inline">Kernel.spawn/3</code></a>
</li>
<li>
<a href="https://hexdocs.pm/elixir/Kernel.html#spawn_link/1"><code class="inline">Kernel.spawn_link/1</code></a> and <a href="https://hexdocs.pm/elixir/Kernel.html#spawn_link/3"><code class="inline">Kernel.spawn_link/3</code></a>
</li>
<li>
<a href="https://hexdocs.pm/elixir/Kernel.html#spawn_monitor/1"><code class="inline">Kernel.spawn_monitor/1</code></a> and <a href="https://hexdocs.pm/elixir/Kernel.html#spawn_monitor/3"><code class="inline">Kernel.spawn_monitor/3</code></a>
</li>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#self/0"><code class="inline">Kernel.self/0</code></a></li>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#send/2"><code class="inline">Kernel.send/2</code></a></li>
</ul>
<p>While this module provides low-level conveniences to work with processes, developers typically use abstractions such as <a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a>, <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a>, <a href="https://hexdocs.pm/elixir/Registry.html"><code class="inline">Registry</code></a>, <a href="https://hexdocs.pm/elixir/Supervisor.html"><code class="inline">Supervisor</code></a> and <a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a> for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:dest/0">dest()</a> </dt> <dd class="summary-synopsis"><p>A process destination.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:spawn_opt/0">spawn_opt()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:spawn_opts/0">spawn_opts()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#alive?/1">alive?(pid)</a> </dt> <dd class="summary-synopsis"><p>Tells whether the given process is alive on the local node.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#cancel_timer/2">cancel_timer(timer_ref, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Cancels a timer returned by <a href="#send_after/3"><code class="inline">send_after/3</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete/1">delete(key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the given <code class="inline">key</code> from the process dictionary.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#demonitor/2">demonitor(monitor_ref, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Demonitors the monitor identified by the given <code class="inline">reference</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#exit/2">exit(pid, reason)</a> </dt> <dd class="summary-synopsis"><p>Sends an exit signal with the given <code class="inline">reason</code> to <code class="inline">pid</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flag/2">flag(flag, value)</a> </dt> <dd class="summary-synopsis"><p>Sets the given <code class="inline">flag</code> to <code class="inline">value</code> for the calling process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flag/3">flag(pid, flag, value)</a> </dt> <dd class="summary-synopsis"><p>Sets the given <code class="inline">flag</code> to <code class="inline">value</code> for the given process <code class="inline">pid</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get/0">get()</a> </dt> <dd class="summary-synopsis"><p>Returns all key-value pairs in the process dictionary.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get/2">get(key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns the value for the given <code class="inline">key</code> in the process dictionary, or <code class="inline">default</code> if <code class="inline">key</code> is not set.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_keys/0">get_keys()</a> </dt> <dd class="summary-synopsis"><p>Returns all keys in the process dictionary.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_keys/1">get_keys(value)</a> </dt> <dd class="summary-synopsis"><p>Returns all keys in the process dictionary that have the given <code class="inline">value</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#group_leader/0">group_leader()</a> </dt> <dd class="summary-synopsis"><p>Returns the PID of the group leader for the calling process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#group_leader/2">group_leader(pid, leader)</a> </dt> <dd class="summary-synopsis"><p>Sets the group leader of the given <code class="inline">pid</code> to <code class="inline">leader</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#hibernate/3">hibernate(mod, fun_name, args)</a> </dt> <dd class="summary-synopsis"><p>Puts the calling process into a "hibernation" state.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#info/1">info(pid)</a> </dt> <dd class="summary-synopsis"><p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#info/2">info(pid, spec)</a> </dt> <dd class="summary-synopsis"><p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#link/1">link(pid_or_port)</a> </dt> <dd class="summary-synopsis"><p>Creates a link between the calling process and the given item (process or port).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#list/0">list()</a> </dt> <dd class="summary-synopsis"><p>Returns a list of PIDs corresponding to all the processes currently existing on the local node.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#monitor/1">monitor(item)</a> </dt> <dd class="summary-synopsis"><p>Starts monitoring the given <code class="inline">item</code> from the calling process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put/2">put(key, value)</a> </dt> <dd class="summary-synopsis"><p>Stores the given <code class="inline">key</code>-<code class="inline">value</code> pair in the process dictionary.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#read_timer/1">read_timer(timer_ref)</a> </dt> <dd class="summary-synopsis"><p>Reads a timer created by <a href="#send_after/3"><code class="inline">send_after/3</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#register/2">register(pid_or_port, name)</a> </dt> <dd class="summary-synopsis"><p>Registers the given <code class="inline">pid_or_port</code> under the given <code class="inline">name</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#registered/0">registered()</a> </dt> <dd class="summary-synopsis"><p>Returns a list of names which have been registered using <a href="#register/2"><code class="inline">register/2</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send/3">send(dest, msg, options)</a> </dt> <dd class="summary-synopsis"><p>Sends a message to the given <code class="inline">dest</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_after/4">send_after(dest, msg, time, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Sends <code class="inline">msg</code> to <code class="inline">dest</code> after <code class="inline">time</code> milliseconds.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sleep/1">sleep(timeout)</a> </dt> <dd class="summary-synopsis"><p>Sleeps the current process for the given <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn/2">spawn(fun, opts)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given function according to the given options.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn/4">spawn(mod, fun, args, opts)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given function <code class="inline">fun</code> from module <code class="inline">mod</code>, passing the given <code class="inline">args</code> according to the given options.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unlink/1">unlink(pid_or_port)</a> </dt> <dd class="summary-synopsis"><p>Removes the link between the calling process and the given item (process or port).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unregister/1">unregister(name)</a> </dt> <dd class="summary-synopsis"><p>Removes the registered <code class="inline">name</code>, associated with a PID or a port identifier.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#whereis/1">whereis(name)</a> </dt> <dd class="summary-synopsis"><p>Returns the PID or port identifier registered under <code class="inline">name</code> or <code class="inline">nil</code> if the name is not registered.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:dest/0">dest()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">dest() ::
  pid()
  | port()
  | (registered_name :: atom())
  | {registered_name :: atom(), node()}</pre> </div> <p>A process destination.</p>
<p>A remote or local PID, a local port, a locally registered name, or a tuple in the form of <code class="inline">{registered_name, node}</code> for a registered name at another node.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:spawn_opt/0">spawn_opt()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn_opt() ::
  :link
  | :monitor
  | {:priority, :low | :normal | :high}
  | {:fullsweep_after, non_neg_integer()}
  | {:min_heap_size, non_neg_integer()}
  | {:min_bin_vheap_size, non_neg_integer()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:spawn_opts/0">spawn_opts()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn_opts() :: [spawn_opt()]</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="alive?/1">alive?(pid)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">alive?(pid()) :: boolean()</pre> </div> <p>Tells whether the given process is alive on the local node.</p>
<p>If the process identified by <code class="inline">pid</code> is alive (that is, it's not exiting and has not exited yet) than this function returns <code class="inline">true</code>. Otherwise, it returns <code class="inline">false</code>.</p>
<p><code class="inline">pid</code> must refer to a process running on the local node or <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> is raised.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="cancel_timer/2">cancel_timer(timer_ref, options \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">cancel_timer(reference(), options) :: non_neg_integer() | false | :ok
when options: [async: boolean(), info: boolean()]</pre> </div> <p>Cancels a timer returned by <a href="#send_after/3"><code class="inline">send_after/3</code></a>.</p>
<p>When the result is an integer, it represents the time in milliseconds left until the timer would have expired.</p>
<p>When the result is <code class="inline">false</code>, a timer corresponding to <code class="inline">timer_ref</code> could not be found. This can happen either because the timer expired, because it has already been canceled, or because <code class="inline">timer_ref</code> never corresponded to a timer.</p>
<p>Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet.</p>
<p>Inlined by the compiler.</p>
<h4 id="cancel_timer/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:async</code> - (boolean) when <code class="inline">false</code>, the request for cancellation is synchronous. When <code class="inline">true</code>, the request for cancellation is asynchronous, meaning that the request to cancel the timer is issued and <code class="inline">:ok</code> is returned right away. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:info</code> - (boolean) whether to return information about the timer being cancelled. When the <code class="inline">:async</code> option is <code class="inline">false</code> and <code class="inline">:info</code> is <code class="inline">true</code>, then either an integer or <code class="inline">false</code> (like described above) is returned. If <code class="inline">:async</code> is <code class="inline">false</code> and <code class="inline">:info</code> is <code class="inline">false</code>, <code class="inline">:ok</code> is returned. If <code class="inline">:async</code> is <code class="inline">true</code> and <code class="inline">:info</code> is <code class="inline">true</code>, a message in the form <code class="inline">{:cancel_timer, timer_ref, result}</code> (where <code class="inline">result</code> is an integer or <code class="inline">false</code> like described above) is sent to the caller of this function when the cancellation has been performed. If <code class="inline">:async</code> is <code class="inline">true</code> and <code class="inline">:info</code> is <code class="inline">false</code>, no message is sent. Defaults to <code class="inline">true</code>.</p></li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete/1">delete(key)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete(term()) :: term() | nil</pre> </div> <p>Deletes the given <code class="inline">key</code> from the process dictionary.</p>
<p>Returns the value that was under <code class="inline">key</code> in the process dictionary, or <code class="inline">nil</code> if <code class="inline">key</code> was not stored in the process dictionary.</p>
<h4 id="delete/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Process.put(:comments, ["comment", "other comment"])
iex&gt; Process.delete(:comments)
["comment", "other comment"]
iex&gt; Process.delete(:comments)
nil</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="demonitor/2">demonitor(monitor_ref, options \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">demonitor(reference(), options :: [:flush | :info]) :: boolean()</pre> </div> <p>Demonitors the monitor identified by the given <code class="inline">reference</code>.</p>
<p>If <code class="inline">monitor_ref</code> is a reference which the calling process obtained by calling <a href="#monitor/1"><code class="inline">monitor/1</code></a>, that monitoring is turned off. If the monitoring is already turned off, nothing happens.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#demonitor-2"><code class="inline">:erlang.demonitor/2</code></a> for more information.</p>
<p>Inlined by the compiler.</p>
<h4 id="demonitor/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">pid = spawn(fn -&gt; 1 + 2 end)
ref = Process.monitor(pid)
Process.demonitor(ref)
#=&gt; true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="exit/2">exit(pid, reason)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">exit(pid(), term()) :: true</pre> </div> <p>Sends an exit signal with the given <code class="inline">reason</code> to <code class="inline">pid</code>.</p>
<p>The following behaviour applies if <code class="inline">reason</code> is any term except <code class="inline">:normal</code> or <code class="inline">:kill</code>:</p>
<ol>
<li><p>If <code class="inline">pid</code> is not trapping exits, <code class="inline">pid</code> will exit with the given <code class="inline">reason</code>.</p></li>
<li><p>If <code class="inline">pid</code> is trapping exits, the exit signal is transformed into a message <code class="inline">{:EXIT, from, reason}</code> and delivered to the message queue of <code class="inline">pid</code>.</p></li>
</ol>
<p>If <code class="inline">reason</code> is the atom <code class="inline">:normal</code>, <code class="inline">pid</code> will not exit (unless <code class="inline">pid</code> is the calling process, in which case it will exit with the reason <code class="inline">:normal</code>). If it is trapping exits, the exit signal is transformed into a message <code class="inline">{:EXIT, from, :normal}</code> and delivered to its message queue.</p>
<p>If <code class="inline">reason</code> is the atom <code class="inline">:kill</code>, that is if <code class="inline">Process.exit(pid, :kill)</code> is called, an untrappable exit signal is sent to <code class="inline">pid</code> which will unconditionally exit with reason <code class="inline">:killed</code>.</p>
<p>Inlined by the compiler.</p>
<h4 id="exit/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.exit(pid, :kill)
#=&gt; true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flag/2">flag(flag, value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">flag(:error_handler, module()) :: module()</pre> <pre data-language="elixir">flag(:max_heap_size, heap_size()) :: heap_size()</pre> <pre data-language="elixir">flag(:message_queue_data, :off_heap | :on_heap) :: :off_heap | :on_heap</pre> <pre data-language="elixir">flag(:min_bin_vheap_size, non_neg_integer()) :: non_neg_integer()</pre> <pre data-language="elixir">flag(:min_heap_size, non_neg_integer()) :: non_neg_integer()</pre> <pre data-language="elixir">flag(:priority, priority_level()) :: priority_level()</pre> <pre data-language="elixir">flag(:save_calls, 0..10000) :: 0..10000</pre> <pre data-language="elixir">flag(:sensitive, boolean()) :: boolean()</pre> <pre data-language="elixir">flag(:trap_exit, boolean()) :: boolean()</pre> </div> <p>Sets the given <code class="inline">flag</code> to <code class="inline">value</code> for the calling process.</p>
<p>Returns the old value of <code class="inline">flag</code>.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_flag-2"><code class="inline">:erlang.process_flag/2</code></a> for more information.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="flag/3">flag(pid, flag, value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">flag(pid(), :save_calls, 0..10000) :: 0..10000</pre> </div> <p>Sets the given <code class="inline">flag</code> to <code class="inline">value</code> for the given process <code class="inline">pid</code>.</p>
<p>Returns the old value of <code class="inline">flag</code>.</p>
<p>It raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if <code class="inline">pid</code> is not a local process.</p>
<p>The allowed values for <code class="inline">flag</code> are only a subset of those allowed in <a href="#flag/2"><code class="inline">flag/2</code></a>, namely <code class="inline">:save_calls</code>.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_flag-3"><code class="inline">:erlang.process_flag/3</code></a> for more information.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get/0">get()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get() :: [{term(), term()}]</pre> </div> <p>Returns all key-value pairs in the process dictionary.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="get/2">get(key, default \\ nil)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get(term(), default :: term()) :: term()</pre> </div> <p>Returns the value for the given <code class="inline">key</code> in the process dictionary, or <code class="inline">default</code> if <code class="inline">key</code> is not set.</p>
<h4 id="get/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming :locale was not set
iex&gt; Process.get(:locale, "pt")
"pt"
iex&gt; Process.put(:locale, "fr")
nil
iex&gt; Process.get(:locale, "pt")
"fr"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_keys/0">get_keys()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_keys() :: [term()]</pre> </div> <p>Returns all keys in the process dictionary.</p>
<p>Inlined by the compiler.</p>
<h4 id="get_keys/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming :locale was not set
iex&gt; :locale in Process.get_keys()
false
iex&gt; Process.put(:locale, "pt")
nil
iex&gt; :locale in Process.get_keys()
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_keys/1">get_keys(value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_keys(term()) :: [term()]</pre> </div> <p>Returns all keys in the process dictionary that have the given <code class="inline">value</code>.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="group_leader/0">group_leader()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">group_leader() :: pid()</pre> </div> <p>Returns the PID of the group leader for the calling process.</p>
<p>Inlined by the compiler.</p>
<h4 id="group_leader/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.group_leader()
#=&gt; #PID&lt;0.53.0&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="group_leader/2">group_leader(pid, leader)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">group_leader(pid(), leader :: pid()) :: true</pre> </div> <p>Sets the group leader of the given <code class="inline">pid</code> to <code class="inline">leader</code>.</p>
<p>Typically, this is used when a process started from a certain shell should have a group leader other than <code class="inline">:init</code>.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="hibernate/3">hibernate(mod, fun_name, args)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">hibernate(module(), atom(), list()) :: no_return()</pre> </div> <p>Puts the calling process into a "hibernation" state.</p>
<p>The calling process is put into a waiting state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#hibernate-3"><code class="inline">:erlang.hibernate/3</code></a> for more information.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="info/1">info(pid)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">info(pid()) :: keyword() | nil</pre> </div> <p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive.</p>
<p>Use this only for debugging information.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_info-1"><code class="inline">:erlang.process_info/1</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="info/2">info(pid, spec)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">info(pid(), atom() | [atom()]) :: {atom(), term()} | [{atom(), term()}] | nil</pre> </div> <p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_info-2"><code class="inline">:erlang.process_info/2</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="link/1">link(pid_or_port)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">link(pid() | port()) :: true</pre> </div> <p>Creates a link between the calling process and the given item (process or port).</p>
<p>Links are bidirectional. Linked processes can be unlinked by using <a href="#unlink/1"><code class="inline">unlink/1</code></a>.</p>
<p>If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen.</p>
<p>When two processes are linked, each one receives exit signals from the other (see also <a href="#exit/2"><code class="inline">exit/2</code></a>). Let's assume <code class="inline">pid1</code> and <code class="inline">pid2</code> are linked. If <code class="inline">pid2</code> exits with a reason other than <code class="inline">:normal</code> (which is also the exit reason used when a process finishes its job) and <code class="inline">pid1</code> is not trapping exits (see <a href="#flag/2"><code class="inline">flag/2</code></a>), then <code class="inline">pid1</code> will exit with the same reason as <code class="inline">pid2</code> and in turn emit an exit signal to all its other linked processes. The behaviour when <code class="inline">pid1</code> is trapping exits is described in <a href="#exit/2"><code class="inline">exit/2</code></a>.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#link-1"><code class="inline">:erlang.link/1</code></a> for more information.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="list/0">list()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">list() :: [pid()]</pre> </div> <p>Returns a list of PIDs corresponding to all the processes currently existing on the local node.</p>
<p>Note that if a process is exiting, it is considered to exist but not be alive. This means that for such process, <a href="#alive?/1"><code class="inline">alive?/1</code></a> will return <code class="inline">false</code> but its PID will be part of the list of PIDs returned by this function.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#processes-0"><code class="inline">:erlang.processes/0</code></a> for more information.</p>
<p>Inlined by the compiler.</p>
<h4 id="list/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.list()
#=&gt; [#PID&lt;0.0.0&gt;, #PID&lt;0.1.0&gt;, #PID&lt;0.2.0&gt;, #PID&lt;0.3.0&gt;, ...]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="monitor/1">monitor(item)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">monitor(pid() | {name, node()} | name) :: reference() when name: atom()</pre> </div> <p>Starts monitoring the given <code class="inline">item</code> from the calling process.</p>
<p>Once the monitored process dies, a message is delivered to the monitoring process in the shape of:</p>
<pre data-language="elixir">{:DOWN, ref, :process, object, reason}</pre>
<p>where:</p>
<ul>
<li>
<code class="inline">ref</code> is a monitor reference returned by this function;</li>
<li>
<code class="inline">object</code> is either a <code class="inline">pid</code> of the monitored process (if monitoring a PID) or <code class="inline">{name, node}</code> (if monitoring a remote or local name);</li>
<li>
<code class="inline">reason</code> is the exit reason.</li>
</ul>
<p>If the process is already dead when calling <a href="#monitor/1"><code class="inline">Process.monitor/1</code></a>, a <code class="inline">:DOWN</code> message is delivered immediately.</p>
<p>See <a href="https://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring">the need for monitoring</a> for an example. See <a href="http://www.erlang.org/doc/man/erlang.html#monitor-2"><code class="inline">:erlang.monitor/2</code></a> for more information.</p>
<p>Inlined by the compiler.</p>
<h4 id="monitor/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">pid = spawn(fn -&gt; 1 + 2 end)
#=&gt; #PID&lt;0.118.0&gt;
Process.monitor(pid)
#=&gt; #Reference&lt;0.906660723.3006791681.40191&gt;
Process.exit(pid, :kill)
#=&gt; true
receive do
  msg -&gt; msg
end
#=&gt; {:DOWN, #Reference&lt;0.906660723.3006791681.40191&gt;, :process, #PID&lt;0.118.0&gt;, :noproc}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put/2">put(key, value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put(term(), term()) :: term() | nil</pre> </div> <p>Stores the given <code class="inline">key</code>-<code class="inline">value</code> pair in the process dictionary.</p>
<p>The return value of this function is the value that was previously stored under <code class="inline">key</code>, or <code class="inline">nil</code> in case no value was stored under it.</p>
<h4 id="put/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming :locale was not set
iex&gt; Process.put(:locale, "en")
nil
iex&gt; Process.put(:locale, "fr")
"en"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="read_timer/1">read_timer(timer_ref)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">read_timer(reference()) :: non_neg_integer() | false</pre> </div> <p>Reads a timer created by <a href="#send_after/3"><code class="inline">send_after/3</code></a>.</p>
<p>When the result is an integer, it represents the time in milliseconds left until the timer will expire.</p>
<p>When the result is <code class="inline">false</code>, a timer corresponding to <code class="inline">timer_ref</code> could not be found. This can be either because the timer expired, because it has already been canceled, or because <code class="inline">timer_ref</code> never corresponded to a timer.</p>
<p>Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="register/2">register(pid_or_port, name)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">register(pid() | port(), atom()) :: true</pre> </div> <p>Registers the given <code class="inline">pid_or_port</code> under the given <code class="inline">name</code>.</p>
<p><code class="inline">name</code> must be an atom and can then be used instead of the PID/port identifier when sending messages with <a href="https://hexdocs.pm/elixir/Kernel.html#send/2"><code class="inline">Kernel.send/2</code></a>.</p>
<p><a href="#register/2"><code class="inline">register/2</code></a> will fail with <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> in any of the following cases:</p>
<ul>
<li>the PID/Port is not existing locally and alive</li>
<li>the name is already registered</li>
<li>the <code class="inline">pid_or_port</code> is already registered under a different <code class="inline">name</code>
</li>
</ul>
<p>The following names are reserved and cannot be assigned to processes nor ports:</p>
<ul>
<li><code class="inline">nil</code></li>
<li><code class="inline">false</code></li>
<li><code class="inline">true</code></li>
<li><code class="inline">:undefined</code></li>
</ul>
<h4 id="register/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.register(self(), :test)
#=&gt; true
send(:test, :hello)
#=&gt; :hello
send(:wrong_name, :hello)
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="registered/0">registered()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">registered() :: [atom()]</pre> </div> <p>Returns a list of names which have been registered using <a href="#register/2"><code class="inline">register/2</code></a>.</p>
<p>Inlined by the compiler.</p>
<h4 id="registered/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.register(self(), :test)
Process.registered()
#=&gt; [:test, :elixir_config, :inet_db, ...]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="send/3">send(dest, msg, options)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">send(dest, msg, [option]) :: :ok | :noconnect | :nosuspend
when dest: dest(), msg: any(), option: :noconnect | :nosuspend</pre> </div> <p>Sends a message to the given <code class="inline">dest</code>.</p>
<p><code class="inline">dest</code> may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of <code class="inline">{registered_name, node}</code> for a registered name at another node.</p>
<p>Inlined by the compiler.</p>
<h4 id="send/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:noconnect</code> - when used, if sending the message would require an auto-connection to another node the message is not sent and <code class="inline">:noconnect</code> is returned.</p></li>
<li><p><code class="inline">:nosuspend</code> - when used, if sending the message would cause the sender to be suspended the message is not sent and <code class="inline">:nosuspend</code> is returned.</p></li>
</ul>
<p>Otherwise the message is sent and <code class="inline">:ok</code> is returned.</p>
<h4 id="send/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Process.send({:name, :node_that_does_not_exist}, :hi, [:noconnect])
:noconnect</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="send_after/4">send_after(dest, msg, time, opts \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">send_after(pid() | atom(), term(), non_neg_integer(), [option]) :: reference()
when option: {:abs, boolean()}</pre> </div> <p>Sends <code class="inline">msg</code> to <code class="inline">dest</code> after <code class="inline">time</code> milliseconds.</p>
<p>If <code class="inline">dest</code> is a PID, it must be the PID of a local process, dead or alive. If <code class="inline">dest</code> is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process.</p>
<p>The message is not sent immediately. Therefore, <code class="inline">dest</code> can receive other messages in-between even when <code class="inline">time</code> is <code class="inline">0</code>.</p>
<p>This function returns a timer reference, which can be read with <a href="#read_timer/1"><code class="inline">read_timer/1</code></a> or canceled with <a href="#cancel_timer/1"><code class="inline">cancel_timer/1</code></a>.</p>
<p>The timer will be automatically canceled if the given <code class="inline">dest</code> is a PID which is not alive or when the given PID exits. Note that timers will not be automatically canceled when <code class="inline">dest</code> is an atom (as the atom resolution is done on delivery).</p>
<p>Inlined by the compiler.</p>
<h4 id="send_after/4-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:abs</code> - (boolean) when <code class="inline">false</code>, <code class="inline">time</code> is treated as relative to the current monotonic time. When <code class="inline">true</code>, <code class="inline">time</code> is the absolute value of the Erlang monotonic time at which <code class="inline">msg</code> should be delivered to <code class="inline">dest</code>. To read more about Erlang monotonic time and other time-related concepts, look at the documentation for the <a href="https://hexdocs.pm/elixir/System.html"><code class="inline">System</code></a> module. Defaults to <code class="inline">false</code>.</li></ul>
<h4 id="send_after/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">timer_ref = Process.send_after(pid, :hi, 1000)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sleep/1">sleep(timeout)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">sleep(timeout()) :: :ok</pre> </div> <p>Sleeps the current process for the given <code class="inline">timeout</code>.</p>
<p><code class="inline">timeout</code> is either the number of milliseconds to sleep as an integer or the atom <code class="inline">:infinity</code>. When <code class="inline">:infinity</code> is given, the current process will sleep forever, and not consume or reply to messages.</p>
<p><strong>Use this function with extreme care</strong>. For almost all situations where you would use <a href="#sleep/1"><code class="inline">sleep/1</code></a> in Elixir, there is likely a more correct, faster and precise way of achieving the same with message passing.</p>
<p>For example, if you are waiting for a process to perform some action, it is better to communicate the progress of such action with messages.</p>
<p>In other words, <strong>do not</strong>:</p>
<pre data-language="elixir">Task.start_link(fn -&gt;
  do_something()
  ...
end)

# Wait until work is done
Process.sleep(2000)</pre>
<p>But <strong>do</strong>:</p>
<pre data-language="elixir">parent = self()

Task.start_link(fn -&gt;
  do_something()
  send(parent, :work_is_done)
  ...
end)

receive do
  :work_is_done -&gt; :ok
after
  # Optional timeout
  30_000 -&gt; :timeout
end</pre>
<p>For cases like the one above, <a href="https://hexdocs.pm/elixir/Task.html#async/1"><code class="inline">Task.async/1</code></a> and <a href="https://hexdocs.pm/elixir/Task.html#await/2"><code class="inline">Task.await/2</code></a> are preferred.</p>
<p>Similarly, if you are waiting for a process to terminate, monitor that process instead of sleeping. <strong>Do not</strong>:</p>
<pre data-language="elixir">Task.start_link(fn -&gt;
  ...
end)

# Wait until task terminates
Process.sleep(2000)</pre>
<p>Instead <strong>do</strong>:</p>
<pre data-language="elixir">{:ok, pid} =
  Task.start_link(fn -&gt;
    ...
  end)

ref = Process.monitor(pid)

receive do
  {:DOWN, ^ref, _, _, _} -&gt; :task_is_down
after
  # Optional timeout
  30_000 -&gt; :timeout
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn/2">spawn(fun, opts)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn((() -&gt; any()), spawn_opts()) :: pid() | {pid(), reference()}</pre> </div> <p>Spawns the given function according to the given options.</p>
<p>The result depends on the given options. In particular, if <code class="inline">:monitor</code> is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID.</p>
<p>More options are available; for the comprehensive list of available options check <a href="http://www.erlang.org/doc/man/erlang.html#spawn_opt-4"><code class="inline">:erlang.spawn_opt/4</code></a>.</p>
<p>Inlined by the compiler.</p>
<h4 id="spawn/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.spawn(fn -&gt; 1 + 2 end, [:monitor])
#=&gt; {#PID&lt;0.93.0&gt;, #Reference&lt;0.18808174.1939079169.202418&gt;}
Process.spawn(fn -&gt; 1 + 2 end, [:link])
#=&gt; #PID&lt;0.95.0&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn/4">spawn(mod, fun, args, opts)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn(module(), atom(), list(), spawn_opts()) :: pid() | {pid(), reference()}</pre> </div> <p>Spawns the given function <code class="inline">fun</code> from module <code class="inline">mod</code>, passing the given <code class="inline">args</code> according to the given options.</p>
<p>The result depends on the given options. In particular, if <code class="inline">:monitor</code> is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID.</p>
<p>It also accepts extra options, for the list of available options check <a href="http://www.erlang.org/doc/man/erlang.html#spawn_opt-4"><code class="inline">:erlang.spawn_opt/4</code></a>.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="unlink/1">unlink(pid_or_port)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unlink(pid() | port()) :: true</pre> </div> <p>Removes the link between the calling process and the given item (process or port).</p>
<p>If there is no such link, this function does nothing. If <code class="inline">pid_or_port</code> does not exist, this function does not produce any errors and simply does nothing.</p>
<p>The return value of this function is always <code class="inline">true</code>.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#unlink-1"><code class="inline">:erlang.unlink/1</code></a> for more information.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="unregister/1">unregister(name)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unregister(atom()) :: true</pre> </div> <p>Removes the registered <code class="inline">name</code>, associated with a PID or a port identifier.</p>
<p>Fails with <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the name is not registered to any PID or port.</p>
<p>Inlined by the compiler.</p>
<h4 id="unregister/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.register(self(), :test)
#=&gt; true
Process.unregister(:test)
#=&gt; true
Process.unregister(:wrong_name)
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="whereis/1">whereis(name)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">whereis(atom()) :: pid() | port() | nil</pre> </div> <p>Returns the PID or port identifier registered under <code class="inline">name</code> or <code class="inline">nil</code> if the name is not registered.</p>
<p>See <a href="http://www.erlang.org/doc/man/erlang.html#whereis-1"><code class="inline">:erlang.whereis/1</code></a> for more information.</p>
<h4 id="whereis/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Process.register(self(), :test)
Process.whereis(:test)
#=&gt; #PID&lt;0.84.0&gt;
Process.whereis(:wrong_name)
#=&gt; nil</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    Â© 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.11.2/Process.html" class="_attribution-link">https://hexdocs.pm/elixir/1.11.2/Process.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
