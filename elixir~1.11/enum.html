
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Enum - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" Provides a set of algorithms to work with enumerables. ">
  <meta name="keywords" content="enum, summary, types, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/enum.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Enum   </h1> <section id="moduledoc"> <p>Provides a set of algorithms to work with enumerables.</p>
<p>In Elixir, an enumerable is any data type that implements the <a href="https://hexdocs.pm/elixir/Enumerable.html"><code class="inline">Enumerable</code></a> protocol. <a href="https://hexdocs.pm/elixir/List.html"><code class="inline">List</code></a>s (<code class="inline">[1, 2, 3]</code>), <a href="https://hexdocs.pm/elixir/Map.html"><code class="inline">Map</code></a>s (<code class="inline">%{foo: 1, bar: 2}</code>) and <a href="https://hexdocs.pm/elixir/Range.html"><code class="inline">Range</code></a>s (<code class="inline">1..3</code>) are common data types used as enumerables:</p>
<pre data-language="elixir">iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.sum([1, 2, 3])
6

iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.sum(1..3)
6

iex&gt; map = %{"a" =&gt; 1, "b" =&gt; 2}
iex&gt; Enum.map(map, fn {k, v} -&gt; {k, v * 2} end)
[{"a", 2}, {"b", 4}]</pre>
<p>However, many other enumerables exist in the language, such as <a href="https://hexdocs.pm/elixir/MapSet.html"><code class="inline">MapSet</code></a>s and the data type returned by <a href="https://hexdocs.pm/elixir/File.html#stream!/3"><code class="inline">File.stream!/3</code></a> which allows a file to be traversed as if it was an enumerable.</p>
<p>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as <a href="#map/2"><code class="inline">Enum.map/2</code></a>. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</p>
<p>This linear behaviour should also be expected on operations like <a href="#count/1"><code class="inline">count/1</code></a>, <a href="#member?/2"><code class="inline">member?/2</code></a>, <a href="#at/2"><code class="inline">at/2</code></a> and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the <a href="#content"><code class="inline">Enum</code></a> module is meant to work with a large variety of data types and not all data types can provide optimized behaviour.</p>
<p>Finally, note the functions in the <a href="#content"><code class="inline">Enum</code></a> module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the <a href="https://hexdocs.pm/elixir/Stream.html"><code class="inline">Stream</code></a> module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the <a href="https://hexdocs.pm/elixir/Stream.html"><code class="inline">Stream</code></a> module for examples and documentation.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:acc/0">acc()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:default/0">default()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:element/0">element()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:index/0">index()</a> </dt> <dd class="summary-synopsis"><p>Zero-based index. It can also be a negative integer.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#all?/2">all?(enumerable, fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for all elements in <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#any?/2">any?(enumerable, fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for at least one element in <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#at/3">at(enumerable, index, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_by/2">chunk_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_every/2">chunk_every(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Shortcut to <code class="inline">chunk_every(enumerable, count, count)</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_every/4">chunk_every(enumerable, count, step, leftover \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns list of lists containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_while/4">chunk_while(enumerable, acc, chunk_fun, after_fun)</a> </dt> <dd class="summary-synopsis"><p>Chunks the <code class="inline">enumerable</code> with fine grained control when every chunk is emitted.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#concat/1">concat(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Given an enumerable of enumerables, concatenates the <code class="inline">enumerables</code> into a single list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#concat/2">concat(left, right)</a> </dt> <dd class="summary-synopsis"><p>Concatenates the enumerable on the <code class="inline">right</code> with the enumerable on the <code class="inline">left</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count/1">count(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns the size of the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count/2">count(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns the count of elements in the <code class="inline">enumerable</code> for which <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dedup/1">dedup(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dedup_by/2">dedup_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop/2">drop(enumerable, amount)</a> </dt> <dd class="summary-synopsis"><p>Drops the <code class="inline">amount</code> of elements from the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop_every/2">drop_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code> dropped, starting with the first element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop_while/2">drop_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Drops elements at the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#each/2">each(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#empty?/1">empty?(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Determines if the <code class="inline">enumerable</code> is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch/2">fetch(enumerable, index)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch!/2">fetch!(enumerable, index)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#filter/2">filter(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Filters the <code class="inline">enumerable</code>, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find/3">find(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns the first element for which <code class="inline">fun</code> returns a truthy value. If no such element is found, returns <code class="inline">default</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find_index/2">find_index(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find_value/3">find_value(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flat_map/2">flat_map(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flat_map_reduce/3">flat_map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Maps and reduces an <code class="inline">enumerable</code>, flattening the given results (only one level deep).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#frequencies/1">frequencies(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a map with keys as unique elements of <code class="inline">enumerable</code> and values as the count of every element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#frequencies_by/2">frequencies_by(enumerable, key_fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a map with keys as unique elements given by <code class="inline">key_fun</code> and values as the count of every element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#group_by/3">group_by(enumerable, key_fun, value_fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> into groups based on <code class="inline">key_fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#intersperse/2">intersperse(enumerable, element)</a> </dt> <dd class="summary-synopsis"><p>Intersperses <code class="inline">element</code> between each element of the enumeration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#into/2">into(enumerable, collectable)</a> </dt> <dd class="summary-synopsis"><p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#into/3">into(enumerable, collectable, transform)</a> </dt> <dd class="summary-synopsis"><p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/2">join(enumerable, joiner \\ "")</a> </dt> <dd class="summary-synopsis"><p>Joins the given <code class="inline">enumerable</code> into a string using <code class="inline">joiner</code> as a separator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map/2">map(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list where each element is the result of invoking <code class="inline">fun</code> on each corresponding element of <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_every/3">map_every(enumerable, nth, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of results of invoking <code class="inline">fun</code> on every <code class="inline">nth</code> element of <code class="inline">enumerable</code>, starting with the first element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_intersperse/3">map_intersperse(enumerable, separator, mapper)</a> </dt> <dd class="summary-synopsis"><p>Maps and intersperses the given enumerable in one pass.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_join/3">map_join(enumerable, joiner \\ "", mapper)</a> </dt> <dd class="summary-synopsis"><p>Maps and joins the given <code class="inline">enumerable</code> in one pass.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_reduce/3">map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given function to each element in the <code class="inline">enumerable</code> to reduce it to a single element, while keeping an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#max/3">max(enumerable, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the maximal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#max_by/4">max_by(enumerable, fun, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the maximal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#member?/2">member?(enumerable, element)</a> </dt> <dd class="summary-synopsis"><p>Checks if <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min/3">min(enumerable, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the minimal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min_by/4">min_by(enumerable, fun, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the minimal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min_max/2">min_max(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min_max_by/4">min_max_by(enumerable, fun, sorter_or_empty_fallback \\ &amp;&lt;/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#random/1">random(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a random element of an <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reduce/2">reduce(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reduce/3">reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reduce_while/3">reduce_while(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Reduces <code class="inline">enumerable</code> until <code class="inline">fun</code> returns <code class="inline">{:halt, term}</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reject/2">reject(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of elements in <code class="inline">enumerable</code> excluding those for which the function <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse/1">reverse(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse/2">reverse(enumerable, tail)</a> </dt> <dd class="summary-synopsis"><p>Reverses the elements in <code class="inline">enumerable</code>, appends the <code class="inline">tail</code>, and returns it as a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse_slice/3">reverse_slice(enumerable, start_index, count)</a> </dt> <dd class="summary-synopsis"><p>Reverses the <code class="inline">enumerable</code> in the range from initial <code class="inline">start_index</code> through <code class="inline">count</code> elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#scan/2">scan(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the <code class="inline">enumerable</code> as the starting value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#scan/3">scan(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shuffle/1">shuffle(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/2">slice(enumerable, index_range)</a> </dt> <dd class="summary-synopsis"><p>Returns a subset list of the given <code class="inline">enumerable</code> by <code class="inline">index_range</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/3">slice(enumerable, start_index, amount)</a> </dt> <dd class="summary-synopsis"><p>Returns a subset list of the given <code class="inline">enumerable</code>, from <code class="inline">start_index</code> (zero-based) with <code class="inline">amount</code> number of elements if available.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sort/1">sort(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Sorts the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sort/2">sort(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Sorts the <code class="inline">enumerable</code> by the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sort_by/3">sort_by(enumerable, mapper, sorter \\ &amp;&lt;=/2)</a> </dt> <dd class="summary-synopsis"><p>Sorts the mapped results of the <code class="inline">enumerable</code> according to the provided <code class="inline">sorter</code> function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/2">split(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split_while/2">split_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) for the first time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split_with/2">split_with(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> in two lists according to the given function <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sum/1">sum(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns the sum of all elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take/2">take(enumerable, amount)</a> </dt> <dd class="summary-synopsis"><p>Takes an <code class="inline">amount</code> of elements from the beginning or the end of the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take_every/2">take_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code>, starting with the first element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take_random/2">take_random(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Takes <code class="inline">count</code> random elements from <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take_while/2">take_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Takes the elements from the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_list/1">to_list(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Converts <code class="inline">enumerable</code> to a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#uniq/1">uniq(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#uniq_by/2">uniq_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unzip/1">unzip(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Opposite of <a href="#zip/2"><code class="inline">zip/2</code></a>. Extracts two-element tuples from the given <code class="inline">enumerable</code> and groups them together.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#with_index/2">with_index(enumerable, offset \\ 0)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">enumerable</code> with each element wrapped in a tuple alongside its index.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip/1">zip(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from a finite collection of enumerables into one list of tuples.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip/2">zip(enumerable1, enumerable2)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from two enumerables into one list of tuples.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:acc/0">acc()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">acc() :: any()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:default/0">default()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">default() :: any()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:element/0">element()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">element() :: any()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:index/0">index()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">index() :: integer()</pre> </div> <p>Zero-based index. It can also be a negative integer.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: Enumerable.t()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="all?/2">all?(enumerable, fun \\ fn x -&gt; x end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">all?(t(), (element() -&gt; as_boolean(term()))) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for all elements in <code class="inline">enumerable</code>.</p>
<p>Iterates over the <code class="inline">enumerable</code> and invokes <code class="inline">fun</code> on each element. When an invocation of <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) iteration stops immediately and <code class="inline">false</code> is returned. In all other cases <code class="inline">true</code> is returned.</p>
<h4 id="all?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.all?([2, 4, 6], fn x -&gt; rem(x, 2) == 0 end)
true

iex&gt; Enum.all?([2, 3, 4], fn x -&gt; rem(x, 2) == 0 end)
false

iex&gt; Enum.all?([], fn x -&gt; x &gt; 0 end)
true</pre>
<p>If no function is given, the truthiness of each element is checked during iteration. When an element has a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) iteration stops immediately and <code class="inline">false</code> is returned. In all other cases <code class="inline">true</code> is returned.</p>
<pre data-language="elixir">iex&gt; Enum.all?([1, 2, 3])
true

iex&gt; Enum.all?([1, nil, 3])
false

iex&gt; Enum.all?([])
true</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="any?/2">any?(enumerable, fun \\ fn x -&gt; x end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">any?(t(), (element() -&gt; as_boolean(term()))) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for at least one element in <code class="inline">enumerable</code>.</p>
<p>Iterates over the <code class="inline">enumerable</code> and invokes <code class="inline">fun</code> on each element. When an invocation of <code class="inline">fun</code> returns a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>) iteration stops immediately and <code class="inline">true</code> is returned. In all other cases <code class="inline">false</code> is returned.</p>
<h4 id="any?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.any?([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
false

iex&gt; Enum.any?([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
true

iex&gt; Enum.any?([], fn x -&gt; x &gt; 0 end)
false</pre>
<p>If no function is given, the truthiness of each element is checked during iteration. When an element has a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>) iteration stops immediately and <code class="inline">true</code> is returned. In all other cases <code class="inline">false</code> is returned.</p>
<pre data-language="elixir">iex&gt; Enum.any?([false, false, false])
false

iex&gt; Enum.any?([false, true, false])
true

iex&gt; Enum.any?([])
false</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="at/3">at(enumerable, index, default \\ nil)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">at(t(), index(), default()) :: element() | default()</pre> </div> <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p>
<p>Returns <code class="inline">default</code> if <code class="inline">index</code> is out of bounds.</p>
<p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (for example, <code class="inline">-1</code> finds the last element).</p>
<h4 id="at/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.at([2, 4, 6], 0)
2

iex&gt; Enum.at([2, 4, 6], 2)
6

iex&gt; Enum.at([2, 4, 6], 4)
nil

iex&gt; Enum.at([2, 4, 6], 4, :none)
:none</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk_by/2">chunk_by(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">chunk_by(t(), (element() -&gt; any())) :: [list()]</pre> </div> <p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value.</p>
<p>Returns a list of lists.</p>
<h4 id="chunk_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))
[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk_every/2">chunk_every(enumerable, count)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">chunk_every(t(), pos_integer()) :: [list()]</pre> </div> <p>Shortcut to <code class="inline">chunk_every(enumerable, count, count)</code>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="chunk_every/4">chunk_every(enumerable, count, step, leftover \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">chunk_every(t(), pos_integer(), pos_integer(), t() | :discard) :: [list()]</pre> </div> <p>Returns list of lists containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the <code class="inline">enumerable</code>.</p>
<p><code class="inline">step</code> is optional and, if not passed, defaults to <code class="inline">count</code>, i.e. chunks do not overlap.</p>
<p>If the last chunk does not have <code class="inline">count</code> elements to fill the chunk, elements are taken from <code class="inline">leftover</code> to fill in the chunk. If <code class="inline">leftover</code> does not have enough elements to fill the chunk, then a partial chunk is returned with less than <code class="inline">count</code> elements.</p>
<p>If <code class="inline">:discard</code> is given in <code class="inline">leftover</code>, the last chunk is discarded unless it has exactly <code class="inline">count</code> elements.</p>
<h4 id="chunk_every/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)
[[1, 2, 3], [3, 4, 5]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])
[[1, 2, 3], [3, 4, 5], [5, 6, 7]]

iex&gt; Enum.chunk_every([1, 2, 3, 4], 3, 3, [])
[[1, 2, 3], [4]]

iex&gt; Enum.chunk_every([1, 2, 3, 4], 10)
[[1, 2, 3, 4]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])
[[1, 2], [4, 5]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk_while/4">chunk_while(enumerable, acc, chunk_fun, after_fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">chunk_while(
  t(),
  acc(),
  (element(), acc() -&gt; {:cont, chunk, acc()} | {:cont, acc()} | {:halt, acc()}),
  (acc() -&gt; {:cont, chunk, acc()} | {:cont, acc()})
) :: Enumerable.t()
when chunk: any()</pre> </div> <p>Chunks the <code class="inline">enumerable</code> with fine grained control when every chunk is emitted.</p>
<p><code class="inline">chunk_fun</code> receives the current element and the accumulator and must return <code class="inline">{:cont, chunk, acc}</code> to emit the given chunk and continue with accumulator or <code class="inline">{:cont, acc}</code> to not emit any chunk and continue with the return accumulator.</p>
<p><code class="inline">after_fun</code> is invoked when iteration is done and must also return <code class="inline">{:cont, chunk, acc}</code> or <code class="inline">{:cont, acc}</code>.</p>
<p>Returns a list of lists.</p>
<h4 id="chunk_while/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; chunk_fun = fn element, acc -&gt;
...&gt;   if rem(element, 2) == 0 do
...&gt;     {:cont, Enum.reverse([element | acc]), []}
...&gt;   else
...&gt;     {:cont, [element | acc]}
...&gt;   end
...&gt; end
iex&gt; after_fun = fn
...&gt;   [] -&gt; {:cont, []}
...&gt;   acc -&gt; {:cont, Enum.reverse(acc), []}
...&gt; end
iex&gt; Enum.chunk_while(1..10, [], chunk_fun, after_fun)
[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="concat/1">concat(enumerables)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">concat(t()) :: t()</pre> </div> <p>Given an enumerable of enumerables, concatenates the <code class="inline">enumerables</code> into a single list.</p>
<h4 id="concat/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.concat([1..3, 4..6, 7..9])
[1, 2, 3, 4, 5, 6, 7, 8, 9]

iex&gt; Enum.concat([[1, [2], 3], [4], [5, 6]])
[1, [2], 3, 4, 5, 6]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="concat/2">concat(left, right)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">concat(t(), t()) :: t()</pre> </div> <p>Concatenates the enumerable on the <code class="inline">right</code> with the enumerable on the <code class="inline">left</code>.</p>
<p>This function produces the same result as the <a href="https://hexdocs.pm/elixir/Kernel.html#++/2"><code class="inline">Kernel.++/2</code></a> operator for lists.</p>
<h4 id="concat/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.concat(1..3, 4..6)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.concat([1, 2, 3], [4, 5, 6])
[1, 2, 3, 4, 5, 6]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count/1">count(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">count(t()) :: non_neg_integer()</pre> </div> <p>Returns the size of the <code class="inline">enumerable</code>.</p>
<h4 id="count/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.count([1, 2, 3])
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count/2">count(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">count(t(), (element() -&gt; as_boolean(term()))) :: non_neg_integer()</pre> </div> <p>Returns the count of elements in the <code class="inline">enumerable</code> for which <code class="inline">fun</code> returns a truthy value.</p>
<h4 id="count/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.count([1, 2, 3, 4, 5], fn x -&gt; rem(x, 2) == 0 end)
2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dedup/1">dedup(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">dedup(t()) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p>
<p>Elements are compared using <a href="https://hexdocs.pm/elixir/Kernel.html#===/2"><code class="inline">===/2</code></a>.</p>
<p>If you want to remove all duplicated elements, regardless of order, see <a href="#uniq/1"><code class="inline">uniq/1</code></a>.</p>
<h4 id="dedup/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.dedup([1, 2, 3, 3, 2, 1])
[1, 2, 3, 2, 1]

iex&gt; Enum.dedup([1, 1, 2, 2.0, :three, :three])
[1, 2, 2.0, :three]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dedup_by/2">dedup_by(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">dedup_by(t(), (element() -&gt; term())) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p>
<p>The function <code class="inline">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p>
<h4 id="dedup_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -&gt; x end)
[{1, :a}, {2, :b}, {1, :a}]

iex&gt; Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -&gt; x &gt; 2 end)
[5, 1, 3, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop/2">drop(enumerable, amount)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">drop(t(), integer()) :: list()</pre> </div> <p>Drops the <code class="inline">amount</code> of elements from the <code class="inline">enumerable</code>.</p>
<p>If a negative <code class="inline">amount</code> is given, the <code class="inline">amount</code> of last values will be dropped. The <code class="inline">enumerable</code> will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p>
<h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.drop([1, 2, 3], 2)
[3]

iex&gt; Enum.drop([1, 2, 3], 10)
[]

iex&gt; Enum.drop([1, 2, 3], 0)
[1, 2, 3]

iex&gt; Enum.drop([1, 2, 3], -1)
[1, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop_every/2">drop_every(enumerable, nth)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">drop_every(t(), non_neg_integer()) :: list()</pre> </div> <p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code> dropped, starting with the first element.</p>
<p>The first element is always dropped, unless <code class="inline">nth</code> is 0.</p>
<p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p>
<h4 id="drop_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.drop_every(1..10, 2)
[2, 4, 6, 8, 10]

iex&gt; Enum.drop_every(1..10, 0)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

iex&gt; Enum.drop_every([1, 2, 3], 1)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop_while/2">drop_while(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">drop_while(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Drops elements at the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p>
<h4 id="drop_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.drop_while([1, 2, 3, 2, 1], fn x -&gt; x &lt; 3 end)
[3, 2, 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="each/2">each(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">each(t(), (element() -&gt; any())) :: :ok</pre> </div> <p>Invokes the given <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="each/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Enum.each(["some", "example"], fn x -&gt; IO.puts(x) end)
"some"
"example"
#=&gt; :ok</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="empty?/1">empty?(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">empty?(t()) :: boolean()</pre> </div> <p>Determines if the <code class="inline">enumerable</code> is empty.</p>
<p>Returns <code class="inline">true</code> if <code class="inline">enumerable</code> is empty, otherwise <code class="inline">false</code>.</p>
<h4 id="empty?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.empty?([])
true

iex&gt; Enum.empty?([1, 2, 3])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch/2">fetch(enumerable, index)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">fetch(t(), index()) :: {:ok, element()} | :error</pre> </div> <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p>
<p>Returns <code class="inline">{:ok, element}</code> if found, otherwise <code class="inline">:error</code>.</p>
<p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (for example, <code class="inline">-1</code> fetches the last element).</p>
<h4 id="fetch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.fetch([2, 4, 6], 0)
{:ok, 2}

iex&gt; Enum.fetch([2, 4, 6], -3)
{:ok, 2}

iex&gt; Enum.fetch([2, 4, 6], 2)
{:ok, 6}

iex&gt; Enum.fetch([2, 4, 6], 4)
:error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch!/2">fetch!(enumerable, index)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">fetch!(t(), index()) :: element()</pre> </div> <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p>
<p>Raises <code class="inline">OutOfBoundsError</code> if the given <code class="inline">index</code> is outside the range of the <code class="inline">enumerable</code>.</p>
<h4 id="fetch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.fetch!([2, 4, 6], 0)
2

iex&gt; Enum.fetch!([2, 4, 6], 2)
6

iex&gt; Enum.fetch!([2, 4, 6], 4)
** (Enum.OutOfBoundsError) out of bounds error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="filter/2">filter(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">filter(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Filters the <code class="inline">enumerable</code>, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value.</p>
<p>See also <a href="#reject/2"><code class="inline">reject/2</code></a> which discards all elements where the function returns a truthy value.</p>
<h4 id="filter/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.filter([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
[2]</pre>
<p>Keep in mind that <code class="inline">filter</code> is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using <a href="#flat_map/2"><code class="inline">flat_map/2</code></a>. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</p>
<pre data-language="elixir">strings = ["1234", "abc", "12ab"]

Enum.flat_map(strings, fn string -&gt;
  case Integer.parse(string) do
    # transform to integer
    {int, _rest} -&gt; [int]
    # skip the value
    :error -&gt; []
  end
end)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="find/3">find(enumerable, default \\ nil, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">find(t(), default(), (element() -&gt; any())) :: element() | default()</pre> </div> <p>Returns the first element for which <code class="inline">fun</code> returns a truthy value. If no such element is found, returns <code class="inline">default</code>.</p>
<h4 id="find/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.find([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
3

iex&gt; Enum.find([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil
iex&gt; Enum.find([2, 4, 6], 0, fn x -&gt; rem(x, 2) == 1 end)
0</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="find_index/2">find_index(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">find_index(t(), (element() -&gt; any())) :: non_neg_integer() | nil</pre> </div> <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p>
<h4 id="find_index/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.find_index([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_index([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
1</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="find_value/3">find_value(enumerable, default \\ nil, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">find_value(t(), any(), (element() -&gt; any())) :: any() | nil</pre> </div> <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p>
<p>The return value is considered to be found when the result is truthy (neither <code class="inline">nil</code> nor <code class="inline">false</code>).</p>
<h4 id="find_value/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.find_value([2, 3, 4], fn x -&gt;
...&gt;   if x &gt; 2, do: x * x
...&gt; end)
9

iex&gt; Enum.find_value([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_value([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
true

iex&gt; Enum.find_value([1, 2, 3], "no bools!", &amp;is_boolean/1)
"no bools!"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flat_map/2">flat_map(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">flat_map(t(), (element() -&gt; t())) :: list()</pre> </div> <p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p>
<p>This function returns a new enumerable built by appending the result of invoking <code class="inline">fun</code> on each element of <code class="inline">enumerable</code> together; conceptually, this is similar to a combination of <a href="#map/2"><code class="inline">map/2</code></a> and <a href="#concat/1"><code class="inline">concat/1</code></a>.</p>
<h4 id="flat_map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.flat_map([:a, :b, :c], fn x -&gt; [x, x] end)
[:a, :a, :b, :b, :c, :c]

iex&gt; Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -&gt; x..y end)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.flat_map([:a, :b, :c], fn x -&gt; [[x]] end)
[[:a], [:b], [:c]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flat_map_reduce/3">flat_map_reduce(enumerable, acc, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">flat_map_reduce(t(), acc(), fun) :: {[any()], acc()}
when fun: (element(), acc() -&gt; {t(), acc()} | {:halt, acc()})</pre> </div> <p>Maps and reduces an <code class="inline">enumerable</code>, flattening the given results (only one level deep).</p>
<p>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with <code class="inline">:halt</code> as first element and the accumulator as second.</p>
<h4 id="flat_map_reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; enumerable = 1..100
iex&gt; n = 3
iex&gt; Enum.flat_map_reduce(enumerable, 0, fn x, acc -&gt;
...&gt;   if acc &lt; n, do: {[x], acc + 1}, else: {:halt, acc}
...&gt; end)
{[1, 2, 3], 3}

iex&gt; Enum.flat_map_reduce(1..5, 0, fn x, acc -&gt; {[[x]], acc + x} end)
{[[1], [2], [3], [4], [5]], 15}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="frequencies/1">frequencies(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">frequencies(t()) :: map()</pre> </div> <p>Returns a map with keys as unique elements of <code class="inline">enumerable</code> and values as the count of every element.</p>
<h4 id="frequencies/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.frequencies(~w{ant buffalo ant ant buffalo dingo})
%{"ant" =&gt; 3, "buffalo" =&gt; 2, "dingo" =&gt; 1}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="frequencies_by/2">frequencies_by(enumerable, key_fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">frequencies_by(t(), (element() -&gt; any())) :: map()</pre> </div> <p>Returns a map with keys as unique elements given by <code class="inline">key_fun</code> and values as the count of every element.</p>
<h4 id="frequencies_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.frequencies_by(~w{aa aA bb cc}, &amp;String.downcase/1)
%{"aa" =&gt; 2, "bb" =&gt; 1, "cc" =&gt; 1}

iex&gt; Enum.frequencies_by(~w{aaa aA bbb cc c}, &amp;String.length/1)
%{3 =&gt; 2, 2 =&gt; 2, 1 =&gt; 1}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="group_by/3">group_by(enumerable, key_fun, value_fun \\ fn x -&gt; x end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">group_by(t(), (element() -&gt; any()), (element() -&gt; any())) :: map()</pre> </div> <p>Splits the <code class="inline">enumerable</code> into groups based on <code class="inline">key_fun</code>.</p>
<p>The result is a map where each key is given by <code class="inline">key_fun</code> and each value is a list of elements given by <code class="inline">value_fun</code>. The order of elements within each list is preserved from the <code class="inline">enumerable</code>. However, like all maps, the resulting map is unordered.</p>
<h4 id="group_by/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1)
%{3 =&gt; ["ant", "cat"], 5 =&gt; ["dingo"], 7 =&gt; ["buffalo"]}

iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1, &amp;String.first/1)
%{3 =&gt; ["a", "c"], 5 =&gt; ["d"], 7 =&gt; ["b"]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="intersperse/2">intersperse(enumerable, element)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">intersperse(t(), element()) :: list()</pre> </div> <p>Intersperses <code class="inline">element</code> between each element of the enumeration.</p>
<h4 id="intersperse/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.intersperse([1, 2, 3], 0)
[1, 0, 2, 0, 3]

iex&gt; Enum.intersperse([1], 0)
[1]

iex&gt; Enum.intersperse([], 0)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="into/2">into(enumerable, collectable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">into(Enumerable.t(), Collectable.t()) :: Collectable.t()</pre> </div> <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code>.</p>
<p>Note that passing a non-empty list as the <code class="inline">collectable</code> is deprecated. If you're collecting into a non-empty keyword list, consider using <a href="https://hexdocs.pm/elixir/Keyword.html#merge/2"><code class="inline">Keyword.merge/2</code></a>. If you're collecting into a non-empty list, consider something like <code class="inline">to_list(enumerable) ++ collectable</code>.</p>
<h4 id="into/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.into([1, 2], [])
[1, 2]

iex&gt; Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}

iex&gt; Enum.into(%{a: 1}, %{b: 2})
%{a: 1, b: 2}

iex&gt; Enum.into([a: 1, a: 2], %{})
%{a: 2}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="into/3">into(enumerable, collectable, transform)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">into(Enumerable.t(), Collectable.t(), (term() -&gt; term())) :: Collectable.t()</pre> </div> <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function.</p>
<h4 id="into/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.into([2, 3], [3], fn x -&gt; x * 3 end)
[3, 6, 9]

iex&gt; Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -&gt; {k, v * 2} end)
%{a: 2, b: 4, c: 3}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="join/2">join(enumerable, joiner \\ "")</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">join(t(), String.t()) :: String.t()</pre> </div> <p>Joins the given <code class="inline">enumerable</code> into a string using <code class="inline">joiner</code> as a separator.</p>
<p>If <code class="inline">joiner</code> is not passed at all, it defaults to an empty string.</p>
<p>All elements in the <code class="inline">enumerable</code> must be convertible to a string, otherwise an error is raised.</p>
<h4 id="join/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.join([1, 2, 3])
"123"

iex&gt; Enum.join([1, 2, 3], " = ")
"1 = 2 = 3"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map/2">map(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">map(t(), (element() -&gt; any())) :: list()</pre> </div> <p>Returns a list where each element is the result of invoking <code class="inline">fun</code> on each corresponding element of <code class="inline">enumerable</code>.</p>
<p>For maps, the function expects a key-value tuple.</p>
<h4 id="map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.map([a: 1, b: 2], fn {k, v} -&gt; {k, -v} end)
[a: -1, b: -2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map_every/3">map_every(enumerable, nth, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">map_every(t(), non_neg_integer(), (element() -&gt; any())) :: list()</pre> </div> <p>Returns a list of results of invoking <code class="inline">fun</code> on every <code class="inline">nth</code> element of <code class="inline">enumerable</code>, starting with the first element.</p>
<p>The first element is always passed to the given function, unless <code class="inline">nth</code> is <code class="inline">0</code>.</p>
<p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p>
<p>If <code class="inline">nth</code> is <code class="inline">0</code>, then <code class="inline">enumerable</code> is directly converted to a list, without <code class="inline">fun</code> being ever applied.</p>
<h4 id="map_every/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map_every(1..10, 2, fn x -&gt; x + 1000 end)
[1001, 2, 1003, 4, 1005, 6, 1007, 8, 1009, 10]

iex&gt; Enum.map_every(1..10, 3, fn x -&gt; x + 1000 end)
[1001, 2, 3, 1004, 5, 6, 1007, 8, 9, 1010]

iex&gt; Enum.map_every(1..5, 0, fn x -&gt; x + 1000 end)
[1, 2, 3, 4, 5]

iex&gt; Enum.map_every([1, 2, 3], 1, fn x -&gt; x + 1000 end)
[1001, 1002, 1003]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map_intersperse/3">map_intersperse(enumerable, separator, mapper)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">map_intersperse(t(), element(), (element() -&gt; any())) :: list()</pre> </div> <p>Maps and intersperses the given enumerable in one pass.</p>
<h4 id="map_intersperse/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map_intersperse([1, 2, 3], :a, &amp;(&amp;1 * 2))
[2, :a, 4, :a, 6]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="map_join/3">map_join(enumerable, joiner \\ "", mapper)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">map_join(t(), String.t(), (element() -&gt; String.Chars.t())) :: String.t()</pre> </div> <p>Maps and joins the given <code class="inline">enumerable</code> in one pass.</p>
<p>If <code class="inline">joiner</code> is not passed at all, it defaults to an empty string.</p>
<p>All elements returned from invoking the <code class="inline">mapper</code> must be convertible to a string, otherwise an error is raised.</p>
<h4 id="map_join/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map_join([1, 2, 3], &amp;(&amp;1 * 2))
"246"

iex&gt; Enum.map_join([1, 2, 3], " = ", &amp;(&amp;1 * 2))
"2 = 4 = 6"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map_reduce/3">map_reduce(enumerable, acc, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">map_reduce(t(), acc(), (element(), acc() -&gt; {element(), acc()})) ::
  {list(), acc()}</pre> </div> <p>Invokes the given function to each element in the <code class="inline">enumerable</code> to reduce it to a single element, while keeping an accumulator.</p>
<p>Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.</p>
<p>The function, <code class="inline">fun</code>, receives two arguments: the first one is the element, and the second one is the accumulator. <code class="inline">fun</code> must return a tuple with two elements in the form of <code class="inline">{result, accumulator}</code>.</p>
<p>For maps, the first tuple element must be a <code class="inline">{key, value}</code> tuple.</p>
<h4 id="map_reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map_reduce([1, 2, 3], 0, fn x, acc -&gt; {x * 2, x + acc} end)
{[2, 4, 6], 6}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="max/3">max(enumerable, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">max(t(), (element(), element() -&gt; boolean()) | module(), (() -&gt; empty_result)) ::
  element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the maximal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p>
<p>By default, the comparison is done with the <code class="inline">&gt;=</code> sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements.</p>
<p>If the enumerable is empty, the provided <code class="inline">empty_fallback</code> is called. The default <code class="inline">empty_fallback</code> raises <a href="https://hexdocs.pm/elixir/Enum.EmptyError.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="max/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.max([1, 2, 3])
3</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</p>
<pre data-language="elixir">iex&gt; Enum.max([~D[2017-03-31], ~D[2017-04-01]])
~D[2017-03-31]</pre>
<p>In the example above, <a href="#max/2"><code class="inline">max/2</code></a> returned March 31st instead of April 1st because the structural comparison compares the day before the year. For this reason, most structs provide a "compare" function, such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)
~D[2017-04-01]</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.max([], &amp;&gt;=/2, fn -&gt; 0 end)
0</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="max_by/4">max_by(enumerable, fun, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">max_by(
  t(),
  (element() -&gt; any()),
  (element(), element() -&gt; boolean()) | module(),
  (() -&gt; empty_result)
) :: element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the maximal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p>
<p>By default, the comparison is done with the <code class="inline">&gt;=</code> sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements.</p>
<p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="https://hexdocs.pm/elixir/Enum.EmptyError.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="max_by/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.max_by(["a", "aa", "aaa"], fn x -&gt; String.length(x) end)
"aaa"

iex&gt; Enum.max_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"aaa"</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a "compare" function, such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.max_by(users, &amp;(&amp;1.birthday), Date)
%{name: "Ellis", birthday: ~D[1943-05-11]}</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.max_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="member?/2">member?(enumerable, element)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">member?(t(), element()) :: boolean()</pre> </div> <p>Checks if <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p>
<p>Membership is tested with the match (<a href="https://hexdocs.pm/elixir/Kernel.html#===/2"><code class="inline">===/2</code></a>) operator.</p>
<h4 id="member?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.member?(1..10, 5)
true
iex&gt; Enum.member?(1..10, 5.0)
false

iex&gt; Enum.member?([1.0, 2.0, 3.0], 2)
false
iex&gt; Enum.member?([1.0, 2.0, 3.0], 2.000)
true

iex&gt; Enum.member?([:a, :b, :c], :d)
false</pre>
<p>When not called whithin guards, the <a href="https://hexdocs.pm/elixir/Kernel.html#in/2"><code class="inline">in</code></a> and <a href="https://hexdocs.pm/elixir/Kernel.html#in/2"><code class="inline">not in</code></a> operators work by using this function.</p> </section> </section> <section class="detail">   <h3 class="detail-header" id="min/3">min(enumerable, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">min(t(), (element(), element() -&gt; boolean()) | module(), (() -&gt; empty_result)) ::
  element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the minimal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p>
<p>By default, the comparison is done with the <code class="inline">&lt;=</code> sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements.</p>
<p>If the enumerable is empty, the provided <code class="inline">empty_fallback</code> is called. The default <code class="inline">empty_fallback</code> raises <a href="https://hexdocs.pm/elixir/Enum.EmptyError.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="min/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min([1, 2, 3])
1</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</p>
<pre data-language="elixir">iex&gt; Enum.min([~D[2017-03-31], ~D[2017-04-01]])
~D[2017-04-01]</pre>
<p>In the example above, <a href="#min/2"><code class="inline">min/2</code></a> returned April 1st instead of March 31st because the structural comparison compares the day before the year. For this reason, most structs provide a "compare" function, such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)
~D[2017-03-31]</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.min([], fn -&gt; 0 end)
0</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="min_by/4">min_by(enumerable, fun, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">min_by(
  t(),
  (element() -&gt; any()),
  (element(), element() -&gt; boolean()) | module(),
  (() -&gt; empty_result)
) :: element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the minimal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p>
<p>By default, the comparison is done with the <code class="inline">&lt;=</code> sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements.</p>
<p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="https://hexdocs.pm/elixir/Enum.EmptyError.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="min_by/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min_by(["a", "aa", "aaa"], fn x -&gt; String.length(x) end)
"a"

iex&gt; Enum.min_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"a"</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a "compare" function, such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.min_by(users, &amp;(&amp;1.birthday), Date)
%{name: "Lovelace", birthday: ~D[1815-12-10]}</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.min_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="min_max/2">min_max(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">min_max(t(), (() -&gt; empty_result)) :: {element(), element()} | empty_result
when empty_result: any()</pre> </div> <p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</p>
<p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p>
<p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="https://hexdocs.pm/elixir/Enum.EmptyError.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="min_max/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min_max([2, 3, 1])
{1, 3}

iex&gt; Enum.min_max([], fn -&gt; {nil, nil} end)
{nil, nil}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="min_max_by/4">min_max_by(enumerable, fun, sorter_or_empty_fallback \\ &amp;&lt;/2, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">min_max_by(
  t(),
  (element() -&gt; any()),
  (element(), element() -&gt; boolean()) | module(),
  (() -&gt; empty_result)
) :: {element(), element()} | empty_result
when empty_result: any()</pre> </div> <p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p>
<p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p>
<h4 id="min_max_by/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min_max_by(["aaa", "bb", "c"], fn x -&gt; String.length(x) end)
{"c", "aaa"}

iex&gt; Enum.min_max_by(["aaa", "a", "bb", "c", "ccc"], &amp;String.length/1)
{"a", "aaa"}

iex&gt; Enum.min_max_by([], &amp;String.length/1, fn -&gt; {nil, nil} end)
{nil, nil}</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a "compare" function, such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.min_max_by(users, &amp;(&amp;1.birthday), Date)
{
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Ellis", birthday: ~D[1943-05-11]}
}</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.min_max_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="random/1">random(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">random(t()) :: element()</pre> </div> <p>Returns a random element of an <code class="inline">enumerable</code>.</p>
<p>Raises <a href="https://hexdocs.pm/elixir/Enum.EmptyError.html"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p>
<p>This function uses Erlang's <a href="http://www.erlang.org/doc/man/rand.html"><code class="inline">:rand</code> module</a> to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p>
<p>The implementation is based on the <a href="https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle">reservoir sampling</a> algorithm. It assumes that the sample being returned can fit into memory; the input <code class="inline">enumerable</code> doesn't have to, as it is traversed just once.</p>
<p>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</p>
<h4 id="random/1-examples" class="section-heading">  Examples </h4> <p>The examples below use the <code class="inline">:exrop</code> pseudorandom algorithm since it's the default from Erlang/OTP 20, however if you are using Erlang/OTP 22 or above then <code class="inline">:exsss</code> is the default algorithm. If you are using <code class="inline">:exsplus</code>, then please update, as this algorithm is deprecated since Erlang/OTP 20.</p>
<pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exrop, {101, 102, 103})
iex&gt; Enum.random([1, 2, 3])
3
iex&gt; Enum.random([1, 2, 3])
2
iex&gt; Enum.random(1..1_000)
846</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reduce/2">reduce(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reduce(t(), (element(), acc() -&gt; acc())) :: acc()</pre> </div> <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p>
<p>Raises <a href="https://hexdocs.pm/elixir/Enum.EmptyError.html"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p>
<p>The first element of the <code class="inline">enumerable</code> is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the <code class="inline">enumerable</code> is done, the last accumulator is returned.</p>
<p>Since the first element of the enumerable is used as the initial value of the accumulator, <code class="inline">fun</code> will only be executed <code class="inline">n - 1</code> times where <code class="inline">n</code> is the length of the enumerable. This function won't call the specified function for enumerables that are one-element long.</p>
<p>If you wish to use another value for the accumulator, use <a href="#reduce/3"><code class="inline">Enum.reduce/3</code></a>.</p>
<h4 id="reduce/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reduce([1, 2, 3, 4], fn x, acc -&gt; x * acc end)
24</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reduce/3">reduce(enumerable, acc, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reduce(t(), any(), (element(), acc() -&gt; acc())) :: acc()</pre> </div> <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p>
<p>The initial value of the accumulator is <code class="inline">acc</code>. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</p>
<h4 id="reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reduce([1, 2, 3], 0, fn x, acc -&gt; x + acc end)
6</pre>
<h4 id="reduce/3-reduce-as-a-building-block" class="section-heading">  Reduce as a building block </h4> <p>Reduce (sometimes called <code class="inline">fold</code>) is a basic building block in functional programming. Almost all of the functions in the <a href="#content"><code class="inline">Enum</code></a> module can be implemented on top of reduce. Those functions often rely on other operations, such as <a href="#reverse/1"><code class="inline">Enum.reverse/1</code></a>, which are optimized by the runtime.</p>
<p>For example, we could implement <a href="#map/2"><code class="inline">map/2</code></a> in terms of <a href="#reduce/3"><code class="inline">reduce/3</code></a> as follows:</p>
<pre data-language="elixir">def my_map(enumerable, fun) do
  enumerable
  |&gt; Enum.reduce([], fn x, acc -&gt; [fun.(x) | acc] end)
  |&gt; Enum.reverse()
end</pre>
<p>In the example above, <a href="#reduce/3"><code class="inline">Enum.reduce/3</code></a> accumulates the result of each call to <code class="inline">fun</code> into a list in reverse order, which is correctly ordered at the end by calling <a href="#reverse/1"><code class="inline">Enum.reverse/1</code></a>.</p>
<p>Implementing functions like <a href="#map/2"><code class="inline">map/2</code></a>, <a href="#filter/2"><code class="inline">filter/2</code></a> and others are a good exercise for understanding the power behind <a href="#reduce/3"><code class="inline">Enum.reduce/3</code></a>. When an operation cannot be expressed by any of the functions in the <a href="#content"><code class="inline">Enum</code></a> module, developers will most likely resort to <a href="#reduce/3"><code class="inline">reduce/3</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="reduce_while/3">reduce_while(enumerable, acc, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reduce_while(t(), any(), (element(), any() -&gt; {:cont, any()} | {:halt, any()})) ::
  any()</pre> </div> <p>Reduces <code class="inline">enumerable</code> until <code class="inline">fun</code> returns <code class="inline">{:halt, term}</code>.</p>
<p>The return value for <code class="inline">fun</code> is expected to be</p>
<ul>
<li>
<code class="inline">{:cont, acc}</code> to continue the reduction with <code class="inline">acc</code> as the new accumulator or</li>
<li>
<code class="inline">{:halt, acc}</code> to halt the reduction</li>
</ul>
<p>If <code class="inline">fun</code> returns <code class="inline">{:halt, acc}</code> the reduction is halted and the function returns <code class="inline">acc</code>. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last <code class="inline">{:cont, acc}</code>.</p>
<h4 id="reduce_while/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reduce_while(1..100, 0, fn x, acc -&gt;
...&gt;   if x &lt; 5, do: {:cont, acc + x}, else: {:halt, acc}
...&gt; end)
10
iex&gt; Enum.reduce_while(1..100, 0, fn x, acc -&gt;
...&gt;   if x &gt; 0, do: {:cont, acc + x}, else: {:halt, acc}
...&gt; end)
5050</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reject/2">reject(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reject(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Returns a list of elements in <code class="inline">enumerable</code> excluding those for which the function <code class="inline">fun</code> returns a truthy value.</p>
<p>See also <a href="#filter/2"><code class="inline">filter/2</code></a>.</p>
<h4 id="reject/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reject([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
[1, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse/1">reverse(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reverse(t()) :: list()</pre> </div> <p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order.</p>
<h4 id="reverse/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reverse([1, 2, 3])
[3, 2, 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse/2">reverse(enumerable, tail)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reverse(t(), t()) :: list()</pre> </div> <p>Reverses the elements in <code class="inline">enumerable</code>, appends the <code class="inline">tail</code>, and returns it as a list.</p>
<p>This is an optimization for <code class="inline">enumerable |&gt; Enum.reverse() |&gt; Enum.concat(tail)</code>.</p>
<h4 id="reverse/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reverse([1, 2, 3], [4, 5, 6])
[3, 2, 1, 4, 5, 6]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse_slice/3">reverse_slice(enumerable, start_index, count)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reverse_slice(t(), non_neg_integer(), non_neg_integer()) :: list()</pre> </div> <p>Reverses the <code class="inline">enumerable</code> in the range from initial <code class="inline">start_index</code> through <code class="inline">count</code> elements.</p>
<p>If <code class="inline">count</code> is greater than the size of the rest of the <code class="inline">enumerable</code>, then this function will reverse the rest of the enumerable.</p>
<h4 id="reverse_slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)
[1, 2, 6, 5, 4, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="scan/2">scan(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">scan(t(), (element(), any() -&gt; any())) :: list()</pre> </div> <p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the <code class="inline">enumerable</code> as the starting value.</p>
<h4 id="scan/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.scan(1..5, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="scan/3">scan(enumerable, acc, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">scan(t(), any(), (element(), any() -&gt; any())) :: list()</pre> </div> <p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p>
<h4 id="scan/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.scan(1..5, 0, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="shuffle/1">shuffle(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">shuffle(t()) :: list()</pre> </div> <p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled.</p>
<p>This function uses Erlang's <a href="http://www.erlang.org/doc/man/rand.html"><code class="inline">:rand</code> module</a> to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p>
<h4 id="shuffle/1-examples" class="section-heading">  Examples </h4> <p>The examples below use the <code class="inline">:exrop</code> pseudorandom algorithm since it's the default from Erlang/OTP 20, however if you are using Erlang/OTP 22 or above then <code class="inline">:exsss</code> is the default algorithm. If you are using <code class="inline">:exsplus</code>, then please update, as this algorithm is deprecated since Erlang/OTP 20.</p>
<pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exrop, {1, 2, 3})
iex&gt; Enum.shuffle([1, 2, 3])
[3, 1, 2]
iex&gt; Enum.shuffle([1, 2, 3])
[1, 3, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/2">slice(enumerable, index_range)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">slice(t(), Range.t()) :: list()</pre> </div> <p>Returns a subset list of the given <code class="inline">enumerable</code> by <code class="inline">index_range</code>.</p>
<p><code class="inline">index_range</code> must be a <a href="https://hexdocs.pm/elixir/Range.html"><code class="inline">Range</code></a>. Given an <code class="inline">enumerable</code>, it drops elements before <code class="inline">index_range.first</code> (zero-base), then takes elements until element <code class="inline">index_range.last</code> (inclusively).</p>
<p>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, <code class="inline">-1</code> means the last element of the <code class="inline">enumerable</code>).</p>
<p>If <code class="inline">index_range.last</code> is out of bounds, then it is assigned as the index of the last element.</p>
<p>If the normalized <code class="inline">index_range.first</code> is out of bounds of the given <code class="inline">enumerable</code>, or this one is greater than the normalized <code class="inline">index_range.last</code>, then <code class="inline">[]</code> is returned.</p>
<h4 id="slice/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.slice(1..100, 5..10)
[6, 7, 8, 9, 10, 11]

iex&gt; Enum.slice(1..10, 5..20)
[6, 7, 8, 9, 10]

# last five elements (negative indexes)
iex&gt; Enum.slice(1..30, -5..-1)
[26, 27, 28, 29, 30]

# last five elements (mixed positive and negative indexes)
iex&gt; Enum.slice(1..30, 25..-1)
[26, 27, 28, 29, 30]

# out of bounds
iex&gt; Enum.slice(1..10, 11..20)
[]

# first is greater than last
iex&gt; Enum.slice(1..10, 6..5)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/3">slice(enumerable, start_index, amount)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">slice(t(), index(), non_neg_integer()) :: list()</pre> </div> <p>Returns a subset list of the given <code class="inline">enumerable</code>, from <code class="inline">start_index</code> (zero-based) with <code class="inline">amount</code> number of elements if available.</p>
<p>Given an <code class="inline">enumerable</code>, it drops elements right before element <code class="inline">start_index</code>, then takes <code class="inline">amount</code> of elements, returning as many elements as possible if there are not enough elements.</p>
<p>A negative <code class="inline">start_index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the index is counted from the end (for example, <code class="inline">-1</code> starts slicing from the last element).</p>
<p>It returns <code class="inline">[]</code> if <code class="inline">amount</code> is <code class="inline">0</code> or if <code class="inline">start_index</code> is out of bounds.</p>
<h4 id="slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.slice(1..100, 5, 10)
[6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# amount to take is greater than the number of elements
iex&gt; Enum.slice(1..10, 5, 100)
[6, 7, 8, 9, 10]

iex&gt; Enum.slice(1..10, 5, 0)
[]

# using a negative start index
iex&gt; Enum.slice(1..10, -6, 3)
[5, 6, 7]

# out of bound start index (positive)
iex&gt; Enum.slice(1..10, 10, 5)
[]

# out of bound start index (negative)
iex&gt; Enum.slice(1..10, -11, 5)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sort/1">sort(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">sort(t()) :: list()</pre> </div> <p>Sorts the <code class="inline">enumerable</code> according to Erlang's term ordering.</p>
<p>This function uses the merge sort algorithm. Do not use this function to sort structs, see <a href="#sort/2"><code class="inline">sort/2</code></a> for more information.</p>
<h4 id="sort/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.sort([3, 2, 1])
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sort/2">sort(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">sort(
  t(),
  (element(), element() -&gt; boolean())
  | :asc
  | :desc
  | module()
  | {:asc | :desc, module()}
) :: list()</pre> </div> <p>Sorts the <code class="inline">enumerable</code> by the given function.</p>
<p>This function uses the merge sort algorithm. The given function should compare two arguments, and return <code class="inline">true</code> if the first argument precedes or is in the same place as the second one.</p>
<h4 id="sort/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.sort([1, 2, 3], &amp;(&amp;1 &gt;= &amp;2))
[3, 2, 1]</pre>
<p>The sorting algorithm will be stable as long as the given function returns <code class="inline">true</code> for values considered equal:</p>
<pre data-language="elixir">iex&gt; Enum.sort(["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt;= byte_size(&amp;2)))
["of", "some", "kind", "monster"]</pre>
<p>If the function does not return <code class="inline">true</code> for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</p>
<pre data-language="elixir">iex&gt; Enum.sort(["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt; byte_size(&amp;2)))
["of", "kind", "some", "monster"]</pre>
<h4 id="sort/2-ascending-and-descending" class="section-heading">  Ascending and descending </h4> <p><a href="#sort/2"><code class="inline">sort/2</code></a> allows a developer to pass <code class="inline">:asc</code> or <code class="inline">:desc</code> as the sorting function, which is a convenience for <a href="https://hexdocs.pm/elixir/Kernel.html#%3C=/2"><code class="inline">&lt;=/2</code></a> and <a href="https://hexdocs.pm/elixir/Kernel.html#%3E=/2"><code class="inline">&gt;=/2</code></a> respectively.</p>
<pre data-language="elixir">iex&gt; Enum.sort([2, 3, 1], :asc)
[1, 2, 3]
iex&gt; Enum.sort([2, 3, 1], :desc)
[3, 2, 1]</pre>
<h4 id="sort/2-sorting-structs" class="section-heading">  Sorting structs </h4> <p>Do not use <a href="https://hexdocs.pm/elixir/Kernel.html#%3C/2"><code class="inline">&lt;/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#%3C=/2"><code class="inline">&lt;=/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#%3E/2"><code class="inline">&gt;/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#%3E=/2"><code class="inline">&gt;=/2</code></a> and friends when sorting structs. That's because the built-in operators above perform structural comparison and not a semantic one. Imagine we sort the following list of dates:</p>
<pre data-language="elixir">iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates)
[~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]</pre>
<p>Note that the returned result is incorrect, because <a href="#sort/1"><code class="inline">sort/1</code></a> by default uses <a href="https://hexdocs.pm/elixir/Kernel.html#%3C=/2"><code class="inline">&lt;=/2</code></a>, which will compare their structure. When comparing structures, the fields are compared in alphabetical order, which means the dates above will be compared by <code class="inline">day</code>, <code class="inline">month</code> and then <code class="inline">year</code>, which is the opposite of what we want.</p>
<p>For this reason, most structs provide a "compare" function, such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates, Date)
[~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]</pre>
<p>To retrieve all dates in descending order, you can wrap the module in a tuple with <code class="inline">:asc</code> or <code class="inline">:desc</code> as first element:</p>
<pre data-language="elixir">iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates, {:asc, Date})
[~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]
iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates, {:desc, Date})
[~D[2020-03-02], ~D[2019-06-06], ~D[2019-01-01]]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="sort_by/3">sort_by(enumerable, mapper, sorter \\ &amp;&lt;=/2)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">sort_by(
  t(),
  (element() -&gt; mapped_element),
  (element(), element() -&gt; boolean())
  | :asc
  | :desc
  | module()
  | {:asc | :desc, module()}
) :: list()
when mapped_element: element()</pre> </div> <p>Sorts the mapped results of the <code class="inline">enumerable</code> according to the provided <code class="inline">sorter</code> function.</p>
<p>This function maps each element of the <code class="inline">enumerable</code> using the provided <code class="inline">mapper</code> function. The enumerable is then sorted by the mapped elements using the <code class="inline">sorter</code> function, which defaults to <a href="https://hexdocs.pm/elixir/Kernel.html#%3C=/2"><code class="inline">Kernel.&lt;=/2</code></a>.</p>
<p><a href="#sort_by/3"><code class="inline">sort_by/3</code></a> differs from <a href="#sort/2"><code class="inline">sort/2</code></a> in that it only calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. If the same function is being called on both elements, it's more efficient to use <a href="#sort_by/3"><code class="inline">sort_by/3</code></a>.</p>
<h4 id="sort_by/3-examples" class="section-heading">  Examples </h4> <p>Using the default <code class="inline">sorter</code> of <a href="https://hexdocs.pm/elixir/Kernel.html#%3C=/2"><code class="inline">&lt;=/2</code></a>:</p>
<pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;byte_size/1)
["of", "some", "kind", "monster"]</pre>
<p>Sorting by multiple properties - first by size, then by first letter (this takes advantage of the fact that tuples are compared element-by-element):</p>
<pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;{byte_size(&amp;1), String.first(&amp;1)})
["of", "kind", "some", "monster"]</pre>
<p>Similar to <a href="#sort/2"><code class="inline">sort/2</code></a>, you can pass a custom sorter:</p>
<pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;byte_size/1, &amp;&gt;=/2)
["monster", "some", "kind", "of"]</pre>
<p>Or use <code class="inline">:asc</code> and <code class="inline">:desc</code>:</p>
<pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;byte_size/1, :desc)
["monster", "some", "kind", "of"]</pre>
<p>As in <a href="#sort/2"><code class="inline">sort/2</code></a>, avoid using the default sorting function to sort structs, as by default it performs structural comparison instead of a semantic one. In such cases, you shall pass a sorting function as third element or any module that implements a <code class="inline">compare/2</code> function. For example, to sort users by their birthday in both ascending and descending order respectively:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.sort_by(users, &amp;(&amp;1.birthday), Date)
[
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Turing", birthday: ~D[1912-06-23]},
  %{name: "Ellis", birthday: ~D[1943-05-11]}
]
iex&gt; Enum.sort_by(users, &amp;(&amp;1.birthday), {:desc, Date})
[
  %{name: "Ellis", birthday: ~D[1943-05-11]},
  %{name: "Turing", birthday: ~D[1912-06-23]},
  %{name: "Lovelace", birthday: ~D[1815-12-10]}
]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/2">split(enumerable, count)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split(t(), integer()) :: {list(), list()}</pre> </div> <p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one.</p>
<p>If <code class="inline">count</code> is a negative number, it starts counting from the back to the beginning of the <code class="inline">enumerable</code>.</p>
<p>Be aware that a negative <code class="inline">count</code> implies the <code class="inline">enumerable</code> will be enumerated twice: once to calculate the position, and a second time to do the actual splitting.</p>
<h4 id="split/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.split([1, 2, 3], 2)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], 10)
{[1, 2, 3], []}

iex&gt; Enum.split([1, 2, 3], 0)
{[], [1, 2, 3]}

iex&gt; Enum.split([1, 2, 3], -1)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], -5)
{[], [1, 2, 3]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split_while/2">split_while(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split_while(t(), (element() -&gt; as_boolean(term()))) :: {list(), list()}</pre> </div> <p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) for the first time.</p>
<p>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</p>
<h4 id="split_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &lt; 3 end)
{[1, 2], [3, 4]}

iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &lt; 0 end)
{[], [1, 2, 3, 4]}

iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &gt; 0 end)
{[1, 2, 3, 4], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split_with/2">split_with(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split_with(t(), (element() -&gt; as_boolean(term()))) :: {list(), list()}</pre> </div> <p>Splits the <code class="inline">enumerable</code> in two lists according to the given function <code class="inline">fun</code>.</p>
<p>Splits the given <code class="inline">enumerable</code> in two lists by calling <code class="inline">fun</code> with each element in the <code class="inline">enumerable</code> as its only argument. Returns a tuple with the first list containing all the elements in <code class="inline">enumerable</code> for which applying <code class="inline">fun</code> returned a truthy value, and a second list with all the elements for which applying <code class="inline">fun</code> returned a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>).</p>
<p>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</p>
<h4 id="split_with/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.split_with([5, 4, 3, 2, 1, 0], fn x -&gt; rem(x, 2) == 0 end)
{[4, 2, 0], [5, 3, 1]}

iex&gt; Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -&gt; v &lt; 0 end)
{[b: -2, d: -3], [a: 1, c: 1]}

iex&gt; Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -&gt; v &gt; 50 end)
{[], [a: 1, b: -2, c: 1, d: -3]}

iex&gt; Enum.split_with(%{}, fn {_k, v} -&gt; v &gt; 50 end)
{[], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sum/1">sum(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">sum(t()) :: number()</pre> </div> <p>Returns the sum of all elements.</p>
<p>Raises <a href="https://hexdocs.pm/elixir/ArithmeticError.html"><code class="inline">ArithmeticError</code></a> if <code class="inline">enumerable</code> contains a non-numeric value.</p>
<h4 id="sum/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.sum([1, 2, 3])
6</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take/2">take(enumerable, amount)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">take(t(), integer()) :: list()</pre> </div> <p>Takes an <code class="inline">amount</code> of elements from the beginning or the end of the <code class="inline">enumerable</code>.</p>
<p>If a positive <code class="inline">amount</code> is given, it takes the <code class="inline">amount</code> elements from the beginning of the <code class="inline">enumerable</code>.</p>
<p>If a negative <code class="inline">amount</code> is given, the <code class="inline">amount</code> of elements will be taken from the end. The <code class="inline">enumerable</code> will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p>
<p>If amount is <code class="inline">0</code>, it returns <code class="inline">[]</code>.</p>
<h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.take([1, 2, 3], 2)
[1, 2]

iex&gt; Enum.take([1, 2, 3], 10)
[1, 2, 3]

iex&gt; Enum.take([1, 2, 3], 0)
[]

iex&gt; Enum.take([1, 2, 3], -1)
[3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take_every/2">take_every(enumerable, nth)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">take_every(t(), non_neg_integer()) :: list()</pre> </div> <p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code>, starting with the first element.</p>
<p>The first element is always included, unless <code class="inline">nth</code> is 0.</p>
<p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p>
<h4 id="take_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.take_every(1..10, 2)
[1, 3, 5, 7, 9]

iex&gt; Enum.take_every(1..10, 0)
[]

iex&gt; Enum.take_every([1, 2, 3], 1)
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take_random/2">take_random(enumerable, count)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">take_random(t(), non_neg_integer()) :: list()</pre> </div> <p>Takes <code class="inline">count</code> random elements from <code class="inline">enumerable</code>.</p>
<p>Note that this function will traverse the whole <code class="inline">enumerable</code> to get the random sublist.</p>
<p>See <a href="#random/1"><code class="inline">random/1</code></a> for notes on implementation and random seed.</p>
<h4 id="take_random/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exrop, {1, 2, 3})
iex&gt; Enum.take_random(1..10, 2)
[7, 2]
iex&gt; Enum.take_random(?a..?z, 5)
'hypnt'</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take_while/2">take_while(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">take_while(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Takes the elements from the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p>
<h4 id="take_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.take_while([1, 2, 3], fn x -&gt; x &lt; 3 end)
[1, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_list/1">to_list(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_list(t()) :: [element()]</pre> </div> <p>Converts <code class="inline">enumerable</code> to a list.</p>
<h4 id="to_list/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.to_list(1..3)
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="uniq/1">uniq(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">uniq(t()) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements.</p>
<h4 id="uniq/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.uniq([1, 2, 3, 3, 2, 1])
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="uniq_by/2">uniq_by(enumerable, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">uniq_by(t(), (element() -&gt; term())) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p>
<p>The function <code class="inline">fun</code> maps every element to a term. Two elements are considered duplicates if the return value of <code class="inline">fun</code> is equal for both of them.</p>
<p>The first occurrence of each element is kept.</p>
<h4 id="uniq_by/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">iex&gt; Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end)
[{1, :x}, {2, :y}]

iex&gt; Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -&gt; y end)
[a: {:tea, 2}, c: {:coffee, 1}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unzip/1">unzip(enumerable)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unzip(t()) :: {[element()], [element()]}</pre> </div> <p>Opposite of <a href="#zip/2"><code class="inline">zip/2</code></a>. Extracts two-element tuples from the given <code class="inline">enumerable</code> and groups them together.</p>
<p>It takes an <code class="inline">enumerable</code> with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</p>
<p>This function fails unless <code class="inline">enumerable</code> is or can be converted into a list of tuples with <em>exactly</em> two elements in each tuple.</p>
<h4 id="unzip/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])
{[:a, :b, :c], [1, 2, 3]}

iex&gt; Enum.unzip(%{a: 1, b: 2})
{[:a, :b], [1, 2]}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="with_index/2">with_index(enumerable, offset \\ 0)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">with_index(t(), integer()) :: [{element(), index()}]</pre> </div> <p>Returns the <code class="inline">enumerable</code> with each element wrapped in a tuple alongside its index.</p>
<p>If an <code class="inline">offset</code> is given, we will index from the given offset instead of from zero.</p>
<h4 id="with_index/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.with_index([:a, :b, :c])
[a: 0, b: 1, c: 2]

iex&gt; Enum.with_index([:a, :b, :c], 3)
[a: 3, b: 4, c: 5]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip/1">zip(enumerables)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">zip(enumerables) :: [tuple()] when enumerables: [t()] | t()</pre> </div> <p>Zips corresponding elements from a finite collection of enumerables into one list of tuples.</p>
<p>The zipping finishes as soon as any enumerable in the given collection completes.</p>
<h4 id="zip/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.zip([[1, 2, 3], [:a, :b, :c], ["foo", "bar", "baz"]])
[{1, :a, "foo"}, {2, :b, "bar"}, {3, :c, "baz"}]

iex&gt; Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])
[{1, :a}, {2, :b}, {3, :c}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip/2">zip(enumerable1, enumerable2)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">zip(t(), t()) :: [{any(), any()}]</pre> </div> <p>Zips corresponding elements from two enumerables into one list of tuples.</p>
<p>The zipping finishes as soon as any enumerable completes.</p>
<h4 id="zip/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.zip([1, 2, 3], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]

iex&gt; Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
     2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.11.2/Enum.html" class="_attribution-link">https://hexdocs.pm/elixir/1.11.2/Enum.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
