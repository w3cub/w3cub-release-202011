
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Time - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" A Time struct and functions. ">
  <meta name="keywords" content="time, summary, types, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/time.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Time   </h1> <section id="moduledoc"> <p>A Time struct and functions.</p>
<p>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the <a href="#new/4"><code class="inline">new/4</code></a> function or using the <code class="inline">~T</code> (see <a href="https://hexdocs.pm/elixir/Kernel.html#sigil_T/2"><code class="inline">Kernel.sigil_T/2</code></a>) sigil:</p>
<pre data-language="elixir">iex&gt; ~T[23:00:07.001]
~T[23:00:07.001]</pre>
<p>Both <a href="#new/4"><code class="inline">new/4</code></a> and sigil return a struct where the time fields can be accessed directly:</p>
<pre data-language="elixir">iex&gt; time = ~T[23:00:07.001]
iex&gt; time.hour
23
iex&gt; time.microsecond
{1000, 3}</pre>
<p>The functions on this module work with the <a href="#content"><code class="inline">Time</code></a> struct as well as any struct that contains the same fields as the <a href="#content"><code class="inline">Time</code></a> struct, such as <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> and <a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a>. Such functions expect <a href="https://hexdocs.pm/elixir/Calendar.html#t:time/0"><code class="inline">Calendar.time/0</code></a> in their typespecs (instead of <a href="#t:t/0"><code class="inline">t/0</code></a>).</p>
<p>Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</p>
<h2 id="module-comparing-times" class="section-heading">  Comparing times </h2> <p>Comparisons in Elixir using <a href="https://hexdocs.pm/elixir/Kernel.html#==/2"><code class="inline">==/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#%3E/2"><code class="inline">&gt;/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#%3C/2"><code class="inline">&lt;/2</code></a> and similar are structural and based on the <a href="#content"><code class="inline">Time</code></a> struct fields. For proper comparison between times, use the <a href="#compare/2"><code class="inline">compare/2</code></a> function.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#add/3">add(time, number, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Adds the <code class="inline">number</code> of <code class="inline">unit</code>s to the given <code class="inline">time</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compare/2">compare(time1, time2)</a> </dt> <dd class="summary-synopsis"><p>Compares two time structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert/2">convert(time, calendar)</a> </dt> <dd class="summary-synopsis"><p>Converts given <code class="inline">time</code> to a different calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert!/2">convert!(time, calendar)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#convert/2"><code class="inline">Time.convert/2</code></a>, but raises an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#diff/3">diff(time1, time2, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Returns the difference between two times, considering only the hour, minute, second and microsecond.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl/3">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang time tuple to a <a href="#content"><code class="inline">Time</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl!/3">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang time tuple to a <a href="#content"><code class="inline">Time</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601!/2">from_iso8601!(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_seconds_after_midnight/3">from_seconds_after_midnight(seconds, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts a number of seconds after midnight to a <a href="#content"><code class="inline">Time</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/5">new(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new!/5">new!(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_erl/1">to_erl(time)</a> </dt> <dd class="summary-synopsis"><p>Converts given <code class="inline">time</code> to an Erlang time tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_iso8601/2">to_iso8601(time, format \\ :extended)</a> </dt> <dd class="summary-synopsis"><p>Converts the given time to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_seconds_after_midnight/1">to_seconds_after_midnight(time)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="#content"><code class="inline">Time</code></a> struct to a number of seconds after midnight.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1">to_string(time)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">time</code> to a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#truncate/2">truncate(time, precision)</a> </dt> <dd class="summary-synopsis"><p>Returns the given time with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">millisecond</code> or <code class="inline">:second</code>).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#utc_now/1">utc_now(calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Returns the current time in UTC.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: %Time{
  calendar: Calendar.calendar(),
  hour: Calendar.hour(),
  microsecond: Calendar.microsecond(),
  minute: Calendar.minute(),
  second: Calendar.second()
}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="add/3">add(time, number, unit \\ :second)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">add(Calendar.time(), integer(), System.time_unit()) :: t()</pre> </div> <p>Adds the <code class="inline">number</code> of <code class="inline">unit</code>s to the given <code class="inline">time</code>.</p>
<p>This function accepts the <code class="inline">number</code> measured according to <a href="https://hexdocs.pm/elixir/Calendar.ISO.html"><code class="inline">Calendar.ISO</code></a>. The time is returned in the same calendar as it was given in.</p>
<p>Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar.</p>
<h4 id="add/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.add(~T[10:00:00], 27000)
~T[17:30:00.000000]
iex&gt; Time.add(~T[11:00:00.005], 2400)
~T[11:40:00.005000]
iex&gt; Time.add(~T[00:00:00], 86_399_999, :millisecond)
~T[23:59:59.999000]
iex&gt; Time.add(~T[17:10:05], 86400)
~T[17:10:05.000000]
iex&gt; Time.add(~T[23:00:00], -60)
~T[22:59:00.000000]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="compare/2">compare(time1, time2)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compare(Calendar.time(), Calendar.time()) :: :lt | :eq | :gt</pre> </div> <p>Compares two time structs.</p>
<p>Returns <code class="inline">:gt</code> if first time is later than the second and <code class="inline">:lt</code> for vice versa. If the two times are equal <code class="inline">:eq</code> is returned.</p>
<h4 id="compare/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.compare(~T[16:04:16], ~T[16:04:28])
:lt
iex&gt; Time.compare(~T[16:04:16], ~T[16:04:16])
:eq
iex&gt; Time.compare(~T[16:04:16.01], ~T[16:04:16.001])
:gt</pre>
<p>This function can also be used to compare across more complex calendar types by considering only the time fields:</p>
<pre data-language="elixir">iex&gt; Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])
:eq
iex&gt; Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])
:lt
iex&gt; Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])
:gt</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert/2">convert(time, calendar)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">convert(Calendar.time(), Calendar.calendar()) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Converts given <code class="inline">time</code> to a different calendar.</p>
<p>Returns <code class="inline">{:ok, time}</code> if the conversion was successful, or <code class="inline">{:error, reason}</code> if it was not, for some reason.</p>
<h4 id="convert/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; Time.convert(~T[13:30:15], Calendar.Holocene)
{:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert!/2">convert!(time, calendar)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">convert!(Calendar.time(), Calendar.calendar()) :: t()</pre> </div> <p>Similar to <a href="#convert/2"><code class="inline">Time.convert/2</code></a>, but raises an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p>
<h4 id="convert!/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; Time.convert!(~T[13:30:15], Calendar.Holocene)
%Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="diff/3">diff(time1, time2, unit \\ :second)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">diff(Calendar.time(), Calendar.time(), System.time_unit()) :: integer()</pre> </div> <p>Returns the difference between two times, considering only the hour, minute, second and microsecond.</p>
<p>As with the <a href="#compare/2"><code class="inline">compare/2</code></a> function both <a href="#content"><code class="inline">Time</code></a> structs and other structures containing time can be used. If for instance a <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> or <a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a> is passed, only the hour, minute, second, and microsecond is considered. Any additional information about a date or time zone is ignored when calculating the difference.</p>
<p>The answer can be returned in any <code class="inline">unit</code> available from <a href="https://hexdocs.pm/elixir/System.html#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>. If the first time value is earlier than the second, a negative number is returned.</p>
<p>This function returns the difference in seconds where seconds are measured according to <a href="https://hexdocs.pm/elixir/Calendar.ISO.html"><code class="inline">Calendar.ISO</code></a>.</p>
<h4 id="diff/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.diff(~T[00:29:12], ~T[00:29:10])
2

# When passing a `NaiveDateTime` the date part is ignored.
iex&gt; Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])
2

# Two `NaiveDateTime` structs could have big differences in the date
# but only the time part is considered.
iex&gt; Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])
2

iex&gt; Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)
2_000_000
iex&gt; Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)
-2_000_000</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_erl/3">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_erl(:calendar.time(), Calendar.microsecond(), Calendar.calendar()) ::
  {:ok, t()} | {:error, atom()}</pre> </div> <p>Converts an Erlang time tuple to a <a href="#content"><code class="inline">Time</code></a> struct.</p>
<h4 id="from_erl/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_erl({23, 30, 15}, {5000, 3})
{:ok, ~T[23:30:15.005]}
iex&gt; Time.from_erl({24, 30, 15})
{:error, :invalid_time}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_erl!/3">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_erl!(:calendar.time(), Calendar.microsecond(), Calendar.calendar()) :: t()</pre> </div> <p>Converts an Erlang time tuple to a <a href="#content"><code class="inline">Time</code></a> struct.</p>
<h4 id="from_erl!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_erl!({23, 30, 15})
~T[23:30:15]
iex&gt; Time.from_erl!({23, 30, 15}, {5000, 3})
~T[23:30:15.005]
iex&gt; Time.from_erl!({24, 30, 15})
** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_iso8601(String.t(), Calendar.calendar()) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p>
<p>Time zone offset may be included in the string but they will be simply discarded as such information is not included in times.</p>
<p>As specified in the standard, the separator "T" may be omitted if desired as there is no ambiguity within this function.</p>
<p>Time representations with reduced accuracy are not supported.</p>
<p>Note that while ISO 8601 allows times to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Leap seconds are not supported as well by the built-in Calendar.ISO.</p>
<h4 id="from_iso8601/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_iso8601("23:50:07")
{:ok, ~T[23:50:07]}
iex&gt; Time.from_iso8601("23:50:07Z")
{:ok, ~T[23:50:07]}
iex&gt; Time.from_iso8601("T23:50:07Z")
{:ok, ~T[23:50:07]}

iex&gt; Time.from_iso8601("23:50:07,0123456")
{:ok, ~T[23:50:07.012345]}
iex&gt; Time.from_iso8601("23:50:07.0123456")
{:ok, ~T[23:50:07.012345]}
iex&gt; Time.from_iso8601("23:50:07.123Z")
{:ok, ~T[23:50:07.123]}

iex&gt; Time.from_iso8601("2015:01:23 23-50-07")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:07A")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:07.")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:61")
{:error, :invalid_time}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601!/2">from_iso8601!(string, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_iso8601!(String.t(), Calendar.calendar()) :: t()</pre> </div> <p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p>
<p>Raises if the format is invalid.</p>
<h4 id="from_iso8601!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_iso8601!("23:50:07,123Z")
~T[23:50:07.123]
iex&gt; Time.from_iso8601!("23:50:07.123Z")
~T[23:50:07.123]
iex&gt; Time.from_iso8601!("2015:01:23 23-50-07")
** (ArgumentError) cannot parse "2015:01:23 23-50-07" as time, reason: :invalid_format</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_seconds_after_midnight/3">from_seconds_after_midnight(seconds, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_seconds_after_midnight(
  integer(),
  Calendar.microsecond(),
  Calendar.calendar()
) :: t()</pre> </div> <p>Converts a number of seconds after midnight to a <a href="#content"><code class="inline">Time</code></a> struct.</p>
<h4 id="from_seconds_after_midnight/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_seconds_after_midnight(10_000)
~T[02:46:40]
iex&gt; Time.from_seconds_after_midnight(30_000, {5000, 3})
~T[08:20:00.005]
iex&gt; Time.from_seconds_after_midnight(-1)
~T[23:59:59]
iex&gt; Time.from_seconds_after_midnight(100_000)
~T[03:46:40]</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new/5">new(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">new(
  Calendar.hour(),
  Calendar.minute(),
  Calendar.second(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Builds a new time.</p>
<p>Expects all values to be integers. Returns <code class="inline">{:ok, time}</code> if each entry fits its appropriate range, returns <code class="inline">{:error, reason}</code> otherwise.</p>
<p>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</p>
<p>The built-in calendar does not support leap seconds.</p>
<h4 id="new/5-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.new(0, 0, 0, 0)
{:ok, ~T[00:00:00.000000]}
iex&gt; Time.new(23, 59, 59, 999_999)
{:ok, ~T[23:59:59.999999]}

iex&gt; Time.new(24, 59, 59, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 60, 59, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 59, 60, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 59, 59, 1_000_000)
{:error, :invalid_time}

# Invalid precision
Time.new(23, 59, 59, {999_999, 10})
{:error, :invalid_time}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new!/5">new!(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">new!(
  Calendar.hour(),
  Calendar.minute(),
  Calendar.second(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: t()</pre> </div> <p>Builds a new time.</p>
<p>Expects all values to be integers. Returns <code class="inline">time</code> if each entry fits its appropriate range, raises if the time is invalid.</p>
<p>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</p>
<p>The built-in calendar does not support leap seconds.</p>
<h4 id="new!/5-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.new!(0, 0, 0, 0)
~T[00:00:00.000000]
iex&gt; Time.new!(23, 59, 59, 999_999)
~T[23:59:59.999999]
iex&gt; Time.new!(24, 59, 59, 999_999)
** (ArgumentError) cannot build time, reason: :invalid_time</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_erl/1">to_erl(time)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_erl(Calendar.time()) :: :calendar.time()</pre> </div> <p>Converts given <code class="inline">time</code> to an Erlang time tuple.</p>
<p>WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds.</p>
<h4 id="to_erl/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.to_erl(~T[23:30:15.999])
{23, 30, 15}

iex&gt; Time.to_erl(~N[2010-04-17 23:30:15.999])
{23, 30, 15}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="to_iso8601/2">to_iso8601(time, format \\ :extended)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_iso8601(Calendar.time(), :extended | :basic) :: String.t()</pre> </div> <p>Converts the given time to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p>
<p>By default, <a href="#to_iso8601/2"><code class="inline">Time.to_iso8601/2</code></a> returns times formatted in the "extended" format, for human readability. It also supports the "basic" format through passing the <code class="inline">:basic</code> option.</p>
<h3 id="to_iso8601/2-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; Time.to_iso8601(~T[23:00:13])
"23:00:13"

iex&gt; Time.to_iso8601(~T[23:00:13.001])
"23:00:13.001"

iex&gt; Time.to_iso8601(~T[23:00:13.001], :basic)
"230013.001"

iex&gt; Time.to_iso8601(~N[2010-04-17 23:00:13])
"23:00:13"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_seconds_after_midnight/1">to_seconds_after_midnight(time)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_seconds_after_midnight(Calendar.time()) :: {integer(), non_neg_integer()}</pre> </div> <p>Converts a <a href="#content"><code class="inline">Time</code></a> struct to a number of seconds after midnight.</p>
<p>The returned value is a two-element tuple with the number of seconds and microseconds.</p>
<h4 id="to_seconds_after_midnight/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.to_seconds_after_midnight(~T[23:30:15])
{84615, 0}
iex&gt; Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])
{84615, 999000}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(time)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_string(Calendar.time()) :: String.t()</pre> </div> <p>Converts the given <code class="inline">time</code> to a string.</p>
<h3 id="to_string/1-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; Time.to_string(~T[23:00:00])
"23:00:00"
iex&gt; Time.to_string(~T[23:00:00.001])
"23:00:00.001"
iex&gt; Time.to_string(~T[23:00:00.123456])
"23:00:00.123456"

iex&gt; Time.to_string(~N[2015-01-01 23:00:00.001])
"23:00:00.001"
iex&gt; Time.to_string(~N[2015-01-01 23:00:00.123456])
"23:00:00.123456"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="truncate/2">truncate(time, precision)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">truncate(t(), :microsecond | :millisecond | :second) :: t()</pre> </div> <p>Returns the given time with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">millisecond</code> or <code class="inline">:second</code>).</p>
<p>The given time is returned unchanged if it already has lower precision than the given precision.</p>
<h4 id="truncate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.truncate(~T[01:01:01.123456], :microsecond)
~T[01:01:01.123456]

iex&gt; Time.truncate(~T[01:01:01.123456], :millisecond)
~T[01:01:01.123]

iex&gt; Time.truncate(~T[01:01:01.123456], :second)
~T[01:01:01]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="utc_now/1">utc_now(calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">utc_now(Calendar.calendar()) :: t()</pre> </div> <p>Returns the current time in UTC.</p>
<h4 id="utc_now/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; time = Time.utc_now()
iex&gt; time.hour &gt;= 0
true</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    Â© 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.11.2/Time.html" class="_attribution-link">https://hexdocs.pm/elixir/1.11.2/Time.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
