
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>List - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" Linked lists hold zero, one, or more elements in the chosen order. ">
  <meta name="keywords" content="list, summary, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/list.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> List   </h1> <section id="moduledoc"> <p>Linked lists hold zero, one, or more elements in the chosen order.</p>
<p>Lists in Elixir are specified between square brackets:</p>
<pre data-language="elixir">iex&gt; [1, "two", 3, :four]
[1, "two", 3, :four]</pre>
<p>Two lists can be concatenated and subtracted using the <a href="https://hexdocs.pm/elixir/Kernel.html#++/2"><code class="inline">Kernel.++/2</code></a> and <a href="https://hexdocs.pm/elixir/Kernel.html#--/2"><code class="inline">Kernel.--/2</code></a> operators:</p>
<pre data-language="elixir">iex&gt; [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex&gt; [1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]</pre>
<p>Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:</p>
<pre data-language="elixir">iex&gt; [head | tail] = [1, 2, 3]
iex&gt; head
1
iex&gt; tail
[2, 3]</pre>
<p>Similarly, we could write the list <code class="inline">[1, 2, 3]</code> using only such pairs (called cons cells):</p>
<pre data-language="elixir">iex&gt; [1 | [2 | [3 | []]]]
[1, 2, 3]</pre>
<p>Some lists, called improper lists, do not have an empty list as the second element in the last cons cell:</p>
<pre data-language="elixir">iex&gt; [1 | [2 | [3 | 4]]]
[1, 2, 3 | 4]</pre>
<p>Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the <a href="https://hexdocs.pm/elixir/IO.html"><code class="inline">IO</code></a> module).</p>
<p>Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time):</p>
<pre data-language="elixir">iex&gt; list = [1, 2, 3]
iex&gt; [0 | list] # fast
[0, 1, 2, 3]
iex&gt; list ++ [4] # slow
[1, 2, 3, 4]</pre>
<p>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example <a href="https://hexdocs.pm/elixir/Kernel.html#length/1"><code class="inline">length/1</code></a> and <a href="#last/1"><code class="inline">last/1</code></a> will run in linear time because they need to iterate through every element of the list, but <a href="#first/1"><code class="inline">first/1</code></a> will run in constant time because it only needs the first element.</p>
<p>Lists also implement the <a href="https://hexdocs.pm/elixir/Enumerable.html"><code class="inline">Enumerable</code></a> protocol, so many functions to work with lists are found in the <a href="https://hexdocs.pm/elixir/Enum.html"><code class="inline">Enum</code></a> module. Additionally, the following functions and operators for lists are found in <a href="https://hexdocs.pm/elixir/Kernel.html"><code class="inline">Kernel</code></a>:</p>
<ul>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#++/2"><code class="inline">++/2</code></a></li>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#--/2"><code class="inline">--/2</code></a></li>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#hd/1"><code class="inline">hd/1</code></a></li>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#tl/1"><code class="inline">tl/1</code></a></li>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#in/2"><code class="inline">in/2</code></a></li>
<li><a href="https://hexdocs.pm/elixir/Kernel.html#length/1"><code class="inline">length/1</code></a></li>
</ul>
<h2 id="module-charlists" class="section-heading">  Charlists </h2> <p>If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:</p>
<ul>
<li>be within the range <code class="inline">0..0x10FFFF</code> (<code class="inline">0..1_114_111</code>);</li>
<li>and be out of the range <code class="inline">0xD800..0xDFFF</code> (<code class="inline">55_296..57_343</code>), which is reserved in Unicode for UTF-16 surrogate pairs.</li>
</ul>
<p>Elixir uses single quotes to define charlists:</p>
<pre data-language="elixir">iex&gt; 'hÃ©llo'
[104, 233, 108, 108, 111]</pre>
<p>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</p>
<pre data-language="elixir">iex&gt; 'abc'
'abc'</pre>
<p>Even though the representation changed, the raw data does remain a list of numbers, which can be handled as such:</p>
<pre data-language="elixir">iex&gt; inspect('abc', charlists: :as_list)
"[97, 98, 99]"
iex&gt; Enum.map('abc', fn num -&gt; 1000 + num end)
[1097, 1098, 1099]</pre>
<p>You can use the <a href="https://hexdocs.pm/iex/IEx.Helpers.html#i/1"><code class="inline">IEx.Helpers.i/1</code></a> helper to get a condensed rundown on charlists in IEx when you encounter them, which shows you the type, description and also the raw representation in one single summary.</p>
<p>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is <a href="https://hexdocs.pm/elixir/Application.html#loaded_applications/0"><code class="inline">Application.loaded_applications/0</code></a>:</p>
<pre data-language="elixir">Application.loaded_applications()
#=&gt;  [
#=&gt;    {:stdlib, 'ERTS  CXC 138 10', '2.6'},
#=&gt;    {:compiler, 'ERTS  CXC 138 10', '6.0.1'},
#=&gt;    {:elixir, 'elixir', '1.0.0'},
#=&gt;    {:kernel, 'ERTS  CXC 138 10', '4.1'},
#=&gt;    {:logger, 'logger', '1.0.0'}
#=&gt;  ]</pre>
<p>A list can be checked if it is made of only printable ASCII characters with <a href="#ascii_printable?/2"><code class="inline">ascii_printable?/2</code></a>.</p>
<p>Improper lists are never deemed as charlists.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#ascii_printable?/2">ascii_printable?(list, limit \\ :infinity)</a> </dt> <dd class="summary-synopsis"><p>Checks if <code class="inline">list</code> is a charlist made only of printable ASCII characters.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete/2">delete(list, element)</a> </dt> <dd class="summary-synopsis"><p>Deletes the given <code class="inline">element</code> from the <code class="inline">list</code>. Returns a new list without the element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_at/2">delete_at(list, index)</a> </dt> <dd class="summary-synopsis"><p>Produces a new list by removing the value at the specified <code class="inline">index</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#duplicate/2">duplicate(elem, n)</a> </dt> <dd class="summary-synopsis"><p>Duplicates the given element <code class="inline">n</code> times in a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#first/1">first(list)</a> </dt> <dd class="summary-synopsis"><p>Returns the first element in <code class="inline">list</code> or <code class="inline">nil</code> if <code class="inline">list</code> is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flatten/1">flatten(list)</a> </dt> <dd class="summary-synopsis"><p>Flattens the given <code class="inline">list</code> of nested lists.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flatten/2">flatten(list, tail)</a> </dt> <dd class="summary-synopsis"><p>Flattens the given <code class="inline">list</code> of nested lists. The list <code class="inline">tail</code> will be added at the end of the flattened list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#foldl/3">foldl(list, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Folds (reduces) the given list from the left with a function. Requires an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#foldr/3">foldr(list, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Folds (reduces) the given list from the right with a function. Requires an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#improper?/1">improper?(list)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">list</code> is an improper list. Otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#insert_at/3">insert_at(list, index, value)</a> </dt> <dd class="summary-synopsis"><p>Returns a list with <code class="inline">value</code> inserted at the specified <code class="inline">index</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keydelete/3">keydelete(list, key, position)</a> </dt> <dd class="summary-synopsis"><p>Receives a <code class="inline">list</code> of tuples and deletes the first tuple where the element at <code class="inline">position</code> matches the given <code class="inline">key</code>. Returns the new list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keyfind/4">keyfind(list, key, position, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Receives a list of tuples and returns the first tuple where the element at <code class="inline">position</code> in the tuple matches the given <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keymember?/3">keymember?(list, key, position)</a> </dt> <dd class="summary-synopsis"><p>Receives a list of tuples and returns <code class="inline">true</code> if there is a tuple where the element at <code class="inline">position</code> in the tuple matches the given <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keyreplace/4">keyreplace(list, key, position, new_tuple)</a> </dt> <dd class="summary-synopsis"><p>Receives a list of tuples and if the identified element by <code class="inline">key</code> at <code class="inline">position</code> exists, it is replaced with <code class="inline">new_tuple</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keysort/2">keysort(list, position)</a> </dt> <dd class="summary-synopsis"><p>Receives a list of tuples and sorts the elements at <code class="inline">position</code> of the tuples. The sort is stable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keystore/4">keystore(list, key, position, new_tuple)</a> </dt> <dd class="summary-synopsis"><p>Receives a <code class="inline">list</code> of tuples and replaces the element identified by <code class="inline">key</code> at <code class="inline">position</code> with <code class="inline">new_tuple</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keytake/3">keytake(list, key, position)</a> </dt> <dd class="summary-synopsis"><p>Receives a <code class="inline">list</code> of tuples and returns the first tuple where the element at <code class="inline">position</code> in the tuple matches the given <code class="inline">key</code>, as well as the <code class="inline">list</code> without found tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#last/1">last(list)</a> </dt> <dd class="summary-synopsis"><p>Returns the last element in <code class="inline">list</code> or <code class="inline">nil</code> if <code class="inline">list</code> is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#myers_difference/2">myers_difference(list1, list2)</a> </dt> <dd class="summary-synopsis"><p>Returns a keyword list that represents an <em>edit script</em>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#myers_difference/3">myers_difference(list1, list2, diff_script)</a> </dt> <dd class="summary-synopsis"><p>Returns a keyword list that represents an <em>edit script</em> with nested diffs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_at/3">pop_at(list, index, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns and removes the value at the specified <code class="inline">index</code> in the <code class="inline">list</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_at/3">replace_at(list, index, value)</a> </dt> <dd class="summary-synopsis"><p>Returns a list with a replaced value at the specified <code class="inline">index</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#starts_with?/2">starts_with?(list, prefix)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">list</code> starts with the given <code class="inline">prefix</code> list; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_atom/1">to_atom(charlist)</a> </dt> <dd class="summary-synopsis"><p>Converts a charlist to an atom.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_charlist/1">to_charlist(list)</a> </dt> <dd class="summary-synopsis"><p>Converts a list of integers representing Unicode code points, lists or strings into a charlist.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_existing_atom/1">to_existing_atom(charlist)</a> </dt> <dd class="summary-synopsis"><p>Converts a charlist to an existing atom. Raises an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the atom does not exist.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_float/1">to_float(charlist)</a> </dt> <dd class="summary-synopsis"><p>Returns the float whose text representation is <code class="inline">charlist</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_integer/1">to_integer(charlist)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer whose text representation is <code class="inline">charlist</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_integer/2">to_integer(charlist, base)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer whose text representation is <code class="inline">charlist</code> in base <code class="inline">base</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1">to_string(list)</a> </dt> <dd class="summary-synopsis"><p>Converts a list of integers representing code points, lists or strings into a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_tuple/1">to_tuple(list)</a> </dt> <dd class="summary-synopsis"><p>Converts a list to a tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_at/3">update_at(list, index, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list with an updated value at the specified <code class="inline">index</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#wrap/1">wrap(term)</a> </dt> <dd class="summary-synopsis"><p>Wraps <code class="inline">term</code> in a list if this is not list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip/1">zip(list_of_lists)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from each list in <code class="inline">list_of_lists</code>.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="ascii_printable?/2">ascii_printable?(list, limit \\ :infinity)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ascii_printable?(list(), 0) :: true</pre> <pre data-language="elixir">ascii_printable?([], limit) :: true when limit: :infinity | pos_integer()</pre> <pre data-language="elixir">ascii_printable?([...], limit) :: boolean()
when limit: :infinity | pos_integer()</pre> </div> <p>Checks if <code class="inline">list</code> is a charlist made only of printable ASCII characters.</p>
<p>Takes an optional <code class="inline">limit</code> as a second argument. <a href="#ascii_printable?/2"><code class="inline">ascii_printable?/2</code></a> only checks the printability of the list up to the <code class="inline">limit</code>.</p>
<p>A printable charlist in Elixir contains only the printable characters in the standard seven-bit ASCII character encoding, which are characters ranging from 32 to 126 in decimal notation, plus the following control characters:</p>
<ul>
<li>
<code class="inline">?\a</code> - Bell</li>
<li>
<code class="inline">?\b</code> - Backspace</li>
<li>
<code class="inline">?\t</code> - Horizontal tab</li>
<li>
<code class="inline">?\n</code> - Line feed</li>
<li>
<code class="inline">?\v</code> - Vertical tab</li>
<li>
<code class="inline">?\f</code> - Form feed</li>
<li>
<code class="inline">?\r</code> - Carriage return</li>
<li>
<code class="inline">?\e</code> - Escape</li>
</ul>
<p>For more information read the <a href="https://en.wikipedia.org/wiki/ASCII#Character_groups">Character groups</a> section in the Wikipedia article of the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> standard.</p>
<h4 id="ascii_printable?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.ascii_printable?('abc')
true

iex&gt; List.ascii_printable?('abc' ++ [0])
false

iex&gt; List.ascii_printable?('abc' ++ [0], 2)
true</pre>
<p>Improper lists are not printable, even if made only of ASCII characters:</p>
<pre data-language="elixir">iex&gt; List.ascii_printable?('abc' ++ ?d)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete/2">delete(list, element)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete([], any()) :: []</pre> <pre data-language="elixir">delete([...], any()) :: list()</pre> </div> <p>Deletes the given <code class="inline">element</code> from the <code class="inline">list</code>. Returns a new list without the element.</p>
<p>If the <code class="inline">element</code> occurs more than once in the <code class="inline">list</code>, just the first occurrence is removed.</p>
<h4 id="delete/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.delete([:a, :b, :c], :a)
[:b, :c]

iex&gt; List.delete([:a, :b, :c], :d)
[:a, :b, :c]

iex&gt; List.delete([:a, :b, :b, :c], :b)
[:a, :b, :c]

iex&gt; List.delete([], :b)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_at/2">delete_at(list, index)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete_at(list(), integer()) :: list()</pre> </div> <p>Produces a new list by removing the value at the specified <code class="inline">index</code>.</p>
<p>Negative indices indicate an offset from the end of the <code class="inline">list</code>. If <code class="inline">index</code> is out of bounds, the original <code class="inline">list</code> is returned.</p>
<h4 id="delete_at/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.delete_at([1, 2, 3], 0)
[2, 3]

iex&gt; List.delete_at([1, 2, 3], 10)
[1, 2, 3]

iex&gt; List.delete_at([1, 2, 3], -1)
[1, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="duplicate/2">duplicate(elem, n)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">duplicate(any(), 0) :: []</pre> <pre data-language="elixir">duplicate(elem, pos_integer()) :: [elem, ...] when elem: var</pre> </div> <p>Duplicates the given element <code class="inline">n</code> times in a list.</p>
<p><code class="inline">n</code> is an integer greater than or equal to <code class="inline">0</code>.</p>
<p>If <code class="inline">n</code> is <code class="inline">0</code>, an empty list is returned.</p>
<h4 id="duplicate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.duplicate("hello", 0)
[]

iex&gt; List.duplicate("hi", 1)
["hi"]

iex&gt; List.duplicate("bye", 2)
["bye", "bye"]

iex&gt; List.duplicate([1, 2], 3)
[[1, 2], [1, 2], [1, 2]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="first/1">first(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">first([]) :: nil</pre> <pre data-language="elixir">first([elem, ...]) :: elem when elem: var</pre> </div> <p>Returns the first element in <code class="inline">list</code> or <code class="inline">nil</code> if <code class="inline">list</code> is empty.</p>
<h4 id="first/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.first([])
nil

iex&gt; List.first([1])
1

iex&gt; List.first([1, 2, 3])
1</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flatten/1">flatten(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">flatten(deep_list) :: list() when deep_list: [any() | deep_list]</pre> </div> <p>Flattens the given <code class="inline">list</code> of nested lists.</p>
<p>Empty list elements are discarded.</p>
<h4 id="flatten/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.flatten([1, [[2], 3]])
[1, 2, 3]

iex&gt; List.flatten([[], [[], []]])
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flatten/2">flatten(list, tail)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">flatten(deep_list, [elem]) :: [elem]
when deep_list: [elem | deep_list], elem: var</pre> </div> <p>Flattens the given <code class="inline">list</code> of nested lists. The list <code class="inline">tail</code> will be added at the end of the flattened list.</p>
<p>Empty list elements from <code class="inline">list</code> are discarded, but not the ones from <code class="inline">tail</code>.</p>
<h4 id="flatten/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.flatten([1, [[2], 3]], [4, 5])
[1, 2, 3, 4, 5]

iex&gt; List.flatten([1, [], 2], [3, [], 4])
[1, 2, 3, [], 4]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="foldl/3">foldl(list, acc, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">foldl([elem], acc, (elem, acc -&gt; acc)) :: acc when elem: var, acc: var</pre> </div> <p>Folds (reduces) the given list from the left with a function. Requires an accumulator.</p>
<h4 id="foldl/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.foldl([5, 5], 10, fn x, acc -&gt; x + acc end)
20

iex&gt; List.foldl([1, 2, 3, 4], 0, fn x, acc -&gt; x - acc end)
2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="foldr/3">foldr(list, acc, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">foldr([elem], acc, (elem, acc -&gt; acc)) :: acc when elem: var, acc: var</pre> </div> <p>Folds (reduces) the given list from the right with a function. Requires an accumulator.</p>
<h4 id="foldr/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.foldr([1, 2, 3, 4], 0, fn x, acc -&gt; x - acc end)
-2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="improper?/1">improper?(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">improper?(maybe_improper_list()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">list</code> is an improper list. Otherwise returns <code class="inline">false</code>.</p>
<h4 id="improper?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.improper?([1, 2 | 3])
true

iex&gt; List.improper?([1, 2, 3])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="insert_at/3">insert_at(list, index, value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">insert_at(list(), integer(), any()) :: list()</pre> </div> <p>Returns a list with <code class="inline">value</code> inserted at the specified <code class="inline">index</code>.</p>
<p>Note that <code class="inline">index</code> is capped at the list length. Negative indices indicate an offset from the end of the <code class="inline">list</code>.</p>
<h4 id="insert_at/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.insert_at([1, 2, 3, 4], 2, 0)
[1, 2, 0, 3, 4]

iex&gt; List.insert_at([1, 2, 3], 10, 0)
[1, 2, 3, 0]

iex&gt; List.insert_at([1, 2, 3], -1, 0)
[1, 2, 3, 0]

iex&gt; List.insert_at([1, 2, 3], -10, 0)
[0, 1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keydelete/3">keydelete(list, key, position)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keydelete([tuple()], any(), non_neg_integer()) :: [tuple()]</pre> </div> <p>Receives a <code class="inline">list</code> of tuples and deletes the first tuple where the element at <code class="inline">position</code> matches the given <code class="inline">key</code>. Returns the new list.</p>
<h4 id="keydelete/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.keydelete([a: 1, b: 2], :a, 0)
[b: 2]

iex&gt; List.keydelete([a: 1, b: 2], 2, 1)
[a: 1]

iex&gt; List.keydelete([a: 1, b: 2], :c, 0)
[a: 1, b: 2]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="keyfind/4">keyfind(list, key, position, default \\ nil)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keyfind([tuple()], any(), non_neg_integer(), any()) :: any()</pre> </div> <p>Receives a list of tuples and returns the first tuple where the element at <code class="inline">position</code> in the tuple matches the given <code class="inline">key</code>.</p>
<p>If no matching tuple is found, <code class="inline">default</code> is returned.</p>
<h4 id="keyfind/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.keyfind([a: 1, b: 2], :a, 0)
{:a, 1}

iex&gt; List.keyfind([a: 1, b: 2], 2, 1)
{:b, 2}

iex&gt; List.keyfind([a: 1, b: 2], :c, 0)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keymember?/3">keymember?(list, key, position)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keymember?([tuple()], any(), non_neg_integer()) :: boolean()</pre> </div> <p>Receives a list of tuples and returns <code class="inline">true</code> if there is a tuple where the element at <code class="inline">position</code> in the tuple matches the given <code class="inline">key</code>.</p>
<h4 id="keymember?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.keymember?([a: 1, b: 2], :a, 0)
true

iex&gt; List.keymember?([a: 1, b: 2], 2, 1)
true

iex&gt; List.keymember?([a: 1, b: 2], :c, 0)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keyreplace/4">keyreplace(list, key, position, new_tuple)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keyreplace([tuple()], any(), non_neg_integer(), tuple()) :: [tuple()]</pre> </div> <p>Receives a list of tuples and if the identified element by <code class="inline">key</code> at <code class="inline">position</code> exists, it is replaced with <code class="inline">new_tuple</code>.</p>
<h4 id="keyreplace/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})
[a: 3, b: 2]

iex&gt; List.keyreplace([a: 1, b: 2], :a, 1, {:a, 3})
[a: 1, b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keysort/2">keysort(list, position)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keysort([tuple()], non_neg_integer()) :: [tuple()]</pre> </div> <p>Receives a list of tuples and sorts the elements at <code class="inline">position</code> of the tuples. The sort is stable.</p>
<h4 id="keysort/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.keysort([a: 5, b: 1, c: 3], 1)
[b: 1, c: 3, a: 5]

iex&gt; List.keysort([a: 5, c: 1, b: 3], 0)
[a: 5, b: 3, c: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keystore/4">keystore(list, key, position, new_tuple)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keystore([tuple()], any(), non_neg_integer(), tuple()) :: [tuple(), ...]</pre> </div> <p>Receives a <code class="inline">list</code> of tuples and replaces the element identified by <code class="inline">key</code> at <code class="inline">position</code> with <code class="inline">new_tuple</code>.</p>
<p>If the element does not exist, it is added to the end of the <code class="inline">list</code>.</p>
<h4 id="keystore/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.keystore([a: 1, b: 2], :a, 0, {:a, 3})
[a: 3, b: 2]

iex&gt; List.keystore([a: 1, b: 2], :c, 0, {:c, 3})
[a: 1, b: 2, c: 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keytake/3">keytake(list, key, position)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keytake([tuple()], any(), non_neg_integer()) :: {tuple(), [tuple()]} | nil</pre> </div> <p>Receives a <code class="inline">list</code> of tuples and returns the first tuple where the element at <code class="inline">position</code> in the tuple matches the given <code class="inline">key</code>, as well as the <code class="inline">list</code> without found tuple.</p>
<p>If such a tuple is not found, <code class="inline">nil</code> will be returned.</p>
<h4 id="keytake/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.keytake([a: 1, b: 2], :a, 0)
{{:a, 1}, [b: 2]}

iex&gt; List.keytake([a: 1, b: 2], 2, 1)
{{:b, 2}, [a: 1]}

iex&gt; List.keytake([a: 1, b: 2], :c, 0)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="last/1">last(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">last([]) :: nil</pre> <pre data-language="elixir">last([elem, ...]) :: elem when elem: var</pre> </div> <p>Returns the last element in <code class="inline">list</code> or <code class="inline">nil</code> if <code class="inline">list</code> is empty.</p>
<h4 id="last/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.last([])
nil

iex&gt; List.last([1])
1

iex&gt; List.last([1, 2, 3])
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="myers_difference/2">myers_difference(list1, list2)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">myers_difference(list(), list()) :: [{:eq | :ins | :del, list()}]</pre> </div> <p>Returns a keyword list that represents an <em>edit script</em>.</p>
<p>The algorithm is outlined in the "An O(ND) Difference Algorithm and Its Variations" paper by E. Myers.</p>
<p>An <em>edit script</em> is a keyword list. Each key describes the "editing action" to take in order to bring <code class="inline">list1</code> closer to being equal to <code class="inline">list2</code>; a key can be <code class="inline">:eq</code>, <code class="inline">:ins</code>, or <code class="inline">:del</code>. Each value is a sublist of either <code class="inline">list1</code> or <code class="inline">list2</code> that should be inserted (if the corresponding key <code class="inline">:ins</code>), deleted (if the corresponding key is <code class="inline">:del</code>), or left alone (if the corresponding key is <code class="inline">:eq</code>) in <code class="inline">list1</code> in order to be closer to <code class="inline">list2</code>.</p>
<p>See <a href="#myers_difference/3"><code class="inline">myers_difference/3</code></a> if you want to handle nesting in the diff scripts.</p>
<h4 id="myers_difference/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])
[eq: [1], del: [4], eq: [2, 3], ins: [4]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="myers_difference/3">myers_difference(list1, list2, diff_script)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">myers_difference(list(), list(), (term(), term() -&gt; script | nil)) :: script
when script: [{:eq | :ins | :del | :diff, list()}]</pre> </div> <p>Returns a keyword list that represents an <em>edit script</em> with nested diffs.</p>
<p>This is an extension of <a href="#myers_difference/2"><code class="inline">myers_difference/2</code></a> where a <code class="inline">diff_script</code> function can be given in case it is desired to compute nested differences. The function may return a list with the inner edit script or <code class="inline">nil</code> in case there is no such script. The returned inner edit script will be under the <code class="inline">:diff</code> key.</p>
<h4 id="myers_difference/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.myers_difference(["a", "db", "c"], ["a", "bc"], &amp;String.myers_difference/2)
[eq: ["a"], diff: [del: "d", eq: "b", ins: "c"], del: ["c"]]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pop_at/3">pop_at(list, index, default \\ nil)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pop_at(list(), integer(), any()) :: {any(), list()}</pre> </div> <p>Returns and removes the value at the specified <code class="inline">index</code> in the <code class="inline">list</code>.</p>
<p>Negative indices indicate an offset from the end of the <code class="inline">list</code>. If <code class="inline">index</code> is out of bounds, the original <code class="inline">list</code> is returned.</p>
<h4 id="pop_at/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.pop_at([1, 2, 3], 0)
{1, [2, 3]}
iex&gt; List.pop_at([1, 2, 3], 5)
{nil, [1, 2, 3]}
iex&gt; List.pop_at([1, 2, 3], 5, 10)
{10, [1, 2, 3]}
iex&gt; List.pop_at([1, 2, 3], -1)
{3, [1, 2]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_at/3">replace_at(list, index, value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace_at(list(), integer(), any()) :: list()</pre> </div> <p>Returns a list with a replaced value at the specified <code class="inline">index</code>.</p>
<p>Negative indices indicate an offset from the end of the <code class="inline">list</code>. If <code class="inline">index</code> is out of bounds, the original <code class="inline">list</code> is returned.</p>
<h4 id="replace_at/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.replace_at([1, 2, 3], 0, 0)
[0, 2, 3]

iex&gt; List.replace_at([1, 2, 3], 10, 0)
[1, 2, 3]

iex&gt; List.replace_at([1, 2, 3], -1, 0)
[1, 2, 0]

iex&gt; List.replace_at([1, 2, 3], -10, 0)
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="starts_with?/2">starts_with?(list, prefix)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">starts_with?([...], [...]) :: boolean()</pre> <pre data-language="elixir">starts_with?(list(), []) :: true</pre> <pre data-language="elixir">starts_with?([], [...]) :: false</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">list</code> starts with the given <code class="inline">prefix</code> list; otherwise returns <code class="inline">false</code>.</p>
<p>If <code class="inline">prefix</code> is an empty list, it returns <code class="inline">true</code>.</p>
<h3 id="starts_with?/2-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; List.starts_with?([1, 2, 3], [1, 2])
true

iex&gt; List.starts_with?([1, 2], [1, 2, 3])
false

iex&gt; List.starts_with?([:alpha], [])
true

iex&gt; List.starts_with?([], [:alpha])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_atom/1">to_atom(charlist)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_atom(charlist()) :: atom()</pre> </div> <p>Converts a charlist to an atom.</p>
<p>Elixir supports conversions from charlists which contains any Unicode code point.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_atom/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.to_atom('Elixir')
:Elixir

iex&gt; List.to_atom('ðŸŒ¢ Elixir')
:"ðŸŒ¢ Elixir"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_charlist/1">to_charlist(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_charlist(:unicode.charlist()) :: charlist()</pre> </div> <p>Converts a list of integers representing Unicode code points, lists or strings into a charlist.</p>
<p>Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the <a href="http://www.erlang.org/doc/man/binary.html"><code class="inline">:binary</code> module</a>.</p>
<h4 id="to_charlist/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.to_charlist([0x00E6, 0x00DF])
'Ã¦ÃŸ'

iex&gt; List.to_charlist([0x0061, "bc"])
'abc'

iex&gt; List.to_charlist([0x0064, "ee", ['p']])
'deep'</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_existing_atom/1">to_existing_atom(charlist)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_existing_atom(charlist()) :: atom()</pre> </div> <p>Converts a charlist to an existing atom. Raises an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the atom does not exist.</p>
<p>Elixir supports conversions from charlists which contains any Unicode code point.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_existing_atom/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; _ = :my_atom
iex&gt; List.to_existing_atom('my_atom')
:my_atom

iex&gt; _ = :"ðŸŒ¢ Elixir"
iex&gt; List.to_existing_atom('ðŸŒ¢ Elixir')
:"ðŸŒ¢ Elixir"

iex&gt; List.to_existing_atom('this_atom_will_never_exist')
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_float/1">to_float(charlist)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_float(charlist()) :: float()</pre> </div> <p>Returns the float whose text representation is <code class="inline">charlist</code>.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_float/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.to_float('2.2017764e+0')
2.2017764</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_integer/1">to_integer(charlist)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_integer(charlist()) :: integer()</pre> </div> <p>Returns an integer whose text representation is <code class="inline">charlist</code>.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_integer/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.to_integer('123')
123</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_integer/2">to_integer(charlist, base)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_integer(charlist(), 2..36) :: integer()</pre> </div> <p>Returns an integer whose text representation is <code class="inline">charlist</code> in base <code class="inline">base</code>.</p>
<p>Inlined by the compiler.</p>
<p>The base needs to be between <code class="inline">2</code> and <code class="inline">36</code>.</p>
<h4 id="to_integer/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.to_integer('3FF', 16)
1023</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_string(:unicode.charlist()) :: String.t()</pre> </div> <p>Converts a list of integers representing code points, lists or strings into a string.</p>
<p>To be converted to a string, a list must either be empty or only contain the following elements:</p>
<ul>
<li>strings</li>
<li>integers representing Unicode code points</li>
<li>a list containing one of these three elements</li>
</ul>
<p>Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the <a href="http://www.erlang.org/doc/man/binary.html"><code class="inline">:binary</code> module</a>.</p>
<h4 id="to_string/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.to_string([0x00E6, 0x00DF])
"Ã¦ÃŸ"

iex&gt; List.to_string([0x0061, "bc"])
"abc"

iex&gt; List.to_string([0x0064, "ee", ['p']])
"deep"

iex&gt; List.to_string([])
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_tuple/1">to_tuple(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_tuple(list()) :: tuple()</pre> </div> <p>Converts a list to a tuple.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_tuple/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.to_tuple([:share, [:elixir, 163]])
{:share, [:elixir, 163]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update_at/3">update_at(list, index, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">update_at([elem], integer(), (elem -&gt; any())) :: list() when elem: var</pre> </div> <p>Returns a list with an updated value at the specified <code class="inline">index</code>.</p>
<p>Negative indices indicate an offset from the end of the <code class="inline">list</code>. If <code class="inline">index</code> is out of bounds, the original <code class="inline">list</code> is returned.</p>
<h4 id="update_at/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.update_at([1, 2, 3], 0, &amp;(&amp;1 + 10))
[11, 2, 3]

iex&gt; List.update_at([1, 2, 3], 10, &amp;(&amp;1 + 10))
[1, 2, 3]

iex&gt; List.update_at([1, 2, 3], -1, &amp;(&amp;1 + 10))
[1, 2, 13]

iex&gt; List.update_at([1, 2, 3], -10, &amp;(&amp;1 + 10))
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="wrap/1">wrap(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">wrap(term()) :: maybe_improper_list()</pre> </div> <p>Wraps <code class="inline">term</code> in a list if this is not list.</p>
<p>If <code class="inline">term</code> is already a list, it returns the list. If <code class="inline">term</code> is <code class="inline">nil</code>, it returns an empty list.</p>
<h4 id="wrap/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.wrap("hello")
["hello"]

iex&gt; List.wrap([1, 2, 3])
[1, 2, 3]

iex&gt; List.wrap(nil)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip/1">zip(list_of_lists)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">zip([list()]) :: [tuple()]</pre> </div> <p>Zips corresponding elements from each list in <code class="inline">list_of_lists</code>.</p>
<p>The zipping finishes as soon as any list terminates.</p>
<h4 id="zip/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; List.zip([[1, 2], [3, 4], [5, 6]])
[{1, 3, 5}, {2, 4, 6}]

iex&gt; List.zip([[1, 2], [3], [5, 6]])
[{1, 3, 5}]</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    Â© 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.11.2/List.html" class="_attribution-link">https://hexdocs.pm/elixir/1.11.2/List.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
