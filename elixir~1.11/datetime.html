
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>DateTime - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" A datetime implementation with a time zone. ">
  <meta name="keywords" content="datetime, summary, types, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/datetime.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> DateTime   </h1> <section id="moduledoc"> <p>A datetime implementation with a time zone.</p>
<p>This datetime can be seen as an ephemeral snapshot of a datetime at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes.</p>
<p>Remember, comparisons in Elixir using <a href="https://hexdocs.pm/elixir/Kernel.html#==/2"><code class="inline">==/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#%3E/2"><code class="inline">&gt;/2</code></a>, <a href="https://hexdocs.pm/elixir/Kernel.html#%3C/2"><code class="inline">&lt;/2</code></a> and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the <a href="#compare/2"><code class="inline">compare/2</code></a> function.</p>
<p>Developers should avoid creating the <a href="#content"><code class="inline">DateTime</code></a> struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</p>
<h2 id="module-time-zone-database" class="section-heading">  Time zone database </h2> <p>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by <a href="https://hexdocs.pm/elixir/Calendar.html#get_time_zone_database/0"><code class="inline">Calendar.get_time_zone_database/0</code></a>, which defaults to <a href="https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html"><code class="inline">Calendar.UTCOnlyTimeZoneDatabase</code></a> which only handles "Etc/UTC" datetimes and returns <code class="inline">{:error, :utc_only_time_zone_database}</code> for any other time zone.</p>
<p>Other time zone databases can also be configured. For example, two of the available options are:</p>
<ul>
<li><a href="https://hexdocs.pm/tz/"><code class="inline">tz</code></a></li>
<li><a href="https://hexdocs.pm/tzdata/"><code class="inline">tzdata</code></a></li>
</ul>
<p>To use them, first make sure it is added as a dependency in <code class="inline">mix.exs</code>. It can then be configured either via configuration:</p>
<pre data-language="elixir">config :elixir, :time_zone_database, Tzdata.TimeZoneDatabase</pre>
<p>or by calling <a href="https://hexdocs.pm/elixir/Calendar.html#put_time_zone_database/1"><code class="inline">Calendar.put_time_zone_database/1</code></a>:</p>
<pre data-language="elixir">Calendar.put_time_zone_database(Tzdata.TimeZoneDatabase)</pre>
<p>See the proper names in the library installation instructions.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#add/4">add(datetime, amount_to_add, unit \\ :second, time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Adds a specified amount of time to a <a href="#content"><code class="inline">DateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compare/2">compare(datetime1, datetime2)</a> </dt> <dd class="summary-synopsis"><p>Compares two datetime structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert/2">convert(datetime, calendar)</a> </dt> <dd class="summary-synopsis"><p>Converts a given <code class="inline">datetime</code> from one calendar to another.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert!/2">convert!(datetime, calendar)</a> </dt> <dd class="summary-synopsis"><p>Converts a given <code class="inline">datetime</code> from one calendar to another.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#diff/3">diff(datetime1, datetime2, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Subtracts <code class="inline">datetime2</code> from <code class="inline">datetime1</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_gregorian_seconds/3">from_gregorian_seconds(seconds, arg \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts a number of gregorian seconds to a <a href="#content"><code class="inline">DateTime</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Date and time of day" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_naive/3">from_naive(naive_datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Converts the given <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> to <a href="#content"><code class="inline">DateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_naive!/3">from_naive!(naive_datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Converts the given <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> to <a href="#content"><code class="inline">DateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_unix/3">from_unix(integer, unit \\ :second, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts the given Unix time to <a href="#content"><code class="inline">DateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_unix!/3">from_unix!(integer, unit \\ :second, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts the given Unix time to <a href="#content"><code class="inline">DateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/4">new(date, time, time_zone \\ "Etc/UTC", time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Builds a datetime from date and time structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new!/4">new!(date, time, time_zone \\ "Etc/UTC", time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Builds a datetime from date and time structs, raising on errors.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#now/2">now(time_zone, time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Returns the current datetime in the provided time zone.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#now!/2">now!(time_zone, time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Returns the current datetime in the provided time zone or raises on errors</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shift_zone/3">shift_zone(datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Changes the time zone of a <a href="#content"><code class="inline">DateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shift_zone!/3">shift_zone!(datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</a> </dt> <dd class="summary-synopsis"><p>Changes the time zone of a <a href="#content"><code class="inline">DateTime</code></a> or raises on errors.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_date/1">to_date(map)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="#content"><code class="inline">DateTime</code></a> into a <a href="https://hexdocs.pm/elixir/Date.html"><code class="inline">Date</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_gregorian_seconds/1">to_gregorian_seconds(datetime)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="#content"><code class="inline">DateTime</code></a> struct to a number of gregorian seconds and microseconds.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_iso8601/2">to_iso8601(datetime, format \\ :extended)</a> </dt> <dd class="summary-synopsis"><p>Converts the given datetime to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a> format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_naive/1">to_naive(map)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">datetime</code> into a <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1">to_string(datetime)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">datetime</code> to a string according to its calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_time/1">to_time(map)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="#content"><code class="inline">DateTime</code></a> into <a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_unix/2">to_unix(datetime, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">datetime</code> to Unix time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#truncate/2">truncate(datetime, precision)</a> </dt> <dd class="summary-synopsis"><p>Returns the given datetime with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#utc_now/1">utc_now(calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Returns the current datetime in UTC.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: %DateTime{
  calendar: Calendar.calendar(),
  day: Calendar.day(),
  hour: Calendar.hour(),
  microsecond: Calendar.microsecond(),
  minute: Calendar.minute(),
  month: Calendar.month(),
  second: Calendar.second(),
  std_offset: Calendar.std_offset(),
  time_zone: Calendar.time_zone(),
  utc_offset: Calendar.utc_offset(),
  year: Calendar.year(),
  zone_abbr: Calendar.zone_abbr()
}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">   <h3 class="detail-header" id="add/4">add(datetime, amount_to_add, unit \\ :second, time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">add(
  Calendar.datetime(),
  integer(),
  System.time_unit(),
  Calendar.time_zone_database()
) :: t()</pre> </div> <p>Adds a specified amount of time to a <a href="#content"><code class="inline">DateTime</code></a>.</p>
<p>Accepts an <code class="inline">amount_to_add</code> in any <code class="inline">unit</code> available from <a href="https://hexdocs.pm/elixir/System.html#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>. Negative values will move backwards in time.</p>
<p>Takes changes such as summer time/DST into account. This means that adding time can cause the wall time to "go backwards" during "fall back" during autumn. Adding just a few seconds to a datetime just before "spring forward" can cause wall time to increase by more than an hour.</p>
<p>Fractional second precision stays the same in a similar way to <a href="https://hexdocs.pm/elixir/NaiveDateTime.html#add/2"><code class="inline">NaiveDateTime.add/2</code></a>.</p>
<h3 id="add/4-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; dt = DateTime.from_naive!(~N[2018-11-15 10:00:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; dt |&gt; DateTime.add(3600, :second, FakeTimeZoneDatabase)
#DateTime&lt;2018-11-15 11:00:00+01:00 CET Europe/Copenhagen&gt;

iex&gt; DateTime.add(~U[2018-11-15 10:00:00Z], 3600, :second)
~U[2018-11-15 11:00:00Z]</pre>
<p>When adding 3 seconds just before "spring forward" we go from 1:59:59 to 3:00:02</p>
<pre data-language="elixir">iex&gt; dt = DateTime.from_naive!(~N[2019-03-31 01:59:59.123], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; dt |&gt; DateTime.add(3, :second, FakeTimeZoneDatabase)
#DateTime&lt;2019-03-31 03:00:02.123+02:00 CEST Europe/Copenhagen&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="compare/2">compare(datetime1, datetime2)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compare(Calendar.datetime(), Calendar.datetime()) :: :lt | :eq | :gt</pre> </div> <p>Compares two datetime structs.</p>
<p>Returns <code class="inline">:gt</code> if the first datetime is later than the second and <code class="inline">:lt</code> for vice versa. If the two datetimes are equal <code class="inline">:eq</code> is returned.</p>
<p>Note that both UTC and Standard offsets will be taken into account when comparison is done.</p>
<h4 id="compare/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "AMT",
...&gt;                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                 utc_offset: -14400, std_offset: 0, time_zone: "America/Manaus"}
iex&gt; dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                 utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.compare(dt1, dt2)
:gt</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert/2">convert(datetime, calendar)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">convert(Calendar.datetime(), Calendar.calendar()) ::
  {:ok, t()} | {:error, :incompatible_calendars}</pre> </div> <p>Converts a given <code class="inline">datetime</code> from one calendar to another.</p>
<p>If it is not possible to convert unambiguously between the calendars (see <a href="https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2"><code class="inline">Calendar.compatible_calendars?/2</code></a>), an <code class="inline">{:error, :incompatible_calendars}</code> tuple is returned.</p>
<h4 id="convert/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "AMT",
...&gt;                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                 utc_offset: -14400, std_offset: 0, time_zone: "America/Manaus"}
iex&gt; DateTime.convert(dt1, Calendar.Holocene)
{:ok, %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,
                microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,
                time_zone: "America/Manaus", utc_offset: -14400, year: 12000,
                zone_abbr: "AMT"}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert!/2">convert!(datetime, calendar)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">convert!(Calendar.datetime(), Calendar.calendar()) :: t()</pre> </div> <p>Converts a given <code class="inline">datetime</code> from one calendar to another.</p>
<p>If it is not possible to convert unambiguously between the calendars (see <a href="https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2"><code class="inline">Calendar.compatible_calendars?/2</code></a>), an ArgumentError is raised.</p>
<h4 id="convert!/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "AMT",
...&gt;                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                 utc_offset: -14400, std_offset: 0, time_zone: "America/Manaus"}
iex&gt; DateTime.convert!(dt1, Calendar.Holocene)
%DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,
          microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,
          time_zone: "America/Manaus", utc_offset: -14400, year: 12000,
          zone_abbr: "AMT"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="diff/3">diff(datetime1, datetime2, unit \\ :second)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">diff(Calendar.datetime(), Calendar.datetime(), System.time_unit()) :: integer()</pre> </div> <p>Subtracts <code class="inline">datetime2</code> from <code class="inline">datetime1</code>.</p>
<p>The answer can be returned in any <code class="inline">unit</code> available from <a href="https://hexdocs.pm/elixir/System.html#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>.</p>
<p>Leap seconds are not taken into account.</p>
<p>This function returns the difference in seconds where seconds are measured according to <a href="https://hexdocs.pm/elixir/Calendar.ISO.html"><code class="inline">Calendar.ISO</code></a>.</p>
<h4 id="diff/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "AMT",
...&gt;                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                 utc_offset: -14400, std_offset: 0, time_zone: "America/Manaus"}
iex&gt; dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                 utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.diff(dt1, dt2)
18000
iex&gt; DateTime.diff(dt2, dt1)
-18000</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_gregorian_seconds/3">from_gregorian_seconds(seconds, arg \\ {0, 0}, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_gregorian_seconds(integer(), Calendar.microsecond(), Calendar.calendar()) ::
  t()</pre> </div> <p>Converts a number of gregorian seconds to a <a href="#content"><code class="inline">DateTime</code></a> struct.</p>
<p>The returned <a href="#content"><code class="inline">DateTime</code></a> will have <code class="inline">UTC</code> timezone, if you want other timezone, please use <a href="#shift_zone/3"><code class="inline">DateTime.shift_zone/3</code></a>.</p>
<h4 id="from_gregorian_seconds/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; DateTime.from_gregorian_seconds(1)
~U[0000-01-01 00:00:01Z]
iex&gt; DateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})
~U[2020-05-01 00:26:31.005Z]
iex&gt; DateTime.from_gregorian_seconds(-1)
~U[-0001-12-31 23:59:59Z]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_iso8601(String.t(), Calendar.calendar()) ::
  {:ok, t(), Calendar.utc_offset()} | {:error, atom()}</pre> </div> <p>Parses the extended "Date and time of day" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a>.</p>
<p>Since ISO 8601 does not include the proper time zone, the given string will be converted to UTC and its offset in seconds will be returned as part of this function. Therefore offset information must be present in the string.</p>
<p>As specified in the standard, the separator "T" may be omitted if desired as there is no ambiguity within this function.</p>
<p>The year parsed by this function is limited to four digits and, while ISO 8601 allows datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Note leap seconds are not supported by the built-in Calendar.ISO.</p>
<h4 id="from_iso8601/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; {:ok, datetime, 0} = DateTime.from_iso8601("2015-01-23T23:50:07Z")
iex&gt; datetime
~U[2015-01-23 23:50:07Z]

iex&gt; {:ok, datetime, 9000} = DateTime.from_iso8601("2015-01-23T23:50:07.123+02:30")
iex&gt; datetime
~U[2015-01-23 21:20:07.123Z]

iex&gt; {:ok, datetime, 9000} = DateTime.from_iso8601("2015-01-23T23:50:07,123+02:30")
iex&gt; datetime
~U[2015-01-23 21:20:07.123Z]

iex&gt; {:ok, datetime, 0} = DateTime.from_iso8601("-2015-01-23T23:50:07Z")
iex&gt; datetime
~U[-2015-01-23 23:50:07Z]

iex&gt; {:ok, datetime, 9000} = DateTime.from_iso8601("-2015-01-23T23:50:07,123+02:30")
iex&gt; datetime
~U[-2015-01-23 21:20:07.123Z]

iex&gt; DateTime.from_iso8601("2015-01-23P23:50:07")
{:error, :invalid_format}
iex&gt; DateTime.from_iso8601("2015-01-23T23:50:07")
{:error, :missing_offset}
iex&gt; DateTime.from_iso8601("2015-01-23 23:50:61")
{:error, :invalid_time}
iex&gt; DateTime.from_iso8601("2015-01-32 23:50:07")
{:error, :invalid_date}
iex&gt; DateTime.from_iso8601("2015-01-23T23:50:07.123-00:00")
{:error, :invalid_format}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_naive/3">from_naive(naive_datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_naive(
  Calendar.naive_datetime(),
  Calendar.time_zone(),
  Calendar.time_zone_database()
) ::
  {:ok, t()}
  | {:ambiguous, t(), t()}
  | {:gap, t(), t()}
  | {:error,
     :incompatible_calendars
     | :time_zone_not_found
     | :utc_only_time_zone_database}</pre> </div> <p>Converts the given <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> to <a href="#content"><code class="inline">DateTime</code></a>.</p>
<p>It expects a time zone to put the <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> in. If the time zone is "Etc/UTC", it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as <code class="inline">time_zone_database</code>. See the "Time zone database" section in the module documentation.</p>
<h4 id="from_naive/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; DateTime.from_naive(~N[2016-05-24 13:26:08.003], "Etc/UTC")
{:ok, ~U[2016-05-24 13:26:08.003Z]}</pre>
<p>When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned. First the one that happens first, then the one that happens after.</p>
<pre data-language="elixir">iex&gt; {:ambiguous, first_dt, second_dt} = DateTime.from_naive(~N[2018-10-28 02:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; first_dt
#DateTime&lt;2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen&gt;
iex&gt; second_dt
#DateTime&lt;2018-10-28 02:30:00+01:00 CET Europe/Copenhagen&gt;</pre>
<p>When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap.</p>
<pre data-language="elixir">iex&gt; {:gap, just_before, just_after} = DateTime.from_naive(~N[2019-03-31 02:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; just_before
#DateTime&lt;2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen&gt;
iex&gt; just_after
#DateTime&lt;2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen&gt;</pre>
<p>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</p>
<pre data-language="elixir">iex&gt; {:ok, datetime} = DateTime.from_naive(~N[2018-07-28 12:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; datetime
#DateTime&lt;2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen&gt;</pre>
<p>This function accepts any map or struct that contains at least the same fields as a <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> struct. The most common example of that is a <a href="#content"><code class="inline">DateTime</code></a>. In this case the information about the time zone of that <a href="#content"><code class="inline">DateTime</code></a> is completely ignored. This is the same principle as passing a <a href="#content"><code class="inline">DateTime</code></a> to <a href="https://hexdocs.pm/elixir/Date.html#to_iso8601/2"><code class="inline">Date.to_iso8601/2</code></a>. <a href="https://hexdocs.pm/elixir/Date.html#to_iso8601/2"><code class="inline">Date.to_iso8601/2</code></a> extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</p>
<p>This way if you have a <a href="#content"><code class="inline">DateTime</code></a> in one time zone, you can get the same wall time in another time zone. For instance if you have 2018-08-24 10:00:00 in Copenhagen and want a <a href="#content"><code class="inline">DateTime</code></a> for 2018-08-24 10:00:00 in UTC you can do:</p>
<pre data-language="elixir">iex&gt; cph_datetime = DateTime.from_naive!(~N[2018-08-24 10:00:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; {:ok, utc_datetime} = DateTime.from_naive(cph_datetime, "Etc/UTC", FakeTimeZoneDatabase)
iex&gt; utc_datetime
~U[2018-08-24 10:00:00Z]</pre>
<p>If instead you want a <a href="#content"><code class="inline">DateTime</code></a> for the same point time in a different time zone see the <a href="#shift_zone/3"><code class="inline">DateTime.shift_zone/3</code></a> function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_naive!/3">from_naive!(naive_datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_naive!(
  NaiveDateTime.t(),
  Calendar.time_zone(),
  Calendar.time_zone_database()
) :: t()</pre> </div> <p>Converts the given <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> to <a href="#content"><code class="inline">DateTime</code></a>.</p>
<p>It expects a time zone to put the NaiveDateTime in. If the time zone is "Etc/UTC", it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as <code class="inline">time_zone_database</code>. See the "Time zone database" section in the module documentation.</p>
<h4 id="from_naive!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; DateTime.from_naive!(~N[2016-05-24 13:26:08.003], "Etc/UTC")
~U[2016-05-24 13:26:08.003Z]

iex&gt; DateTime.from_naive!(~N[2018-05-24 13:26:08.003], "Europe/Copenhagen", FakeTimeZoneDatabase)
#DateTime&lt;2018-05-24 13:26:08.003+02:00 CEST Europe/Copenhagen&gt;</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_unix/3">from_unix(integer, unit \\ :second, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_unix(integer(), :native | System.time_unit(), Calendar.calendar()) ::
  {:ok, t()} | {:error, atom()}</pre> </div> <p>Converts the given Unix time to <a href="#content"><code class="inline">DateTime</code></a>.</p>
<p>The integer can be given in different unit according to <a href="https://hexdocs.pm/elixir/System.html#convert_time_unit/3"><code class="inline">System.convert_time_unit/3</code></a> and it will be converted to microseconds internally. Up to 253402300799 seconds is supported.</p>
<p>Unix times are always in UTC and therefore the DateTime will be returned in UTC.</p>
<h4 id="from_unix/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; {:ok, datetime} = DateTime.from_unix(1_464_096_368)
iex&gt; datetime
~U[2016-05-24 13:26:08Z]

iex&gt; {:ok, datetime} = DateTime.from_unix(1_432_560_368_868_569, :microsecond)
iex&gt; datetime
~U[2015-05-25 13:26:08.868569Z]

iex&gt; {:ok, datetime} = DateTime.from_unix(253_402_300_799)
iex&gt; datetime
~U[9999-12-31 23:59:59Z]

iex&gt; {:error, :invalid_unix_time} = DateTime.from_unix(253_402_300_800)</pre>
<p>The unit can also be an integer as in <a href="https://hexdocs.pm/elixir/System.html#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>:</p>
<pre data-language="elixir">iex&gt; {:ok, datetime} = DateTime.from_unix(143_256_036_886_856, 1024)
iex&gt; datetime
~U[6403-03-17 07:05:22.320312Z]</pre>
<p>Negative Unix times are supported up to -377705116800 seconds:</p>
<pre data-language="elixir">iex&gt; {:ok, datetime} = DateTime.from_unix(-377_705_116_800)
iex&gt; datetime
~U[-9999-01-01 00:00:00Z]

iex&gt; {:error, :invalid_unix_time} = DateTime.from_unix(-377_705_116_801)</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_unix!/3">from_unix!(integer, unit \\ :second, calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">from_unix!(integer(), :native | System.time_unit(), Calendar.calendar()) :: t()</pre> </div> <p>Converts the given Unix time to <a href="#content"><code class="inline">DateTime</code></a>.</p>
<p>The integer can be given in different unit according to <a href="https://hexdocs.pm/elixir/System.html#convert_time_unit/3"><code class="inline">System.convert_time_unit/3</code></a> and it will be converted to microseconds internally.</p>
<p>Unix times are always in UTC and therefore the DateTime will be returned in UTC.</p>
<h4 id="from_unix!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># An easy way to get the Unix epoch is passing 0 to this function
iex&gt; DateTime.from_unix!(0)
~U[1970-01-01 00:00:00Z]

iex&gt; DateTime.from_unix!(1_464_096_368)
~U[2016-05-24 13:26:08Z]

iex&gt; DateTime.from_unix!(1_432_560_368_868_569, :microsecond)
~U[2015-05-25 13:26:08.868569Z]

iex&gt; DateTime.from_unix!(143_256_036_886_856, 1024)
~U[6403-03-17 07:05:22.320312Z]</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new/4">new(date, time, time_zone \\ "Etc/UTC", time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">new(Date.t(), Time.t(), Calendar.time_zone(), Calendar.time_zone_database()) ::
  {:ok, t()}
  | {:ambiguous, t(), t()}
  | {:gap, t(), t()}
  | {:error,
     :incompatible_calendars
     | :time_zone_not_found
     | :utc_only_time_zone_database}</pre> </div> <p>Builds a datetime from date and time structs.</p>
<p>It expects a time zone to put the <a href="#content"><code class="inline">DateTime</code></a> in. If the time zone is not passed it will default to <code class="inline">"Etc/UTC"</code>, which always succeeds. Otherwise, the <a href="#content"><code class="inline">DateTime</code></a> is checked against the time zone database given as <code class="inline">time_zone_database</code>. See the "Time zone database" section in the module documentation.</p>
<h4 id="new/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; DateTime.new(~D[2016-05-24], ~T[13:26:08.003], "Etc/UTC")
{:ok, ~U[2016-05-24 13:26:08.003Z]}</pre>
<p>When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned. First the one that happens first, then the one that happens after.</p>
<pre data-language="elixir">iex&gt; {:ambiguous, first_dt, second_dt} = DateTime.new(~D[2018-10-28], ~T[02:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; first_dt
#DateTime&lt;2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen&gt;
iex&gt; second_dt
#DateTime&lt;2018-10-28 02:30:00+01:00 CET Europe/Copenhagen&gt;</pre>
<p>When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap.</p>
<pre data-language="elixir">iex&gt; {:gap, just_before, just_after} = DateTime.new(~D[2019-03-31], ~T[02:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; just_before
#DateTime&lt;2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen&gt;
iex&gt; just_after
#DateTime&lt;2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen&gt;</pre>
<p>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</p>
<pre data-language="elixir">iex&gt; {:ok, datetime} = DateTime.new(~D[2018-07-28], ~T[12:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; datetime
#DateTime&lt;2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen&gt;</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new!/4">new!(date, time, time_zone \\ "Etc/UTC", time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">new!(Date.t(), Time.t(), Calendar.time_zone(), Calendar.time_zone_database()) ::
  t()</pre> </div> <p>Builds a datetime from date and time structs, raising on errors.</p>
<p>It expects a time zone to put the <a href="#content"><code class="inline">DateTime</code></a> in. If the time zone is not passed it will default to <code class="inline">"Etc/UTC"</code>, which always succeeds. Otherwise, the DateTime is checked against the time zone database given as <code class="inline">time_zone_database</code>. See the "Time zone database" section in the module documentation.</p>
<h4 id="new!/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; DateTime.new!(~D[2016-05-24], ~T[13:26:08.003], "Etc/UTC")
~U[2016-05-24 13:26:08.003Z]</pre>
<p>When the datetime is ambiguous - for instance during changing from summer to winter time - an error will be raised.</p>
<pre data-language="elixir">iex&gt; DateTime.new!(~D[2018-10-28], ~T[02:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
** (ArgumentError) cannot build datetime with ~D[2018-10-28] and ~T[02:30:00] because such instant is ambiguous in time zone Europe/Copenhagen as there is an overlap between #DateTime&lt;2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen&gt; and #DateTime&lt;2018-10-28 02:30:00+01:00 CET Europe/Copenhagen&gt;</pre>
<p>When there is a gap in wall time - for instance in spring when the clocks are turned forward - an error will be raised.</p>
<pre data-language="elixir">iex&gt; DateTime.new!(~D[2019-03-31], ~T[02:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
** (ArgumentError) cannot build datetime with ~D[2019-03-31] and ~T[02:30:00] because such instant does not exist in time zone Europe/Copenhagen as there is a gap between #DateTime&lt;2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen&gt; and #DateTime&lt;2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen&gt;</pre>
<p>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</p>
<pre data-language="elixir">iex&gt; datetime = DateTime.new!(~D[2018-07-28], ~T[12:30:00], "Europe/Copenhagen", FakeTimeZoneDatabase)
iex&gt; datetime
#DateTime&lt;2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen&gt;</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="now/2">now(time_zone, time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">now(Calendar.time_zone(), Calendar.time_zone_database()) ::
  {:ok, t()} | {:error, :time_zone_not_found | :utc_only_time_zone_database}</pre> </div> <p>Returns the current datetime in the provided time zone.</p>
<p>By default, it uses the default time_zone returned by <a href="https://hexdocs.pm/elixir/Calendar.html#get_time_zone_database/0"><code class="inline">Calendar.get_time_zone_database/0</code></a>, which defaults to <a href="https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html"><code class="inline">Calendar.UTCOnlyTimeZoneDatabase</code></a> which only handles "Etc/UTC" datetimes. Other time zone databases can be passed as argument or set globally. See the "Time zone database" section in the module docs.</p>
<h4 id="now/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; {:ok, datetime} = DateTime.now("Etc/UTC")
iex&gt; datetime.time_zone
"Etc/UTC"

iex&gt; DateTime.now("Europe/Copenhagen")
{:error, :utc_only_time_zone_database}

iex&gt; DateTime.now("bad timezone", FakeTimeZoneDatabase)
{:error, :time_zone_not_found}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="now!/2">now!(time_zone, time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">now!(Calendar.time_zone(), Calendar.time_zone_database()) :: t()</pre> </div> <p>Returns the current datetime in the provided time zone or raises on errors</p>
<p>See <a href="#now/2"><code class="inline">now/2</code></a> for more information.</p>
<h4 id="now!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; datetime = DateTime.now!("Etc/UTC")
iex&gt; datetime.time_zone
"Etc/UTC"

iex&gt; DateTime.now!("Europe/Copenhagen")
** (ArgumentError) cannot get current datetime in "Europe/Copenhagen" time zone, reason: :utc_only_time_zone_database

iex&gt; DateTime.now!("bad timezone", FakeTimeZoneDatabase)
** (ArgumentError) cannot get current datetime in "bad timezone" time zone, reason: :time_zone_not_found</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="shift_zone/3">shift_zone(datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">shift_zone(t(), Calendar.time_zone(), Calendar.time_zone_database()) ::
  {:ok, t()} | {:error, :time_zone_not_found | :utc_only_time_zone_database}</pre> </div> <p>Changes the time zone of a <a href="#content"><code class="inline">DateTime</code></a>.</p>
<p>Returns a <a href="#content"><code class="inline">DateTime</code></a> for the same point in time, but instead at the time zone provided. It assumes that <a href="#content"><code class="inline">DateTime</code></a> is valid and exists in the given time zone and calendar.</p>
<p>By default, it uses the default time zone database returned by <a href="https://hexdocs.pm/elixir/Calendar.html#get_time_zone_database/0"><code class="inline">Calendar.get_time_zone_database/0</code></a>, which defaults to <a href="https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html"><code class="inline">Calendar.UTCOnlyTimeZoneDatabase</code></a> which only handles "Etc/UTC" datetimes. Other time zone databases can be passed as argument or set globally. See the "Time zone database" section in the module docs.</p>
<h4 id="shift_zone/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; {:ok, pacific_datetime} = DateTime.shift_zone(~U[2018-07-16 10:00:00Z], "America/Los_Angeles", FakeTimeZoneDatabase)
iex&gt; pacific_datetime
#DateTime&lt;2018-07-16 03:00:00-07:00 PDT America/Los_Angeles&gt;

iex&gt; DateTime.shift_zone(~U[2018-07-16 10:00:00Z], "bad timezone", FakeTimeZoneDatabase)
{:error, :time_zone_not_found}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="shift_zone!/3">shift_zone!(datetime, time_zone, time_zone_database \\ Calendar.get_time_zone_database())</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">shift_zone!(t(), Calendar.time_zone(), Calendar.time_zone_database()) :: t()</pre> </div> <p>Changes the time zone of a <a href="#content"><code class="inline">DateTime</code></a> or raises on errors.</p>
<p>See <a href="#shift_zone/3"><code class="inline">shift_zone/3</code></a> for more information.</p>
<h4 id="shift_zone!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], "America/Los_Angeles", FakeTimeZoneDatabase)
#DateTime&lt;2018-07-16 03:00:00-07:00 PDT America/Los_Angeles&gt;

iex&gt; DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], "bad timezone", FakeTimeZoneDatabase)
** (ArgumentError) cannot shift ~U[2018-07-16 10:00:00Z] to "bad timezone" time zone, reason: :time_zone_not_found</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_date/1">to_date(map)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_date(Calendar.datetime()) :: Date.t()</pre> </div> <p>Converts a <a href="#content"><code class="inline">DateTime</code></a> into a <a href="https://hexdocs.pm/elixir/Date.html"><code class="inline">Date</code></a>.</p>
<p>Because <a href="https://hexdocs.pm/elixir/Date.html"><code class="inline">Date</code></a> does not hold time nor time zone information, data will be lost during the conversion.</p>
<h4 id="to_date/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.to_date(dt)
~D[2000-02-29]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_gregorian_seconds/1">to_gregorian_seconds(datetime)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_gregorian_seconds(Calendar.datetime()) :: {integer(), non_neg_integer()}</pre> </div> <p>Converts a <a href="#content"><code class="inline">DateTime</code></a> struct to a number of gregorian seconds and microseconds.</p>
<h4 id="to_gregorian_seconds/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; dt = %DateTime{year: 0000, month: 1, day: 1, zone_abbr: "UTC",
...&gt;                hour: 0, minute: 0, second: 1, microsecond: {0, 0},
...&gt;                utc_offset: 0, std_offset: 0, time_zone: "Etc/UTC"}
iex&gt; DateTime.to_gregorian_seconds(dt)
{1, 0}

iex&gt; dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: "UTC",
...&gt;                hour: 0, minute: 26, second: 31, microsecond: {5000, 0},
...&gt;                utc_offset: 0, std_offset: 0, time_zone: "Etc/UTC"}
iex&gt; DateTime.to_gregorian_seconds(dt)
{63_755_511_991, 5000}

iex&gt; dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: "CET",
...&gt;                hour: 1, minute: 26, second: 31, microsecond: {5000, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.to_gregorian_seconds(dt)
{63_755_511_991, 5000}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="to_iso8601/2">to_iso8601(datetime, format \\ :extended)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_iso8601(Calendar.datetime(), :extended | :basic) :: String.t()</pre> </div> <p>Converts the given datetime to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2004</a> format.</p>
<p>By default, <a href="#to_iso8601/2"><code class="inline">DateTime.to_iso8601/2</code></a> returns datetimes formatted in the "extended" format, for human readability. It also supports the "basic" format through passing the <code class="inline">:basic</code> option.</p>
<p>Only supports converting datetimes which are in the ISO calendar, attempting to convert datetimes from other calendars will raise.</p>
<p>WARNING: the ISO 8601 datetime format does not contain the time zone nor its abbreviation, which means information is lost when converting to such format.</p>
<h3 id="to_iso8601/2-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.to_iso8601(dt)
"2000-02-29T23:00:07+01:00"

iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "UTC",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 0, std_offset: 0, time_zone: "Etc/UTC"}
iex&gt; DateTime.to_iso8601(dt)
"2000-02-29T23:00:07Z"

iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "AMT",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: -14400, std_offset: 0, time_zone: "America/Manaus"}
iex&gt; DateTime.to_iso8601(dt, :extended)
"2000-02-29T23:00:07-04:00"

iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "AMT",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: -14400, std_offset: 0, time_zone: "America/Manaus"}
iex&gt; DateTime.to_iso8601(dt, :basic)
"20000229T230007-0400"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_naive/1">to_naive(map)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_naive(Calendar.datetime()) :: NaiveDateTime.t()</pre> </div> <p>Converts the given <code class="inline">datetime</code> into a <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a>.</p>
<p>Because <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> does not hold time zone information, any time zone related data will be lost during the conversion.</p>
<h4 id="to_naive/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 1},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.to_naive(dt)
~N[2000-02-29 23:00:07.0]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(datetime)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_string(Calendar.datetime()) :: String.t()</pre> </div> <p>Converts the given <code class="inline">datetime</code> to a string according to its calendar.</p>
<h3 id="to_string/1-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.to_string(dt)
"2000-02-29 23:00:07+01:00 CET Europe/Warsaw"

iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "UTC",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 0, std_offset: 0, time_zone: "Etc/UTC"}
iex&gt; DateTime.to_string(dt)
"2000-02-29 23:00:07Z"

iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "AMT",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: -14400, std_offset: 0, time_zone: "America/Manaus"}
iex&gt; DateTime.to_string(dt)
"2000-02-29 23:00:07-04:00 AMT America/Manaus"

iex&gt; dt = %DateTime{year: -100, month: 12, day: 19, zone_abbr: "CET",
...&gt;                hour: 3, minute: 20, second: 31, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Stockholm"}
iex&gt; DateTime.to_string(dt)
"-0100-12-19 03:20:31+01:00 CET Europe/Stockholm"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_time/1">to_time(map)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_time(Calendar.datetime()) :: Time.t()</pre> </div> <p>Converts a <a href="#content"><code class="inline">DateTime</code></a> into <a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a>.</p>
<p>Because <a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a> does not hold date nor time zone information, data will be lost during the conversion.</p>
<h4 id="to_time/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 1},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; DateTime.to_time(dt)
~T[23:00:07.0]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="to_unix/2">to_unix(datetime, unit \\ :second)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_unix(Calendar.datetime(), System.time_unit()) :: integer()</pre> </div> <p>Converts the given <code class="inline">datetime</code> to Unix time.</p>
<p>The <code class="inline">datetime</code> is expected to be using the ISO calendar with a year greater than or equal to 0.</p>
<p>It will return the integer with the given unit, according to <a href="https://hexdocs.pm/elixir/System.html#convert_time_unit/3"><code class="inline">System.convert_time_unit/3</code></a>.</p>
<p>If you want to get the current time in Unix seconds, do not do <code class="inline">DateTime.utc_now() |&gt; DateTime.to_unix()</code>. Simply call <code class="inline">System.os_time(:second)</code> instead.</p>
<h4 id="to_unix/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1_464_096_368 |&gt; DateTime.from_unix!() |&gt; DateTime.to_unix()
1464096368

iex&gt; dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, microsecond: {273806, 6},
...&gt;                minute: 58, month: 11, second: 19, time_zone: "America/Montevideo",
...&gt;                utc_offset: -10800, std_offset: 3600, year: 2014, zone_abbr: "UYST"}
iex&gt; DateTime.to_unix(dt)
1416517099

iex&gt; flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, microsecond: {527771, 6},
...&gt;                minute: 2, month: 3, second: 25, std_offset: 0, time_zone: "Etc/UTC",
...&gt;                utc_offset: 0, year: 1418, zone_abbr: "UTC"}
iex&gt; DateTime.to_unix(flamel)
-17412508655</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="truncate/2">truncate(datetime, precision)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">truncate(Calendar.datetime(), :microsecond | :millisecond | :second) :: t()</pre> </div> <p>Returns the given datetime with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p>
<p>The given datetime is returned unchanged if it already has lower precision than the given precision.</p>
<h4 id="truncate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; dt1 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: "CET",
...&gt;                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},
...&gt;                 utc_offset: 3600, std_offset: 0, time_zone: "Europe/Paris"}
iex&gt; DateTime.truncate(dt1, :microsecond)
#DateTime&lt;2017-11-07 11:45:18.123456+01:00 CET Europe/Paris&gt;

iex&gt; dt2 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: "CET",
...&gt;                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},
...&gt;                 utc_offset: 3600, std_offset: 0, time_zone: "Europe/Paris"}
iex&gt; DateTime.truncate(dt2, :millisecond)
#DateTime&lt;2017-11-07 11:45:18.123+01:00 CET Europe/Paris&gt;

iex&gt; dt3 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: "CET",
...&gt;                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},
...&gt;                 utc_offset: 3600, std_offset: 0, time_zone: "Europe/Paris"}
iex&gt; DateTime.truncate(dt3, :second)
#DateTime&lt;2017-11-07 11:45:18+01:00 CET Europe/Paris&gt;</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="utc_now/1">utc_now(calendar \\ Calendar.ISO)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">utc_now(Calendar.calendar()) :: t()</pre> </div> <p>Returns the current datetime in UTC.</p>
<h4 id="utc_now/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; datetime = DateTime.utc_now()
iex&gt; datetime.time_zone
"Etc/UTC"</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
     2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.11.2/DateTime.html" class="_attribution-link">https://hexdocs.pm/elixir/1.11.2/DateTime.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
