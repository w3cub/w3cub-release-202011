
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Specificity - CSS - W3cubDocs</title>
  
  <meta name="description" content="Specificity is the algorithm used by browsers to determine the CSS declaration that is the most relevant to an element, which in turn, determines &hellip;">
  <meta name="keywords" content="specificity, css">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/css/specificity.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/css.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/css/" class="_nav-link" title="" style="margin-left:0;">CSS</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _mdn">
				
				
<h1>Specificity</h1>
<div class="section-content">
<p><strong>Specificity</strong> is the algorithm used by browsers to determine the <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS#css_syntax">CSS declaration</a> that is the most relevant to an element, which in turn, determines the property value to apply to the element. The specificity algorithm calculates the weight of a <a href="reference#selectors">CSS selector</a> to determine which rule from competing CSS declarations gets applied to an element.</p> <div class="notecard note" id="sect1"> <p><strong>Note:</strong> Browsers consider specificity <strong>after</strong> determining <a href="cascade">cascade origin and importance</a>. In other words, for competing property declarations, specificity is relevant and compared only between selectors from the one <a href="@layer">cascade origin and layer</a> that has precedence for the property. Order of appearance becomes relevant when the selector specificities of the competing declarations in the cascade layer with precedence are equal.</p> </div>
</div>
<section aria-labelledby="how_is_specificity_calculated"><h2 id="how_is_specificity_calculated">How is specificity calculated?</h2>
<div class="section-content">
<p>Specificity is an algorithm that calculates the weight that is applied to a given CSS declaration. The weight is determined by the number of <a href="#selector_weight_categories">selectors of each weight category</a> in the selector matching the element (or pseudo-element). If there are two or more declarations providing different property values for the same element, the declaration value in the style block having the matching selector with the greatest algorithmic weight gets applied.</p> <p>The specificity algorithm is basically a three-column value of three categories or weights - ID, CLASS, and TYPE - corresponding to the three types of selectors. The value represents the count of selector components in each weight category and is written as <em>ID - CLASS - TYPE</em>. The three columns are created by counting the number of selector components for each selector weight category in the selectors that match the element.</p>
</div></section><section aria-labelledby="selector_weight_categories"><h3 id="selector_weight_categories">Selector weight categories</h3>
<div class="section-content">
<p>The selector weight categories are listed here in the order of decreasing specificity:</p> <dl> <dt id="id_column">ID column</dt> <dd> <p>Includes only <a href="id_selectors">ID selectors</a>, such as <code>#example</code>. For each ID in a matching selector, add 1-0-0 to the weight value.</p> </dd> <dt id="class_column">CLASS column</dt> <dd> <p>Includes <a href="class_selectors">class selectors</a>, such as <code>.myClass</code>, attribute selectors like <code>[type="radio"]</code> and <code>[lang|="fr"]</code>, and pseudo-classes, such as <code>:hover</code>, <code>:nth-of-type(3n)</code>, and <code>:required</code>. For each class, attribute selector, or pseudo-class in a matching selector, add 0-1-0 to the weight value.</p> </dd> <dt id="type_column">TYPE column</dt> <dd> <p>Includes <a href="type_selectors">type selectors</a>, such as <code>p</code>, <code>h1</code>, and <code>td</code>, and pseudo-elements like <code>::before</code>, <code>::placeholder</code>, and all other selectors with double-colon notation. For each type or pseudo-element in a matching selector, add 0-0-1 to the weight value.</p> </dd> <dt id="no_value">No value</dt> <dd> <p>The universal selector (<a href="universal_selectors"><code>*</code></a>) and the pseudo-class <a href=":where"><code>:where()</code></a> and its parameters aren't counted when calculating the weight so their value is 0-0-0, but they do match elements. These selectors do not impact the specificity weight value.</p> </dd> </dl> <p>Combinators, such as <a href="adjacent_sibling_combinator"><code>+</code></a>, <a href="child_combinator"><code>&gt;</code></a>, <a href="general_sibling_combinator"><code>~</code></a>, <a href="descendant_combinator">" "</a>, and <a href="column_combinator"><code>||</code></a>, may make a selector more specific in what is selected but they don't add any value to the specificity weight.</p> <p>The negation pseudo-class, <a href=":not"><code>:not()</code></a>, itself has no weight. Neither do the <a href=":is"><code>:is()</code></a> or the <a href=":has"><code>:has()</code></a> pseudo-classes. The parameters in these selectors, however, do. The values of both come from the parameter in the list of parameters that has the highest specificity. The <a href="#the_is_not_and_has_exceptions"><code>:not()</code>, <code>:is()</code> and <code>:has()</code> exceptions</a> are discussed below.</p> <h4 id="matching_selector">Matching selector</h4> <p>The specificity weight comes from the matching selector. Take this CSS selector with three comma-separated selectors as an example:</p> <div class="code-example"><pre data-language="css"><span class="token selector">[type="password"],
input:focus,
:root #myApp input:required</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div> <p>The <code>[type="password"]</code> selector in the above selector list, with a specificity weight of <code>0-1-0</code>, applies the <code>color: blue</code> declaration to all password input types.</p> <p>All inputs, no matter the type, when receiving focus, match the second selector in the list, <code>input:focus</code>, with a specificity weight of <code>0-1-1</code>; this weight is made up of the <code>:focus</code> pseudo-class (0-1-0) and the <code>input</code> type (0-0-1). If the password input has focus, it will match <code>input:focus</code>, and the specificity weight for the <code>color: blue</code> style declaration will be <code>0-1-1</code>. When that password doesn't have focus, the specificity weight remains at <code>0-1-0</code>.</p> <p>The specificity for a required input nested in an element with attribute <code>id="myApp"</code> is <code>1-2-1</code>, based on one ID, two pseudo-classes, and one element type.</p> <p>If the password input type with <code>required</code> is nested in an element with <code>id="myApp"</code> set, the specificity weight will be <code>1-2-1</code>, based on one ID, two pseudo-classes, and one element type, whether or not it has focus. Why is the specificity weight <code>1-2-1</code> rather than <code>0-1-1</code> or <code>0-1-0</code> in this case? Because the specificity weight comes from the matching selector with the greatest specificity weight. The weight is determined by comparing the values in the three columns, from left to right.</p> <div class="code-example"><pre data-language="css">[type=<span class="token string">"password"</span>]             <span class="token comment">/* 0-1-0 */</span>
<span class="token property">input</span><span class="token punctuation">:</span>focus                   <span class="token comment">/* 0-1-1 */</span>
<span class="token punctuation">:</span>root #myApp <span class="token property">input</span><span class="token punctuation">:</span>required   <span class="token comment">/* 1-2-1 */</span>
</pre></div>
</div></section><section aria-labelledby="three-column_comparison"><h3 id="three-column_comparison">Three-column comparison</h3>
<div class="section-content">
<p>Once the specificity values of the relevant selectors are determined, the number of selector components in each column are compared, from left to right.</p> <div class="code-example"><pre data-language="css"><span class="token selector">#myElement</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token comment">/* 1-0-0  - WINS!! */</span>
<span class="token punctuation">}</span>
<span class="token selector">.bodyClass .sectionClass .parentClass [id="myElement"]</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span> <span class="token comment">/* 0-4-0 */</span>
<span class="token punctuation">}</span>
</pre></div> <p>The first column is the value of the <em>ID</em> component, which is the number of IDs in each selector. The numbers in the <em>ID</em> columns of competing selectors are compared. The selector with the greater value in the <em>ID</em> column wins no matter what the values are in the other columns. In the above example, even though the yellow selector has more components in total, only the value of the first column matters.</p> <p>If the number in the <em>ID</em> columns of competing selectors is the same, then the next column, <em>CLASS</em>, is compared, as shown below.</p> <div class="code-example"><pre data-language="css"><span class="token selector">#myElement</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span> <span class="token comment">/* 1-0-0 */</span>
<span class="token punctuation">}</span>
<span class="token selector">#myApp [id="myElement"]</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token comment">/* 1-1-0  - WINS!! */</span>
<span class="token punctuation">}</span>
</pre></div> <p>The <em>CLASS</em> column is the count of class names, attribute selectors, and pseudo-classes in the selector. When the <em>ID</em> column value is the same, the selector with the greater value in the <em>CLASS</em> column wins, no matter the value in the <em>TYPE</em> column. This is shown in the example below.</p> <div class="code-example"><pre data-language="css"><span class="token selector">:root input</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token comment">/* 0-1-1 - WINS because CLASS column is greater */</span>
<span class="token punctuation">}</span>
<span class="token selector">html body main input</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span> <span class="token comment">/* 0-0-4 */</span>
<span class="token punctuation">}</span>
</pre></div> <p>If the numbers in the <em>CLASS</em> and <em>ID</em> columns in competing selectors are the same, the <em>TYPE</em> column becomes relevant. The <em>TYPE</em> column is the number of element types and pseudo-elements in the selector. When the first two columns have the same value, the selector with the greater number in the <em>TYPE</em> column wins.</p> <p>If the competing selectors have the same values in all the three columns, the proximity rule comes into play, wherein the last declared style gets precedence.</p> <div class="code-example"><pre data-language="css"><span class="token selector">input.myClass</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span> <span class="token comment">/* 0-1-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">:root input</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token comment">/* 0-1-1 WINS because it comes later */</span>
<span class="token punctuation">}</span>
</pre></div>
</div></section><section aria-labelledby="the_is_not_and_has_exceptions"><h3 id="the_is_not_and_has_exceptions">The <code>:is()</code>, <code>:not()</code> and <code>:has()</code> exceptions</h3>
<div class="section-content">
<p>The matches-any pseudo-class <a href=":is"><code>:is()</code></a>, the relational pseudo-class <a href=":has"><code>:has()</code></a>, and the negation pseudo-class <a href=":not"><code>:not()</code></a> are <em>not</em> considered as pseudo-classes in the specificity weight calculation. They themselves don't add any weight to the specificity equation. However, the selector parameters passed into the pseudo-class parenthesis are part of the specificity algorithm; the weight of the matches-any and negation pseudo-class in the specificity value calculation is the weight of the parameter's <a href="#selector_weight_categories">weight</a>.</p> <div class="code-example"><pre data-language="css"><span class="token selector">p</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-0-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">:is(p)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-0-1 */</span>
<span class="token punctuation">}</span>

<span class="token selector">h2:nth-last-of-type(n + 2)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-1-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">h2:has(~ h2)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-0-2 */</span>
<span class="token punctuation">}</span>

<span class="token selector">div.outer p</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-1-2 */</span>
<span class="token punctuation">}</span>
<span class="token selector">div:not(.inner) p</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-1-2 */</span>
<span class="token punctuation">}</span>
</pre></div> <p>Note that in the above CSS pairing, the specificity weight provided by the <code>:is()</code>, <code>:has()</code> and <code>:not()</code> pseudo-classes is the value of the selector parameter, not of the pseudo-class.</p> <p>All three of these pseudo-classes accept complex selector lists, a list of comma-separated selectors, as a parameter. This feature can be used to increase a selector's specificity:</p> <div class="code-example"><pre data-language="css"><span class="token selector">:is(p, #fakeId)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 1-0-0 */</span>
<span class="token punctuation">}</span>
<span class="token selector">h1:has(+ h2, &gt; #fakeId)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 1-0-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">p:not(#fakeId)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 1-0-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">div:not(.inner, #fakeId) p</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 1-0-2 */</span>
<span class="token punctuation">}</span>
</pre></div> <p>In the above CSS code block, we have included <code>#fakeId</code> in the selectors. This <code>#fakeId</code> adds <code>1-0-0</code> to the specificity weight of each paragraph.</p> <p>Generally, you want to keep specificity down to a minimum, but if you need to increase an element's specificity for a particular reason, these three pseudo-classes can help.</p> <div class="code-example"><pre data-language="css"><span class="token selector">a:not(#fakeId#fakeId#fakeID)</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token comment">/* 3-0-1 */</span>
<span class="token punctuation">}</span>
</pre></div> <p>In this example, all links will be blue, unless overridden by a link declaration with 3 or more IDs, a color value matching an <code>a</code> includes the <a href="#the_!important_exception"><code>!important</code> flag</a>, or if the link has an <a href="#inline_styles">inline style</a> color declaration. If you use such a technique, add a comment to explain why the hack was needed.</p>
</div></section><section aria-labelledby="inline_styles"><h3 id="inline_styles">Inline styles</h3>
<div class="section-content">
<p>Inline styles added to an element (e.g., <code>style="font-weight: bold;"</code>) always overwrite any normal styles in author stylesheets, and therefore, can be thought of as having the highest specificity. Think of inline styles as having a specificity weight of <code>1-0-0-0</code>.</p> <p>The only way to override inline styles is by using <code>!important</code>.</p> <p>Many JavaScript frameworks and libraries add inline styles. Using <code>!important</code> with a very targeted selector, such as an attribute selector using the inline style, is one way to override these inline styles.</p> <div class="code-example"><pre data-language="html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> purple</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>…<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</pre></div> <div class="code-example"><pre data-language="css"><span class="token selector">p[style*="purple"]</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> rebeccapurple <span class="token important">!important</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div> <p>Make sure to include a comment with every inclusion of the important flag so code maintainers understand why a CSS anti-pattern was used.</p>
</div></section><section aria-labelledby="the_!important_exception"><h3 id="the_!important_exception">The <code>!important</code> exception</h3>
<div class="section-content">
<p>CSS declarations marked as important override any other declarations within the same cascade layer and origin. Although technically, <a href="important"><code>!important</code></a> has nothing to do with specificity, it interacts directly with specificity and the cascade. It reverses the <a href="cascade">cascade</a> order of stylesheets.</p> <p>If declarations from the same origin and cascade layer conflict and one property value has the <code>!important</code> flag set, the important declaration is applied no matter the specificity. When conflicting declarations from the same origin and cascade layer with the <code>!important</code> flag are applied to the same element, the declaration with a greater specificity is applied.</p> <p>Using <code>!important</code> to override specificity is considered a <strong>bad practice</strong> and should be avoided for this purpose. Understanding and effectively using specificity and the cascade can remove any need for the <code>!important</code> flag.</p> <p>Instead of using <code>!important</code> to override foreign CSS (from external libraries, like Bootstrap or normalize.css), import the third-party scripts directly into <a href="@layer">cascade layers</a>. If you must use <code>!important</code> in your CSS, comment your usage so future code maintainers know why the declaration was marked important and know not to override it. But definitely, don't use <code>!important</code> when writing plugins or frameworks that other developers will need to incorporate without being able to control.</p>
</div></section><section aria-labelledby="the_where_exception"><h3 id="the_where_exception">The <code>:where()</code> exception</h3>
<div class="section-content">
<p>The specificity-adjustment pseudo-class <a href=":where"><code>:where()</code></a> always has its specificity replaced with zero, <code>0-0-0</code>. It enables making CSS selectors very specific in what element is targeted without any increase to specificity.</p> <p>In creating third-party CSS to be used by developers who don't have access to edit your CSS, it's considered a good practice to create CSS with the lowest possible specificity. For example, if your theme includes the following CSS:</p> <div class="code-example"><pre data-language="css"><span class="token selector">:where(#defaultTheme) a</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-0-1 */</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div> <p>Then the developer implementing the widget can easily override the link color using only type selectors.</p> <div class="code-example"><pre data-language="css"><span class="token selector">footer a</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-0-2 */</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div>
</div></section><section aria-labelledby="tips_for_handling_specificity_headaches"><h2 id="tips_for_handling_specificity_headaches">Tips for handling specificity headaches</h2>
<div class="section-content"><p>Instead of using <code>!important</code>, consider using cascade layers and using low weight specificity throughout your CSS so that styles are easily overridden with slightly more specific rules. Using semantic HTML helps provide anchors from which to apply styling.</p></div></section><section aria-labelledby="making_selectors_specific_with_and_without_adding_specificity"><h3 id="making_selectors_specific_with_and_without_adding_specificity">Making selectors specific with and without adding specificity</h3>
<div class="section-content">
<p>By indicating the section of the document you're styling before the element you're selecting, the rule becomes more specific. Depending on how you add it, you can add some, a lot, or no specificity, as shown below:</p> <div class="code-example"><pre data-language="html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myContent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span>
</pre></div> <div class="code-example"><pre data-language="css"><span class="token selector">#myContent h1</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token comment">/* 1-0-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">[id="myContent"] h1</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span> <span class="token comment">/* 0-1-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">:where(#myContent) h1</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token comment">/* 0-0-1 */</span>
<span class="token punctuation">}</span>
</pre></div> <p>No matter the order, the heading will be green because that rule is the most specific.</p> <h4 id="reducing_id_specificity">Reducing ID specificity</h4> <p>Specificity is based on the form of a selector. Including the <code>id</code> of an element as an attribute selector rather than an id selector is a good way to make an element more specific without adding an overabundance of specificity. In the previous example, the selector <code>[id="myContent"]</code> counts as an attribute selector for the purpose of determining the selector's specificity, even though it selects an ID.</p> <p>You can also include the <code>id</code> or any part of a selector as a parameter in the <code>:where()</code> specificity-adjustment pseudo class if you need to make a selector more specific but don't want to add any specificity at all.</p>
</div></section><section aria-labelledby="increasing_specificity_by_duplicating_selector"><h3 id="increasing_specificity_by_duplicating_selector">Increasing specificity by duplicating selector</h3>
<div class="section-content">
<p>As a special case for increasing specificity, you can duplicate weights from the <em>CLASS</em> or <em>ID</em> columns. Duplicating id, class, pseudo-class or attribute selectors within a compound selector will increase specificity when overriding very specific selectors over which you have no control.</p> <div class="code-example"><pre data-language="css"><span class="token selector">#myId#myId#myId span</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 3-0-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">.myClass.myClass.myClass span</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 0-3-1 */</span>
<span class="token punctuation">}</span>
</pre></div> <p>Use this sparingly, if at all. If using selector duplication, always comment your CSS.</p> <p>By using <code>:is()</code> and <code>:not()</code> (and also <code>:has()</code>), you can increase specificity even if you can't add an <code>id</code> to a parent element:</p> <div class="code-example"><pre data-language="css"><span class="token selector">:not(#fakeID#fakeId#fakeID) span</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 3-0-1 */</span>
<span class="token punctuation">}</span>
<span class="token selector">:is(#fakeID#fakeId#fakeID, span)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 3-0-0 */</span>
<span class="token punctuation">}</span>
</pre></div>
</div></section><section aria-labelledby="precedence_over_third-party_css"><h3 id="precedence_over_third-party_css">Precedence over third-party CSS</h3>
<div class="section-content">
<p>Leveraging cascade layers is the standard way of enabling one set of styles to take precedence over another set of styles; cascade layers enable this without using specificity! Normal (not important) author styles imported into cascade layers have lower precedence than unlayered author styles.</p> <p>If styles are coming from a stylesheet you can't edit or don't understand and you need to override styles, a strategy is to import the styles you don't control into a cascade layer. Styles in subsequently declared layers take precedence, with unlayered styles having precedence over all layered styles from the same origin.</p> <p>When two selectors from different layers match the same element, origin and importance take precedence; the specificity of the selector in the losing stylesheet is irrelevant.</p> <div class="code-example"><pre data-language="html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token atrule"><span class="token rule">@import</span> TW.css <span class="token function">layer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
  <span class="token selector">p,
  p *</span> <span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 1rem<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</pre></div> <p>In the above example, all paragraph text, including the nested content, will be <code>1rem</code> no matter how many class names the paragraphs have that match the TW stylesheet.</p>
</div></section><section aria-labelledby="avoiding_and_overriding_!important"><h3 id="avoiding_and_overriding_!important">Avoiding and overriding <code>!important</code>
</h3>
<div class="section-content">
<p>The best approach is to not use <code>!important</code>. The above explanations on specificity should be helpful in avoiding using the flag and removing it altogether when encountered.</p> <p>To remove the perceived need for <code>!important</code>, you can do one of the following:</p> <ul> <li>Increase the specificity of the selector of the formerly <code>!important</code> declaration so that it is greater than other declarations</li> <li>Give it the same specificity and put it after the declaration it is meant to override</li> <li>Reduce the specificity of the selector you are trying to override.</li> </ul> <p>All these methods are covered in preceding sections.</p> <p>If you're unable to remove <code>!important</code> flags from an authors style sheet, the only solution to overriding the important styles is by using <code>!important</code>. Creating a <a href="@layer">cascade layer</a> of important declaration overrides is an excellent solution. Two ways of doing this include:</p> <h4 id="method_1">Method 1</h4> <ol> <li>Create a separate, short style sheet containing only important declarations specifically overriding any important declarations you were unable to remove.</li> <li>Import this stylesheet as the first import in your CSS using <code>layer()</code>, including the <code>@import</code> statement, before linking to other stylesheets. This is to ensure that the important overrides is imported as the first layer.</li> </ol> <div class="code-example"><pre data-language="html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token atrule"><span class="token rule">@import</span> importantOverrides.css <span class="token function">layer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</pre></div> <h4 id="method_2">Method 2</h4> <ol> <li>At the beginning of your stylesheet declarations, create a named cascade layer, like so: <div class="code-example"><pre data-language="css"><span class="token atrule"><span class="token rule">@layer</span> importantOverrides<span class="token punctuation">;</span></span>
</pre></div> </li> <li>Each time you need to override an important declaration, declare it within the named layer. Only declare important rules within the layer. <div class="code-example"><pre data-language="css"><span class="token selector">[id="myElement"] p</span> <span class="token punctuation">{</span>
  <span class="token comment">/* normal styles here */</span>
<span class="token punctuation">}</span>
<span class="token atrule"><span class="token rule">@layer</span> importantOverrides</span> <span class="token punctuation">{</span>
  <span class="token selector">[id="myElement"] p</span> <span class="token punctuation">{</span>
    <span class="token comment">/* important style here */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></div> </li> </ol> <p>The specificity of the selector of the important style within the layer can be low, as long as it matches the element you are trying to override. Normal layers should be declared outside the layer because layered styles have lower precedence than unlayered styles.</p>
</div></section><section aria-labelledby="tree_proximity_ignorance"><h3 id="tree_proximity_ignorance">Tree proximity ignorance</h3>
<div class="section-content">
<p>The proximity of an element to other elements that are referenced in a given selector has no impact on specificity.</p> <div class="code-example"><pre data-language="css"><span class="token selector">body h1</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">html h1</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> purple<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div> <p>The <code>&lt;h1&gt;</code> elements will be purple because when declarations have the same specificity, the last declared selector has precedence.</p>
</div></section><section aria-labelledby="directly_targeted_elements_vs._inherited_styles"><h3 id="directly_targeted_elements_vs._inherited_styles">Directly targeted elements vs. inherited styles</h3>
<div class="section-content">
<p>Styles for a directly targeted element will always take precedence over inherited styles, regardless of the specificity of the inherited rule. Given the following CSS and HTML:</p> <div class="code-example"><pre data-language="css"><span class="token selector">#parent</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">h1</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> purple<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div> <div class="code-example"><pre data-language="html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Here is a title!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</pre></div> <p>The <code>h1</code> will be purple because the <code>h1</code> selector targets the element specifically, while the green is inherited from the <code>#parent</code> declarations.</p>
</div></section><section aria-labelledby="examples"><h2 id="examples">Examples</h2>
<div class="section-content">
<p>In the following CSS, we have three selectors targeting <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input"><code>&lt;input&gt;</code></a> elements to set a color. For a given input, the specificity weight of the color declaration having precedence is the matching selector with the greatest weight:</p> <div class="code-example"><pre data-language="css"><span class="token selector">#myElement input.myClass</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">/* 1-1-1 */</span>
<span class="token selector">input[type="password"]:required</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">/* 0-2-1 */</span>
<span class="token selector">html body main input</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">/* 0-0-4 */</span>
</pre></div> <p>If the above selectors all target the same input, the input will be red, as the first declaration has the highest value in the <em>ID</em> column.</p> <p>The last selector has four <em>TYPE</em> components. While it has the highest integer value, no matter how many elements and pseudo-elements are included, even if there were 150, TYPE components never have precedence over <em>CLASS</em> components. The column values are compared starting from left to right when column values are equal.</p> <p>Had we converted the id selector in the example code above to an attribute selector, the first two selectors would have the same specificity, as shown below:</p> <div class="code-example"><pre data-language="css"><span class="token selector">[id="myElement"] input.myClass</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">/* 0-2-1 */</span>
<span class="token selector">input[type="password"]:required</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">/* 0-2-1 */</span>
</pre></div> <p>When multiple declarations have equal specificity, the last declaration found in the CSS is applied to the element. If both selectors match the same <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input"><code>&lt;input&gt;</code></a>, the color will be blue.</p>
</div></section><section aria-labelledby="additional_notes"><h2 id="additional_notes">Additional notes</h2>
<div class="section-content">
<p>A few things to remember about specificity:</p> <ol> <li>Specificity only applies when the same element is targeted by multiple declarations in the same cascade layer or origin. Specificity only matters for declarations of the same importance and same origin and <a href="@layer">cascade layer</a>. If matching selectors are in different origins, the <a href="cascade">cascade</a> determines which declaration takes precedence.</li> <li>When two selectors in the same cascade layer and origin have the same specificity, proximity is important; the last selector wins.</li> <li>As per CSS rules, <a href="#directly_targeted_elements_vs._inherited_styles">directly targeted elements</a> will always take precedence over rules which an element inherits from its ancestor.</li> <li>
<a href="#tree_proximity_ignorance">Proximity of elements</a> in the document tree has no effect on the specificity.</li> </ol>
</div></section><h2 id="specifications">Specifications</h2>
<div class="_table"><table class="standard-table">
<thead><tr><th scope="col">Specification</th></tr></thead>
<tbody><tr><td><a href="https://drafts.csswg.org/selectors/#specificity-rules">Selectors Level 4 <br><small># specificity-rules</small></a></td></tr></tbody>
</table></div>
<section aria-labelledby="see_also"><h2 id="see_also">See also</h2>
<div class="section-content"><ul> <li><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#specificity_2">"Specificity" in "Cascade and inheritance"</a></li> <li><a href="https://specifishity.com" target="_blank">SpeciFISHity</a></li> <li>
<a href="https://specificity.keegan.st/" target="_blank">Specificity Calculator</a>: An interactive website to test and understand your own CSS rules</li> <li>
<a href="https://estelle.github.io/CSS/selectors/exercises/specificity.html" target="_blank"><em>ID-CLASS-TYPE</em> exercise</a> a specificity quiz</li> <li>CSS key concepts: <ul> <li><a href="syntax">CSS syntax</a></li> <li><a href="at-rule">At-rules</a></li> <li><a href="comments">Comments</a></li> <li><a href="inheritance">Inheritance</a></li> <li><a href="css_box_model/introduction_to_the_css_box_model">Box model</a></li> <li><a href="layout_mode">Layout modes</a></li> <li><a href="visual_formatting_model">Visual formatting models</a></li> <li><a href="css_box_model/mastering_margin_collapsing">Margin collapsing</a></li> <li>Values <ul> <li><a href="initial_value">Initial values</a></li> <li><a href="computed_value">Computed values</a></li> <li><a href="used_value">Used values</a></li> <li><a href="actual_value">Actual values</a></li> </ul> </li> <li><a href="value_definition_syntax">Value definition syntax</a></li> <li><a href="shorthand_properties">Shorthand properties</a></li> <li><a href="replaced_element">Replaced elements</a></li> </ul> </li> </ul></div></section><div class="_attribution">
  <p class="_attribution-p">
    © 2005–2023 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
