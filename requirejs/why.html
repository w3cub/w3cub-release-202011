
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Why Web Modules? - RequireJS - W3cubDocs</title>
  
  <meta name="description" content="This page discusses why modules on the web are useful and the mechanisms that can be used on the web today to enable them. There is a separate page &hellip;">
  <meta name="keywords" content="why, web, modules, requirejs">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/requirejs/why.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/requirejs.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/requirejs/" class="_nav-link" title="" style="margin-left:0;">RequireJS</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Why Web Modules?</h1> <ul class="index mono"> <li class="hbox"> <a href="#1">The Problem</a> </li> <li class="hbox"> <a href="#2">Solution</a> </li> <li class="hbox"> <a href="#3">Script loading APIs</a> </li> <li class="hbox"> <a href="#4">Async vs Sync</a> </li> <li class="hbox"> <a href="#5">Script loading: XHR</a> </li> <li class="hbox"> <a href="#6">Script loading: Web Workers</a> </li> <li class="hbox"> <a href="#7">Script loading: document.write()</a> </li> <li class="hbox"> <a href="#8">Script loading: head.appendchild(script)</a> </li> <li class="hbox"> <a href="#9">Function wrapping</a> </li> </ul> <p>This page discusses why modules on the web are useful and the mechanisms that can be used on the web today to enable them. There is a separate page that talks about <a href="whyamd">the design forces</a> for the particular function wrapped format used by RequireJS.</p>   <h2 id="1"> The Problem  </h2> <ul> <li>Web sites are turning into Web apps</li> <li>Code complexity grows as the site gets bigger</li> <li>Assembly gets harder</li> <li>Developer wants discrete JS files/modules</li> <li>Deployment wants optimized code in just one or a few HTTP calls</li> </ul>   <h2 id="2">Solution</h2> <p>Front-end developers need a solution with:</p> <ul> <li>Some sort of #include/import/require</li> <li>Ability to load nested dependencies</li> <li>Ease of use for developer but then backed by an optimization tool that helps deployment</li> </ul>   <h2 id="3">Script Loading APIs</h2> <p>First thing to sort out is a script loading API. Here are some candidates:</p> <ul> <li>Dojo: dojo.require("some.module")</li> <li>LABjs: $LAB.script("some/module.js")</li> <li>CommonJS: require("some/module")</li> </ul> <p>All of them map to loading some/path/some/module.js. Ideally we could choose the CommonJS syntax, since it is likely to get more common over time, and we want to reuse code.</p> <p>We also want some sort of syntax that will allow loading plain JavaScript files that exist today -- a developer should not have to rewrite all of their JavaScript to get the benefits of script loading.</p> <p>However, we need something that works well in the browser. The CommonJS require() is a synchronous call, it is expected to return the module immediately. This does not work well in the browser.</p>   <h2 id="4">Async vs Sync</h2> <p>This example should illustrate the basic problem for the browser. Suppose we have an Employee object and we want a Manager object to derive from the Employee object. <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy">Taking this example</a>, we might code it up like this using our script loading API:</p> <pre data-language="javascript">var Employee = require("types/Employee");

function Manager () {
    this.reports = [];
}

//Error if require call is async
Manager.prototype = new Employee();
</pre> <p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>   <h2 id="5">Script Loading: XHR</h2> <p>It is tempting to use XMLHttpRequest (XHR) to load the scripts. If XHR is used, then we can massage the text above -- we can do a regexp to find require() calls, make sure we load those scripts, then use eval() or script elements that have their body text set to the text of the script loaded via XHR.</p> <p>Using eval() to evaluate the modules is bad:</p> <ul> <li>Developers have been taught that eval() is bad.</li> <li>Some environments do not allow eval().</li> <li>It is harder to debug. Firebug and WebKit's inspector have an //@ sourceURL= convention, which helps give a name to evaled text, but this support is not universal across browsers.</li> <li>eval context is different across browsers. You might be able to use execScript in IE to help this, but it means more moving parts.</li> </ul> <p>Using script tags with body text set to file text is bad:</p> <ul> <li>While debugging, the line number you get for an error does not map to the original source file.</li> </ul> <p>XHR also has issues with cross-domain requests. Some browsers now have cross-domain XHR support, but it is not universal, and IE decided to create a different API object for cross-domain calls, XDomainRequest. More moving parts and more things to get wrong. In particular, you need to be sure to not send any non-standard HTTP headers or there may be another "preflight" request done to make sure the cross-domain access is allowed.</p> <p>Dojo has used an XHR-based loader with eval() and, while it works, it has been a source of frustration for developers. Dojo has an xdomain loader but it requires the modules to be modified via a build step to use a function wrapper, so that script src="" tags can be used to load the modules. There are many edge cases and moving parts that create a tax on the developer.</p> <p>If we are creating a new script loader, we can do better.</p>   <h2 id="6">Script Loading: Web Workers</h2> <p>Web Workers might be another way to load scripts, but:</p> <ul> <li>It does not have strong cross browser support</li> <li>It is a message-passing API, and the scripts likely want to interact with the DOM, so it means just using the worker to fetch the script text, but pass the text back to the main window then use eval/script with text body to execute the script. This has all of the problems as XHR mentioned above.</li> </ul>   <h2 id="7">Script Loading: document.write()</h2> <p>document.write() can be used to load scripts -- it can load scripts from other domains and it maps to how browsers normally consume scripts, so it allows for easy debugging.</p> <p>However, in the <a href="#4">Async vs Sync example</a> we cannot just execute that script directly. Ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first. But we do not have access to the script before it is executed.</p> <p>Also, document.write() does not work after page load. A great way to get perceived performance for your site is loading code on demand, as the user needs it for their next action.</p> <p>Finally, scripts loaded via document.write() will block page rendering. When looking at reaching the very best performance for your site, this is undesirable.</p>   <h2 id="8">Script Loading: head.appendChild(script)</h2> <p>We can create scripts on demand and add them to the head:</p> <pre data-language="javascript">var head = document.getElementsByTagName('head')[0],
    script = document.createElement('script');

script.src = url;
head.appendChild(script);
</pre> <p>There is a bit more involved than just the above snippet, but that is the basic idea. This approach has the advantage over document.write in that it will not block page rendering and it works after page load.</p> <p>However, it still has the <a href="#4">Async vs Sync example</a> problem: ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first.</p>   <h2 id="9">Function Wrapping</h2> <p>So we need to know the dependencies and make sure we load them before executing our script. The best way to do that is construct our module loading API with function wrappers. Like so:</p> <pre data-language="javascript">define(
    //The name of this module
    "types/Manager",

    //The array of dependencies
    ["types/Employee"],

    //The function to execute when all dependencies have loaded. The
    //arguments to this function are the array of dependencies mentioned
    //above.
    function (Employee) {
        function Manager () {
            this.reports = [];
        }

        //This will now work
        Manager.prototype = new Employee();

        //return the Manager constructor function so it can be used by
        //other modules.
        return Manager;
    }
);
</pre> <p>And this is the syntax used by RequireJS. There is also a simplified syntax if you just want to load some plain JavaScript files that do not define modules:</p> <pre data-language="javascript">require(["some/script.js"], function() {
    //This function is called after some/script.js has loaded.
});
</pre> <p>This type of syntax was chosen because it is terse and allows the loader to use head.appendChild(script) type of loading.</p> <p>It differs from the normal CommonJS syntax out of necessity to work well in the browser. There have been suggestions that the normal CommonJS syntax could be used with head.appendChild(script) type of loading if a server process transforms the modules to a transport format that has a function wrapper.</p> <p>I believe it is important to not force the use of a runtime server process to transform code:</p> <ul> <li>It makes debugging weird, line numbers will be off vs. the source file since the server is injecting a function wrapper.</li> <li>It requires more gear. Front-end development should be possible with static files.</li> </ul> <p>More details on the design forces and use cases for this function wrapping format, called Asynchronous Module Definition (AMD), can be found on the <a href="whyamd">Why AMD?</a> page. </p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://requirejs.org/docs/why.html" class="_attribution-link">http://requirejs.org/docs/why.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
