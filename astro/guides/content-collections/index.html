
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Content Collections - Astro - W3cubDocs</title>
  
  <meta name="description" content=" Added in&#58; astro&#64;2.0.0 ">
  <meta name="keywords" content="content, collections, astro">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/astro/guides/content-collections/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/astro.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/astro/" class="_nav-link" title="" style="margin-left:0;">Astro</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="content-title astro-J75B3YUS" id="overview">Content Collections</h1> <p><span> <strong>Added in:</strong> <code>astro@2.0.0</code> </span></p> <p><strong>Content collections</strong> are the best way to manage and author content in any Astro project. Collections help to organize your documents, validate your frontmatter, and provide automatic TypeScript type-safety for all of your content.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="what-are-content-collections">What are Content Collections?</h2></div> <p>A <strong>content collection</strong> is any top-level directory inside the reserved <code>src/content</code> project directory, such as <code>src/content/newsletter</code> and <code>src/content/authors</code>. Only content collections are allowed inside the <code>src/content</code> directory. This directory cannot be used for anything else.</p> <p>A <strong>collection entry</strong> is any piece of content stored inside of your content collection directory. Entries can use content authoring formats including Markdown (<code>.md</code>) and MDX (<code>.mdx</code> using the <a href="../integrations-guide/mdx/index">MDX integration</a>) or as data formats including YAML (<code>.yaml</code>) and JSON (<code>.json</code>). We recommend using a consistent naming scheme (lower-case, dashes instead of spaces) for your files to make it easier to find and organize your content, but this is not required. You can also <a href="../../core-concepts/routing/index#excluding-pages">exclude entries from being built</a> by prefixing the filename with an underscore (_).</p> <docs-file-tree><ul><li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>src/content/ </span> </span></summary><ul><li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>newsletter/</strong></span> <span class="comment"> the “newsletter” collection </span></span></summary><ul>
<li class="file" data-filetype="md"><span class="tree-entry"><span class="">week-1.md</span> <span class="comment">a collection entry</span></span></li>
<li class="file" data-filetype="md"><span class="tree-entry"><span class="">week-2.md</span> <span class="comment">a collection entry</span></span></li>
<li class="file" data-filetype="md"><span class="tree-entry"><span class="">week-3.md</span> <span class="comment">a collection entry</span></span></li>
</ul></details></li></ul></details></li></ul></docs-file-tree> <p>Once you have a collection, you can start <a href="#querying-collections">querying your content</a> using Astro’s built-in content APIs.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="the-astro-directory">The “.astro” Directory</h3></div> <p>Astro stores important metadata for content collections in an <code>.astro</code> directory in your project. No action is needed on your part to maintain or update this directory. You are encouraged to ignore it entirely while working in your project.</p> <p>The <code>.astro</code> directory will be updated for you automatically anytime you run the <a href="../../reference/cli-reference/index#astro-dev"><code>astro dev</code></a>, <a href="../../reference/cli-reference/index#astro-build"><code>astro build</code></a> commands. You can run <a href="../../reference/cli-reference/index#astro-sync"><code>astro sync</code></a> at any time to update the <code>.astro</code> directory manually.</p> <aside class="content tip astro-DUQFCLOB" aria-label="Tip"> <p class="title astro-DUQFCLOB" aria-hidden="true">  Tip </p> <section class="astro-DUQFCLOB"> <p>If you’re using Git for version control, we recommend ignoring the <code>.astro</code> directory by adding <code>.astro</code> to your <code>.gitignore</code>. This tells Git to ignore this directory and any files inside of it.</p>
<div class="expressive-code ec ec-miaxv">
<div class="_pre-heading">
<span class="sr-only">Terminal window</span>
</div>


</div> </section> </aside> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="organizing-with-multiple-collections">Organizing with multiple collections</h3></div> <p>If two files represent different kinds of content (e.g. a blog post and an author profile), they most likely belong in different collections. This is important because many features (frontmatter validation, automatic TypeScript type-safety) require that all entries in a collection share a similar structure.</p> <p>If you find yourself working with different types of content, you should create multiple collections to represent each type. You can create as many different collections in your project as you’d like.</p> <docs-file-tree><ul><li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>src/content/ </span> </span></summary><ul>
<li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>newsletter/</strong></span></span></summary><ul>
<li class="file" data-filetype="md"><span class="tree-entry"><span class="">week-1.md</span> </span></li>
<li class="file" data-filetype="md"><span class="tree-entry"><span class="">week-2.md</span> </span></li>
</ul></details></li>
<li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>blog/</strong></span></span></summary><ul>
<li class="file" data-filetype="md"><span class="tree-entry"><span class="">post-1.md</span> </span></li>
<li class="file" data-filetype="md"><span class="tree-entry"><span class="">post-2.md</span> </span></li>
</ul></details></li>
<li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>authors/</strong></span></span></summary><ul>
<li class="file" data-filetype="json"><span class="tree-entry"><span class="">grace-hopper.json</span> </span></li>
<li class="file" data-filetype="json"><span class="tree-entry"><span class="">alan-turing.json</span> </span></li>
</ul></details></li>
</ul></details></li></ul></docs-file-tree> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="organizing-with-subdirectories">Organizing with subdirectories</h3></div> <p>A content collection is always a top-level folder inside of the <code>src/content/</code> directory. You cannot nest one collection inside of another. However, you can use subdirectories to organize your content within a collection.</p> <p>For example, you can use the following directory structure to organize i18n translations within a single <code>docs</code> collection. When you query this collection, you’ll be able to filter the result by language using the file path.</p> <docs-file-tree><ul><li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>src/content/ </span> </span></summary><ul><li class="directory" data-filetype="dir"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>docs/</span> <span class="comment">this collection uses subdirectories to organize by language </span></span></summary><ul>
<li class="directory" data-filetype="dir"><details><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>en/</strong></span></span></summary><ul><li class="file empty" data-filetype="…"><span class="tree-entry"><span class="">…</span> </span></li></ul></details></li>
<li class="directory" data-filetype="dir"><details><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>es/</strong></span></span></summary><ul><li class="file empty" data-filetype="…"><span class="tree-entry"><span class="">…</span> </span></li></ul></details></li>
<li class="directory" data-filetype="dir"><details><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>de/</strong></span></span></summary><ul><li class="file empty" data-filetype="…"><span class="tree-entry"><span class="">…</span> </span></li></ul></details></li>
</ul></details></li></ul></details></li></ul></docs-file-tree> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="defining-collections">Defining Collections</h2></div> <aside class="content note astro-DUQFCLOB" aria-label="Note"> <p class="title astro-DUQFCLOB" aria-hidden="true">  Note </p> <section class="astro-DUQFCLOB"> <p>The <code>src/content/config.ts</code> file is optional. However, choosing not to define your collections will disable some of their best features like frontmatter schema validation or automatic TypeScript typings.</p> </section> </aside> <p>To get the most out of your content collections, create a <code>src/content/config.ts</code> file in your project (<code>.js</code> and <code>.mjs</code> extensions are also supported.) This is a special file that Astro will automatically load and use to configure your content collections.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="setting-up-typescript">Setting up TypeScript</h3></div> <p>If you <strong>do not</strong> already extend Astro’s <code>strict</code> or <code>strictest</code> recommended TypeScript settings in your <code>tsconfig.json</code> file, you may need to update your <code>tsconfig.json</code> to enable <code>strictNullChecks</code>.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">tsconfig.json</span></div>


</div> <p>If you use <code>.js</code> or <code>.mjs</code> files in an Astro project, you can enable IntelliSense and type checking in your editor by enabling <code>allowJs</code> in your <code>tsconfig.json</code>:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">tsconfig.json</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-a-collection-schema">Defining a collection schema</h3></div> <p>Schemas enforce consistent frontmatter or entry data within a collection. A schema <strong>guarantees</strong> that this data exists in a predictable form when you need to reference or query it. If any file violates its collection schema, Astro will provide a helpful error to let you know.</p> <p>Schemas also power Astro’s automatic TypeScript typings for your content. When you define a schema for your collection, Astro will automatically generate and apply a TypeScript interface to it. The result is full TypeScript support when you query your collection, including property autocompletion and type-checking.</p> <p>To define your first collection, create a <code>src/content/config.ts</code> file if one does not already exist (<code>.js</code> and <code>.mjs</code> extensions are also supported.) This file should:</p> <ol> <li>
<strong>Import the proper utilities</strong> from <code>astro:content</code>.</li> <li>
<strong>Define each collection that you’d like to validate.</strong> This includes a <code>type</code> (introduced in Astro v2.5.0) specifying whether the collection contains content authoring formats like Markdown (<code>type: 'content'</code>) or data formats like JSON or YAML (<code>type: 'data'</code>). It also includes a <code>schema</code> that defines the shape of your frontmatter or entry data.</li> <li>
<strong>Export a single <code>collections</code> object</strong> to register your collections.</li> </ol> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-multiple-collections">Defining multiple collections</h3></div> <p>You can use <code>defineCollection()</code> as many times as you want to create multiple schemas. All collections must be exported from inside the single <code>collections</code> object.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>


</div> <p>As your project grows, you are also free to reorganize your codebase and move logic out of the <code>src/content/config.ts</code> file. Defining your schemas separately can be useful for reusing schemas across multiple collections and sharing schemas with other parts of your project.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="using-third-party-collection-schemas">Using third-party collection schemas</h3></div> <p>You can import collection schemas from anywhere, including external npm packages. This can be useful when working with themes and libraries that provide their own collection schemas for you to use.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-datatypes-with-zod">Defining datatypes with Zod</h3></div> <p>Astro uses <a href="https://github.com/colinhacks/zod">Zod</a> to power its content schemas. With Zod, Astro is able to validate every file’s frontmatter within a collection <em>and</em> provide automatic TypeScript types when you go to query content from inside your project.</p> <p>To use Zod in Astro, import the <code>z</code> utility from <code>"astro:content"</code>. This is a re-export of the Zod library, and it supports all of the features of Zod. See <a href="https://github.com/colinhacks/zod">Zod’s README</a> for complete documentation on how Zod works and what features are available.</p>  <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-collection-references">Defining collection references</h3></div> <p>Collection entries can also “reference” other related entries.</p> <p>With the <code>reference()</code> function from the Collections API, you can define a property in a collection schema as an entry from another collection. For example, you can require that every <code>space-shuttle</code> entry includes a <code>pilot</code> property which uses the <code>pilot</code> collection’s own schema for type checking, autocomplete, and validation.</p> <p>A common example is a blog post that references reusable author profiles stored as JSON, or related post URLs stored in the same collection:</p>  <p>This example blog post specifies the <code>slug</code>s of related posts and the <code>id</code> of the post author:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/blog/welcome.md</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-custom-slugs">Defining custom slugs</h3></div> <p>When using <code>type: 'content'</code>, every content entry generates a URL-friendly <code>slug</code> property from its <a href="../../reference/api-reference/index#id">file <code>id</code></a>. The slug is used to query the entry directly from your collection. It is also useful when creating new pages and URLs from your content.</p> <p>You can override an entry’s generated slug by adding your own <code>slug</code> property to the file frontmatter. This is similar to the “permalink” feature of other web frameworks. <code>"slug"</code> is a special, reserved property name that is not allowed in your custom collection <code>schema</code> and will not appear in your entry’s <code>data</code> property.</p>  <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="querying-collections">Querying Collections</h2></div> <p>Astro provides two functions to query a collection and return one (or more) content entries: <a href="../../reference/api-reference/index#getcollection"><code>getCollection()</code></a> and <a href="../../reference/api-reference/index#getentry"><code>getEntry()</code></a>.</p>  <p>Both functions return content entries as defined by the <a href="../../reference/api-reference/index#collection-entry-type"><code>CollectionEntry</code></a> type.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="accessing-referenced-data">Accessing referenced data</h3></div> <p>Any <a href="#defining-collection-references">references defined in your schema</a> must be queried separately after first querying your collection entry. You can use the <code>getEntry()</code> function again, or <code>getEntries()</code>, to retrieve the referenced entry from the returned <code>data</code> object.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/blog/welcome.astro</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="filtering-collection-queries">Filtering collection queries</h3></div> <p><code>getCollection()</code> takes an optional “filter” callback that allows you to filter your query based on an entry’s <code>id</code> or <code>data</code> (frontmatter) properties. For collections of <code>type: content</code>, you can also filter based on <code>slug</code>.</p> <aside class="content note astro-DUQFCLOB" aria-label="Note"> <p class="title astro-DUQFCLOB" aria-hidden="true">  Note </p> <section class="astro-DUQFCLOB"> <p>The <code>slug</code> property is specific to content collections, and will not be available when filtering collections of JSON or YAML.</p> </section> </aside> <p>You can use this to filter by any content criteria you like. For example, you can filter by properties like <code>draft</code> to prevent any draft blog posts from publishing to your blog:</p>  <p>The filter argument also supports filtering by nested directories within a collection. Since the <code>id</code> includes the full nested path, you can filter by the start of each <code>id</code> to only return items from a specific nested directory:</p>  <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="using-content-in-astro-templates">Using content in Astro templates</h3></div> <p>Once you have queried your collection entries, you can access each entry directly inside of your Astro component template. This lets you to render HTML for things like links to your content (using the content <code>slug</code>) or information about your content (using the <code>data</code> property).</p> <p>For information about rendering your content to HTML, see <a href="index#rendering-content-to-html">Rendering Content to HTML</a> below.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/index.astro</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="passing-content-as-props">Passing content as props</h3></div> <p>A component can also pass an entire content entry as a prop.</p> <p>If you do this, you can use the <a href="../../reference/api-reference/index#collection-entry-type"><code>CollectionEntry</code></a> utility to correctly type your components props using TypeScript. This utility takes a string argument that matches the name of your collection schema, and will inherit all of the properties of that collection’s schema.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/components/BlogCard.astro</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="rendering-content-to-html">Rendering content to HTML</h3></div> <p>Once queried, you can render Markdown and MDX entries to HTML using the entry <code>render()</code> function property. Calling this function gives you access to rendered content and metadata, including both a <code>&lt;Content /&gt;</code> component and a list of all rendered headings.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/render-example.astro</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="generating-routes-from-content">Generating Routes from Content</h2></div> <p>Content collections are stored outside of the <code>src/pages/</code> directory. This means that no routes are generated for your collection items by default. You will need to manually create a new <a href="../../core-concepts/routing/index#dynamic-routes">dynamic route</a> to generate HTML pages from your collection entries. Your dynamic route will map the incoming request param (ex: <code>Astro.params.slug</code> in <code>src/pages/blog/[...slug].astro</code>) to fetch the correct entry inside a collection.</p> <p>The exact method for generating routes will depend on your build <a href="../../reference/configuration-reference/index#output"><code>output</code></a> mode: ‘static’ (the default) or ‘server’ (for SSR).</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="building-for-static-output-default">Building for static output (default)</h3></div> <p>If you are building a static website (Astro’s default behavior), you would use the <a href="../../reference/api-reference/index#getstaticpaths"><code>getStaticPaths()</code></a> function to create multiple pages from a single <code>src/pages/</code> component during your build.</p> <p>Call <a href="../../reference/api-reference/index#getcollection"><code>getCollection()</code></a> inside of <code>getStaticPaths()</code> to query your content. Then, create your new URL paths using the <code>slug</code> property of each content entry.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/posts/[...slug].astro</span></div>


</div> <p>This will generate a new page for every entry in the <code>blog</code> collection. For example, an entry at <code>src/content/blog/hello-world.md</code> will have a slug of <code>hello-world</code>, and therefore its final URL will be <code>/posts/hello-world/</code>.</p> <aside class="content note astro-DUQFCLOB" aria-label="Note"> <p class="title astro-DUQFCLOB" aria-hidden="true">  Note </p> <section class="astro-DUQFCLOB"> <p>If your custom slugs contain the <code>/</code> character to produce URLs with multiple path segments, you must use a <a href="../../core-concepts/routing/index#rest-parameters">rest parameter (<code>[...path]</code>)</a> in the <code>.astro</code> filename for this dynamic routing page.</p> </section> </aside> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="building-for-server-output-ssr">Building for server output (SSR)</h3></div> <p>If you are building a dynamic website (using Astro’s SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using <code>Astro.request</code> or <code>Astro.params</code>) to find the <code>slug</code> on-demand, and then fetch it using <a href="../../reference/api-reference/index#getentry"><code>getEntry()</code></a>.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/posts/[...slug].astro</span></div>


</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="migrating-from-file-based-routing">Migrating from File-Based Routing</h2></div> <p>This guide shows you how to convert an existing Astro project with Markdown files in the <code>src/pages/</code> folder to content collections. It uses the <a href="https://github.com/withastro/blog-tutorial-demo">Build a Blog tutorial’s finished project</a> as an example.</p> <ol> <li> <p><a href="../upgrade-to/v2/index">Upgrade</a> to Astro v2.0 or later, and upgrade all integrations to their latest versions.</p> </li> <li> <p><a href="index#setting-up-typescript">Set up TypeScript</a> for content collections.</p> </li> <li> <p>Create at least one collection (folder in <code>src/content/</code>) and move your Markdown and MDX pages from <code>src/pages/</code> into these subdirectories of <code>src/content/</code>. Collections work best when all files in the same collection have similar frontmatter properties. So, choose your new folder structure to reflect similar types of pages.</p> <p>For example, to migrate the <a href="https://docs.astro.build/en/tutorial/2-pages/2/">blog posts in the tutorial</a>, move the contents of <code>src/pages/posts/</code> to <code>src/content/posts/</code>.</p> </li> <li> <p>Create a <code>src/content/config.ts</code> file and <a href="index#defining-a-collection-schema">define a schema</a> for each content type. For the blog, we only have one content type, <code>posts</code>:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>


</div> <aside class="content tip astro-DUQFCLOB" aria-label="Tip"> <p class="title astro-DUQFCLOB" aria-hidden="true">  Tip </p> <section class="astro-DUQFCLOB"> <p>If your editor doesn’t recognize <code>astro:content</code>, make sure you’re on the latest version of Astro and try restarting the dev server.</p> </section> </aside> </li> <li> <p><a href="index#generating-routes-from-content">Generate routes from your collections</a>. Inside a collection, Markdown and MDX files no longer automatically become pages using Astro’s <a href="../markdown-content/index#file-based-routing">file-based routing</a>, so you must generate the pages yourself.</p> <p>For the tutorial, create a <code>src/pages/posts/[...slug].astro</code>. This page will use <a href="../../core-concepts/routing/index#dynamic-routes">dynamic routing</a> to generate a page for each collection entry.</p> <p>This page will also need to <a href="#querying-collections">query your collection</a> to fetch page slugs and make the page content available to each route.</p> <p>Render your post <code>&lt;Content /&gt;</code> within the layout for your Markdown or MDX pages. This allows you to specify a common layout for all of your posts.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/posts/[...slug].astro</span></div>


</div> </li> <li> <p>Remove the <code>layout</code> definition in each individual post’s frontmatter. Your content is now wrapped in a layout when rendered, and this property is no longer needed.</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/content/post-1.md</span></div>


</div> </li> <li> <p>Replace <code>Astro.glob()</code> with <a href="../../reference/api-reference/index#getcollection"><code>getCollection()</code></a> to fetch content and metadata from your Markdown files. You will also need to update references to the returned post object, since you will now find your frontmatter values on the <code>data</code> property.</p> <p>The blog index page in the tutorial lists a card for each post. This becomes:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/blog.astro</span></div>


</div> <p>The tutorial blog project also dynamically generates a page for each tag. This page now becomes:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/tags/[tag].astro</span></div>


</div> <p>The same logic appears in the tag index page, which becomes:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/tags/index.astro</span></div>


</div> <aside class="content note astro-DUQFCLOB" aria-label="Note"> <p class="title astro-DUQFCLOB" aria-hidden="true">  Note </p> <section class="astro-DUQFCLOB"> <p>Any individual Markdown or MDX file imports should be replaced by <a href="../../reference/api-reference/index#getentry"><code>getEntry()</code></a>.</p> </section> </aside> </li> <li> <p>Update the code that uses the publish date in the <code>layouts/MarkdownPostLayout.astro</code> file.</p> <p>Previously, <code>pubDate</code> was a string. Now, after introducing types for your posts’ frontmatter, <code>pubDate</code> is a <code>Date</code>. To render the date, convert it to a string:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/layouts/MarkdownPostLayout.astro</span></div>


</div> <p>Lastly, the tutorial blog project includes an RSS feed. This function must also use <code>getCollection</code> and the <code>data</code> object, and be converted to an async function to do so:</p> <div class="expressive-code ec ec-miaxv">
<div class="_pre-heading"><span class="title">src/pages/rss.xml.js</span></div>


</div> </li> </ol> <p>For the full example of the blog tutorial using content collections, see the <a href="https://github.com/withastro/blog-tutorial-demo/tree/content-collections">Content Collections branch</a> of the tutorial repo.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="modifying-frontmatter-with-remark">Modifying Frontmatter with Remark</h2></div> <aside class="content caution astro-DUQFCLOB" aria-label="Caution"> <p class="title astro-DUQFCLOB" aria-hidden="true">  Caution </p> <section class="astro-DUQFCLOB"> <p><strong>Not recommended.</strong> Remark and rehype plugins access the <em>raw</em> Markdown or MDX document frontmatter. This means that <code>remarkPluginFrontmatter</code> frontmatter is handled separately from your type-safe <code>schema</code>, and will not reflect any changes or defaults applied through Astro. Use at your own risk!</p> </section> </aside> <p>Astro supports remark or rehype plugins that <a href="../markdown-content/index#modifying-frontmatter-programmatically">modify your frontmatter directly</a>. You can access this modified frontmatter inside of a content entry by using the <code>remarkPluginFrontmatter</code> property returned from <code>render()</code>:</p>  <p>The remark and rehype pipelines only run when your content is rendered, which explains why <code>remarkPluginFrontmatter</code> is only available after you call <code>render()</code> on your content entry. In contrast, <code>getCollection()</code> and <code>getEntry()</code> cannot return these values directly because they do not render your content.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2021 Fred K. Schott<br>Licensed under the MIT License.<br>
    <a href="https://docs.astro.build/en/guides/content-collections/" class="_attribution-link">https://docs.astro.build/en/guides/content-collections/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
