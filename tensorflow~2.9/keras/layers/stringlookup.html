
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.keras.layers.StringLookup - TensorFlow 2.9 - W3cubDocs</title>
  
  <meta name="description" content=" A preprocessing layer which maps string features to integer indices. ">
  <meta name="keywords" content="tf, keras, layers, stringlookup, tensorflow, tensorflow~2.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~2.9/keras/layers/stringlookup.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/tensorflow~2.9.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~2.9/" class="_nav-link" title="" style="margin-left:0;">TensorFlow 2.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 class="devsite-page-title">tf.keras.layers.StringLookup</h1> <devsite-bookmark></devsite-bookmark>       <p>A preprocessing layer which maps string features to integer indices.</p> <p>Inherits From: <a href="experimental/preprocessing/preprocessinglayer"><code translate="no" dir="ltr">PreprocessingLayer</code></a>, <a href="layer"><code translate="no" dir="ltr">Layer</code></a>, <a href="../../module"><code translate="no" dir="ltr">Module</code></a></p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases">View aliases</h4> <p> <b>Main aliases</b> </p>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/StringLookup"><code translate="no" dir="ltr">tf.keras.layers.experimental.preprocessing.StringLookup</code></a></p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.keras.layers.StringLookup(
    max_tokens=None,
    num_oov_indices=1,
    mask_token=None,
    oov_token='[UNK]',
    vocabulary=None,
    idf_weights=None,
    encoding=None,
    invert=False,
    output_mode='int',
    sparse=False,
    pad_to_max_tokens=False,
    **kwargs
)
</pre>  <p>This layer translates a set of arbitrary strings into integer output via a table-based vocabulary lookup. This layer will perform no splitting or transformation of input strings. For a layer than can split and tokenize natural language, see the <code translate="no" dir="ltr">TextVectorization</code> layer.</p> <p>The vocabulary for the layer must be either supplied on construction or learned via <code translate="no" dir="ltr">adapt()</code>. During <code translate="no" dir="ltr">adapt()</code>, the layer will analyze a data set, determine the frequency of individual strings tokens, and create a vocabulary from them. If the vocabulary is capped in size, the most frequent tokens will be used to create the vocabulary and all others will be treated as out-of-vocabulary (OOV).</p> <p>There are two possible output modes for the layer. When <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"int"</code>, input strings are converted to their index in the vocabulary (an integer). When <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"multi_hot"</code>, <code translate="no" dir="ltr">"count"</code>, or <code translate="no" dir="ltr">"tf_idf"</code>, input strings are encoded into an array where each dimension corresponds to an element in the vocabulary.</p> <p>The vocabulary can optionally contain a mask token as well as an OOV token (which can optionally occupy multiple indices in the vocabulary, as set by <code translate="no" dir="ltr">num_oov_indices</code>). The position of these tokens in the vocabulary is fixed. When <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"int"</code>, the vocabulary will begin with the mask token (if set), followed by OOV indices, followed by the rest of the vocabulary. When <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"multi_hot"</code>, <code translate="no" dir="ltr">"count"</code>, or <code translate="no" dir="ltr">"tf_idf"</code> the vocabulary will begin with OOV indices and instances of the mask token will be dropped.</p> <p>For an overview and full list of preprocessing layers, see the preprocessing <a href="https://www.tensorflow.org/guide/keras/preprocessing_layers">guide</a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">max_tokens</code> </td> <td> Maximum size of the vocabulary for this layer. This should only be specified when adapting the vocabulary or when setting <code translate="no" dir="ltr">pad_to_max_tokens=True</code>. If None, there is no cap on the size of the vocabulary. Note that this size includes the OOV and mask tokens. Defaults to None. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_oov_indices</code> </td> <td> The number of out-of-vocabulary tokens to use. If this value is more than 1, OOV inputs are hashed to determine their OOV value. If this value is 0, OOV inputs will cause an error when calling the layer. Defaults to 1. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">mask_token</code> </td> <td> A token that represents masked inputs. When <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"int"</code>, the token is included in vocabulary and mapped to index 0. In other output modes, the token will not appear in the vocabulary and instances of the mask token in the input will be dropped. If set to None, no mask term will be added. Defaults to <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">oov_token</code> </td> <td> Only used when <code translate="no" dir="ltr">invert</code> is True. The token to return for OOV indices. Defaults to <code translate="no" dir="ltr">"[UNK]"</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">vocabulary</code> </td> <td> Optional. Either an array of strings or a string path to a text file. If passing an array, can pass a tuple, list, 1D numpy array, or 1D tensor containing the string vocbulary terms. If passing a file path, the file should contain one line per term in the vocabulary. If this argument is set, there is no need to <code translate="no" dir="ltr">adapt()</code> the layer. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">idf_weights</code> </td> <td> Only valid when <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"tf_idf"</code>. A tuple, list, 1D numpy array, or 1D tensor or the same length as the vocabulary, containing the floating point inverse document frequency weights, which will be multiplied by per sample term counts for the final <code translate="no" dir="ltr">tf_idf</code> weight. If the <code translate="no" dir="ltr">vocabulary</code> argument is set, and <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"tf_idf"</code>, this argument must be supplied. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">invert</code> </td> <td> Only valid when <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"int"</code>. If True, this layer will map indices to vocabulary items instead of mapping vocabulary items to indices. Default to False. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_mode</code> </td> <td> Specification for the output of the layer. Defaults to <code translate="no" dir="ltr">"int"</code>. Values can be <code translate="no" dir="ltr">"int"</code>, <code translate="no" dir="ltr">"one_hot"</code>, <code translate="no" dir="ltr">"multi_hot"</code>, <code translate="no" dir="ltr">"count"</code>, or <code translate="no" dir="ltr">"tf_idf"</code> configuring the layer as follows: <ul> <li>
<code translate="no" dir="ltr">"int"</code>: Return the raw integer indices of the input tokens.</li> <li>
<code translate="no" dir="ltr">"one_hot"</code>: Encodes each individual element in the input into an array the same size as the vocabulary, containing a 1 at the element index. If the last dimension is size 1, will encode on that dimension. If the last dimension is not size 1, will append a new dimension for the encoded output.</li> <li>
<code translate="no" dir="ltr">"multi_hot"</code>: Encodes each sample in the input into a single array the same size as the vocabulary, containing a 1 for each vocabulary term present in the sample. Treats the last dimension as the sample dimension, if input shape is (..., sample_length), output shape will be (..., num_tokens).</li> <li>
<code translate="no" dir="ltr">"count"</code>: As <code translate="no" dir="ltr">"multi_hot"</code>, but the int array contains a count of the number of times the token at that index appeared in the sample.</li> <li>
<code translate="no" dir="ltr">"tf_idf"</code>: As <code translate="no" dir="ltr">"multi_hot"</code>, but the TF-IDF algorithm is applied to find the value in each token slot. For <code translate="no" dir="ltr">"int"</code> output, any shape of input and output is supported. For all other output modes, currently only output up to rank 2 is supported. </li>
</ul>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">pad_to_max_tokens</code> </td> <td> Only applicable when <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"multi_hot"</code>, <code translate="no" dir="ltr">"count"</code>, or <code translate="no" dir="ltr">"tf_idf"</code>. If True, the output will have its feature axis padded to <code translate="no" dir="ltr">max_tokens</code> even if the number of unique tokens in the vocabulary is less than max_tokens, resulting in a tensor of shape [batch_size, max_tokens] regardless of vocabulary size. Defaults to False. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">sparse</code> </td> <td> Boolean. Only applicable when <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"multi_hot"</code>, <code translate="no" dir="ltr">"count"</code>, or <code translate="no" dir="ltr">"tf_idf"</code>. If True, returns a <code translate="no" dir="ltr">SparseTensor</code> instead of a dense <code translate="no" dir="ltr">Tensor</code>. Defaults to False. </td> </tr> </table> <h4 id="examples" data-text="Examples:">Examples:</h4> <p><strong>Creating a lookup layer with a known vocabulary</strong></p> <p>This example creates a lookup layer with a pre-existing vocabulary.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
data = tf.constant([["a", "c", "d"], ["d", "z", "b"]])
layer = tf.keras.layers.StringLookup(vocabulary=vocab)
layer(data)
&lt;tf.Tensor: shape=(2, 3), dtype=int64, numpy=
array([[1, 3, 4],
       [4, 0, 2]])&gt;
</pre> <p><strong>Creating a lookup layer with an adapted vocabulary</strong></p> <p>This example creates a lookup layer and generates the vocabulary by analyzing the dataset.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
data = tf.constant([["a", "c", "d"], ["d", "z", "b"]])
layer = tf.keras.layers.StringLookup()
layer.adapt(data)
layer.get_vocabulary()
['[UNK]', 'd', 'z', 'c', 'b', 'a']
</pre> <p>Note that the OOV token <code translate="no" dir="ltr">"[UNK]"</code> has been added to the vocabulary. The remaining tokens are sorted by frequency (<code translate="no" dir="ltr">"d"</code>, which has 2 occurrences, is first) then by inverse sort order.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
data = tf.constant([["a", "c", "d"], ["d", "z", "b"]])
layer = tf.keras.layers.StringLookup()
layer.adapt(data)
layer(data)
&lt;tf.Tensor: shape=(2, 3), dtype=int64, numpy=
array([[5, 3, 1],
       [1, 2, 4]])&gt;
</pre> <p><strong>Lookups with multiple OOV indices</strong></p> <p>This example demonstrates how to use a lookup layer with multiple OOV indices. When a layer is created with more than one OOV index, any OOV values are hashed into the number of OOV buckets, distributing OOV values in a deterministic fashion across the set.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
data = tf.constant([["a", "c", "d"], ["m", "z", "b"]])
layer = tf.keras.layers.StringLookup(vocabulary=vocab, num_oov_indices=2)
layer(data)
&lt;tf.Tensor: shape=(2, 3), dtype=int64, numpy=
array([[2, 4, 5],
       [0, 1, 3]])&gt;
</pre> <p>Note that the output for OOV value 'm' is 0, while the output for OOV value 'z' is 1. The in-vocab terms have their output index increased by 1 from earlier examples (a maps to 2, etc) in order to make space for the extra OOV value.</p> <p><strong>One-hot output</strong></p> <p>Configure the layer with <code translate="no" dir="ltr">output_mode='one_hot'</code>. Note that the first <code translate="no" dir="ltr">num_oov_indices</code> dimensions in the ont_hot encoding represent OOV values.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
data = tf.constant(["a", "b", "c", "d", "z"])
layer = tf.keras.layers.StringLookup(
    vocabulary=vocab, output_mode='one_hot')
layer(data)
&lt;tf.Tensor: shape=(5, 5), dtype=float32, numpy=
  array([[0., 1., 0., 0., 0.],
         [0., 0., 1., 0., 0.],
         [0., 0., 0., 1., 0.],
         [0., 0., 0., 0., 1.],
         [1., 0., 0., 0., 0.]], dtype=float32)&gt;
</pre> <p><strong>Multi-hot output</strong></p> <p>Configure the layer with <code translate="no" dir="ltr">output_mode='multi_hot'</code>. Note that the first <code translate="no" dir="ltr">num_oov_indices</code> dimensions in the multi_hot encoding represent OOV values.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
data = tf.constant([["a", "c", "d", "d"], ["d", "z", "b", "z"]])
layer = tf.keras.layers.StringLookup(
    vocabulary=vocab, output_mode='multi_hot')
layer(data)
&lt;tf.Tensor: shape=(2, 5), dtype=float32, numpy=
  array([[0., 1., 0., 1., 1.],
         [1., 0., 1., 0., 1.]], dtype=float32)&gt;
</pre> <p><strong>Token count output</strong></p> <p>Configure the layer with <code translate="no" dir="ltr">output_mode='count'</code>. As with multi_hot output, the first <code translate="no" dir="ltr">num_oov_indices</code> dimensions in the output represent OOV values.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
data = tf.constant([["a", "c", "d", "d"], ["d", "z", "b", "z"]])
layer = tf.keras.layers.StringLookup(
    vocabulary=vocab, output_mode='count')
layer(data)
&lt;tf.Tensor: shape=(2, 5), dtype=float32, numpy=
  array([[0., 1., 0., 1., 2.],
         [2., 0., 1., 0., 1.]], dtype=float32)&gt;
</pre> <p><strong>TF-IDF output</strong></p> <p>Configure the layer with <code translate="no" dir="ltr">output_mode="tf_idf"</code>. As with multi_hot output, the first <code translate="no" dir="ltr">num_oov_indices</code> dimensions in the output represent OOV values.</p> <p>Each token bin will output <code translate="no" dir="ltr">token_count * idf_weight</code>, where the idf weights are the inverse document frequency weights per token. These should be provided along with the vocabulary. Note that the <code translate="no" dir="ltr">idf_weight</code> for OOV values will default to the average of all idf weights passed in.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
idf_weights = [0.25, 0.75, 0.6, 0.4]
data = tf.constant([["a", "c", "d", "d"], ["d", "z", "b", "z"]])
layer = tf.keras.layers.StringLookup(output_mode="tf_idf")
layer.set_vocabulary(vocab, idf_weights=idf_weights)
layer(data)
&lt;tf.Tensor: shape=(2, 5), dtype=float32, numpy=
  array([[0.  , 0.25, 0.  , 0.6 , 0.8 ],
         [1.0 , 0.  , 0.75, 0.  , 0.4 ]], dtype=float32)&gt;
</pre> <p>To specify the idf weights for oov values, you will need to pass the entire vocabularly including the leading oov token.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["[UNK]", "a", "b", "c", "d"]
idf_weights = [0.9, 0.25, 0.75, 0.6, 0.4]
data = tf.constant([["a", "c", "d", "d"], ["d", "z", "b", "z"]])
layer = tf.keras.layers.StringLookup(output_mode="tf_idf")
layer.set_vocabulary(vocab, idf_weights=idf_weights)
layer(data)
&lt;tf.Tensor: shape=(2, 5), dtype=float32, numpy=
  array([[0.  , 0.25, 0.  , 0.6 , 0.8 ],
         [1.8 , 0.  , 0.75, 0.  , 0.4 ]], dtype=float32)&gt;
</pre> <p>When adapting the layer in <code translate="no" dir="ltr">"tf_idf"</code> mode, each input sample will be considered a document, and IDF weight per token will be calculated as <code translate="no" dir="ltr">log(1 + num_documents / (1 + token_document_count))</code>.</p> <p><strong>Inverse lookup</strong></p> <p>This example demonstrates how to map indices to strings using this layer. (You can also use <code translate="no" dir="ltr">adapt()</code> with <code translate="no" dir="ltr">inverse=True</code>, but for simplicity we'll pass the vocab in this example.)</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
data = tf.constant([[1, 3, 4], [4, 0, 2]])
layer = tf.keras.layers.StringLookup(vocabulary=vocab, invert=True)
layer(data)
&lt;tf.Tensor: shape=(2, 3), dtype=string, numpy=
array([[b'a', b'c', b'd'],
       [b'd', b'[UNK]', b'b']], dtype=object)&gt;
</pre> <p>Note that the first index correspond to the oov token by default.</p> <p><strong>Forward and inverse lookup pairs</strong></p> <p>This example demonstrates how to use the vocabulary of a standard lookup layer to create an inverse lookup layer.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
vocab = ["a", "b", "c", "d"]
data = tf.constant([["a", "c", "d"], ["d", "z", "b"]])
layer = tf.keras.layers.StringLookup(vocabulary=vocab)
i_layer = tf.keras.layers.StringLookup(vocabulary=vocab, invert=True)
int_data = layer(data)
i_layer(int_data)
&lt;tf.Tensor: shape=(2, 3), dtype=string, numpy=
array([[b'a', b'c', b'd'],
       [b'd', b'[UNK]', b'b']], dtype=object)&gt;
</pre> <p>In this example, the input value <code translate="no" dir="ltr">"z"</code> resulted in an output of <code translate="no" dir="ltr">"[UNK]"</code>, since 1000 was not in the vocabulary - it got represented as an OOV, and all OOV values are returned as <code translate="no" dir="ltr">"[UNK]"</code> in the inverse layer. Also, note that for the inverse to work, you must have already set the forward layer vocabulary either directly or via <code translate="no" dir="ltr">adapt()</code> before calling <code translate="no" dir="ltr">get_vocabulary()</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">is_adapted</code> </td> <td> Whether the layer has been fit to data already. </td> </tr> </table> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="adapt" data-text="adapt"><code translate="no" dir="ltr">adapt</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/preprocessing/string_lookup.py#L349-L396">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
adapt(
    data, batch_size=None, steps=None
)
</pre> <p>Computes a vocabulary of string terms from tokens in a dataset.</p> <p>Calling <code translate="no" dir="ltr">adapt()</code> on a <code translate="no" dir="ltr">StringLookup</code> layer is an alternative to passing in a precomputed vocabulary on construction via the <code translate="no" dir="ltr">vocabulary</code> argument. A <code translate="no" dir="ltr">StringLookup</code> layer should always be either adapted over a dataset or supplied with a vocabulary.</p> <p>During <code translate="no" dir="ltr">adapt()</code>, the layer will build a vocabulary of all string tokens seen in the dataset, sorted by occurance count, with ties broken by sort order of the tokens (high to low). At the end of <code translate="no" dir="ltr">adapt()</code>, if <code translate="no" dir="ltr">max_tokens</code> is set, the voculary wil be truncated to <code translate="no" dir="ltr">max_tokens</code> size. For example, adapting a layer with <code translate="no" dir="ltr">max_tokens=1000</code> will compute the 1000 most frequent tokens occurring in the input dataset. If <code translate="no" dir="ltr">output_mode='tf-idf'</code>, <code translate="no" dir="ltr">adapt()</code> will also learn the document frequencies of each token in the input dataset.</p> <p>In order to make <code translate="no" dir="ltr">StringLookup</code> efficient in any distribution context, the vocabulary is kept static with respect to any compiled <a href="../../graph"><code translate="no" dir="ltr">tf.Graph</code></a>s that call the layer. As a consequence, if the layer is adapted a second time, any models using the layer should be re-compiled. For more information see <a href="experimental/preprocessing/preprocessinglayer#adapt"><code translate="no" dir="ltr">tf.keras.layers.experimental.preprocessing.PreprocessingLayer.adapt</code></a>.</p> <p><code translate="no" dir="ltr">adapt()</code> is meant only as a single machine utility to compute layer state. To analyze a dataset that cannot fit on a single machine, see <a href="https://www.tensorflow.org/tfx/transform/get_started">Tensorflow Transform</a> for a multi-machine, map-reduce solution.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Arguments</th></tr> 
<tr> <td> <code translate="no" dir="ltr">data</code> </td> <td> The data to train on. It can be passed either as a <a href="../../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a>, or as a numpy array. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> Integer or <code translate="no" dir="ltr">None</code>. Number of samples per state update. If unspecified, <code translate="no" dir="ltr">batch_size</code> will default to 32. Do not specify the <code translate="no" dir="ltr">batch_size</code> if your data is in the form of datasets, generators, or <a href="../utils/sequence"><code translate="no" dir="ltr">keras.utils.Sequence</code></a> instances (since they generate batches). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">steps</code> </td> <td> Integer or <code translate="no" dir="ltr">None</code>. Total number of steps (batches of samples) When training with input tensors such as TensorFlow data tensors, the default <code translate="no" dir="ltr">None</code> is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a <a href="../../data"><code translate="no" dir="ltr">tf.data</code></a> dataset, and 'steps' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the <code translate="no" dir="ltr">steps</code> argument. This argument is not supported with array inputs. </td> </tr> </table> <h3 id="compile" data-text="compile"><code translate="no" dir="ltr">compile</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/engine/base_preprocessing_layer.py#L134-L154">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
compile(
    run_eagerly=None, steps_per_execution=None
)
</pre> <p>Configures the layer for <code translate="no" dir="ltr">adapt</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Arguments</th></tr> 
<tr> <td> <code translate="no" dir="ltr">run_eagerly</code> </td> <td> Bool. Defaults to <code translate="no" dir="ltr">False</code>. If <code translate="no" dir="ltr">True</code>, this <code translate="no" dir="ltr">Model</code>'s logic will not be wrapped in a <a href="../../function"><code translate="no" dir="ltr">tf.function</code></a>. Recommended to leave this as <code translate="no" dir="ltr">None</code> unless your <code translate="no" dir="ltr">Model</code> cannot be run inside a <a href="../../function"><code translate="no" dir="ltr">tf.function</code></a>. steps_per_execution: Int. Defaults to 1. The number of batches to run during each <a href="../../function"><code translate="no" dir="ltr">tf.function</code></a> call. Running multiple batches inside a single <a href="../../function"><code translate="no" dir="ltr">tf.function</code></a> call can greatly improve performance on TPUs or small models with a large Python overhead. </td> </tr> </table> <h3 id="get_vocabulary" data-text="get_vocabulary"><code translate="no" dir="ltr">get_vocabulary</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/preprocessing/index_lookup.py#L320-L344">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_vocabulary(
    include_special_tokens=True
)
</pre> <p>Returns the current vocabulary of the layer.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">include_special_tokens</code> </td> <td> If True, the returned vocabulary will include mask and OOV tokens, and a term's index in the vocabulary will equal the term's index when calling the layer. If False, the returned vocabulary will not include any mask or OOV tokens. </td> </tr> </table> <h3 id="reset_state" data-text="reset_state"><code translate="no" dir="ltr">reset_state</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/preprocessing/index_lookup.py#L603-L610">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
reset_state()
</pre> <p>Resets the statistics of the preprocessing layer.</p> <h3 id="set_vocabulary" data-text="set_vocabulary"><code translate="no" dir="ltr">set_vocabulary</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/preprocessing/index_lookup.py#L376-L523">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
set_vocabulary(
    vocabulary, idf_weights=None
)
</pre> <p>Sets vocabulary (and optionally document frequency) data for this layer.</p> <p>This method sets the vocabulary and idf weights for this layer directly, instead of analyzing a dataset through <code translate="no" dir="ltr">adapt</code>. It should be used whenever the vocab (and optionally document frequency) information is already known. If vocabulary data is already present in the layer, this method will replace it.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">vocabulary</code> </td> <td> Either an array or a string path to a text file. If passing an array, can pass a tuple, list, 1D numpy array, or 1D tensor containing the vocbulary terms. If passing a file path, the file should contain one line per term in the vocabulary. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">idf_weights</code> </td> <td> A tuple, list, 1D numpy array, or 1D tensor of inverse document frequency weights with equal length to vocabulary. Must be set if <code translate="no" dir="ltr">output_mode</code> is <code translate="no" dir="ltr">"tf_idf"</code>. Should not be set otherwise. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If there are too many inputs, the inputs do not match, or input data is missing. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If the vocabulary cannot be set when this function is called. This happens when <code translate="no" dir="ltr">"multi_hot"</code>, <code translate="no" dir="ltr">"count"</code>, and <code translate="no" dir="ltr">"tf_idf"</code> modes, if <code translate="no" dir="ltr">pad_to_max_tokens</code> is False and the layer itself has already been called. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If a tensor vocabulary is passed outside of eager execution. </td> </tr> </table> <h3 id="update_state" data-text="update_state"><code translate="no" dir="ltr">update_state</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/preprocessing/index_lookup.py#L525-L551">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
update_state(
    data
)
</pre> <p>Accumulates statistics for the preprocessing layer.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Arguments</th></tr> 
<tr> <td> <code translate="no" dir="ltr">data</code> </td> <td> A mini-batch of inputs to the layer. </td> </tr> </table> <h3 id="vocab_size" data-text="vocab_size"><code translate="no" dir="ltr">vocab_size</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/preprocessing/index_lookup.py#L354-L356">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
vocab_size()
</pre> <h3 id="vocabulary_size" data-text="vocabulary_size"><code translate="no" dir="ltr">vocabulary_size</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/preprocessing/index_lookup.py#L346-L352">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
vocabulary_size()
</pre> <p>Gets the current size of the layer's vocabulary.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The integer size of the voculary, including optional mask and oov indices. </td> </tr> 
</table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    Â© 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/layers/StringLookup" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/layers/StringLookup</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
