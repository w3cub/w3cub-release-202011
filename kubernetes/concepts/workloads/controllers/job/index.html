
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Jobs - Kubernetes - W3cubDocs</title>
  
  <meta name="description" content="A Job creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate. As pods &hellip;">
  <meta name="keywords" content="jobs, kubernetes">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kubernetes/concepts/workloads/controllers/job/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/kubernetes.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kubernetes/" class="_nav-link" title="" style="margin-left:0;">Kubernetes</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kubernetes">
				
				
<h1>Jobs</h1>  <p>A Job creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. Suspending a Job will delete its active Pods until the Job is resumed again.</p> <p>A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot).</p> <p>You can also use a Job to run multiple Pods in parallel.</p> <p>If you want to run a Job (either a single task, or several in parallel) on a schedule, see <a href="../cron-jobs/index">CronJob</a>.</p>  <h2 id="running-an-example-job">Running an example Job</h2> <p>Here is an example Job config. It computes π to 2000 places and prints it out. It takes around 10s to complete.</p> <div class="highlight">  <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/job.yaml" download="controllers/job.yaml"><code>controllers/job.yaml</code> </a>   <div class="includecode" id="controllers-job-yaml"> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
  backoffLimit: 4

</pre></div> </div> </div> <p>You can run the example with this command:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml
</pre></div>
<p>The output is similar to this:</p> <pre><code>job.batch/pi created
</code></pre>
<p>Check on the status of the Job with <code>kubectl</code>:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl describe jobs/pi
</pre></div>
<p>The output is similar to this:</p> <pre><code>Name:           pi
Namespace:      default
Selector:       controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c
Labels:         controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c
                job-name=pi
Annotations:    kubectl.kubernetes.io/last-applied-configuration:
                  {"apiVersion":"batch/v1","kind":"Job","metadata":{"annotations":{},"name":"pi","namespace":"default"},"spec":{"backoffLimit":4,"template":...
Parallelism:    1
Completions:    1
Start Time:     Mon, 02 Dec 2019 15:20:11 +0200
Completed At:   Mon, 02 Dec 2019 15:21:16 +0200
Duration:       65s
Pods Statuses:  0 Running / 1 Succeeded / 0 Failed
Pod Template:
  Labels:  controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c
           job-name=pi
  Containers:
   pi:
    Image:      perl
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      perl
      -Mbignum=bpi
      -wle
      print bpi(2000)
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  14m   job-controller  Created pod: pi-5rwd7
</code></pre>
<p>To view completed Pods of a Job, use <code>kubectl get pods</code>.</p> <p>To list all the Pods that belong to a Job in a machine readable form, you can use a command like this:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">pods=$(kubectl get pods --selector=job-name=pi --output=jsonpath='{.items[*].metadata.name}')
echo $pods
</pre></div>
<p>The output is similar to this:</p> <pre><code>pi-5rwd7
</code></pre>
<p>Here, the selector is the same as the selector for the Job. The <code>--output=jsonpath</code> option specifies an expression with the name from each Pod in the returned list.</p> <p>View the standard output of one of the pods:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl logs $pods
</pre></div>
<p>The output is similar to this:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
</pre></div>
<h2 id="writing-a-job-spec">Writing a Job spec</h2> <p>As with all other Kubernetes config, a Job needs <code>apiVersion</code>, <code>kind</code>, and <code>metadata</code> fields. Its name must be a valid <a href="../../../overview/working-with-objects/names/index#dns-subdomain-names">DNS subdomain name</a>.</p> <p>A Job also needs a <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status"><code>.spec</code> section</a>.</p> <h3 id="pod-template">Pod Template</h3> <p>The <code>.spec.template</code> is the only required field of the <code>.spec</code>.</p> <p>The <code>.spec.template</code> is a <a href="../../pods/index#pod-templates">pod template</a>. It has exactly the same schema as a <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="../../pods/index" target="_blank" aria-label="Pod">Pod</a>, except it is nested and does not have an <code>apiVersion</code> or <code>kind</code>.</p> <p>In addition to required fields for a Pod, a pod template in a Job must specify appropriate labels (see <a href="#pod-selector">pod selector</a>) and an appropriate restart policy.</p> <p>Only a <a href="../../pods/pod-lifecycle/index#restart-policy"><code>RestartPolicy</code></a> equal to <code>Never</code> or <code>OnFailure</code> is allowed.</p> <h3 id="pod-selector">Pod selector</h3> <p>The <code>.spec.selector</code> field is optional. In almost all cases you should not specify it. See section <a href="#specifying-your-own-pod-selector">specifying your own pod selector</a>.</p> <h3 id="parallel-jobs">Parallel execution for Jobs</h3> <p>There are three main types of task suitable to run as a Job:</p> <ol> <li>Non-parallel Jobs <ul> <li>normally, only one Pod is started, unless the Pod fails.</li> <li>the Job is complete as soon as its Pod terminates successfully.</li> </ul> </li> <li>Parallel Jobs with a <em>fixed completion count</em>: <ul> <li>specify a non-zero positive value for <code>.spec.completions</code>.</li> <li>the Job represents the overall task, and is complete when there are <code>.spec.completions</code> successful Pods.</li> <li>when using <code>.spec.completionMode="Indexed"</code>, each Pod gets a different index in the range 0 to <code>.spec.completions-1</code>.</li> </ul> </li> <li>Parallel Jobs with a <em>work queue</em>: <ul> <li>do not specify <code>.spec.completions</code>, default to <code>.spec.parallelism</code>.</li> <li>the Pods must coordinate amongst themselves or an external service to determine what each should work on. For example, a Pod might fetch a batch of up to N items from the work queue.</li> <li>each Pod is independently capable of determining whether or not all its peers are done, and thus that the entire Job is done.</li> <li>when <em>any</em> Pod from the Job terminates with success, no new Pods are created.</li> <li>once at least one Pod has terminated with success and all Pods are terminated, then the Job is completed with success.</li> <li>once any Pod has exited with success, no other Pod should still be doing any work for this task or writing any output. They should all be in the process of exiting.</li> </ul> </li> </ol> <p>For a <em>non-parallel</em> Job, you can leave both <code>.spec.completions</code> and <code>.spec.parallelism</code> unset. When both are unset, both are defaulted to 1.</p> <p>For a <em>fixed completion count</em> Job, you should set <code>.spec.completions</code> to the number of completions needed. You can set <code>.spec.parallelism</code>, or leave it unset and it will default to 1.</p> <p>For a <em>work queue</em> Job, you must leave <code>.spec.completions</code> unset, and set <code>.spec.parallelism</code> to a non-negative integer.</p> <p>For more information about how to make use of the different types of job, see the <a href="#job-patterns">job patterns</a> section.</p> <h4 id="controlling-parallelism">Controlling parallelism</h4> <p>The requested parallelism (<code>.spec.parallelism</code>) can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased.</p> <p>Actual parallelism (number of pods running at any instant) may be more or less than requested parallelism, for a variety of reasons:</p> <ul> <li>For <em>fixed completion count</em> Jobs, the actual number of pods running in parallel will not exceed the number of remaining completions. Higher values of <code>.spec.parallelism</code> are effectively ignored.</li> <li>For <em>work queue</em> Jobs, no new Pods are started after any Pod has succeeded -- remaining Pods are allowed to complete, however.</li> <li>If the Job <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="../../../architecture/controller/index" target="_blank" aria-label="Controller">Controller</a> has not had time to react.</li> <li>If the Job controller failed to create Pods for any reason (lack of <code>ResourceQuota</code>, lack of permission, etc.), then there may be fewer pods than requested.</li> <li>The Job controller may throttle new Pod creation due to excessive previous pod failures in the same Job.</li> <li>When a Pod is gracefully shut down, it takes time to stop.</li> </ul> <h3 id="completion-mode">Completion mode</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code> </div> <p>Jobs with <em>fixed completion count</em> - that is, jobs that have non null <code>.spec.completions</code> - can have a completion mode that is specified in <code>.spec.completionMode</code>:</p> <ul> <li> <p><code>NonIndexed</code> (default): the Job is considered complete when there have been <code>.spec.completions</code> successfully completed Pods. In other words, each Pod completion is homologous to each other. Note that Jobs that have null <code>.spec.completions</code> are implicitly <code>NonIndexed</code>.</p> </li> <li> <p><code>Indexed</code>: the Pods of a Job get an associated completion index from 0 to <code>.spec.completions-1</code>. The index is available through three mechanisms:</p> <ul> <li>The Pod annotation <code>batch.kubernetes.io/job-completion-index</code>.</li> <li>As part of the Pod hostname, following the pattern <code>$(job-name)-$(index)</code>. When you use an Indexed Job in combination with a <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." data-toggle="tooltip" data-placement="top" href="../../../services-networking/service/index" target="_blank" aria-label="Service">Service</a>, Pods within the Job can use the deterministic hostnames to address each other via DNS.</li> <li>From the containarized task, in the environment variable <code>JOB_COMPLETION_INDEX</code>.</li> </ul> <p>The Job is considered complete when there is one successfully completed Pod for each index. For more information about how to use this mode, see <a href="../../../../tasks/job/indexed-parallel-processing-static/index">Indexed Job for Parallel Processing with Static Work Assignment</a>. Note that, although rare, more than one Pod could be started for the same index, but only one of them will count towards the completion count.</p> </li> </ul> <h2 id="handling-pod-and-container-failures">Handling Pod and container failures</h2> <p>A container in a Pod may fail for a number of reasons, such as because the process in it exited with a non-zero exit code, or the container was killed for exceeding a memory limit, etc. If this happens, and the <code>.spec.template.spec.restartPolicy = "OnFailure"</code>, then the Pod stays on the node, but the container is re-run. Therefore, your program needs to handle the case when it is restarted locally, or else specify <code>.spec.template.spec.restartPolicy = "Never"</code>. See <a href="../../pods/pod-lifecycle/index#example-states">pod lifecycle</a> for more information on <code>restartPolicy</code>.</p> <p>An entire Pod can also fail, for a number of reasons, such as when the pod is kicked off the node (node is upgraded, rebooted, deleted, etc.), or if a container of the Pod fails and the <code>.spec.template.spec.restartPolicy = "Never"</code>. When a Pod fails, then the Job controller starts a new Pod. This means that your application needs to handle the case when it is restarted in a new pod. In particular, it needs to handle temporary files, locks, incomplete output and the like caused by previous runs.</p> <p>Note that even if you specify <code>.spec.parallelism = 1</code> and <code>.spec.completions = 1</code> and <code>.spec.template.spec.restartPolicy = "Never"</code>, the same program may sometimes be started twice.</p> <p>If you do specify <code>.spec.parallelism</code> and <code>.spec.completions</code> both greater than 1, then there may be multiple pods running at once. Therefore, your pods must also be tolerant of concurrency.</p> <h3 id="pod-backoff-failure-policy">Pod backoff failure policy</h3> <p>There are situations where you want to fail a Job after some amount of retries due to a logical error in configuration etc. To do so, set <code>.spec.backoffLimit</code> to specify the number of retries before considering a Job as failed. The back-off limit is set by default to 6. Failed Pods associated with the Job are recreated by the Job controller with an exponential back-off delay (10s, 20s, 40s ...) capped at six minutes. The back-off count is reset when a Job's Pod is deleted or successful without any other Pods for the Job failing around that time.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> If your job has <code>restartPolicy = "OnFailure"</code>, keep in mind that your Pod running the Job will be terminated once the job backoff limit has been reached. This can make debugging the Job's executable more difficult. We suggest setting <code>restartPolicy = "Never"</code> when debugging the Job or using a logging system to ensure output from failed Jobs is not lost inadvertently. </div> <h2 id="job-termination-and-cleanup">Job termination and cleanup</h2> <p>When a Job completes, no more Pods are created, but the Pods are <a href="#pod-backoff-failure-policy">usually</a> not deleted either. Keeping them around allows you to still view the logs of completed pods to check for errors, warnings, or other diagnostic output. The job object also remains after it is completed so that you can view its status. It is up to the user to delete old jobs after noting their status. Delete the job with <code>kubectl</code> (e.g. <code>kubectl delete jobs/pi</code> or <code>kubectl delete -f ./job.yaml</code>). When you delete the job using <code>kubectl</code>, all the pods it created are deleted too.</p> <p>By default, a Job will run uninterrupted unless a Pod fails (<code>restartPolicy=Never</code>) or a Container exits in error (<code>restartPolicy=OnFailure</code>), at which point the Job defers to the <code>.spec.backoffLimit</code> described above. Once <code>.spec.backoffLimit</code> has been reached the Job will be marked as failed and any running Pods will be terminated.</p> <p>Another way to terminate a Job is by setting an active deadline. Do this by setting the <code>.spec.activeDeadlineSeconds</code> field of the Job to a number of seconds. The <code>activeDeadlineSeconds</code> applies to the duration of the job, no matter how many Pods are created. Once a Job reaches <code>activeDeadlineSeconds</code>, all of its running Pods are terminated and the Job status will become <code>type: Failed</code> with <code>reason: DeadlineExceeded</code>.</p> <p>Note that a Job's <code>.spec.activeDeadlineSeconds</code> takes precedence over its <code>.spec.backoffLimit</code>. Therefore, a Job that is retrying one or more failed Pods will not deploy additional Pods once it reaches the time limit specified by <code>activeDeadlineSeconds</code>, even if the <code>backoffLimit</code> is not yet reached.</p> <p>Example:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: pi-with-timeout
spec:
  backoffLimit: 5
  activeDeadlineSeconds: 100
  template:
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
</pre></div>
<p>Note that both the Job spec and the <a href="../../pods/init-containers/index#detailed-behavior">Pod template spec</a> within the Job have an <code>activeDeadlineSeconds</code> field. Ensure that you set this field at the proper level.</p> <p>Keep in mind that the <code>restartPolicy</code> applies to the Pod, and not to the Job itself: there is no automatic Job restart once the Job status is <code>type: Failed</code>. That is, the Job termination mechanisms activated with <code>.spec.activeDeadlineSeconds</code> and <code>.spec.backoffLimit</code> result in a permanent Job failure that requires manual intervention to resolve.</p> <h2 id="clean-up-finished-jobs-automatically">Clean up finished jobs automatically</h2> <p>Finished Jobs are usually no longer needed in the system. Keeping them around in the system will put pressure on the API server. If the Jobs are managed directly by a higher level controller, such as <a href="../cron-jobs/index">CronJobs</a>, the Jobs can be cleaned up by CronJobs based on the specified capacity-based cleanup policy.</p> <h3 id="ttl-mechanism-for-finished-jobs">TTL mechanism for finished Jobs</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code> </div> <p>Another way to clean up finished Jobs (either <code>Complete</code> or <code>Failed</code>) automatically is to use a TTL mechanism provided by a <a href="../ttlafterfinished/index">TTL controller</a> for finished resources, by specifying the <code>.spec.ttlSecondsAfterFinished</code> field of the Job.</p> <p>When the TTL controller cleans up the Job, it will delete the Job cascadingly, i.e. delete its dependent objects, such as Pods, together with the Job. Note that when the Job is deleted, its lifecycle guarantees, such as finalizers, will be honored.</p> <p>For example:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: pi-with-ttl
spec:
  ttlSecondsAfterFinished: 100
  template:
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
</pre></div>
<p>The Job <code>pi-with-ttl</code> will be eligible to be automatically deleted, <code>100</code> seconds after it finishes.</p> <p>If the field is set to <code>0</code>, the Job will be eligible to be automatically deleted immediately after it finishes. If the field is unset, this Job won't be cleaned up by the TTL controller after it finishes.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>It is recommended to set <code>ttlSecondsAfterFinished</code> field because unmanaged jobs (Jobs that you created directly, and not indirectly through other workload APIs such as CronJob) have a default deletion policy of <code>orphanDependents</code> causing Pods created by an unmanaged Job to be left around after that Job is fully deleted. Even though the <a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="https://kubernetes.io/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a> eventually <a href="../../pods/pod-lifecycle/index#pod-garbage-collection">garbage collects</a> the Pods from a deleted Job after they either fail or complete, sometimes those lingering pods may cause cluster performance degradation or in worst case cause the cluster to go offline due to this degradation.</p> <p>You can use <a href="../../../policy/limit-range/index">LimitRanges</a> and <a href="../../../policy/resource-quotas/index">ResourceQuotas</a> to place a cap on the amount of resources that a particular namespace can consume.</p> </div> <h2 id="job-patterns">Job patterns</h2> <p>The Job object can be used to support reliable parallel execution of Pods. The Job object is not designed to support closely-communicating parallel processes, as commonly found in scientific computing. It does support parallel processing of a set of independent but related <em>work items</em>. These might be emails to be sent, frames to be rendered, files to be transcoded, ranges of keys in a NoSQL database to scan, and so on.</p> <p>In a complex system, there may be multiple different sets of work items. Here we are just considering one set of work items that the user wants to manage together — a <em>batch job</em>.</p> <p>There are several different patterns for parallel computation, each with strengths and weaknesses. The tradeoffs are:</p> <ul> <li>One Job object for each work item, vs. a single Job object for all work items. The latter is better for large numbers of work items. The former creates some overhead for the user and for the system to manage large numbers of Job objects.</li> <li>Number of pods created equals number of work items, vs. each Pod can process multiple work items. The former typically requires less modification to existing code and containers. The latter is better for large numbers of work items, for similar reasons to the previous bullet.</li> <li>Several approaches use a work queue. This requires running a queue service, and modifications to the existing program or container to make it use the work queue. Other approaches are easier to adapt to an existing containerised application.</li> </ul> <p>The tradeoffs are summarized here, with columns 2 to 4 corresponding to the above tradeoffs. The pattern names are also links to examples and more detailed description.</p> <table> <thead> <tr> <th>Pattern</th> <th style="text-align:center">Single Job object</th> <th style="text-align:center">Fewer pods than work items?</th> <th style="text-align:center">Use app unmodified?</th> </tr> </thead> <tbody> <tr> <td><a href="../../../../tasks/job/coarse-parallel-processing-work-queue/index">Queue with Pod Per Work Item</a></td> <td style="text-align:center">✓</td> <td style="text-align:center"></td> <td style="text-align:center">sometimes</td> </tr> <tr> <td><a href="../../../../tasks/job/fine-parallel-processing-work-queue/index">Queue with Variable Pod Count</a></td> <td style="text-align:center">✓</td> <td style="text-align:center">✓</td> <td style="text-align:center"></td> </tr> <tr> <td><a href="../../../../tasks/job/indexed-parallel-processing-static/index">Indexed Job with Static Work Assignment</a></td> <td style="text-align:center">✓</td> <td style="text-align:center"></td> <td style="text-align:center">✓</td> </tr> <tr> <td><a href="../../../../tasks/job/parallel-processing-expansion/index">Job Template Expansion</a></td> <td style="text-align:center"></td> <td style="text-align:center"></td> <td style="text-align:center">✓</td> </tr> </tbody> </table> <p>When you specify completions with <code>.spec.completions</code>, each Pod created by the Job controller has an identical <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status"><code>spec</code></a>. This means that all pods for a task will have the same command line and the same image, the same volumes, and (almost) the same environment variables. These patterns are different ways to arrange for pods to work on different things.</p> <p>This table shows the required settings for <code>.spec.parallelism</code> and <code>.spec.completions</code> for each of the patterns. Here, <code>W</code> is the number of work items.</p> <table> <thead> <tr> <th>Pattern</th> <th style="text-align:center"><code>.spec.completions</code></th> <th style="text-align:center"><code>.spec.parallelism</code></th> </tr> </thead> <tbody> <tr> <td><a href="../../../../tasks/job/coarse-parallel-processing-work-queue/index">Queue with Pod Per Work Item</a></td> <td style="text-align:center">W</td> <td style="text-align:center">any</td> </tr> <tr> <td><a href="../../../../tasks/job/fine-parallel-processing-work-queue/index">Queue with Variable Pod Count</a></td> <td style="text-align:center">null</td> <td style="text-align:center">any</td> </tr> <tr> <td><a href="../../../../tasks/job/indexed-parallel-processing-static/index">Indexed Job with Static Work Assignment</a></td> <td style="text-align:center">W</td> <td style="text-align:center">any</td> </tr> <tr> <td><a href="../../../../tasks/job/parallel-processing-expansion/index">Job Template Expansion</a></td> <td style="text-align:center">1</td> <td style="text-align:center">should be 1</td> </tr> </tbody> </table> <h2 id="advanced-usage">Advanced usage</h2> <h3 id="suspending-a-job">Suspending a Job</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code> </div> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> In Kubernetes version 1.21, this feature was in alpha, which required additional steps to enable this feature; make sure to read the <a href="https://kubernetes.io/docs/home/supported-doc-versions/">right documentation for the version of Kubernetes you're using</a>. </div> <p>When a Job is created, the Job controller will immediately begin creating Pods to satisfy the Job's requirements and will continue to do so until the Job is complete. However, you may want to temporarily suspend a Job's execution and resume it later, or start Jobs in suspended state and have a custom controller decide later when to start them.</p> <p>To suspend a Job, you can update the <code>.spec.suspend</code> field of the Job to true; later, when you want to resume it again, update it to false. Creating a Job with <code>.spec.suspend</code> set to true will create it in the suspended state.</p> <p>When a Job is resumed from suspension, its <code>.status.startTime</code> field will be reset to the current time. This means that the <code>.spec.activeDeadlineSeconds</code> timer will be stopped and reset when a Job is suspended and resumed.</p> <p>Remember that suspending a Job will delete all active Pods. When the Job is suspended, your <a href="../../pods/pod-lifecycle/index#pod-termination">Pods will be terminated</a> with a SIGTERM signal. The Pod's graceful termination period will be honored and your Pod must handle this signal in this period. This may involve saving progress for later or undoing changes. Pods terminated this way will not count towards the Job's <code>completions</code> count.</p> <p>An example Job definition in the suspended state can be like so:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl get job myjob -o yaml
</pre></div>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: myjob
spec:
  suspend: true
  parallelism: 1
  completions: 5
  template:
    spec:
      ...
</pre></div>
<p>The Job's status can be used to determine if a Job is suspended or has been suspended in the past:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl get jobs/myjob -o yaml
</pre></div>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="json">apiVersion: batch/v1
kind: Job
# .metadata and .spec omitted
status:
  conditions:
  - lastProbeTime: "2021-02-05T13:14:33Z"
    lastTransitionTime: "2021-02-05T13:14:33Z"
    status: "True"
    type: Suspended
  startTime: "2021-02-05T13:13:48Z"
</pre></div>
<p>The Job condition of type "Suspended" with status "True" means the Job is suspended; the <code>lastTransitionTime</code> field can be used to determine how long the Job has been suspended for. If the status of that condition is "False", then the Job was previously suspended and is now running. If such a condition does not exist in the Job's status, the Job has never been stopped.</p> <p>Events are also created when the Job is suspended and resumed:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl describe jobs/myjob
</pre></div>
<pre><code>Name:           myjob
...
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  12m   job-controller  Created pod: myjob-hlrpl
  Normal  SuccessfulDelete  11m   job-controller  Deleted pod: myjob-hlrpl
  Normal  Suspended         11m   job-controller  Job suspended
  Normal  SuccessfulCreate  3s    job-controller  Created pod: myjob-jvb44
  Normal  Resumed           3s    job-controller  Job resumed
</code></pre>
<p>The last four events, particularly the "Suspended" and "Resumed" events, are directly a result of toggling the <code>.spec.suspend</code> field. In the time between these two events, we see that no Pods were created, but Pod creation restarted as soon as the Job was resumed.</p> <h3 id="mutable-scheduling-directives">Mutable Scheduling Directives</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code> </div> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> In order to use this behavior, you must enable the <code>JobMutableNodeSchedulingDirectives</code> <a href="../../../../reference/command-line-tools-reference/feature-gates/index">feature gate</a> on the <a href="../../../../reference/command-line-tools-reference/kube-apiserver/index">API server</a>. It is enabled by default. </div> <p>In most cases a parallel job will want the pods to run with constraints, like all in the same zone, or all either on GPU model x or y but not a mix of both.</p> <p>The <a href="#suspending-a-job">suspend</a> field is the first step towards achieving those semantics. Suspend allows a custom queue controller to decide when a job should start; However, once a job is unsuspended, a custom queue controller has no influence on where the pods of a job will actually land.</p> <p>This feature allows updating a Job's scheduling directives before it starts, which gives custom queue controllers the ability to influence pod placement while at the same time offloading actual pod-to-node assignment to kube-scheduler. This is allowed only for suspended Jobs that have never been unsuspended before.</p> <p>The fields in a Job's pod template that can be updated are node affinity, node selector, tolerations, labels and annotations.</p> <h3 id="specifying-your-own-pod-selector">Specifying your own Pod selector</h3> <p>Normally, when you create a Job object, you do not specify <code>.spec.selector</code>. The system defaulting logic adds this field when the Job is created. It picks a selector value that will not overlap with any other jobs.</p> <p>However, in some cases, you might need to override this automatically set selector. To do this, you can specify the <code>.spec.selector</code> of the Job.</p> <p>Be very careful when doing this. If you specify a label selector which is not unique to the pods of that Job, and which matches unrelated Pods, then pods of the unrelated job may be deleted, or this Job may count other Pods as completing it, or one or both Jobs may refuse to create Pods or run to completion. If a non-unique selector is chosen, then other controllers (e.g. ReplicationController) and their Pods may behave in unpredictable ways too. Kubernetes will not stop you from making a mistake when specifying <code>.spec.selector</code>.</p> <p>Here is an example of a case when you might want to use this feature.</p> <p>Say Job <code>old</code> is already running. You want existing Pods to keep running, but you want the rest of the Pods it creates to use a different pod template and for the Job to have a new name. You cannot update the Job because these fields are not updatable. Therefore, you delete Job <code>old</code> but <em>leave its pods running</em>, using <code>kubectl delete jobs/old --cascade=orphan</code>. Before deleting it, you make a note of what selector it uses:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl get job old -o yaml
</pre></div>
<p>The output is similar to this:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">kind: Job
metadata:
  name: old
  ...
spec:
  selector:
    matchLabels:
      controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
</pre></div>
<p>Then you create a new Job with name <code>new</code> and you explicitly specify the same selector. Since the existing Pods have label <code>controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002</code>, they are controlled by Job <code>new</code> as well.</p> <p>You need to specify <code>manualSelector: true</code> in the new Job since you are not using the selector that the system normally generates for you automatically.</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">kind: Job
metadata:
  name: new
  ...
spec:
  manualSelector: true
  selector:
    matchLabels:
      controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
</pre></div>
<p>The new Job itself will have a different uid from <code>a8f3d00d-c6d2-11e5-9f87-42010af00002</code>. Setting <code>manualSelector: true</code> tells the system that you know what you are doing and to allow this mismatch.</p> <h3 id="job-tracking-with-finalizers">Job tracking with finalizers</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code> </div> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>In order to use this behavior, you must enable the <code>JobTrackingWithFinalizers</code> <a href="../../../../reference/command-line-tools-reference/feature-gates/index">feature gate</a> on the <a href="../../../../reference/command-line-tools-reference/kube-apiserver/index">API server</a> and the <a href="../../../../reference/command-line-tools-reference/kube-controller-manager/index">controller manager</a>. It is enabled by default.</p> <p>When enabled, the control plane tracks new Jobs using the behavior described below. Jobs created before the feature was enabled are unaffected. As a user, the only difference you would see is that the control plane tracking of Job completion is more accurate.</p> </div> <p>When this feature isn't enabled, the Job <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="../../../architecture/controller/index" target="_blank" aria-label="Controller">Controller</a> relies on counting the Pods that exist in the cluster to track the Job status, that is, to keep the counters for <code>succeeded</code> and <code>failed</code> Pods. However, Pods can be removed for a number of reasons, including:</p> <ul> <li>The garbage collector that removes orphan Pods when a Node goes down.</li> <li>The garbage collector that removes finished Pods (in <code>Succeeded</code> or <code>Failed</code> phase) after a threshold.</li> <li>Human intervention to delete Pods belonging to a Job.</li> <li>An external controller (not provided as part of Kubernetes) that removes or replaces Pods.</li> </ul> <p>If you enable the <code>JobTrackingWithFinalizers</code> feature for your cluster, the control plane keeps track of the Pods that belong to any Job and notices if any such Pod is removed from the API server. To do that, the Job controller creates Pods with the finalizer <code>batch.kubernetes.io/job-tracking</code>. The controller removes the finalizer only after the Pod has been accounted for in the Job status, allowing the Pod to be removed by other controllers or users.</p> <p>The Job controller uses the new algorithm for new Jobs only. Jobs created before the feature is enabled are unaffected. You can determine if the Job controller is tracking a Job using Pod finalizers by checking if the Job has the annotation <code>batch.kubernetes.io/job-tracking</code>. You should <strong>not</strong> manually add or remove this annotation from Jobs.</p> <h2 id="alternatives">Alternatives</h2> <h3 id="bare-pods">Bare Pods</h3> <p>When the node that a Pod is running on reboots or fails, the pod is terminated and will not be restarted. However, a Job will create new Pods to replace terminated ones. For this reason, we recommend that you use a Job rather than a bare Pod, even if your application requires only a single Pod.</p> <h3 id="replication-controller">Replication Controller</h3> <p>Jobs are complementary to <a href="../replicationcontroller/index">Replication Controllers</a>. A Replication Controller manages Pods which are not expected to terminate (e.g. web servers), and a Job manages Pods that are expected to terminate (e.g. batch tasks).</p> <p>As discussed in <a href="../../pods/pod-lifecycle/index">Pod Lifecycle</a>, <code>Job</code> is <em>only</em> appropriate for pods with <code>RestartPolicy</code> equal to <code>OnFailure</code> or <code>Never</code>. (Note: If <code>RestartPolicy</code> is not set, the default value is <code>Always</code>.)</p> <h3 id="single-job-starts-controller-pod">Single Job starts controller Pod</h3> <p>Another pattern is for a single Job to create a Pod which then creates other Pods, acting as a sort of custom controller for those Pods. This allows the most flexibility, but may be somewhat complicated to get started with and offers less integration with Kubernetes.</p> <p>One example of this pattern would be a Job which starts a Pod which runs a script that in turn starts a Spark master controller (see <a href="https://github.com/kubernetes/examples/tree/master/staging/spark/README.md">spark example</a>), runs a spark driver, and then cleans up.</p> <p>An advantage of this approach is that the overall process gets the completion guarantee of a Job object, but maintains complete control over what Pods are created and how work is assigned to them.</p> <h2 id="what-s-next">What's next</h2> <ul> <li>Learn about <a href="../../pods/index">Pods</a>.</li> <li>Read about different ways of running Jobs: <ul> <li><a href="../../../../tasks/job/coarse-parallel-processing-work-queue/index">Coarse Parallel Processing Using a Work Queue</a></li> <li><a href="../../../../tasks/job/fine-parallel-processing-work-queue/index">Fine Parallel Processing Using a Work Queue</a></li> <li>Use an <a href="../../../../tasks/job/indexed-parallel-processing-static/index">indexed Job for parallel processing with static work assignment</a> (beta)</li> <li>Create multiple Jobs based on a template: <a href="../../../../tasks/job/parallel-processing-expansion/index">Parallel Processing using Expansions</a>
</li> </ul> </li> <li>Follow the links within <a href="#clean-up-finished-jobs-automatically">Clean up finished jobs automatically</a> to learn more about how your cluster can clean up completed and / or failed tasks.</li> <li>
<code>Job</code> is part of the Kubernetes REST API. Read the <a href="../../../../reference/kubernetes-api/workload-resources/job-v1/index">Job</a> object definition to understand the API for jobs.</li> <li>Read about <a href="../cron-jobs/index"><code>CronJob</code></a>, which you can use to define a series of Jobs that will run based on a schedule, similar to the Unix tool <code>cron</code>.</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2022 The Kubernetes Authors<br>Documentation Distributed under CC BY 4.0.<br>
    <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" class="_attribution-link">https://kubernetes.io/docs/concepts/workloads/controllers/job/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
