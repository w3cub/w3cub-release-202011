
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Pod Security Policies - Kubernetes - W3cubDocs</title>
  
  <meta name="description" content="PodSecurityPolicy is deprecated as of Kubernetes v1.21, and will be removed in v1.25. For more information on the deprecation, see PodSecurityPolicy &hellip;">
  <meta name="keywords" content="pod, security, policies, kubernetes">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kubernetes/concepts/policy/pod-security-policy/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/kubernetes.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kubernetes/" class="_nav-link" title="" style="margin-left:0;">Kubernetes</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kubernetes">
				
				
<h1>Pod Security Policies</h1>  <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code> </div> <p>PodSecurityPolicy is deprecated as of Kubernetes v1.21, and will be removed in v1.25. For more information on the deprecation, see <a href="https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/">PodSecurityPolicy Deprecation: Past, Present, and Future</a>.</p> <p>Pod Security Policies enable fine-grained authorization of pod creation and updates.</p>  <h2 id="what-is-a-pod-security-policy">What is a Pod Security Policy?</h2> <p>A <em>Pod Security Policy</em> is a cluster-level resource that controls security sensitive aspects of the pod specification. The <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#podsecuritypolicy-v1beta1-policy">PodSecurityPolicy</a> objects define a set of conditions that a pod must run with in order to be accepted into the system, as well as defaults for the related fields. They allow an administrator to control the following:</p> <table> <thead> <tr> <th>Control Aspect</th> <th>Field Names</th> </tr> </thead> <tbody> <tr> <td>Running of privileged containers</td> <td><a href="#privileged"><code>privileged</code></a></td> </tr> <tr> <td>Usage of host namespaces</td> <td><a href="#host-namespaces"><code>hostPID</code>, <code>hostIPC</code></a></td> </tr> <tr> <td>Usage of host networking and ports</td> <td><a href="#host-namespaces"><code>hostNetwork</code>, <code>hostPorts</code></a></td> </tr> <tr> <td>Usage of volume types</td> <td><a href="#volumes-and-file-systems"><code>volumes</code></a></td> </tr> <tr> <td>Usage of the host filesystem</td> <td><a href="#volumes-and-file-systems"><code>allowedHostPaths</code></a></td> </tr> <tr> <td>Allow specific FlexVolume drivers</td> <td><a href="#flexvolume-drivers"><code>allowedFlexVolumes</code></a></td> </tr> <tr> <td>Allocating an FSGroup that owns the pod's volumes</td> <td><a href="#volumes-and-file-systems"><code>fsGroup</code></a></td> </tr> <tr> <td>Requiring the use of a read only root file system</td> <td><a href="#volumes-and-file-systems"><code>readOnlyRootFilesystem</code></a></td> </tr> <tr> <td>The user and group IDs of the container</td> <td><a href="#users-and-groups"><code>runAsUser</code>, <code>runAsGroup</code>, <code>supplementalGroups</code></a></td> </tr> <tr> <td>Restricting escalation to root privileges</td> <td><a href="#privilege-escalation"><code>allowPrivilegeEscalation</code>, <code>defaultAllowPrivilegeEscalation</code></a></td> </tr> <tr> <td>Linux capabilities</td> <td><a href="#capabilities"><code>defaultAddCapabilities</code>, <code>requiredDropCapabilities</code>, <code>allowedCapabilities</code></a></td> </tr> <tr> <td>The SELinux context of the container</td> <td><a href="#selinux"><code>seLinux</code></a></td> </tr> <tr> <td>The Allowed Proc Mount types for the container</td> <td><a href="#allowedprocmounttypes"><code>allowedProcMountTypes</code></a></td> </tr> <tr> <td>The AppArmor profile used by containers</td> <td><a href="#apparmor">annotations</a></td> </tr> <tr> <td>The seccomp profile used by containers</td> <td><a href="#seccomp">annotations</a></td> </tr> <tr> <td>The sysctl profile used by containers</td> <td><a href="#sysctl"><code>forbiddenSysctls</code>,<code>allowedUnsafeSysctls</code></a></td> </tr> </tbody> </table> <h2 id="enabling-pod-security-policies">Enabling Pod Security Policies</h2> <p>Pod security policy control is implemented as an optional <a href="../../../reference/access-authn-authz/admission-controllers/index#podsecuritypolicy">admission controller</a>. PodSecurityPolicies are enforced by <a href="../../../reference/access-authn-authz/admission-controllers/index#how-do-i-turn-on-an-admission-control-plug-in">enabling the admission controller</a>, but doing so without authorizing any policies <strong>will prevent any pods from being created</strong> in the cluster.</p> <p>Since the pod security policy API (<code>policy/v1beta1/podsecuritypolicy</code>) is enabled independently of the admission controller, for existing clusters it is recommended that policies are added and authorized before enabling the admission controller.</p> <h2 id="authorizing-policies">Authorizing Policies</h2> <p>When a PodSecurityPolicy resource is created, it does nothing. In order to use it, the requesting user or target pod's <a href="../../../tasks/configure-pod-container/configure-service-account/index">service account</a> must be authorized to use the policy, by allowing the <code>use</code> verb on the policy.</p> <p>Most Kubernetes pods are not created directly by users. Instead, they are typically created indirectly as part of a <a href="../../workloads/controllers/deployment/index">Deployment</a>, <a href="../../workloads/controllers/replicaset/index">ReplicaSet</a>, or other templated controller via the controller manager. Granting the controller access to the policy would grant access for <em>all</em> pods created by that controller, so the preferred method for authorizing policies is to grant access to the pod's service account (see <a href="#run-another-pod">example</a>).</p> <h3 id="via-rbac">Via RBAC</h3> <p><a href="../../../reference/access-authn-authz/rbac/index">RBAC</a> is a standard Kubernetes authorization mode, and can easily be used to authorize use of policies.</p> <p>First, a <code>Role</code> or <code>ClusterRole</code> needs to grant access to <code>use</code> the desired policies. The rules to grant access look like this:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: &lt;role name&gt;
rules:
- apiGroups: ['policy']
  resources: ['podsecuritypolicies']
  verbs:     ['use']
  resourceNames:
  - &lt;list of policies to authorize&gt;
</pre></div>
<p>Then the <code>(Cluster)Role</code> is bound to the authorized user(s):</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: &lt;binding name&gt;
roleRef:
  kind: ClusterRole
  name: &lt;role name&gt;
  apiGroup: rbac.authorization.k8s.io
subjects:
# Authorize all service accounts in a namespace (recommended):
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:serviceaccounts:&lt;authorized namespace&gt;
# Authorize specific service accounts (not recommended):
- kind: ServiceAccount
  name: &lt;authorized service account name&gt;
  namespace: &lt;authorized pod namespace&gt;
# Authorize specific users (not recommended):
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: &lt;authorized user name&gt;
</pre></div>
<p>If a <code>RoleBinding</code> (not a <code>ClusterRoleBinding</code>) is used, it will only grant usage for pods being run in the same namespace as the binding. This can be paired with system groups to grant access to all pods run in the namespace:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml"># Authorize all service accounts in a namespace:
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:serviceaccounts
# Or equivalently, all authenticated users in a namespace:
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:authenticated
</pre></div>
<p>For more examples of RBAC bindings, see <a href="../../../reference/access-authn-authz/rbac/index#role-binding-examples">Role Binding Examples</a>. For a complete example of authorizing a PodSecurityPolicy, see <a href="#example">below</a>.</p> <h3 id="recommended-practice">Recommended Practice</h3> <p>PodSecurityPolicy is being replaced by a new, simplified <code>PodSecurity</code> <a class="glossary-tooltip" title="A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object." data-toggle="tooltip" data-placement="top" href="../../../reference/access-authn-authz/admission-controllers/index" target="_blank" aria-label="admission controller">admission controller</a>. For more details on this change, see <a href="https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/">PodSecurityPolicy Deprecation: Past, Present, and Future</a>. Follow these guidelines to simplify migration from PodSecurityPolicy to the new admission controller:</p> <ol> <li> <p>Limit your PodSecurityPolicies to the policies defined by the <a href="../../security/pod-security-standards/index">Pod Security Standards</a>:</p> <ul> <li> <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/privileged-psp.yaml" download="policy/privileged-psp.yaml">Privileged</a> </li> <li> <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/baseline-psp.yaml" download="policy/baseline-psp.yaml">Baseline</a> </li> <li> <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/restricted-psp.yaml" download="policy/restricted-psp.yaml">Restricted</a> </li> </ul> </li> <li> <p>Only bind PSPs to entire namespaces, by using the <code>system:serviceaccounts:&lt;namespace&gt;</code> group (where <code>&lt;namespace&gt;</code> is the target namespace). For example:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: rbac.authorization.k8s.io/v1
# This cluster role binding allows all pods in the "development" namespace to use the baseline PSP.
kind: ClusterRoleBinding
metadata:
  name: psp-baseline-namespaces
roleRef:
  kind: ClusterRole
  name: psp-baseline
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: Group
  name: system:serviceaccounts:development
  apiGroup: rbac.authorization.k8s.io
- kind: Group
  name: system:serviceaccounts:canary
  apiGroup: rbac.authorization.k8s.io
</pre></div>
</li> </ol> <h3 id="troubleshooting">Troubleshooting</h3> <ul> <li> <p>The <a href="../../../reference/command-line-tools-reference/kube-controller-manager/index">controller manager</a> must be run against the secured API port and must not have superuser permissions. See <a href="../../security/controlling-access/index">Controlling Access to the Kubernetes API</a> to learn about API server access controls.<br> If the controller manager connected through the trusted API port (also known as the <code>localhost</code> listener), requests would bypass authentication and authorization modules; all PodSecurityPolicy objects would be allowed, and users would be able to create grant themselves the ability to create privileged containers.</p> <p>For more details on configuring controller manager authorization, see <a href="../../../reference/access-authn-authz/rbac/index#controller-roles">Controller Roles</a>.</p> </li> </ul> <h2 id="policy-order">Policy Order</h2> <p>In addition to restricting pod creation and update, pod security policies can also be used to provide default values for many of the fields that it controls. When multiple policies are available, the pod security policy controller selects policies according to the following criteria:</p> <ol> <li>PodSecurityPolicies which allow the pod as-is, without changing defaults or mutating the pod, are preferred. The order of these non-mutating PodSecurityPolicies doesn't matter.</li> <li>If the pod must be defaulted or mutated, the first PodSecurityPolicy (ordered by name) to allow the pod is selected.</li> </ol> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> During update operations (during which mutations to pod specs are disallowed) only non-mutating PodSecurityPolicies are used to validate the pod. </div> <h2 id="example">Example</h2> <p><em>This example assumes you have a running cluster with the PodSecurityPolicy admission controller enabled and you have cluster admin privileges.</em></p> <h3 id="set-up">Set up</h3> <p>Set up a namespace and a service account to act as for this example. We'll use this service account to mock a non-admin user.</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl create namespace psp-example
kubectl create serviceaccount -n psp-example fake-user
kubectl create rolebinding -n psp-example fake-editor --clusterrole=edit --serviceaccount=psp-example:fake-user
</pre></div>
<p>To make it clear which user we're acting as and save some typing, create 2 aliases:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">alias kubectl-admin='kubectl -n psp-example'
alias kubectl-user='kubectl --as=system:serviceaccount:psp-example:fake-user -n psp-example'
</pre></div>
<h3 id="create-a-policy-and-a-pod">Create a policy and a pod</h3> <p>Define the example PodSecurityPolicy object in a file. This is a policy that prevents the creation of privileged pods. The name of a PodSecurityPolicy object must be a valid <a href="../../overview/working-with-objects/names/index#dns-subdomain-names">DNS subdomain name</a>.</p> <div class="highlight">  <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/example-psp.yaml" download="policy/example-psp.yaml"><code>policy/example-psp.yaml</code> </a>   <div class="includecode" id="policy-example-psp-yaml"> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: example
spec:
  privileged: false  # Don't allow privileged pods!
  # The rest fills in some required fields.
  seLinux:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  runAsUser:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  volumes:
  - '*'
</pre></div> </div> </div> <p>And create it with kubectl:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-admin create -f example-psp.yaml
</pre></div>
<p>Now, as the unprivileged user, try to create a simple pod:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-user create -f- &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: pause
spec:
  containers:
    - name: pause
      image: k8s.gcr.io/pause
EOF
</pre></div>
<p>The output is similar to this:</p> <pre><code>Error from server (Forbidden): error when creating "STDIN": pods "pause" is forbidden: unable to validate against any pod security policy: []
</code></pre>
<p><strong>What happened?</strong> Although the PodSecurityPolicy was created, neither the pod's service account nor <code>fake-user</code> have permission to use the new policy:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-user auth can-i use podsecuritypolicy/example
no
</pre></div>
<p>Create the rolebinding to grant <code>fake-user</code> the <code>use</code> verb on the example policy:</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> This is not the recommended way! See the <a href="#run-another-pod">next section</a> for the preferred approach. </div> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-admin create role psp:unprivileged \
    --verb=use \
    --resource=podsecuritypolicy \
    --resource-name=example
role "psp:unprivileged" created

kubectl-admin create rolebinding fake-user:psp:unprivileged \
    --role=psp:unprivileged \
    --serviceaccount=psp-example:fake-user
rolebinding "fake-user:psp:unprivileged" created

kubectl-user auth can-i use podsecuritypolicy/example
yes
</pre></div>
<p>Now retry creating the pod:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-user create -f- &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: pause
spec:
  containers:
    - name: pause
      image: k8s.gcr.io/pause
EOF
</pre></div>
<p>The output is similar to this</p> <pre><code>pod "pause" created
</code></pre>
<p>It works as expected! But any attempts to create a privileged pod should still be denied:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-user create -f- &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged
spec:
  containers:
    - name: pause
      image: k8s.gcr.io/pause
      securityContext:
        privileged: true
EOF
</pre></div>
<p>The output is similar to this:</p> <pre><code>Error from server (Forbidden): error when creating "STDIN": pods "privileged" is forbidden: unable to validate against any pod security policy: [spec.containers[0].securityContext.privileged: Invalid value: true: Privileged containers are not allowed]
</code></pre>
<p>Delete the pod before moving on:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-user delete pod pause
</pre></div>
<h3 id="run-another-pod">Run another pod</h3> <p>Let's try that again, slightly differently:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-user create deployment pause --image=k8s.gcr.io/pause
deployment "pause" created

kubectl-user get pods
No resources found.

kubectl-user get events | head -n 2
LASTSEEN   FIRSTSEEN   COUNT     NAME              KIND         SUBOBJECT                TYPE      REASON                  SOURCE                                  MESSAGE
1m         2m          15        pause-7774d79b5   ReplicaSet                            Warning   FailedCreate            replicaset-controller                   Error creating: pods "pause-7774d79b5-" is forbidden: no providers available to validate pod request
</pre></div>
<p><strong>What happened?</strong> We already bound the <code>psp:unprivileged</code> role for our <code>fake-user</code>, why are we getting the error <code>Error creating: pods "pause-7774d79b5-" is forbidden: no providers available to validate pod request</code>? The answer lies in the source - <code>replicaset-controller</code>. Fake-user successfully created the deployment (which successfully created a replicaset), but when the replicaset went to create the pod it was not authorized to use the example podsecuritypolicy.</p> <p>In order to fix this, bind the <code>psp:unprivileged</code> role to the pod's service account instead. In this case (since we didn't specify it) the service account is <code>default</code>:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-admin create rolebinding default:psp:unprivileged \
    --role=psp:unprivileged \
    --serviceaccount=psp-example:default
rolebinding "default:psp:unprivileged" created
</pre></div>
<p>Now if you give it a minute to retry, the replicaset-controller should eventually succeed in creating the pod:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-user get pods --watch
NAME                    READY     STATUS    RESTARTS   AGE
pause-7774d79b5-qrgcb   0/1       Pending   0         1s
pause-7774d79b5-qrgcb   0/1       Pending   0         1s
pause-7774d79b5-qrgcb   0/1       ContainerCreating   0         1s
pause-7774d79b5-qrgcb   1/1       Running   0         2s
</pre></div>
<h3 id="clean-up">Clean up</h3> <p>Delete the namespace to clean up most of the example resources:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-admin delete ns psp-example
namespace "psp-example" deleted
</pre></div>
<p>Note that <code>PodSecurityPolicy</code> resources are not namespaced, and must be cleaned up separately:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="shell">kubectl-admin delete psp example
podsecuritypolicy "example" deleted
</pre></div>
<h3 id="example-policies">Example Policies</h3> <p>This is the least restrictive policy you can create, equivalent to not using the pod security policy admission controller:</p> <div class="highlight">  <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/privileged-psp.yaml" download="policy/privileged-psp.yaml"><code>policy/privileged-psp.yaml</code> </a>   <div class="includecode" id="policy-privileged-psp-yaml"> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: privileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
spec:
  privileged: true
  allowPrivilegeEscalation: true
  allowedCapabilities:
  - '*'
  volumes:
  - '*'
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  hostIPC: true
  hostPID: true
  runAsUser:
    rule: 'RunAsAny'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
</pre></div> </div> </div> <p>This is an example of a restrictive policy that requires users to run as an unprivileged user, blocks possible escalations to root, and requires use of several security mechanisms.</p> <div class="highlight">  <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/restricted-psp.yaml" download="policy/restricted-psp.yaml"><code>policy/restricted-psp.yaml</code> </a>   <div class="includecode" id="policy-restricted-psp-yaml"> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'docker/default,runtime/default'
    apparmor.security.beta.kubernetes.io/allowedProfileNames: 'runtime/default'
    apparmor.security.beta.kubernetes.io/defaultProfileName:  'runtime/default'
spec:
  privileged: false
  # Required to prevent escalations to root.
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  # Allow core volume types.
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    # Assume that ephemeral CSI drivers &amp; persistentVolumes set up by the cluster admin are safe to use.
    - 'csi'
    - 'persistentVolumeClaim'
    - 'ephemeral'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    # Require the container to run without root privileges.
    rule: 'MustRunAsNonRoot'
  seLinux:
    # This policy assumes the nodes are using AppArmor rather than SELinux.
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'MustRunAs'
    ranges:
      # Forbid adding the root group.
      - min: 1
        max: 65535
  fsGroup:
    rule: 'MustRunAs'
    ranges:
      # Forbid adding the root group.
      - min: 1
        max: 65535
  readOnlyRootFilesystem: false
</pre></div> </div> </div> <p>See <a href="../../security/pod-security-standards/index#policy-instantiation">Pod Security Standards</a> for more examples.</p> <h2 id="policy-reference">Policy Reference</h2> <h3 id="privileged">Privileged</h3> <p><strong>Privileged</strong> - determines if any container in a pod can enable privileged mode. By default a container is not allowed to access any devices on the host, but a "privileged" container is given access to all devices on the host. This allows the container nearly all the same access as processes running on the host. This is useful for containers that want to use linux capabilities like manipulating the network stack and accessing devices.</p> <h3 id="host-namespaces">Host namespaces</h3> <p><strong>HostPID</strong> - Controls whether the pod containers can share the host process ID namespace. Note that when paired with ptrace this can be used to escalate privileges outside of the container (ptrace is forbidden by default).</p> <p><strong>HostIPC</strong> - Controls whether the pod containers can share the host IPC namespace.</p> <p><strong>HostNetwork</strong> - Controls whether the pod may use the node network namespace. Doing so gives the pod access to the loopback device, services listening on localhost, and could be used to snoop on network activity of other pods on the same node.</p> <p><strong>HostPorts</strong> - Provides a list of ranges of allowable ports in the host network namespace. Defined as a list of <code>HostPortRange</code>, with <code>min</code>(inclusive) and <code>max</code>(inclusive). Defaults to no allowed host ports.</p> <h3 id="volumes-and-file-systems">Volumes and file systems</h3> <p><strong>Volumes</strong> - Provides a list of allowed volume types. The allowable values correspond to the volume sources that are defined when creating a volume. For the complete list of volume types, see <a href="../../storage/volumes/index#types-of-volumes">Types of Volumes</a>. Additionally, <code>*</code> may be used to allow all volume types.</p> <p>The <strong>recommended minimum set</strong> of allowed volumes for new PSPs are:</p> <ul> <li>configMap</li> <li>downwardAPI</li> <li>emptyDir</li> <li>persistentVolumeClaim</li> <li>secret</li> <li>projected</li> </ul> <div class="alert alert-danger warning callout" role="alert"> <strong>Warning:</strong> PodSecurityPolicy does not limit the types of <code>PersistentVolume</code> objects that may be referenced by a <code>PersistentVolumeClaim</code>, and hostPath type <code>PersistentVolumes</code> do not support read-only access mode. Only trusted users should be granted permission to create <code>PersistentVolume</code> objects. </div> <p><strong>FSGroup</strong> - Controls the supplemental group applied to some volumes.</p> <ul> <li>
<em>MustRunAs</em> - Requires at least one <code>range</code> to be specified. Uses the minimum value of the first range as the default. Validates against all ranges.</li> <li>
<em>MayRunAs</em> - Requires at least one <code>range</code> to be specified. Allows <code>FSGroups</code> to be left unset without providing a default. Validates against all ranges if <code>FSGroups</code> is set.</li> <li>
<em>RunAsAny</em> - No default provided. Allows any <code>fsGroup</code> ID to be specified.</li> </ul> <p><strong>AllowedHostPaths</strong> - This specifies a list of host paths that are allowed to be used by hostPath volumes. An empty list means there is no restriction on host paths used. This is defined as a list of objects with a single <code>pathPrefix</code> field, which allows hostPath volumes to mount a path that begins with an allowed prefix, and a <code>readOnly</code> field indicating it must be mounted read-only. For example:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">  allowedHostPaths:
    # This allows "/foo", "/foo/", "/foo/bar" etc., but
    # disallows "/fool", "/etc/foo" etc.
    # "/foo/../" is never valid.
    - pathPrefix: "/foo"
      readOnly: true # only allow read-only mounts
</pre></div>
<div class="alert alert-danger warning callout" role="alert"> <strong>Warning:</strong> <p>There are many ways a container with unrestricted access to the host filesystem can escalate privileges, including reading data from other containers, and abusing the credentials of system services, such as Kubelet.</p> <p>Writeable hostPath directory volumes allow containers to write to the filesystem in ways that let them traverse the host filesystem outside the <code>pathPrefix</code>. <code>readOnly: true</code>, available in Kubernetes 1.11+, must be used on <strong>all</strong> <code>allowedHostPaths</code> to effectively limit access to the specified <code>pathPrefix</code>.</p> </div> <p><strong>ReadOnlyRootFilesystem</strong> - Requires that containers must run with a read-only root filesystem (i.e. no writable layer).</p> <h3 id="flexvolume-drivers">FlexVolume drivers</h3> <p>This specifies a list of FlexVolume drivers that are allowed to be used by flexvolume. An empty list or nil means there is no restriction on the drivers. Please make sure <a href="#volumes-and-file-systems"><code>volumes</code></a> field contains the <code>flexVolume</code> volume type; no FlexVolume driver is allowed otherwise.</p> <p>For example:</p> <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4" data-language="yaml">apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: allow-flex-volumes
spec:
  # ... other spec fields
  volumes:
    - flexVolume
  allowedFlexVolumes:
    - driver: example/lvm
    - driver: example/cifs
</pre></div>
<h3 id="users-and-groups">Users and groups</h3> <p><strong>RunAsUser</strong> - Controls which user ID the containers are run with.</p> <ul> <li>
<em>MustRunAs</em> - Requires at least one <code>range</code> to be specified. Uses the minimum value of the first range as the default. Validates against all ranges.</li> <li>
<em>MustRunAsNonRoot</em> - Requires that the pod be submitted with a non-zero <code>runAsUser</code> or have the <code>USER</code> directive defined (using a numeric UID) in the image. Pods which have specified neither <code>runAsNonRoot</code> nor <code>runAsUser</code> settings will be mutated to set <code>runAsNonRoot=true</code>, thus requiring a defined non-zero numeric <code>USER</code> directive in the container. No default provided. Setting <code>allowPrivilegeEscalation=false</code> is strongly recommended with this strategy.</li> <li>
<em>RunAsAny</em> - No default provided. Allows any <code>runAsUser</code> to be specified.</li> </ul> <p><strong>RunAsGroup</strong> - Controls which primary group ID the containers are run with.</p> <ul> <li>
<em>MustRunAs</em> - Requires at least one <code>range</code> to be specified. Uses the minimum value of the first range as the default. Validates against all ranges.</li> <li>
<em>MayRunAs</em> - Does not require that RunAsGroup be specified. However, when RunAsGroup is specified, they have to fall in the defined range.</li> <li>
<em>RunAsAny</em> - No default provided. Allows any <code>runAsGroup</code> to be specified.</li> </ul> <p><strong>SupplementalGroups</strong> - Controls which group IDs containers add.</p> <ul> <li>
<em>MustRunAs</em> - Requires at least one <code>range</code> to be specified. Uses the minimum value of the first range as the default. Validates against all ranges.</li> <li>
<em>MayRunAs</em> - Requires at least one <code>range</code> to be specified. Allows <code>supplementalGroups</code> to be left unset without providing a default. Validates against all ranges if <code>supplementalGroups</code> is set.</li> <li>
<em>RunAsAny</em> - No default provided. Allows any <code>supplementalGroups</code> to be specified.</li> </ul> <h3 id="privilege-escalation">Privilege Escalation</h3> <p>These options control the <code>allowPrivilegeEscalation</code> container option. This bool directly controls whether the <a href="https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt"><code>no_new_privs</code></a> flag gets set on the container process. This flag will prevent <code>setuid</code> binaries from changing the effective user ID, and prevent files from enabling extra capabilities (e.g. it will prevent the use of the <code>ping</code> tool). This behavior is required to effectively enforce <code>MustRunAsNonRoot</code>.</p> <p><strong>AllowPrivilegeEscalation</strong> - Gates whether or not a user is allowed to set the security context of a container to <code>allowPrivilegeEscalation=true</code>. This defaults to allowed so as to not break setuid binaries. Setting it to <code>false</code> ensures that no child process of a container can gain more privileges than its parent.</p> <p><strong>DefaultAllowPrivilegeEscalation</strong> - Sets the default for the <code>allowPrivilegeEscalation</code> option. The default behavior without this is to allow privilege escalation so as to not break setuid binaries. If that behavior is not desired, this field can be used to default to disallow, while still permitting pods to request <code>allowPrivilegeEscalation</code> explicitly.</p> <h3 id="capabilities">Capabilities</h3> <p>Linux capabilities provide a finer grained breakdown of the privileges traditionally associated with the superuser. Some of these capabilities can be used to escalate privileges or for container breakout, and may be restricted by the PodSecurityPolicy. For more details on Linux capabilities, see <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities(7)</a>.</p> <p>The following fields take a list of capabilities, specified as the capability name in ALL_CAPS without the <code>CAP_</code> prefix.</p> <p><strong>AllowedCapabilities</strong> - Provides a list of capabilities that are allowed to be added to a container. The default set of capabilities are implicitly allowed. The empty set means that no additional capabilities may be added beyond the default set. <code>*</code> can be used to allow all capabilities.</p> <p><strong>RequiredDropCapabilities</strong> - The capabilities which must be dropped from containers. These capabilities are removed from the default set, and must not be added. Capabilities listed in <code>RequiredDropCapabilities</code> must not be included in <code>AllowedCapabilities</code> or <code>DefaultAddCapabilities</code>.</p> <p><strong>DefaultAddCapabilities</strong> - The capabilities which are added to containers by default, in addition to the runtime defaults. See the <a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">Docker documentation</a> for the default list of capabilities when using the Docker runtime.</p> <h3 id="selinux">SELinux</h3> <ul> <li>
<em>MustRunAs</em> - Requires <code>seLinuxOptions</code> to be configured. Uses <code>seLinuxOptions</code> as the default. Validates against <code>seLinuxOptions</code>.</li> <li>
<em>RunAsAny</em> - No default provided. Allows any <code>seLinuxOptions</code> to be specified.</li> </ul> <h3 id="allowedprocmounttypes">AllowedProcMountTypes</h3> <p><code>allowedProcMountTypes</code> is a list of allowed ProcMountTypes. Empty or nil indicates that only the <code>DefaultProcMountType</code> may be used.</p> <p><code>DefaultProcMount</code> uses the container runtime defaults for readonly and masked paths for /proc. Most container runtimes mask certain paths in /proc to avoid accidental security exposure of special devices or information. This is denoted as the string <code>Default</code>.</p> <p>The only other ProcMountType is <code>UnmaskedProcMount</code>, which bypasses the default masking behavior of the container runtime and ensures the newly created /proc the container stays intact with no modifications. This is denoted as the string <code>Unmasked</code>.</p> <h3 id="apparmor">AppArmor</h3> <p>Controlled via annotations on the PodSecurityPolicy. Refer to the <a href="../../../tutorials/security/apparmor/index#podsecuritypolicy-annotations">AppArmor documentation</a>.</p> <h3 id="seccomp">Seccomp</h3> <p>As of Kubernetes v1.19, you can use the <code>seccompProfile</code> field in the <code>securityContext</code> of Pods or containers to <a href="../../../tutorials/security/seccomp/index">control use of seccomp profiles</a>. In prior versions, seccomp was controlled by adding annotations to a Pod. The same PodSecurityPolicies can be used with either version to enforce how these fields or annotations are applied.</p> <p><strong>seccomp.security.alpha.kubernetes.io/defaultProfileName</strong> - Annotation that specifies the default seccomp profile to apply to containers. Possible values are:</p> <ul> <li>
<code>unconfined</code> - Seccomp is not applied to the container processes (this is the default in Kubernetes), if no alternative is provided.</li> <li>
<code>runtime/default</code> - The default container runtime profile is used.</li> <li>
<code>docker/default</code> - The Docker default seccomp profile is used. Deprecated as of Kubernetes 1.11. Use <code>runtime/default</code> instead.</li> <li>
<code>localhost/&lt;path&gt;</code> - Specify a profile as a file on the node located at <code>&lt;seccomp_root&gt;/&lt;path&gt;</code>, where <code>&lt;seccomp_root&gt;</code> is defined via the <code>--seccomp-profile-root</code> flag on the Kubelet. If the <code>--seccomp-profile-root</code> flag is not defined, the default path will be used, which is <code>&lt;root-dir&gt;/seccomp</code> where <code>&lt;root-dir&gt;</code> is specified by the <code>--root-dir</code> flag.</li> </ul> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> The <code>--seccomp-profile-root</code> flag is deprecated since Kubernetes v1.19. Users are encouraged to use the default path. </div> <p><strong>seccomp.security.alpha.kubernetes.io/allowedProfileNames</strong> - Annotation that specifies which values are allowed for the pod seccomp annotations. Specified as a comma-delimited list of allowed values. Possible values are those listed above, plus <code>*</code> to allow all profiles. Absence of this annotation means that the default cannot be changed.</p> <h3 id="sysctl">Sysctl</h3> <p>By default, all safe sysctls are allowed.</p> <ul> <li>
<code>forbiddenSysctls</code> - excludes specific sysctls. You can forbid a combination of safe and unsafe sysctls in the list. To forbid setting any sysctls, use <code>*</code> on its own.</li> <li>
<code>allowedUnsafeSysctls</code> - allows specific sysctls that had been disallowed by the default list, so long as these are not listed in <code>forbiddenSysctls</code>.</li> </ul> <p>Refer to the <a href="https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy">Sysctl documentation</a>.</p> <h2 id="what-s-next">What's next</h2> <ul> <li> <p>See <a href="https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/">PodSecurityPolicy Deprecation: Past, Present, and Future</a> to learn about the future of pod security policy.</p> </li> <li> <p>See <a href="../../security/pod-security-standards/index">Pod Security Standards</a> for policy recommendations.</p> </li> <li> <p>Refer to <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#podsecuritypolicy-v1beta1-policy">Pod Security Policy Reference</a> for the api details.</p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2022 The Kubernetes Authors<br>Documentation Distributed under CC BY 4.0.<br>
    <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" class="_attribution-link">https://kubernetes.io/docs/concepts/policy/pod-security-policy/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
